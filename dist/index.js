"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __name = (target, value2) => __defProp(target, "name", { value: value2, configurable: true });
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod2) => function __require() {
  return mod2 || (0, cb[__getOwnPropNames(cb)[0]])((mod2 = { exports: {} }).exports, mod2), mod2.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod2, isNodeMode, target) => (target = mod2 != null ? __create(__getProtoOf(mod2)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod2 || !mod2.__esModule ? __defProp(target, "default", { value: mod2, enumerable: true }) : target,
  mod2
));
var __toCommonJS = (mod2) => __copyProps(__defProp({}, "__esModule", { value: true }), mod2);

// node_modules/cliui/build/lib/index.js
function addBorder(col, ts, style) {
  if (col.border) {
    if (/[.']-+[.']/.test(ts)) {
      return "";
    }
    if (ts.trim().length !== 0) {
      return style;
    }
    return "  ";
  }
  return "";
}
function _minWidth(col) {
  const padding = col.padding || [];
  const minWidth = 1 + (padding[left] || 0) + (padding[right] || 0);
  if (col.border) {
    return minWidth + 4;
  }
  return minWidth;
}
function getWindowWidth() {
  if (typeof process === "object" && process.stdout && process.stdout.columns) {
    return process.stdout.columns;
  }
  return 80;
}
function alignRight(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth < width) {
    return " ".repeat(width - strWidth) + str;
  }
  return str;
}
function alignCenter(str, width) {
  str = str.trim();
  const strWidth = mixin.stringWidth(str);
  if (strWidth >= width) {
    return str;
  }
  return " ".repeat(width - strWidth >> 1) + str;
}
function cliui(opts, _mixin) {
  mixin = _mixin;
  return new UI({
    width: (opts === null || opts === void 0 ? void 0 : opts.width) || getWindowWidth(),
    wrap: opts === null || opts === void 0 ? void 0 : opts.wrap
  });
}
var align, top, right, bottom, left, UI, mixin;
var init_lib = __esm({
  "node_modules/cliui/build/lib/index.js"() {
    "use strict";
    align = {
      right: alignRight,
      center: alignCenter
    };
    top = 0;
    right = 1;
    bottom = 2;
    left = 3;
    UI = class {
      static {
        __name(this, "UI");
      }
      constructor(opts) {
        var _a2;
        this.width = opts.width;
        this.wrap = (_a2 = opts.wrap) !== null && _a2 !== void 0 ? _a2 : true;
        this.rows = [];
      }
      span(...args) {
        const cols = this.div(...args);
        cols.span = true;
      }
      resetOutput() {
        this.rows = [];
      }
      div(...args) {
        if (args.length === 0) {
          this.div("");
        }
        if (this.wrap && this.shouldApplyLayoutDSL(...args) && typeof args[0] === "string") {
          return this.applyLayoutDSL(args[0]);
        }
        const cols = args.map((arg) => {
          if (typeof arg === "string") {
            return this.colFromString(arg);
          }
          return arg;
        });
        this.rows.push(cols);
        return cols;
      }
      shouldApplyLayoutDSL(...args) {
        return args.length === 1 && typeof args[0] === "string" && /[\t\n]/.test(args[0]);
      }
      applyLayoutDSL(str) {
        const rows = str.split("\n").map((row) => row.split("	"));
        let leftColumnWidth = 0;
        rows.forEach((columns) => {
          if (columns.length > 1 && mixin.stringWidth(columns[0]) > leftColumnWidth) {
            leftColumnWidth = Math.min(Math.floor(this.width * 0.5), mixin.stringWidth(columns[0]));
          }
        });
        rows.forEach((columns) => {
          this.div(...columns.map((r, i) => {
            return {
              text: r.trim(),
              padding: this.measurePadding(r),
              width: i === 0 && columns.length > 1 ? leftColumnWidth : void 0
            };
          }));
        });
        return this.rows[this.rows.length - 1];
      }
      colFromString(text) {
        return {
          text,
          padding: this.measurePadding(text)
        };
      }
      measurePadding(str) {
        const noAnsi = mixin.stripAnsi(str);
        return [
          0,
          noAnsi.match(/\s*$/)[0].length,
          0,
          noAnsi.match(/^\s*/)[0].length
        ];
      }
      toString() {
        const lines = [];
        this.rows.forEach((row) => {
          this.rowToString(row, lines);
        });
        return lines.filter((line) => !line.hidden).map((line) => line.text).join("\n");
      }
      rowToString(row, lines) {
        this.rasterize(row).forEach((rrow, r) => {
          let str = "";
          rrow.forEach((col, c) => {
            const { width } = row[c];
            const wrapWidth = this.negatePadding(row[c]);
            let ts = col;
            if (wrapWidth > mixin.stringWidth(col)) {
              ts += " ".repeat(wrapWidth - mixin.stringWidth(col));
            }
            if (row[c].align && row[c].align !== "left" && this.wrap) {
              const fn = align[row[c].align];
              ts = fn(ts, wrapWidth);
              if (mixin.stringWidth(ts) < wrapWidth) {
                ts += " ".repeat((width || 0) - mixin.stringWidth(ts) - 1);
              }
            }
            const padding = row[c].padding || [
              0,
              0,
              0,
              0
            ];
            if (padding[left]) {
              str += " ".repeat(padding[left]);
            }
            str += addBorder(row[c], ts, "| ");
            str += ts;
            str += addBorder(row[c], ts, " |");
            if (padding[right]) {
              str += " ".repeat(padding[right]);
            }
            if (r === 0 && lines.length > 0) {
              str = this.renderInline(str, lines[lines.length - 1]);
            }
          });
          lines.push({
            text: str.replace(/ +$/, ""),
            span: row.span
          });
        });
        return lines;
      }
      // if the full 'source' can render in
      // the target line, do so.
      renderInline(source, previousLine) {
        const match = source.match(/^ */);
        const leadingWhitespace = match ? match[0].length : 0;
        const target = previousLine.text;
        const targetTextWidth = mixin.stringWidth(target.trimRight());
        if (!previousLine.span) {
          return source;
        }
        if (!this.wrap) {
          previousLine.hidden = true;
          return target + source;
        }
        if (leadingWhitespace < targetTextWidth) {
          return source;
        }
        previousLine.hidden = true;
        return target.trimRight() + " ".repeat(leadingWhitespace - targetTextWidth) + source.trimLeft();
      }
      rasterize(row) {
        const rrows = [];
        const widths = this.columnWidths(row);
        let wrapped;
        row.forEach((col, c) => {
          col.width = widths[c];
          if (this.wrap) {
            wrapped = mixin.wrap(col.text, this.negatePadding(col), {
              hard: true
            }).split("\n");
          } else {
            wrapped = col.text.split("\n");
          }
          if (col.border) {
            wrapped.unshift("." + "-".repeat(this.negatePadding(col) + 2) + ".");
            wrapped.push("'" + "-".repeat(this.negatePadding(col) + 2) + "'");
          }
          if (col.padding) {
            wrapped.unshift(...new Array(col.padding[top] || 0).fill(""));
            wrapped.push(...new Array(col.padding[bottom] || 0).fill(""));
          }
          wrapped.forEach((str, r) => {
            if (!rrows[r]) {
              rrows.push([]);
            }
            const rrow = rrows[r];
            for (let i = 0; i < c; i++) {
              if (rrow[i] === void 0) {
                rrow.push("");
              }
            }
            rrow.push(str);
          });
        });
        return rrows;
      }
      negatePadding(col) {
        let wrapWidth = col.width || 0;
        if (col.padding) {
          wrapWidth -= (col.padding[left] || 0) + (col.padding[right] || 0);
        }
        if (col.border) {
          wrapWidth -= 4;
        }
        return wrapWidth;
      }
      columnWidths(row) {
        if (!this.wrap) {
          return row.map((col) => {
            return col.width || mixin.stringWidth(col.text);
          });
        }
        let unset = row.length;
        let remainingWidth = this.width;
        const widths = row.map((col) => {
          if (col.width) {
            unset--;
            remainingWidth -= col.width;
            return col.width;
          }
          return void 0;
        });
        const unsetWidth = unset ? Math.floor(remainingWidth / unset) : 0;
        return widths.map((w, i) => {
          if (w === void 0) {
            return Math.max(unsetWidth, _minWidth(row[i]));
          }
          return w;
        });
      }
    };
    __name(addBorder, "addBorder");
    __name(_minWidth, "_minWidth");
    __name(getWindowWidth, "getWindowWidth");
    __name(alignRight, "alignRight");
    __name(alignCenter, "alignCenter");
    __name(cliui, "cliui");
  }
});

// node_modules/cliui/build/lib/string-utils.js
function stripAnsi(str) {
  return str.replace(ansi, "");
}
function wrap(str, width) {
  const [start, end] = str.match(ansi) || [
    "",
    ""
  ];
  str = stripAnsi(str);
  let wrapped = "";
  for (let i = 0; i < str.length; i++) {
    if (i !== 0 && i % width === 0) {
      wrapped += "\n";
    }
    wrapped += str.charAt(i);
  }
  if (start && end) {
    wrapped = `${start}${wrapped}${end}`;
  }
  return wrapped;
}
var ansi;
var init_string_utils = __esm({
  "node_modules/cliui/build/lib/string-utils.js"() {
    "use strict";
    ansi = new RegExp("\x1B(?:\\[(?:\\d+[ABCDEFGJKSTm]|\\d+;\\d+[Hfm]|\\d+;\\d+;\\d+m|6n|s|u|\\?25[lh])|\\w)", "g");
    __name(stripAnsi, "stripAnsi");
    __name(wrap, "wrap");
  }
});

// node_modules/cliui/index.mjs
function ui(opts) {
  return cliui(opts, {
    stringWidth: /* @__PURE__ */ __name((str) => {
      return [...str].length;
    }, "stringWidth"),
    stripAnsi,
    wrap
  });
}
var init_cliui = __esm({
  "node_modules/cliui/index.mjs"() {
    "use strict";
    init_lib();
    init_string_utils();
    __name(ui, "ui");
  }
});

// node_modules/escalade/sync/index.mjs
function sync_default(start, callback) {
  let dir = (0, import_path.resolve)(".", start);
  let tmp, stats = (0, import_fs.statSync)(dir);
  if (!stats.isDirectory()) {
    dir = (0, import_path.dirname)(dir);
  }
  while (true) {
    tmp = callback(dir, (0, import_fs.readdirSync)(dir));
    if (tmp) return (0, import_path.resolve)(dir, tmp);
    dir = (0, import_path.dirname)(tmp = dir);
    if (tmp === dir) break;
  }
}
var import_path, import_fs;
var init_sync = __esm({
  "node_modules/escalade/sync/index.mjs"() {
    "use strict";
    import_path = require("path");
    import_fs = require("fs");
    __name(sync_default, "default");
  }
});

// node_modules/yargs-parser/build/lib/string-utils.js
function camelCase(str) {
  const isCamelCase = str !== str.toLowerCase() && str !== str.toUpperCase();
  if (!isCamelCase) {
    str = str.toLowerCase();
  }
  if (str.indexOf("-") === -1 && str.indexOf("_") === -1) {
    return str;
  } else {
    let camelcase = "";
    let nextChrUpper = false;
    const leadingHyphens = str.match(/^-+/);
    for (let i = leadingHyphens ? leadingHyphens[0].length : 0; i < str.length; i++) {
      let chr = str.charAt(i);
      if (nextChrUpper) {
        nextChrUpper = false;
        chr = chr.toUpperCase();
      }
      if (i !== 0 && (chr === "-" || chr === "_")) {
        nextChrUpper = true;
      } else if (chr !== "-" && chr !== "_") {
        camelcase += chr;
      }
    }
    return camelcase;
  }
}
function decamelize(str, joinString) {
  const lowercase = str.toLowerCase();
  joinString = joinString || "-";
  let notCamelcase = "";
  for (let i = 0; i < str.length; i++) {
    const chrLower = lowercase.charAt(i);
    const chrString = str.charAt(i);
    if (chrLower !== chrString && i > 0) {
      notCamelcase += `${joinString}${lowercase.charAt(i)}`;
    } else {
      notCamelcase += chrString;
    }
  }
  return notCamelcase;
}
function looksLikeNumber(x) {
  if (x === null || x === void 0) return false;
  if (typeof x === "number") return true;
  if (/^0x[0-9a-f]+$/i.test(x)) return true;
  if (/^0[^.]/.test(x)) return false;
  return /^[-]?(?:\d+(?:\.\d*)?|\.\d+)(e[-+]?\d+)?$/.test(x);
}
var init_string_utils2 = __esm({
  "node_modules/yargs-parser/build/lib/string-utils.js"() {
    "use strict";
    __name(camelCase, "camelCase");
    __name(decamelize, "decamelize");
    __name(looksLikeNumber, "looksLikeNumber");
  }
});

// node_modules/yargs-parser/build/lib/tokenize-arg-string.js
function tokenizeArgString(argString) {
  if (Array.isArray(argString)) {
    return argString.map((e) => typeof e !== "string" ? e + "" : e);
  }
  argString = argString.trim();
  let i = 0;
  let prevC = null;
  let c = null;
  let opening = null;
  const args = [];
  for (let ii = 0; ii < argString.length; ii++) {
    prevC = c;
    c = argString.charAt(ii);
    if (c === " " && !opening) {
      if (!(prevC === " ")) {
        i++;
      }
      continue;
    }
    if (c === opening) {
      opening = null;
    } else if ((c === "'" || c === '"') && !opening) {
      opening = c;
    }
    if (!args[i]) args[i] = "";
    args[i] += c;
  }
  return args;
}
var init_tokenize_arg_string = __esm({
  "node_modules/yargs-parser/build/lib/tokenize-arg-string.js"() {
    "use strict";
    __name(tokenizeArgString, "tokenizeArgString");
  }
});

// node_modules/yargs-parser/build/lib/yargs-parser-types.js
var DefaultValuesForTypeKey;
var init_yargs_parser_types = __esm({
  "node_modules/yargs-parser/build/lib/yargs-parser-types.js"() {
    "use strict";
    (function(DefaultValuesForTypeKey2) {
      DefaultValuesForTypeKey2["BOOLEAN"] = "boolean";
      DefaultValuesForTypeKey2["STRING"] = "string";
      DefaultValuesForTypeKey2["NUMBER"] = "number";
      DefaultValuesForTypeKey2["ARRAY"] = "array";
    })(DefaultValuesForTypeKey || (DefaultValuesForTypeKey = {}));
  }
});

// node_modules/yargs-parser/build/lib/yargs-parser.js
function combineAliases(aliases) {
  const aliasArrays = [];
  const combined = /* @__PURE__ */ Object.create(null);
  let change = true;
  Object.keys(aliases).forEach(function(key) {
    aliasArrays.push([].concat(aliases[key], key));
  });
  while (change) {
    change = false;
    for (let i = 0; i < aliasArrays.length; i++) {
      for (let ii = i + 1; ii < aliasArrays.length; ii++) {
        const intersect = aliasArrays[i].filter(function(v) {
          return aliasArrays[ii].indexOf(v) !== -1;
        });
        if (intersect.length) {
          aliasArrays[i] = aliasArrays[i].concat(aliasArrays[ii]);
          aliasArrays.splice(ii, 1);
          change = true;
          break;
        }
      }
    }
  }
  aliasArrays.forEach(function(aliasArray) {
    aliasArray = aliasArray.filter(function(v, i, self2) {
      return self2.indexOf(v) === i;
    });
    const lastAlias = aliasArray.pop();
    if (lastAlias !== void 0 && typeof lastAlias === "string") {
      combined[lastAlias] = aliasArray;
    }
  });
  return combined;
}
function increment(orig) {
  return orig !== void 0 ? orig + 1 : 1;
}
function sanitizeKey(key) {
  if (key === "__proto__") return "___proto___";
  return key;
}
function stripQuotes(val) {
  return typeof val === "string" && (val[0] === "'" || val[0] === '"') && val[val.length - 1] === val[0] ? val.substring(1, val.length - 1) : val;
}
var mixin2, YargsParser;
var init_yargs_parser = __esm({
  "node_modules/yargs-parser/build/lib/yargs-parser.js"() {
    "use strict";
    init_tokenize_arg_string();
    init_yargs_parser_types();
    init_string_utils2();
    YargsParser = class {
      static {
        __name(this, "YargsParser");
      }
      constructor(_mixin) {
        mixin2 = _mixin;
      }
      parse(argsInput, options) {
        const opts = Object.assign({
          alias: void 0,
          array: void 0,
          boolean: void 0,
          config: void 0,
          configObjects: void 0,
          configuration: void 0,
          coerce: void 0,
          count: void 0,
          default: void 0,
          envPrefix: void 0,
          narg: void 0,
          normalize: void 0,
          string: void 0,
          number: void 0,
          __: void 0,
          key: void 0
        }, options);
        const args = tokenizeArgString(argsInput);
        const inputIsString = typeof argsInput === "string";
        const aliases = combineAliases(Object.assign(/* @__PURE__ */ Object.create(null), opts.alias));
        const configuration = Object.assign({
          "boolean-negation": true,
          "camel-case-expansion": true,
          "combine-arrays": false,
          "dot-notation": true,
          "duplicate-arguments-array": true,
          "flatten-duplicate-arrays": true,
          "greedy-arrays": true,
          "halt-at-non-option": false,
          "nargs-eats-options": false,
          "negation-prefix": "no-",
          "parse-numbers": true,
          "parse-positional-numbers": true,
          "populate--": false,
          "set-placeholder-key": false,
          "short-option-groups": true,
          "strip-aliased": false,
          "strip-dashed": false,
          "unknown-options-as-args": false
        }, opts.configuration);
        const defaults = Object.assign(/* @__PURE__ */ Object.create(null), opts.default);
        const configObjects = opts.configObjects || [];
        const envPrefix = opts.envPrefix;
        const notFlagsOption = configuration["populate--"];
        const notFlagsArgv = notFlagsOption ? "--" : "_";
        const newAliases = /* @__PURE__ */ Object.create(null);
        const defaulted = /* @__PURE__ */ Object.create(null);
        const __ = opts.__ || mixin2.format;
        const flags = {
          aliases: /* @__PURE__ */ Object.create(null),
          arrays: /* @__PURE__ */ Object.create(null),
          bools: /* @__PURE__ */ Object.create(null),
          strings: /* @__PURE__ */ Object.create(null),
          numbers: /* @__PURE__ */ Object.create(null),
          counts: /* @__PURE__ */ Object.create(null),
          normalize: /* @__PURE__ */ Object.create(null),
          configs: /* @__PURE__ */ Object.create(null),
          nargs: /* @__PURE__ */ Object.create(null),
          coercions: /* @__PURE__ */ Object.create(null),
          keys: []
        };
        const negative = /^-([0-9]+(\.[0-9]+)?|\.[0-9]+)$/;
        const negatedBoolean = new RegExp("^--" + configuration["negation-prefix"] + "(.+)");
        [].concat(opts.array || []).filter(Boolean).forEach(function(opt) {
          const key = typeof opt === "object" ? opt.key : opt;
          const assignment = Object.keys(opt).map(function(key2) {
            const arrayFlagKeys = {
              boolean: "bools",
              string: "strings",
              number: "numbers"
            };
            return arrayFlagKeys[key2];
          }).filter(Boolean).pop();
          if (assignment) {
            flags[assignment][key] = true;
          }
          flags.arrays[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.boolean || []).filter(Boolean).forEach(function(key) {
          flags.bools[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.string || []).filter(Boolean).forEach(function(key) {
          flags.strings[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.number || []).filter(Boolean).forEach(function(key) {
          flags.numbers[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.count || []).filter(Boolean).forEach(function(key) {
          flags.counts[key] = true;
          flags.keys.push(key);
        });
        [].concat(opts.normalize || []).filter(Boolean).forEach(function(key) {
          flags.normalize[key] = true;
          flags.keys.push(key);
        });
        if (typeof opts.narg === "object") {
          Object.entries(opts.narg).forEach(([key, value2]) => {
            if (typeof value2 === "number") {
              flags.nargs[key] = value2;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.coerce === "object") {
          Object.entries(opts.coerce).forEach(([key, value2]) => {
            if (typeof value2 === "function") {
              flags.coercions[key] = value2;
              flags.keys.push(key);
            }
          });
        }
        if (typeof opts.config !== "undefined") {
          if (Array.isArray(opts.config) || typeof opts.config === "string") {
            ;
            [].concat(opts.config).filter(Boolean).forEach(function(key) {
              flags.configs[key] = true;
            });
          } else if (typeof opts.config === "object") {
            Object.entries(opts.config).forEach(([key, value2]) => {
              if (typeof value2 === "boolean" || typeof value2 === "function") {
                flags.configs[key] = value2;
              }
            });
          }
        }
        extendAliases(opts.key, aliases, opts.default, flags.arrays);
        Object.keys(defaults).forEach(function(key) {
          (flags.aliases[key] || []).forEach(function(alias) {
            defaults[alias] = defaults[key];
          });
        });
        let error = null;
        checkConfiguration();
        let notFlags = [];
        const argv2 = Object.assign(/* @__PURE__ */ Object.create(null), {
          _: []
        });
        const argvReturn = {};
        for (let i = 0; i < args.length; i++) {
          const arg = args[i];
          const truncatedArg = arg.replace(/^-{3,}/, "---");
          let broken;
          let key;
          let letters;
          let m;
          let next;
          let value2;
          if (arg !== "--" && /^-/.test(arg) && isUnknownOptionAsArg(arg)) {
            pushPositional(arg);
          } else if (truncatedArg.match(/^---+(=|$)/)) {
            pushPositional(arg);
            continue;
          } else if (arg.match(/^--.+=/) || !configuration["short-option-groups"] && arg.match(/^-.+=/)) {
            m = arg.match(/^--?([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              if (checkAllAliases(m[1], flags.arrays)) {
                i = eatArray(i, m[1], args, m[2]);
              } else if (checkAllAliases(m[1], flags.nargs) !== false) {
                i = eatNargs(i, m[1], args, m[2]);
              } else {
                setArg(m[1], m[2], true);
              }
            }
          } else if (arg.match(negatedBoolean) && configuration["boolean-negation"]) {
            m = arg.match(negatedBoolean);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              setArg(key, checkAllAliases(key, flags.arrays) ? [
                false
              ] : false);
            }
          } else if (arg.match(/^--.+/) || !configuration["short-option-groups"] && arg.match(/^-[^-]+/)) {
            m = arg.match(/^--?(.+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!next.match(/^-/) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-.\..+=/)) {
            m = arg.match(/^-([^=]+)=([\s\S]*)$/);
            if (m !== null && Array.isArray(m) && m.length >= 3) {
              setArg(m[1], m[2]);
            }
          } else if (arg.match(/^-.\..+/) && !arg.match(negative)) {
            next = args[i + 1];
            m = arg.match(/^-(.\..+)/);
            if (m !== null && Array.isArray(m) && m.length >= 2) {
              key = m[1];
              if (next !== void 0 && !next.match(/^-/) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                setArg(key, next);
                i++;
              } else {
                setArg(key, defaultValue(key));
              }
            }
          } else if (arg.match(/^-[^-]+/) && !arg.match(negative)) {
            letters = arg.slice(1, -1).split("");
            broken = false;
            for (let j = 0; j < letters.length; j++) {
              next = arg.slice(j + 2);
              if (letters[j + 1] && letters[j + 1] === "=") {
                value2 = arg.slice(j + 3);
                key = letters[j];
                if (checkAllAliases(key, flags.arrays)) {
                  i = eatArray(i, key, args, value2);
                } else if (checkAllAliases(key, flags.nargs) !== false) {
                  i = eatNargs(i, key, args, value2);
                } else {
                  setArg(key, value2);
                }
                broken = true;
                break;
              }
              if (next === "-") {
                setArg(letters[j], next);
                continue;
              }
              if (/[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) && checkAllAliases(next, flags.bools) === false) {
                setArg(letters[j], next);
                broken = true;
                break;
              }
              if (letters[j + 1] && letters[j + 1].match(/\W/)) {
                setArg(letters[j], next);
                broken = true;
                break;
              } else {
                setArg(letters[j], defaultValue(letters[j]));
              }
            }
            key = arg.slice(-1)[0];
            if (!broken && key !== "-") {
              if (checkAllAliases(key, flags.arrays)) {
                i = eatArray(i, key, args);
              } else if (checkAllAliases(key, flags.nargs) !== false) {
                i = eatNargs(i, key, args);
              } else {
                next = args[i + 1];
                if (next !== void 0 && (!/^(-|--)[^-]/.test(next) || next.match(negative)) && !checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts)) {
                  setArg(key, next);
                  i++;
                } else if (/^(true|false)$/.test(next)) {
                  setArg(key, next);
                  i++;
                } else {
                  setArg(key, defaultValue(key));
                }
              }
            }
          } else if (arg.match(/^-[0-9]$/) && arg.match(negative) && checkAllAliases(arg.slice(1), flags.bools)) {
            key = arg.slice(1);
            setArg(key, defaultValue(key));
          } else if (arg === "--") {
            notFlags = args.slice(i + 1);
            break;
          } else if (configuration["halt-at-non-option"]) {
            notFlags = args.slice(i);
            break;
          } else {
            pushPositional(arg);
          }
        }
        applyEnvVars(argv2, true);
        applyEnvVars(argv2, false);
        setConfig(argv2);
        setConfigObjects();
        applyDefaultsAndAliases(argv2, flags.aliases, defaults, true);
        applyCoercions(argv2);
        if (configuration["set-placeholder-key"]) setPlaceholderKeys(argv2);
        Object.keys(flags.counts).forEach(function(key) {
          if (!hasKey(argv2, key.split("."))) setArg(key, 0);
        });
        if (notFlagsOption && notFlags.length) argv2[notFlagsArgv] = [];
        notFlags.forEach(function(key) {
          argv2[notFlagsArgv].push(key);
        });
        if (configuration["camel-case-expansion"] && configuration["strip-dashed"]) {
          Object.keys(argv2).filter((key) => key !== "--" && key.includes("-")).forEach((key) => {
            delete argv2[key];
          });
        }
        if (configuration["strip-aliased"]) {
          ;
          [].concat(...Object.keys(aliases).map((k) => aliases[k])).forEach((alias) => {
            if (configuration["camel-case-expansion"] && alias.includes("-")) {
              delete argv2[alias.split(".").map((prop) => camelCase(prop)).join(".")];
            }
            delete argv2[alias];
          });
        }
        function pushPositional(arg) {
          const maybeCoercedNumber = maybeCoerceNumber("_", arg);
          if (typeof maybeCoercedNumber === "string" || typeof maybeCoercedNumber === "number") {
            argv2._.push(maybeCoercedNumber);
          }
        }
        __name(pushPositional, "pushPositional");
        function eatNargs(i, key, args2, argAfterEqualSign) {
          let ii;
          let toEat = checkAllAliases(key, flags.nargs);
          toEat = typeof toEat !== "number" || isNaN(toEat) ? 1 : toEat;
          if (toEat === 0) {
            if (!isUndefined(argAfterEqualSign)) {
              error = Error(__("Argument unexpected for: %s", key));
            }
            setArg(key, defaultValue(key));
            return i;
          }
          let available = isUndefined(argAfterEqualSign) ? 0 : 1;
          if (configuration["nargs-eats-options"]) {
            if (args2.length - (i + 1) + available < toEat) {
              error = Error(__("Not enough arguments following: %s", key));
            }
            available = toEat;
          } else {
            for (ii = i + 1; ii < args2.length; ii++) {
              if (!args2[ii].match(/^-[^0-9]/) || args2[ii].match(negative) || isUnknownOptionAsArg(args2[ii])) available++;
              else break;
            }
            if (available < toEat) error = Error(__("Not enough arguments following: %s", key));
          }
          let consumed = Math.min(available, toEat);
          if (!isUndefined(argAfterEqualSign) && consumed > 0) {
            setArg(key, argAfterEqualSign);
            consumed--;
          }
          for (ii = i + 1; ii < consumed + i + 1; ii++) {
            setArg(key, args2[ii]);
          }
          return i + consumed;
        }
        __name(eatNargs, "eatNargs");
        function eatArray(i, key, args2, argAfterEqualSign) {
          let argsToSet = [];
          let next = argAfterEqualSign || args2[i + 1];
          const nargsCount = checkAllAliases(key, flags.nargs);
          if (checkAllAliases(key, flags.bools) && !/^(true|false)$/.test(next)) {
            argsToSet.push(true);
          } else if (isUndefined(next) || isUndefined(argAfterEqualSign) && /^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) {
            if (defaults[key] !== void 0) {
              const defVal = defaults[key];
              argsToSet = Array.isArray(defVal) ? defVal : [
                defVal
              ];
            }
          } else {
            if (!isUndefined(argAfterEqualSign)) {
              argsToSet.push(processValue(key, argAfterEqualSign, true));
            }
            for (let ii = i + 1; ii < args2.length; ii++) {
              if (!configuration["greedy-arrays"] && argsToSet.length > 0 || nargsCount && typeof nargsCount === "number" && argsToSet.length >= nargsCount) break;
              next = args2[ii];
              if (/^-/.test(next) && !negative.test(next) && !isUnknownOptionAsArg(next)) break;
              i = ii;
              argsToSet.push(processValue(key, next, inputIsString));
            }
          }
          if (typeof nargsCount === "number" && (nargsCount && argsToSet.length < nargsCount || isNaN(nargsCount) && argsToSet.length === 0)) {
            error = Error(__("Not enough arguments following: %s", key));
          }
          setArg(key, argsToSet);
          return i;
        }
        __name(eatArray, "eatArray");
        function setArg(key, val, shouldStripQuotes = inputIsString) {
          if (/-/.test(key) && configuration["camel-case-expansion"]) {
            const alias = key.split(".").map(function(prop) {
              return camelCase(prop);
            }).join(".");
            addNewAlias(key, alias);
          }
          const value2 = processValue(key, val, shouldStripQuotes);
          const splitKey = key.split(".");
          setKey(argv2, splitKey, value2);
          if (flags.aliases[key]) {
            flags.aliases[key].forEach(function(x) {
              const keyProperties = x.split(".");
              setKey(argv2, keyProperties, value2);
            });
          }
          if (splitKey.length > 1 && configuration["dot-notation"]) {
            ;
            (flags.aliases[splitKey[0]] || []).forEach(function(x) {
              let keyProperties = x.split(".");
              const a = [].concat(splitKey);
              a.shift();
              keyProperties = keyProperties.concat(a);
              if (!(flags.aliases[key] || []).includes(keyProperties.join("."))) {
                setKey(argv2, keyProperties, value2);
              }
            });
          }
          if (checkAllAliases(key, flags.normalize) && !checkAllAliases(key, flags.arrays)) {
            const keys = [
              key
            ].concat(flags.aliases[key] || []);
            keys.forEach(function(key2) {
              Object.defineProperty(argvReturn, key2, {
                enumerable: true,
                get() {
                  return val;
                },
                set(value3) {
                  val = typeof value3 === "string" ? mixin2.normalize(value3) : value3;
                }
              });
            });
          }
        }
        __name(setArg, "setArg");
        function addNewAlias(key, alias) {
          if (!(flags.aliases[key] && flags.aliases[key].length)) {
            flags.aliases[key] = [
              alias
            ];
            newAliases[alias] = true;
          }
          if (!(flags.aliases[alias] && flags.aliases[alias].length)) {
            addNewAlias(alias, key);
          }
        }
        __name(addNewAlias, "addNewAlias");
        function processValue(key, val, shouldStripQuotes) {
          if (shouldStripQuotes) {
            val = stripQuotes(val);
          }
          if (checkAllAliases(key, flags.bools) || checkAllAliases(key, flags.counts)) {
            if (typeof val === "string") val = val === "true";
          }
          let value2 = Array.isArray(val) ? val.map(function(v) {
            return maybeCoerceNumber(key, v);
          }) : maybeCoerceNumber(key, val);
          if (checkAllAliases(key, flags.counts) && (isUndefined(value2) || typeof value2 === "boolean")) {
            value2 = increment();
          }
          if (checkAllAliases(key, flags.normalize) && checkAllAliases(key, flags.arrays)) {
            if (Array.isArray(val)) value2 = val.map((val2) => {
              return mixin2.normalize(val2);
            });
            else value2 = mixin2.normalize(val);
          }
          return value2;
        }
        __name(processValue, "processValue");
        function maybeCoerceNumber(key, value2) {
          if (!configuration["parse-positional-numbers"] && key === "_") return value2;
          if (!checkAllAliases(key, flags.strings) && !checkAllAliases(key, flags.bools) && !Array.isArray(value2)) {
            const shouldCoerceNumber = looksLikeNumber(value2) && configuration["parse-numbers"] && Number.isSafeInteger(Math.floor(parseFloat(`${value2}`)));
            if (shouldCoerceNumber || !isUndefined(value2) && checkAllAliases(key, flags.numbers)) {
              value2 = Number(value2);
            }
          }
          return value2;
        }
        __name(maybeCoerceNumber, "maybeCoerceNumber");
        function setConfig(argv3) {
          const configLookup = /* @__PURE__ */ Object.create(null);
          applyDefaultsAndAliases(configLookup, flags.aliases, defaults);
          Object.keys(flags.configs).forEach(function(configKey) {
            const configPath = argv3[configKey] || configLookup[configKey];
            if (configPath) {
              try {
                let config = null;
                const resolvedConfigPath = mixin2.resolve(mixin2.cwd(), configPath);
                const resolveConfig = flags.configs[configKey];
                if (typeof resolveConfig === "function") {
                  try {
                    config = resolveConfig(resolvedConfigPath);
                  } catch (e) {
                    config = e;
                  }
                  if (config instanceof Error) {
                    error = config;
                    return;
                  }
                } else {
                  config = mixin2.require(resolvedConfigPath);
                }
                setConfigObject(config);
              } catch (ex) {
                if (ex.name === "PermissionDenied") error = ex;
                else if (argv3[configKey]) error = Error(__("Invalid JSON config file: %s", configPath));
              }
            }
          });
        }
        __name(setConfig, "setConfig");
        function setConfigObject(config, prev) {
          Object.keys(config).forEach(function(key) {
            const value2 = config[key];
            const fullKey = prev ? prev + "." + key : key;
            if (typeof value2 === "object" && value2 !== null && !Array.isArray(value2) && configuration["dot-notation"]) {
              setConfigObject(value2, fullKey);
            } else {
              if (!hasKey(argv2, fullKey.split(".")) || checkAllAliases(fullKey, flags.arrays) && configuration["combine-arrays"]) {
                setArg(fullKey, value2);
              }
            }
          });
        }
        __name(setConfigObject, "setConfigObject");
        function setConfigObjects() {
          if (typeof configObjects !== "undefined") {
            configObjects.forEach(function(configObject) {
              setConfigObject(configObject);
            });
          }
        }
        __name(setConfigObjects, "setConfigObjects");
        function applyEnvVars(argv3, configOnly) {
          if (typeof envPrefix === "undefined") return;
          const prefix = typeof envPrefix === "string" ? envPrefix : "";
          const env2 = mixin2.env();
          Object.keys(env2).forEach(function(envVar) {
            if (prefix === "" || envVar.lastIndexOf(prefix, 0) === 0) {
              const keys = envVar.split("__").map(function(key, i) {
                if (i === 0) {
                  key = key.substring(prefix.length);
                }
                return camelCase(key);
              });
              if ((configOnly && flags.configs[keys.join(".")] || !configOnly) && !hasKey(argv3, keys)) {
                setArg(keys.join("."), env2[envVar]);
              }
            }
          });
        }
        __name(applyEnvVars, "applyEnvVars");
        function applyCoercions(argv3) {
          let coerce2;
          const applied = /* @__PURE__ */ new Set();
          Object.keys(argv3).forEach(function(key) {
            if (!applied.has(key)) {
              coerce2 = checkAllAliases(key, flags.coercions);
              if (typeof coerce2 === "function") {
                try {
                  const value2 = maybeCoerceNumber(key, coerce2(argv3[key]));
                  [].concat(flags.aliases[key] || [], key).forEach((ali) => {
                    applied.add(ali);
                    argv3[ali] = value2;
                  });
                } catch (err) {
                  error = err;
                }
              }
            }
          });
        }
        __name(applyCoercions, "applyCoercions");
        function setPlaceholderKeys(argv3) {
          flags.keys.forEach((key) => {
            if (~key.indexOf(".")) return;
            if (typeof argv3[key] === "undefined") argv3[key] = void 0;
          });
          return argv3;
        }
        __name(setPlaceholderKeys, "setPlaceholderKeys");
        function applyDefaultsAndAliases(obj, aliases2, defaults2, canLog = false) {
          Object.keys(defaults2).forEach(function(key) {
            if (!hasKey(obj, key.split("."))) {
              setKey(obj, key.split("."), defaults2[key]);
              if (canLog) defaulted[key] = true;
              (aliases2[key] || []).forEach(function(x) {
                if (hasKey(obj, x.split("."))) return;
                setKey(obj, x.split("."), defaults2[key]);
              });
            }
          });
        }
        __name(applyDefaultsAndAliases, "applyDefaultsAndAliases");
        function hasKey(obj, keys) {
          let o = obj;
          if (!configuration["dot-notation"]) keys = [
            keys.join(".")
          ];
          keys.slice(0, -1).forEach(function(key2) {
            o = o[key2] || {};
          });
          const key = keys[keys.length - 1];
          if (typeof o !== "object") return false;
          else return key in o;
        }
        __name(hasKey, "hasKey");
        function setKey(obj, keys, value2) {
          let o = obj;
          if (!configuration["dot-notation"]) keys = [
            keys.join(".")
          ];
          keys.slice(0, -1).forEach(function(key2) {
            key2 = sanitizeKey(key2);
            if (typeof o === "object" && o[key2] === void 0) {
              o[key2] = {};
            }
            if (typeof o[key2] !== "object" || Array.isArray(o[key2])) {
              if (Array.isArray(o[key2])) {
                o[key2].push({});
              } else {
                o[key2] = [
                  o[key2],
                  {}
                ];
              }
              o = o[key2][o[key2].length - 1];
            } else {
              o = o[key2];
            }
          });
          const key = sanitizeKey(keys[keys.length - 1]);
          const isTypeArray = checkAllAliases(keys.join("."), flags.arrays);
          const isValueArray = Array.isArray(value2);
          let duplicate = configuration["duplicate-arguments-array"];
          if (!duplicate && checkAllAliases(key, flags.nargs)) {
            duplicate = true;
            if (!isUndefined(o[key]) && flags.nargs[key] === 1 || Array.isArray(o[key]) && o[key].length === flags.nargs[key]) {
              o[key] = void 0;
            }
          }
          if (value2 === increment()) {
            o[key] = increment(o[key]);
          } else if (Array.isArray(o[key])) {
            if (duplicate && isTypeArray && isValueArray) {
              o[key] = configuration["flatten-duplicate-arrays"] ? o[key].concat(value2) : (Array.isArray(o[key][0]) ? o[key] : [
                o[key]
              ]).concat([
                value2
              ]);
            } else if (!duplicate && Boolean(isTypeArray) === Boolean(isValueArray)) {
              o[key] = value2;
            } else {
              o[key] = o[key].concat([
                value2
              ]);
            }
          } else if (o[key] === void 0 && isTypeArray) {
            o[key] = isValueArray ? value2 : [
              value2
            ];
          } else if (duplicate && !(o[key] === void 0 || checkAllAliases(key, flags.counts) || checkAllAliases(key, flags.bools))) {
            o[key] = [
              o[key],
              value2
            ];
          } else {
            o[key] = value2;
          }
        }
        __name(setKey, "setKey");
        function extendAliases(...args2) {
          args2.forEach(function(obj) {
            Object.keys(obj || {}).forEach(function(key) {
              if (flags.aliases[key]) return;
              flags.aliases[key] = [].concat(aliases[key] || []);
              flags.aliases[key].concat(key).forEach(function(x) {
                if (/-/.test(x) && configuration["camel-case-expansion"]) {
                  const c = camelCase(x);
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].concat(key).forEach(function(x) {
                if (x.length > 1 && /[A-Z]/.test(x) && configuration["camel-case-expansion"]) {
                  const c = decamelize(x, "-");
                  if (c !== key && flags.aliases[key].indexOf(c) === -1) {
                    flags.aliases[key].push(c);
                    newAliases[c] = true;
                  }
                }
              });
              flags.aliases[key].forEach(function(x) {
                flags.aliases[x] = [
                  key
                ].concat(flags.aliases[key].filter(function(y) {
                  return x !== y;
                }));
              });
            });
          });
        }
        __name(extendAliases, "extendAliases");
        function checkAllAliases(key, flag) {
          const toCheck = [].concat(flags.aliases[key] || [], key);
          const keys = Object.keys(flag);
          const setAlias = toCheck.find((key2) => keys.includes(key2));
          return setAlias ? flag[setAlias] : false;
        }
        __name(checkAllAliases, "checkAllAliases");
        function hasAnyFlag(key) {
          const flagsKeys = Object.keys(flags);
          const toCheck = [].concat(flagsKeys.map((k) => flags[k]));
          return toCheck.some(function(flag) {
            return Array.isArray(flag) ? flag.includes(key) : flag[key];
          });
        }
        __name(hasAnyFlag, "hasAnyFlag");
        function hasFlagsMatching(arg, ...patterns) {
          const toCheck = [].concat(...patterns);
          return toCheck.some(function(pattern) {
            const match = arg.match(pattern);
            return match && hasAnyFlag(match[1]);
          });
        }
        __name(hasFlagsMatching, "hasFlagsMatching");
        function hasAllShortFlags(arg) {
          if (arg.match(negative) || !arg.match(/^-[^-]+/)) {
            return false;
          }
          let hasAllFlags = true;
          let next;
          const letters = arg.slice(1).split("");
          for (let j = 0; j < letters.length; j++) {
            next = arg.slice(j + 2);
            if (!hasAnyFlag(letters[j])) {
              hasAllFlags = false;
              break;
            }
            if (letters[j + 1] && letters[j + 1] === "=" || next === "-" || /[A-Za-z]/.test(letters[j]) && /^-?\d+(\.\d*)?(e-?\d+)?$/.test(next) || letters[j + 1] && letters[j + 1].match(/\W/)) {
              break;
            }
          }
          return hasAllFlags;
        }
        __name(hasAllShortFlags, "hasAllShortFlags");
        function isUnknownOptionAsArg(arg) {
          return configuration["unknown-options-as-args"] && isUnknownOption(arg);
        }
        __name(isUnknownOptionAsArg, "isUnknownOptionAsArg");
        function isUnknownOption(arg) {
          arg = arg.replace(/^-{3,}/, "--");
          if (arg.match(negative)) {
            return false;
          }
          if (hasAllShortFlags(arg)) {
            return false;
          }
          const flagWithEquals = /^-+([^=]+?)=[\s\S]*$/;
          const normalFlag = /^-+([^=]+?)$/;
          const flagEndingInHyphen = /^-+([^=]+?)-$/;
          const flagEndingInDigits = /^-+([^=]+?\d+)$/;
          const flagEndingInNonWordCharacters = /^-+([^=]+?)\W+.*$/;
          return !hasFlagsMatching(arg, flagWithEquals, negatedBoolean, normalFlag, flagEndingInHyphen, flagEndingInDigits, flagEndingInNonWordCharacters);
        }
        __name(isUnknownOption, "isUnknownOption");
        function defaultValue(key) {
          if (!checkAllAliases(key, flags.bools) && !checkAllAliases(key, flags.counts) && `${key}` in defaults) {
            return defaults[key];
          } else {
            return defaultForType(guessType2(key));
          }
        }
        __name(defaultValue, "defaultValue");
        function defaultForType(type) {
          const def = {
            [DefaultValuesForTypeKey.BOOLEAN]: true,
            [DefaultValuesForTypeKey.STRING]: "",
            [DefaultValuesForTypeKey.NUMBER]: void 0,
            [DefaultValuesForTypeKey.ARRAY]: []
          };
          return def[type];
        }
        __name(defaultForType, "defaultForType");
        function guessType2(key) {
          let type = DefaultValuesForTypeKey.BOOLEAN;
          if (checkAllAliases(key, flags.strings)) type = DefaultValuesForTypeKey.STRING;
          else if (checkAllAliases(key, flags.numbers)) type = DefaultValuesForTypeKey.NUMBER;
          else if (checkAllAliases(key, flags.bools)) type = DefaultValuesForTypeKey.BOOLEAN;
          else if (checkAllAliases(key, flags.arrays)) type = DefaultValuesForTypeKey.ARRAY;
          return type;
        }
        __name(guessType2, "guessType");
        function isUndefined(num) {
          return num === void 0;
        }
        __name(isUndefined, "isUndefined");
        function checkConfiguration() {
          Object.keys(flags.counts).find((key) => {
            if (checkAllAliases(key, flags.arrays)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.array.", key));
              return true;
            } else if (checkAllAliases(key, flags.nargs)) {
              error = Error(__("Invalid configuration: %s, opts.count excludes opts.narg.", key));
              return true;
            }
            return false;
          });
        }
        __name(checkConfiguration, "checkConfiguration");
        return {
          aliases: Object.assign({}, flags.aliases),
          argv: Object.assign(argvReturn, argv2),
          configuration,
          defaulted: Object.assign({}, defaulted),
          error,
          newAliases: Object.assign({}, newAliases)
        };
      }
    };
    __name(combineAliases, "combineAliases");
    __name(increment, "increment");
    __name(sanitizeKey, "sanitizeKey");
    __name(stripQuotes, "stripQuotes");
  }
});

// node_modules/yargs-parser/build/lib/index.js
var import_util, import_path2, import_fs2, _a, _b, _c, minNodeVersion, nodeVersion, env, parser, yargsParser, lib_default;
var init_lib2 = __esm({
  "node_modules/yargs-parser/build/lib/index.js"() {
    "use strict";
    import_util = require("util");
    import_path2 = require("path");
    init_string_utils2();
    init_yargs_parser();
    import_fs2 = require("fs");
    minNodeVersion = process && process.env && process.env.YARGS_MIN_NODE_VERSION ? Number(process.env.YARGS_MIN_NODE_VERSION) : 12;
    nodeVersion = (_b = (_a = process === null || process === void 0 ? void 0 : process.versions) === null || _a === void 0 ? void 0 : _a.node) !== null && _b !== void 0 ? _b : (_c = process === null || process === void 0 ? void 0 : process.version) === null || _c === void 0 ? void 0 : _c.slice(1);
    if (nodeVersion) {
      const major = Number(nodeVersion.match(/^([^.]+)/)[1]);
      if (major < minNodeVersion) {
        throw Error(`yargs parser supports a minimum Node.js version of ${minNodeVersion}. Read our version support policy: https://github.com/yargs/yargs-parser#supported-nodejs-versions`);
      }
    }
    env = process ? process.env : {};
    parser = new YargsParser({
      cwd: process.cwd,
      env: /* @__PURE__ */ __name(() => {
        return env;
      }, "env"),
      format: import_util.format,
      normalize: import_path2.normalize,
      resolve: import_path2.resolve,
      // TODO: figure  out a  way to combine ESM and CJS coverage, such  that
      // we can exercise all the lines below:
      require: /* @__PURE__ */ __name((path) => {
        if (typeof require !== "undefined") {
          return require(path);
        } else if (path.match(/\.json$/)) {
          return JSON.parse((0, import_fs2.readFileSync)(path, "utf8"));
        } else {
          throw Error("only .json config files are supported in ESM");
        }
      }, "require")
    });
    yargsParser = /* @__PURE__ */ __name(function Parser(args, opts) {
      const result2 = parser.parse(args.slice(), opts);
      return result2.argv;
    }, "Parser");
    yargsParser.detailed = function(args, opts) {
      return parser.parse(args.slice(), opts);
    };
    yargsParser.camelCase = camelCase;
    yargsParser.decamelize = decamelize;
    yargsParser.looksLikeNumber = looksLikeNumber;
    lib_default = yargsParser;
  }
});

// node_modules/yargs/build/lib/utils/process-argv.js
function getProcessArgvBinIndex() {
  if (isBundledElectronApp()) return 0;
  return 1;
}
function isBundledElectronApp() {
  return isElectronApp() && !process.defaultApp;
}
function isElectronApp() {
  return !!process.versions.electron;
}
function hideBin(argv2) {
  return argv2.slice(getProcessArgvBinIndex() + 1);
}
function getProcessArgvBin() {
  return process.argv[getProcessArgvBinIndex()];
}
var init_process_argv = __esm({
  "node_modules/yargs/build/lib/utils/process-argv.js"() {
    "use strict";
    __name(getProcessArgvBinIndex, "getProcessArgvBinIndex");
    __name(isBundledElectronApp, "isBundledElectronApp");
    __name(isElectronApp, "isElectronApp");
    __name(hideBin, "hideBin");
    __name(getProcessArgvBin, "getProcessArgvBin");
  }
});

// node_modules/yargs/build/lib/yerror.js
var YError;
var init_yerror = __esm({
  "node_modules/yargs/build/lib/yerror.js"() {
    "use strict";
    YError = class _YError extends Error {
      static {
        __name(this, "YError");
      }
      constructor(msg) {
        super(msg || "yargs error");
        this.name = "YError";
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _YError);
        }
      }
    };
  }
});

// node_modules/y18n/build/lib/platform-shims/node.js
var import_fs3, import_util2, import_path3, node_default;
var init_node = __esm({
  "node_modules/y18n/build/lib/platform-shims/node.js"() {
    "use strict";
    import_fs3 = require("fs");
    import_util2 = require("util");
    import_path3 = require("path");
    node_default = {
      fs: {
        readFileSync: import_fs3.readFileSync,
        writeFile: import_fs3.writeFile
      },
      format: import_util2.format,
      resolve: import_path3.resolve,
      exists: /* @__PURE__ */ __name((file) => {
        try {
          return (0, import_fs3.statSync)(file).isFile();
        } catch (err) {
          return false;
        }
      }, "exists")
    };
  }
});

// node_modules/y18n/build/lib/index.js
function y18n(opts, _shim) {
  shim = _shim;
  const y18n3 = new Y18N(opts);
  return {
    __: y18n3.__.bind(y18n3),
    __n: y18n3.__n.bind(y18n3),
    setLocale: y18n3.setLocale.bind(y18n3),
    getLocale: y18n3.getLocale.bind(y18n3),
    updateLocale: y18n3.updateLocale.bind(y18n3),
    locale: y18n3.locale
  };
}
var shim, Y18N;
var init_lib3 = __esm({
  "node_modules/y18n/build/lib/index.js"() {
    "use strict";
    Y18N = class Y18N2 {
      static {
        __name(this, "Y18N");
      }
      constructor(opts) {
        opts = opts || {};
        this.directory = opts.directory || "./locales";
        this.updateFiles = typeof opts.updateFiles === "boolean" ? opts.updateFiles : true;
        this.locale = opts.locale || "en";
        this.fallbackToLanguage = typeof opts.fallbackToLanguage === "boolean" ? opts.fallbackToLanguage : true;
        this.cache = /* @__PURE__ */ Object.create(null);
        this.writeQueue = [];
      }
      __(...args) {
        if (typeof arguments[0] !== "string") {
          return this._taggedLiteral(arguments[0], ...arguments);
        }
        const str = args.shift();
        let cb = /* @__PURE__ */ __name(function() {
        }, "cb");
        if (typeof args[args.length - 1] === "function") cb = args.pop();
        cb = cb || function() {
        };
        if (!this.cache[this.locale]) this._readLocaleFile();
        if (!this.cache[this.locale][str] && this.updateFiles) {
          this.cache[this.locale][str] = str;
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        return shim.format.apply(shim.format, [
          this.cache[this.locale][str] || str
        ].concat(args));
      }
      __n() {
        const args = Array.prototype.slice.call(arguments);
        const singular = args.shift();
        const plural = args.shift();
        const quantity = args.shift();
        let cb = /* @__PURE__ */ __name(function() {
        }, "cb");
        if (typeof args[args.length - 1] === "function") cb = args.pop();
        if (!this.cache[this.locale]) this._readLocaleFile();
        let str = quantity === 1 ? singular : plural;
        if (this.cache[this.locale][singular]) {
          const entry = this.cache[this.locale][singular];
          str = entry[quantity === 1 ? "one" : "other"];
        }
        if (!this.cache[this.locale][singular] && this.updateFiles) {
          this.cache[this.locale][singular] = {
            one: singular,
            other: plural
          };
          this._enqueueWrite({
            directory: this.directory,
            locale: this.locale,
            cb
          });
        } else {
          cb();
        }
        const values = [
          str
        ];
        if (~str.indexOf("%d")) values.push(quantity);
        return shim.format.apply(shim.format, values.concat(args));
      }
      setLocale(locale) {
        this.locale = locale;
      }
      getLocale() {
        return this.locale;
      }
      updateLocale(obj) {
        if (!this.cache[this.locale]) this._readLocaleFile();
        for (const key in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, key)) {
            this.cache[this.locale][key] = obj[key];
          }
        }
      }
      _taggedLiteral(parts2, ...args) {
        let str = "";
        parts2.forEach(function(part, i) {
          const arg = args[i + 1];
          str += part;
          if (typeof arg !== "undefined") {
            str += "%s";
          }
        });
        return this.__.apply(this, [
          str
        ].concat([].slice.call(args, 1)));
      }
      _enqueueWrite(work) {
        this.writeQueue.push(work);
        if (this.writeQueue.length === 1) this._processWriteQueue();
      }
      _processWriteQueue() {
        const _this = this;
        const work = this.writeQueue[0];
        const directory = work.directory;
        const locale = work.locale;
        const cb = work.cb;
        const languageFile = this._resolveLocaleFile(directory, locale);
        const serializedLocale = JSON.stringify(this.cache[locale], null, 2);
        shim.fs.writeFile(languageFile, serializedLocale, "utf-8", function(err) {
          _this.writeQueue.shift();
          if (_this.writeQueue.length > 0) _this._processWriteQueue();
          cb(err);
        });
      }
      _readLocaleFile() {
        let localeLookup = {};
        const languageFile = this._resolveLocaleFile(this.directory, this.locale);
        try {
          if (shim.fs.readFileSync) {
            localeLookup = JSON.parse(shim.fs.readFileSync(languageFile, "utf-8"));
          }
        } catch (err) {
          if (err instanceof SyntaxError) {
            err.message = "syntax error in " + languageFile;
          }
          if (err.code === "ENOENT") localeLookup = {};
          else throw err;
        }
        this.cache[this.locale] = localeLookup;
      }
      _resolveLocaleFile(directory, locale) {
        let file = shim.resolve(directory, "./", locale + ".json");
        if (this.fallbackToLanguage && !this._fileExistsSync(file) && ~locale.lastIndexOf("_")) {
          const languageFile = shim.resolve(directory, "./", locale.split("_")[0] + ".json");
          if (this._fileExistsSync(languageFile)) file = languageFile;
        }
        return file;
      }
      _fileExistsSync(file) {
        return shim.exists(file);
      }
    };
    __name(y18n, "y18n");
  }
});

// node_modules/y18n/index.mjs
var y18n2, y18n_default;
var init_y18n = __esm({
  "node_modules/y18n/index.mjs"() {
    "use strict";
    init_node();
    init_lib3();
    y18n2 = /* @__PURE__ */ __name((opts) => {
      return y18n(opts, node_default);
    }, "y18n");
    y18n_default = y18n2;
  }
});

// node_modules/yargs/lib/platform-shims/esm.mjs
var import_assert, import_util3, import_fs4, import_url, import_path4, import_meta, REQUIRE_ERROR, REQUIRE_DIRECTORY_ERROR, __dirname2, mainFilename, esm_default;
var init_esm = __esm({
  "node_modules/yargs/lib/platform-shims/esm.mjs"() {
    "use strict";
    import_assert = require("assert");
    init_cliui();
    init_sync();
    import_util3 = require("util");
    import_fs4 = require("fs");
    import_url = require("url");
    init_lib2();
    import_path4 = require("path");
    init_process_argv();
    init_yerror();
    init_y18n();
    import_meta = {};
    REQUIRE_ERROR = "require is not supported by ESM";
    REQUIRE_DIRECTORY_ERROR = "loading a directory of commands is not supported yet for ESM";
    try {
      __dirname2 = (0, import_url.fileURLToPath)(import_meta.url);
    } catch (e) {
      __dirname2 = process.cwd();
    }
    mainFilename = __dirname2.substring(0, __dirname2.lastIndexOf("node_modules"));
    esm_default = {
      assert: {
        notStrictEqual: import_assert.notStrictEqual,
        strictEqual: import_assert.strictEqual
      },
      cliui: ui,
      findUp: sync_default,
      getEnv: /* @__PURE__ */ __name((key) => {
        return process.env[key];
      }, "getEnv"),
      inspect: import_util3.inspect,
      getCallerFile: /* @__PURE__ */ __name(() => {
        throw new YError(REQUIRE_DIRECTORY_ERROR);
      }, "getCallerFile"),
      getProcessArgvBin,
      mainFilename: mainFilename || process.cwd(),
      Parser: lib_default,
      path: {
        basename: import_path4.basename,
        dirname: import_path4.dirname,
        extname: import_path4.extname,
        relative: import_path4.relative,
        resolve: import_path4.resolve
      },
      process: {
        argv: /* @__PURE__ */ __name(() => process.argv, "argv"),
        cwd: process.cwd,
        emitWarning: /* @__PURE__ */ __name((warning, type) => process.emitWarning(warning, type), "emitWarning"),
        execPath: /* @__PURE__ */ __name(() => process.execPath, "execPath"),
        exit: process.exit,
        nextTick: process.nextTick,
        stdColumns: typeof process.stdout.columns !== "undefined" ? process.stdout.columns : null
      },
      readFileSync: import_fs4.readFileSync,
      require: /* @__PURE__ */ __name(() => {
        throw new YError(REQUIRE_ERROR);
      }, "require"),
      requireDirectory: /* @__PURE__ */ __name(() => {
        throw new YError(REQUIRE_DIRECTORY_ERROR);
      }, "requireDirectory"),
      stringWidth: /* @__PURE__ */ __name((str) => {
        return [...str].length;
      }, "stringWidth"),
      y18n: y18n_default({
        directory: (0, import_path4.resolve)(__dirname2, "../../../locales"),
        updateFiles: false
      })
    };
  }
});

// node_modules/yargs/build/lib/typings/common-types.js
function assertNotStrictEqual(actual, expected, shim3, message) {
  shim3.assert.notStrictEqual(actual, expected, message);
}
function assertSingleKey(actual, shim3) {
  shim3.assert.strictEqual(typeof actual, "string");
}
function objectKeys(object) {
  return Object.keys(object);
}
var init_common_types = __esm({
  "node_modules/yargs/build/lib/typings/common-types.js"() {
    "use strict";
    __name(assertNotStrictEqual, "assertNotStrictEqual");
    __name(assertSingleKey, "assertSingleKey");
    __name(objectKeys, "objectKeys");
  }
});

// node_modules/yargs/build/lib/utils/is-promise.js
function isPromise(maybePromise) {
  return !!maybePromise && !!maybePromise.then && typeof maybePromise.then === "function";
}
var init_is_promise = __esm({
  "node_modules/yargs/build/lib/utils/is-promise.js"() {
    "use strict";
    __name(isPromise, "isPromise");
  }
});

// node_modules/yargs/build/lib/parse-command.js
function parseCommand(cmd) {
  const extraSpacesStrippedCommand = cmd.replace(/\s{2,}/g, " ");
  const splitCommand = extraSpacesStrippedCommand.split(/\s+(?![^[]*]|[^<]*>)/);
  const bregex = /\.*[\][<>]/g;
  const firstCommand = splitCommand.shift();
  if (!firstCommand) throw new Error(`No command found in: ${cmd}`);
  const parsedCommand = {
    cmd: firstCommand.replace(bregex, ""),
    demanded: [],
    optional: []
  };
  splitCommand.forEach((cmd2, i) => {
    let variadic = false;
    cmd2 = cmd2.replace(/\s/g, "");
    if (/\.+[\]>]/.test(cmd2) && i === splitCommand.length - 1) variadic = true;
    if (/^\[/.test(cmd2)) {
      parsedCommand.optional.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    } else {
      parsedCommand.demanded.push({
        cmd: cmd2.replace(bregex, "").split("|"),
        variadic
      });
    }
  });
  return parsedCommand;
}
var init_parse_command = __esm({
  "node_modules/yargs/build/lib/parse-command.js"() {
    "use strict";
    __name(parseCommand, "parseCommand");
  }
});

// node_modules/yargs/build/lib/argsert.js
function argsert(arg1, arg2, arg3) {
  function parseArgs() {
    return typeof arg1 === "object" ? [
      {
        demanded: [],
        optional: []
      },
      arg1,
      arg2
    ] : [
      parseCommand(`cmd ${arg1}`),
      arg2,
      arg3
    ];
  }
  __name(parseArgs, "parseArgs");
  try {
    let position = 0;
    const [parsed, callerArguments, _length] = parseArgs();
    const args = [].slice.call(callerArguments);
    while (args.length && args[args.length - 1] === void 0) args.pop();
    const length = _length || args.length;
    if (length < parsed.demanded.length) {
      throw new YError(`Not enough arguments provided. Expected ${parsed.demanded.length} but received ${args.length}.`);
    }
    const totalCommands = parsed.demanded.length + parsed.optional.length;
    if (length > totalCommands) {
      throw new YError(`Too many arguments provided. Expected max ${totalCommands} but received ${length}.`);
    }
    parsed.demanded.forEach((demanded) => {
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = demanded.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0) argumentTypeError(observedType, demanded.cmd, position);
      position += 1;
    });
    parsed.optional.forEach((optional) => {
      if (args.length === 0) return;
      const arg = args.shift();
      const observedType = guessType(arg);
      const matchingTypes = optional.cmd.filter((type) => type === observedType || type === "*");
      if (matchingTypes.length === 0) argumentTypeError(observedType, optional.cmd, position);
      position += 1;
    });
  } catch (err) {
    console.warn(err.stack);
  }
}
function guessType(arg) {
  if (Array.isArray(arg)) {
    return "array";
  } else if (arg === null) {
    return "null";
  }
  return typeof arg;
}
function argumentTypeError(observedType, allowedTypes, position) {
  throw new YError(`Invalid ${positionName[position] || "manyith"} argument. Expected ${allowedTypes.join(" or ")} but received ${observedType}.`);
}
var positionName;
var init_argsert = __esm({
  "node_modules/yargs/build/lib/argsert.js"() {
    "use strict";
    init_yerror();
    init_parse_command();
    positionName = [
      "first",
      "second",
      "third",
      "fourth",
      "fifth",
      "sixth"
    ];
    __name(argsert, "argsert");
    __name(guessType, "guessType");
    __name(argumentTypeError, "argumentTypeError");
  }
});

// node_modules/yargs/build/lib/middleware.js
function commandMiddlewareFactory(commandMiddleware) {
  if (!commandMiddleware) return [];
  return commandMiddleware.map((middleware) => {
    middleware.applyBeforeValidation = false;
    return middleware;
  });
}
function applyMiddleware(argv2, yargs, middlewares, beforeValidation) {
  return middlewares.reduce((acc, middleware) => {
    if (middleware.applyBeforeValidation !== beforeValidation) {
      return acc;
    }
    if (middleware.mutates) {
      if (middleware.applied) return acc;
      middleware.applied = true;
    }
    if (isPromise(acc)) {
      return acc.then((initialObj) => Promise.all([
        initialObj,
        middleware(initialObj, yargs)
      ])).then(([initialObj, middlewareObj]) => Object.assign(initialObj, middlewareObj));
    } else {
      const result2 = middleware(acc, yargs);
      return isPromise(result2) ? result2.then((middlewareObj) => Object.assign(acc, middlewareObj)) : Object.assign(acc, result2);
    }
  }, argv2);
}
var GlobalMiddleware;
var init_middleware = __esm({
  "node_modules/yargs/build/lib/middleware.js"() {
    "use strict";
    init_argsert();
    init_is_promise();
    GlobalMiddleware = class {
      static {
        __name(this, "GlobalMiddleware");
      }
      constructor(yargs) {
        this.globalMiddleware = [];
        this.frozens = [];
        this.yargs = yargs;
      }
      addMiddleware(callback, applyBeforeValidation, global2 = true, mutates = false) {
        argsert("<array|function> [boolean] [boolean] [boolean]", [
          callback,
          applyBeforeValidation,
          global2
        ], arguments.length);
        if (Array.isArray(callback)) {
          for (let i = 0; i < callback.length; i++) {
            if (typeof callback[i] !== "function") {
              throw Error("middleware must be a function");
            }
            const m = callback[i];
            m.applyBeforeValidation = applyBeforeValidation;
            m.global = global2;
          }
          Array.prototype.push.apply(this.globalMiddleware, callback);
        } else if (typeof callback === "function") {
          const m = callback;
          m.applyBeforeValidation = applyBeforeValidation;
          m.global = global2;
          m.mutates = mutates;
          this.globalMiddleware.push(callback);
        }
        return this.yargs;
      }
      addCoerceMiddleware(callback, option) {
        const aliases = this.yargs.getAliases();
        this.globalMiddleware = this.globalMiddleware.filter((m) => {
          const toCheck = [
            ...aliases[option] || [],
            option
          ];
          if (!m.option) return true;
          else return !toCheck.includes(m.option);
        });
        callback.option = option;
        return this.addMiddleware(callback, true, true, true);
      }
      getMiddleware() {
        return this.globalMiddleware;
      }
      freeze() {
        this.frozens.push([
          ...this.globalMiddleware
        ]);
      }
      unfreeze() {
        const frozen = this.frozens.pop();
        if (frozen !== void 0) this.globalMiddleware = frozen;
      }
      reset() {
        this.globalMiddleware = this.globalMiddleware.filter((m) => m.global);
      }
    };
    __name(commandMiddlewareFactory, "commandMiddlewareFactory");
    __name(applyMiddleware, "applyMiddleware");
  }
});

// node_modules/yargs/build/lib/utils/maybe-async-result.js
function maybeAsyncResult(getResult, resultHandler, errorHandler = (err) => {
  throw err;
}) {
  try {
    const result2 = isFunction(getResult) ? getResult() : getResult;
    return isPromise(result2) ? result2.then((result3) => resultHandler(result3)) : resultHandler(result2);
  } catch (err) {
    return errorHandler(err);
  }
}
function isFunction(arg) {
  return typeof arg === "function";
}
var init_maybe_async_result = __esm({
  "node_modules/yargs/build/lib/utils/maybe-async-result.js"() {
    "use strict";
    init_is_promise();
    __name(maybeAsyncResult, "maybeAsyncResult");
    __name(isFunction, "isFunction");
  }
});

// node_modules/yargs/build/lib/utils/which-module.js
function whichModule(exported) {
  if (typeof require === "undefined") return null;
  for (let i = 0, files = Object.keys(require.cache), mod2; i < files.length; i++) {
    mod2 = require.cache[files[i]];
    if (mod2.exports === exported) return mod2;
  }
  return null;
}
var init_which_module = __esm({
  "node_modules/yargs/build/lib/utils/which-module.js"() {
    "use strict";
    __name(whichModule, "whichModule");
  }
});

// node_modules/yargs/build/lib/command.js
function command(usage2, validation2, globalMiddleware, shim3) {
  return new CommandInstance(usage2, validation2, globalMiddleware, shim3);
}
function isCommandBuilderDefinition(builder) {
  return typeof builder === "object" && !!builder.builder && typeof builder.handler === "function";
}
function isCommandAndAliases(cmd) {
  return cmd.every((c) => typeof c === "string");
}
function isCommandBuilderCallback(builder) {
  return typeof builder === "function";
}
function isCommandBuilderOptionDefinitions(builder) {
  return typeof builder === "object";
}
function isCommandHandlerDefinition(cmd) {
  return typeof cmd === "object" && !Array.isArray(cmd);
}
var DEFAULT_MARKER, CommandInstance;
var init_command = __esm({
  "node_modules/yargs/build/lib/command.js"() {
    "use strict";
    init_common_types();
    init_is_promise();
    init_middleware();
    init_parse_command();
    init_yargs_factory();
    init_maybe_async_result();
    init_which_module();
    DEFAULT_MARKER = /(^\*)|(^\$0)/;
    CommandInstance = class {
      static {
        __name(this, "CommandInstance");
      }
      constructor(usage2, validation2, globalMiddleware, shim3) {
        this.requireCache = /* @__PURE__ */ new Set();
        this.handlers = {};
        this.aliasMap = {};
        this.frozens = [];
        this.shim = shim3;
        this.usage = usage2;
        this.globalMiddleware = globalMiddleware;
        this.validation = validation2;
      }
      addDirectory(dir, req, callerFile, opts) {
        opts = opts || {};
        if (typeof opts.recurse !== "boolean") opts.recurse = false;
        if (!Array.isArray(opts.extensions)) opts.extensions = [
          "js"
        ];
        const parentVisit = typeof opts.visit === "function" ? opts.visit : (o) => o;
        opts.visit = (obj, joined, filename) => {
          const visited = parentVisit(obj, joined, filename);
          if (visited) {
            if (this.requireCache.has(joined)) return visited;
            else this.requireCache.add(joined);
            this.addHandler(visited);
          }
          return visited;
        };
        this.shim.requireDirectory({
          require: req,
          filename: callerFile
        }, dir, opts);
      }
      addHandler(cmd, description, builder, handler, commandMiddleware, deprecated) {
        let aliases = [];
        const middlewares = commandMiddlewareFactory(commandMiddleware);
        handler = handler || (() => {
        });
        if (Array.isArray(cmd)) {
          if (isCommandAndAliases(cmd)) {
            [cmd, ...aliases] = cmd;
          } else {
            for (const command2 of cmd) {
              this.addHandler(command2);
            }
          }
        } else if (isCommandHandlerDefinition(cmd)) {
          let command2 = Array.isArray(cmd.command) || typeof cmd.command === "string" ? cmd.command : this.moduleName(cmd);
          if (cmd.aliases) command2 = [].concat(command2).concat(cmd.aliases);
          this.addHandler(command2, this.extractDesc(cmd), cmd.builder, cmd.handler, cmd.middlewares, cmd.deprecated);
          return;
        } else if (isCommandBuilderDefinition(builder)) {
          this.addHandler([
            cmd
          ].concat(aliases), description, builder.builder, builder.handler, builder.middlewares, builder.deprecated);
          return;
        }
        if (typeof cmd === "string") {
          const parsedCommand = parseCommand(cmd);
          aliases = aliases.map((alias) => parseCommand(alias).cmd);
          let isDefault = false;
          const parsedAliases = [
            parsedCommand.cmd
          ].concat(aliases).filter((c) => {
            if (DEFAULT_MARKER.test(c)) {
              isDefault = true;
              return false;
            }
            return true;
          });
          if (parsedAliases.length === 0 && isDefault) parsedAliases.push("$0");
          if (isDefault) {
            parsedCommand.cmd = parsedAliases[0];
            aliases = parsedAliases.slice(1);
            cmd = cmd.replace(DEFAULT_MARKER, parsedCommand.cmd);
          }
          aliases.forEach((alias) => {
            this.aliasMap[alias] = parsedCommand.cmd;
          });
          if (description !== false) {
            this.usage.command(cmd, description, isDefault, aliases, deprecated);
          }
          this.handlers[parsedCommand.cmd] = {
            original: cmd,
            description,
            handler,
            builder: builder || {},
            middlewares,
            deprecated,
            demanded: parsedCommand.demanded,
            optional: parsedCommand.optional
          };
          if (isDefault) this.defaultCommand = this.handlers[parsedCommand.cmd];
        }
      }
      getCommandHandlers() {
        return this.handlers;
      }
      getCommands() {
        return Object.keys(this.handlers).concat(Object.keys(this.aliasMap));
      }
      hasDefaultCommand() {
        return !!this.defaultCommand;
      }
      runCommand(command2, yargs, parsed, commandIndex, helpOnly, helpOrVersionSet) {
        const commandHandler = this.handlers[command2] || this.handlers[this.aliasMap[command2]] || this.defaultCommand;
        const currentContext = yargs.getInternalMethods().getContext();
        const parentCommands = currentContext.commands.slice();
        const isDefaultCommand = !command2;
        if (command2) {
          currentContext.commands.push(command2);
          currentContext.fullCommands.push(commandHandler.original);
        }
        const builderResult = this.applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, parsed.aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet);
        return isPromise(builderResult) ? builderResult.then((result2) => this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, result2.innerArgv, currentContext, helpOnly, result2.aliases, yargs)) : this.applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, builderResult.innerArgv, currentContext, helpOnly, builderResult.aliases, yargs);
      }
      applyBuilderUpdateUsageAndParse(isDefaultCommand, commandHandler, yargs, aliases, parentCommands, commandIndex, helpOnly, helpOrVersionSet) {
        const builder = commandHandler.builder;
        let innerYargs = yargs;
        if (isCommandBuilderCallback(builder)) {
          yargs.getInternalMethods().getUsageInstance().freeze();
          const builderOutput = builder(yargs.getInternalMethods().reset(aliases), helpOrVersionSet);
          if (isPromise(builderOutput)) {
            return builderOutput.then((output) => {
              innerYargs = isYargsInstance(output) ? output : yargs;
              return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
            });
          }
        } else if (isCommandBuilderOptionDefinitions(builder)) {
          yargs.getInternalMethods().getUsageInstance().freeze();
          innerYargs = yargs.getInternalMethods().reset(aliases);
          Object.keys(commandHandler.builder).forEach((key) => {
            innerYargs.option(key, builder[key]);
          });
        }
        return this.parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly);
      }
      parseAndUpdateUsage(isDefaultCommand, commandHandler, innerYargs, parentCommands, commandIndex, helpOnly) {
        if (isDefaultCommand) innerYargs.getInternalMethods().getUsageInstance().unfreeze(true);
        if (this.shouldUpdateUsage(innerYargs)) {
          innerYargs.getInternalMethods().getUsageInstance().usage(this.usageFromParentCommandsCommandHandler(parentCommands, commandHandler), commandHandler.description);
        }
        const innerArgv = innerYargs.getInternalMethods().runYargsParserAndExecuteCommands(null, void 0, true, commandIndex, helpOnly);
        return isPromise(innerArgv) ? innerArgv.then((argv2) => ({
          aliases: innerYargs.parsed.aliases,
          innerArgv: argv2
        })) : {
          aliases: innerYargs.parsed.aliases,
          innerArgv
        };
      }
      shouldUpdateUsage(yargs) {
        return !yargs.getInternalMethods().getUsageInstance().getUsageDisabled() && yargs.getInternalMethods().getUsageInstance().getUsage().length === 0;
      }
      usageFromParentCommandsCommandHandler(parentCommands, commandHandler) {
        const c = DEFAULT_MARKER.test(commandHandler.original) ? commandHandler.original.replace(DEFAULT_MARKER, "").trim() : commandHandler.original;
        const pc = parentCommands.filter((c2) => {
          return !DEFAULT_MARKER.test(c2);
        });
        pc.push(c);
        return `$0 ${pc.join(" ")}`;
      }
      handleValidationAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, aliases, yargs, middlewares, positionalMap) {
        if (!yargs.getInternalMethods().getHasOutput()) {
          const validation2 = yargs.getInternalMethods().runValidation(aliases, positionalMap, yargs.parsed.error, isDefaultCommand);
          innerArgv = maybeAsyncResult(innerArgv, (result2) => {
            validation2(result2);
            return result2;
          });
        }
        if (commandHandler.handler && !yargs.getInternalMethods().getHasOutput()) {
          yargs.getInternalMethods().setHasOutput();
          const populateDoubleDash = !!yargs.getOptions().configuration["populate--"];
          yargs.getInternalMethods().postProcess(innerArgv, populateDoubleDash, false, false);
          innerArgv = applyMiddleware(innerArgv, yargs, middlewares, false);
          innerArgv = maybeAsyncResult(innerArgv, (result2) => {
            const handlerResult = commandHandler.handler(result2);
            return isPromise(handlerResult) ? handlerResult.then(() => result2) : result2;
          });
          if (!isDefaultCommand) {
            yargs.getInternalMethods().getUsageInstance().cacheHelpMessage();
          }
          if (isPromise(innerArgv) && !yargs.getInternalMethods().hasParseCallback()) {
            innerArgv.catch((error) => {
              try {
                yargs.getInternalMethods().getUsageInstance().fail(null, error);
              } catch (_err) {
              }
            });
          }
        }
        if (!isDefaultCommand) {
          currentContext.commands.pop();
          currentContext.fullCommands.pop();
        }
        return innerArgv;
      }
      applyMiddlewareAndGetResult(isDefaultCommand, commandHandler, innerArgv, currentContext, helpOnly, aliases, yargs) {
        let positionalMap = {};
        if (helpOnly) return innerArgv;
        if (!yargs.getInternalMethods().getHasOutput()) {
          positionalMap = this.populatePositionals(commandHandler, innerArgv, currentContext, yargs);
        }
        const middlewares = this.globalMiddleware.getMiddleware().slice(0).concat(commandHandler.middlewares);
        const maybePromiseArgv = applyMiddleware(innerArgv, yargs, middlewares, true);
        return isPromise(maybePromiseArgv) ? maybePromiseArgv.then((resolvedInnerArgv) => this.handleValidationAndGetResult(isDefaultCommand, commandHandler, resolvedInnerArgv, currentContext, aliases, yargs, middlewares, positionalMap)) : this.handleValidationAndGetResult(isDefaultCommand, commandHandler, maybePromiseArgv, currentContext, aliases, yargs, middlewares, positionalMap);
      }
      populatePositionals(commandHandler, argv2, context, yargs) {
        argv2._ = argv2._.slice(context.commands.length);
        const demanded = commandHandler.demanded.slice(0);
        const optional = commandHandler.optional.slice(0);
        const positionalMap = {};
        this.validation.positionalCount(demanded.length, argv2._.length);
        while (demanded.length) {
          const demand = demanded.shift();
          this.populatePositional(demand, argv2, positionalMap);
        }
        while (optional.length) {
          const maybe = optional.shift();
          this.populatePositional(maybe, argv2, positionalMap);
        }
        argv2._ = context.commands.concat(argv2._.map((a) => "" + a));
        this.postProcessPositionals(argv2, positionalMap, this.cmdToParseOptions(commandHandler.original), yargs);
        return positionalMap;
      }
      populatePositional(positional, argv2, positionalMap) {
        const cmd = positional.cmd[0];
        if (positional.variadic) {
          positionalMap[cmd] = argv2._.splice(0).map(String);
        } else {
          if (argv2._.length) positionalMap[cmd] = [
            String(argv2._.shift())
          ];
        }
      }
      cmdToParseOptions(cmdString) {
        const parseOptions = {
          array: [],
          default: {},
          alias: {},
          demand: {}
        };
        const parsed = parseCommand(cmdString);
        parsed.demanded.forEach((d) => {
          const [cmd, ...aliases] = d.cmd;
          if (d.variadic) {
            parseOptions.array.push(cmd);
            parseOptions.default[cmd] = [];
          }
          parseOptions.alias[cmd] = aliases;
          parseOptions.demand[cmd] = true;
        });
        parsed.optional.forEach((o) => {
          const [cmd, ...aliases] = o.cmd;
          if (o.variadic) {
            parseOptions.array.push(cmd);
            parseOptions.default[cmd] = [];
          }
          parseOptions.alias[cmd] = aliases;
        });
        return parseOptions;
      }
      postProcessPositionals(argv2, positionalMap, parseOptions, yargs) {
        const options = Object.assign({}, yargs.getOptions());
        options.default = Object.assign(parseOptions.default, options.default);
        for (const key of Object.keys(parseOptions.alias)) {
          options.alias[key] = (options.alias[key] || []).concat(parseOptions.alias[key]);
        }
        options.array = options.array.concat(parseOptions.array);
        options.config = {};
        const unparsed = [];
        Object.keys(positionalMap).forEach((key) => {
          positionalMap[key].map((value2) => {
            if (options.configuration["unknown-options-as-args"]) options.key[key] = true;
            unparsed.push(`--${key}`);
            unparsed.push(value2);
          });
        });
        if (!unparsed.length) return;
        const config = Object.assign({}, options.configuration, {
          "populate--": false
        });
        const parsed = this.shim.Parser.detailed(unparsed, Object.assign({}, options, {
          configuration: config
        }));
        if (parsed.error) {
          yargs.getInternalMethods().getUsageInstance().fail(parsed.error.message, parsed.error);
        } else {
          const positionalKeys = Object.keys(positionalMap);
          Object.keys(positionalMap).forEach((key) => {
            positionalKeys.push(...parsed.aliases[key]);
          });
          Object.keys(parsed.argv).forEach((key) => {
            if (positionalKeys.includes(key)) {
              if (!positionalMap[key]) positionalMap[key] = parsed.argv[key];
              if (!this.isInConfigs(yargs, key) && !this.isDefaulted(yargs, key) && Object.prototype.hasOwnProperty.call(argv2, key) && Object.prototype.hasOwnProperty.call(parsed.argv, key) && (Array.isArray(argv2[key]) || Array.isArray(parsed.argv[key]))) {
                argv2[key] = [].concat(argv2[key], parsed.argv[key]);
              } else {
                argv2[key] = parsed.argv[key];
              }
            }
          });
        }
      }
      isDefaulted(yargs, key) {
        const { default: defaults } = yargs.getOptions();
        return Object.prototype.hasOwnProperty.call(defaults, key) || Object.prototype.hasOwnProperty.call(defaults, this.shim.Parser.camelCase(key));
      }
      isInConfigs(yargs, key) {
        const { configObjects } = yargs.getOptions();
        return configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, key)) || configObjects.some((c) => Object.prototype.hasOwnProperty.call(c, this.shim.Parser.camelCase(key)));
      }
      runDefaultBuilderOn(yargs) {
        if (!this.defaultCommand) return;
        if (this.shouldUpdateUsage(yargs)) {
          const commandString = DEFAULT_MARKER.test(this.defaultCommand.original) ? this.defaultCommand.original : this.defaultCommand.original.replace(/^[^[\]<>]*/, "$0 ");
          yargs.getInternalMethods().getUsageInstance().usage(commandString, this.defaultCommand.description);
        }
        const builder = this.defaultCommand.builder;
        if (isCommandBuilderCallback(builder)) {
          return builder(yargs, true);
        } else if (!isCommandBuilderDefinition(builder)) {
          Object.keys(builder).forEach((key) => {
            yargs.option(key, builder[key]);
          });
        }
        return void 0;
      }
      moduleName(obj) {
        const mod2 = whichModule(obj);
        if (!mod2) throw new Error(`No command name given for module: ${this.shim.inspect(obj)}`);
        return this.commandFromFilename(mod2.filename);
      }
      commandFromFilename(filename) {
        return this.shim.path.basename(filename, this.shim.path.extname(filename));
      }
      extractDesc({ describe, description, desc }) {
        for (const test of [
          describe,
          description,
          desc
        ]) {
          if (typeof test === "string" || test === false) return test;
          assertNotStrictEqual(test, true, this.shim);
        }
        return false;
      }
      freeze() {
        this.frozens.push({
          handlers: this.handlers,
          aliasMap: this.aliasMap,
          defaultCommand: this.defaultCommand
        });
      }
      unfreeze() {
        const frozen = this.frozens.pop();
        assertNotStrictEqual(frozen, void 0, this.shim);
        ({ handlers: this.handlers, aliasMap: this.aliasMap, defaultCommand: this.defaultCommand } = frozen);
      }
      reset() {
        this.handlers = {};
        this.aliasMap = {};
        this.defaultCommand = void 0;
        this.requireCache = /* @__PURE__ */ new Set();
        return this;
      }
    };
    __name(command, "command");
    __name(isCommandBuilderDefinition, "isCommandBuilderDefinition");
    __name(isCommandAndAliases, "isCommandAndAliases");
    __name(isCommandBuilderCallback, "isCommandBuilderCallback");
    __name(isCommandBuilderOptionDefinitions, "isCommandBuilderOptionDefinitions");
    __name(isCommandHandlerDefinition, "isCommandHandlerDefinition");
  }
});

// node_modules/yargs/build/lib/utils/obj-filter.js
function objFilter(original = {}, filter = () => true) {
  const obj = {};
  objectKeys(original).forEach((key) => {
    if (filter(key, original[key])) {
      obj[key] = original[key];
    }
  });
  return obj;
}
var init_obj_filter = __esm({
  "node_modules/yargs/build/lib/utils/obj-filter.js"() {
    "use strict";
    init_common_types();
    __name(objFilter, "objFilter");
  }
});

// node_modules/yargs/build/lib/utils/set-blocking.js
function setBlocking(blocking) {
  if (typeof process === "undefined") return;
  [
    process.stdout,
    process.stderr
  ].forEach((_stream) => {
    const stream = _stream;
    if (stream._handle && stream.isTTY && typeof stream._handle.setBlocking === "function") {
      stream._handle.setBlocking(blocking);
    }
  });
}
var init_set_blocking = __esm({
  "node_modules/yargs/build/lib/utils/set-blocking.js"() {
    "use strict";
    __name(setBlocking, "setBlocking");
  }
});

// node_modules/yargs/build/lib/usage.js
function isBoolean(fail) {
  return typeof fail === "boolean";
}
function usage(yargs, shim3) {
  const __ = shim3.y18n.__;
  const self2 = {};
  const fails = [];
  self2.failFn = /* @__PURE__ */ __name(function failFn(f) {
    fails.push(f);
  }, "failFn");
  let failMessage = null;
  let globalFailMessage = null;
  let showHelpOnFail = true;
  self2.showHelpOnFail = /* @__PURE__ */ __name(function showHelpOnFailFn(arg1 = true, arg2) {
    const [enabled, message] = typeof arg1 === "string" ? [
      true,
      arg1
    ] : [
      arg1,
      arg2
    ];
    if (yargs.getInternalMethods().isGlobalContext()) {
      globalFailMessage = message;
    }
    failMessage = message;
    showHelpOnFail = enabled;
    return self2;
  }, "showHelpOnFailFn");
  let failureOutput = false;
  self2.fail = /* @__PURE__ */ __name(function fail(msg, err) {
    const logger2 = yargs.getInternalMethods().getLoggerInstance();
    if (fails.length) {
      for (let i = fails.length - 1; i >= 0; --i) {
        const fail2 = fails[i];
        if (isBoolean(fail2)) {
          if (err) throw err;
          else if (msg) throw Error(msg);
        } else {
          fail2(msg, err, self2);
        }
      }
    } else {
      if (yargs.getExitProcess()) setBlocking(true);
      if (!failureOutput) {
        failureOutput = true;
        if (showHelpOnFail) {
          yargs.showHelp("error");
          logger2.error();
        }
        if (msg || err) logger2.error(msg || err);
        const globalOrCommandFailMessage = failMessage || globalFailMessage;
        if (globalOrCommandFailMessage) {
          if (msg || err) logger2.error("");
          logger2.error(globalOrCommandFailMessage);
        }
      }
      err = err || new YError(msg);
      if (yargs.getExitProcess()) {
        return yargs.exit(1);
      } else if (yargs.getInternalMethods().hasParseCallback()) {
        return yargs.exit(1, err);
      } else {
        throw err;
      }
    }
  }, "fail");
  let usages = [];
  let usageDisabled = false;
  self2.usage = (msg, description) => {
    if (msg === null) {
      usageDisabled = true;
      usages = [];
      return self2;
    }
    usageDisabled = false;
    usages.push([
      msg,
      description || ""
    ]);
    return self2;
  };
  self2.getUsage = () => {
    return usages;
  };
  self2.getUsageDisabled = () => {
    return usageDisabled;
  };
  self2.getPositionalGroupName = () => {
    return __("Positionals:");
  };
  let examples = [];
  self2.example = (cmd, description) => {
    examples.push([
      cmd,
      description || ""
    ]);
  };
  let commands = [];
  self2.command = /* @__PURE__ */ __name(function command2(cmd, description, isDefault, aliases, deprecated = false) {
    if (isDefault) {
      commands = commands.map((cmdArray) => {
        cmdArray[2] = false;
        return cmdArray;
      });
    }
    commands.push([
      cmd,
      description || "",
      isDefault,
      aliases,
      deprecated
    ]);
  }, "command");
  self2.getCommands = () => commands;
  let descriptions = {};
  self2.describe = /* @__PURE__ */ __name(function describe(keyOrKeys, desc) {
    if (Array.isArray(keyOrKeys)) {
      keyOrKeys.forEach((k) => {
        self2.describe(k, desc);
      });
    } else if (typeof keyOrKeys === "object") {
      Object.keys(keyOrKeys).forEach((k) => {
        self2.describe(k, keyOrKeys[k]);
      });
    } else {
      descriptions[keyOrKeys] = desc;
    }
  }, "describe");
  self2.getDescriptions = () => descriptions;
  let epilogs = [];
  self2.epilog = (msg) => {
    epilogs.push(msg);
  };
  let wrapSet = false;
  let wrap2;
  self2.wrap = (cols) => {
    wrapSet = true;
    wrap2 = cols;
  };
  self2.getWrap = () => {
    if (shim3.getEnv("YARGS_DISABLE_WRAP")) {
      return null;
    }
    if (!wrapSet) {
      wrap2 = windowWidth();
      wrapSet = true;
    }
    return wrap2;
  };
  const deferY18nLookupPrefix = "__yargsString__:";
  self2.deferY18nLookup = (str) => deferY18nLookupPrefix + str;
  self2.help = /* @__PURE__ */ __name(function help() {
    if (cachedHelpMessage) return cachedHelpMessage;
    normalizeAliases();
    const base$0 = yargs.customScriptName ? yargs.$0 : shim3.path.basename(yargs.$0);
    const demandedOptions = yargs.getDemandedOptions();
    const demandedCommands = yargs.getDemandedCommands();
    const deprecatedOptions = yargs.getDeprecatedOptions();
    const groups = yargs.getGroups();
    const options = yargs.getOptions();
    let keys = [];
    keys = keys.concat(Object.keys(descriptions));
    keys = keys.concat(Object.keys(demandedOptions));
    keys = keys.concat(Object.keys(demandedCommands));
    keys = keys.concat(Object.keys(options.default));
    keys = keys.filter(filterHiddenOptions);
    keys = Object.keys(keys.reduce((acc, key) => {
      if (key !== "_") acc[key] = true;
      return acc;
    }, {}));
    const theWrap = self2.getWrap();
    const ui2 = shim3.cliui({
      width: theWrap,
      wrap: !!theWrap
    });
    if (!usageDisabled) {
      if (usages.length) {
        usages.forEach((usage2) => {
          ui2.div({
            text: `${usage2[0].replace(/\$0/g, base$0)}`
          });
          if (usage2[1]) {
            ui2.div({
              text: `${usage2[1]}`,
              padding: [
                1,
                0,
                0,
                0
              ]
            });
          }
        });
        ui2.div();
      } else if (commands.length) {
        let u = null;
        if (demandedCommands._) {
          u = `${base$0} <${__("command")}>
`;
        } else {
          u = `${base$0} [${__("command")}]
`;
        }
        ui2.div(`${u}`);
      }
    }
    if (commands.length > 1 || commands.length === 1 && !commands[0][2]) {
      ui2.div(__("Commands:"));
      const context = yargs.getInternalMethods().getContext();
      const parentCommands = context.commands.length ? `${context.commands.join(" ")} ` : "";
      if (yargs.getInternalMethods().getParserConfiguration()["sort-commands"] === true) {
        commands = commands.sort((a, b) => a[0].localeCompare(b[0]));
      }
      const prefix = base$0 ? `${base$0} ` : "";
      commands.forEach((command2) => {
        const commandString = `${prefix}${parentCommands}${command2[0].replace(/^\$0 ?/, "")}`;
        ui2.span({
          text: commandString,
          padding: [
            0,
            2,
            0,
            2
          ],
          width: maxWidth(commands, theWrap, `${base$0}${parentCommands}`) + 4
        }, {
          text: command2[1]
        });
        const hints = [];
        if (command2[2]) hints.push(`[${__("default")}]`);
        if (command2[3] && command2[3].length) {
          hints.push(`[${__("aliases:")} ${command2[3].join(", ")}]`);
        }
        if (command2[4]) {
          if (typeof command2[4] === "string") {
            hints.push(`[${__("deprecated: %s", command2[4])}]`);
          } else {
            hints.push(`[${__("deprecated")}]`);
          }
        }
        if (hints.length) {
          ui2.div({
            text: hints.join(" "),
            padding: [
              0,
              0,
              0,
              2
            ],
            align: "right"
          });
        } else {
          ui2.div();
        }
      });
      ui2.div();
    }
    const aliasKeys = (Object.keys(options.alias) || []).concat(Object.keys(yargs.parsed.newAliases) || []);
    keys = keys.filter((key) => !yargs.parsed.newAliases[key] && aliasKeys.every((alias) => (options.alias[alias] || []).indexOf(key) === -1));
    const defaultGroup = __("Options:");
    if (!groups[defaultGroup]) groups[defaultGroup] = [];
    addUngroupedKeys(keys, options.alias, groups, defaultGroup);
    const isLongSwitch = /* @__PURE__ */ __name((sw) => /^--/.test(getText(sw)), "isLongSwitch");
    const displayedGroups = Object.keys(groups).filter((groupName) => groups[groupName].length > 0).map((groupName) => {
      const normalizedKeys = groups[groupName].filter(filterHiddenOptions).map((key) => {
        if (aliasKeys.includes(key)) return key;
        for (let i = 0, aliasKey; (aliasKey = aliasKeys[i]) !== void 0; i++) {
          if ((options.alias[aliasKey] || []).includes(key)) return aliasKey;
        }
        return key;
      });
      return {
        groupName,
        normalizedKeys
      };
    }).filter(({ normalizedKeys }) => normalizedKeys.length > 0).map(({ groupName, normalizedKeys }) => {
      const switches = normalizedKeys.reduce((acc, key) => {
        acc[key] = [
          key
        ].concat(options.alias[key] || []).map((sw) => {
          if (groupName === self2.getPositionalGroupName()) return sw;
          else {
            return (/^[0-9]$/.test(sw) ? options.boolean.includes(key) ? "-" : "--" : sw.length > 1 ? "--" : "-") + sw;
          }
        }).sort((sw1, sw2) => isLongSwitch(sw1) === isLongSwitch(sw2) ? 0 : isLongSwitch(sw1) ? 1 : -1).join(", ");
        return acc;
      }, {});
      return {
        groupName,
        normalizedKeys,
        switches
      };
    });
    const shortSwitchesUsed = displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).some(({ normalizedKeys, switches }) => !normalizedKeys.every((key) => isLongSwitch(switches[key])));
    if (shortSwitchesUsed) {
      displayedGroups.filter(({ groupName }) => groupName !== self2.getPositionalGroupName()).forEach(({ normalizedKeys, switches }) => {
        normalizedKeys.forEach((key) => {
          if (isLongSwitch(switches[key])) {
            switches[key] = addIndentation(switches[key], "-x, ".length);
          }
        });
      });
    }
    displayedGroups.forEach(({ groupName, normalizedKeys, switches }) => {
      ui2.div(groupName);
      normalizedKeys.forEach((key) => {
        const kswitch = switches[key];
        let desc = descriptions[key] || "";
        let type = null;
        if (desc.includes(deferY18nLookupPrefix)) desc = __(desc.substring(deferY18nLookupPrefix.length));
        if (options.boolean.includes(key)) type = `[${__("boolean")}]`;
        if (options.count.includes(key)) type = `[${__("count")}]`;
        if (options.string.includes(key)) type = `[${__("string")}]`;
        if (options.normalize.includes(key)) type = `[${__("string")}]`;
        if (options.array.includes(key)) type = `[${__("array")}]`;
        if (options.number.includes(key)) type = `[${__("number")}]`;
        const deprecatedExtra = /* @__PURE__ */ __name((deprecated) => typeof deprecated === "string" ? `[${__("deprecated: %s", deprecated)}]` : `[${__("deprecated")}]`, "deprecatedExtra");
        const extra = [
          key in deprecatedOptions ? deprecatedExtra(deprecatedOptions[key]) : null,
          type,
          key in demandedOptions ? `[${__("required")}]` : null,
          options.choices && options.choices[key] ? `[${__("choices:")} ${self2.stringifiedValues(options.choices[key])}]` : null,
          defaultString(options.default[key], options.defaultDescription[key])
        ].filter(Boolean).join(" ");
        ui2.span({
          text: getText(kswitch),
          padding: [
            0,
            2,
            0,
            2 + getIndentation(kswitch)
          ],
          width: maxWidth(switches, theWrap) + 4
        }, desc);
        const shouldHideOptionExtras = yargs.getInternalMethods().getUsageConfiguration()["hide-types"] === true;
        if (extra && !shouldHideOptionExtras) ui2.div({
          text: extra,
          padding: [
            0,
            0,
            0,
            2
          ],
          align: "right"
        });
        else ui2.div();
      });
      ui2.div();
    });
    if (examples.length) {
      ui2.div(__("Examples:"));
      examples.forEach((example) => {
        example[0] = example[0].replace(/\$0/g, base$0);
      });
      examples.forEach((example) => {
        if (example[1] === "") {
          ui2.div({
            text: example[0],
            padding: [
              0,
              2,
              0,
              2
            ]
          });
        } else {
          ui2.div({
            text: example[0],
            padding: [
              0,
              2,
              0,
              2
            ],
            width: maxWidth(examples, theWrap) + 4
          }, {
            text: example[1]
          });
        }
      });
      ui2.div();
    }
    if (epilogs.length > 0) {
      const e = epilogs.map((epilog) => epilog.replace(/\$0/g, base$0)).join("\n");
      ui2.div(`${e}
`);
    }
    return ui2.toString().replace(/\s*$/, "");
  }, "help");
  function maxWidth(table, theWrap, modifier) {
    let width = 0;
    if (!Array.isArray(table)) {
      table = Object.values(table).map((v) => [
        v
      ]);
    }
    table.forEach((v) => {
      width = Math.max(shim3.stringWidth(modifier ? `${modifier} ${getText(v[0])}` : getText(v[0])) + getIndentation(v[0]), width);
    });
    if (theWrap) width = Math.min(width, parseInt((theWrap * 0.5).toString(), 10));
    return width;
  }
  __name(maxWidth, "maxWidth");
  function normalizeAliases() {
    const demandedOptions = yargs.getDemandedOptions();
    const options = yargs.getOptions();
    (Object.keys(options.alias) || []).forEach((key) => {
      options.alias[key].forEach((alias) => {
        if (descriptions[alias]) self2.describe(key, descriptions[alias]);
        if (alias in demandedOptions) yargs.demandOption(key, demandedOptions[alias]);
        if (options.boolean.includes(alias)) yargs.boolean(key);
        if (options.count.includes(alias)) yargs.count(key);
        if (options.string.includes(alias)) yargs.string(key);
        if (options.normalize.includes(alias)) yargs.normalize(key);
        if (options.array.includes(alias)) yargs.array(key);
        if (options.number.includes(alias)) yargs.number(key);
      });
    });
  }
  __name(normalizeAliases, "normalizeAliases");
  let cachedHelpMessage;
  self2.cacheHelpMessage = function() {
    cachedHelpMessage = this.help();
  };
  self2.clearCachedHelpMessage = function() {
    cachedHelpMessage = void 0;
  };
  self2.hasCachedHelpMessage = function() {
    return !!cachedHelpMessage;
  };
  function addUngroupedKeys(keys, aliases, groups, defaultGroup) {
    let groupedKeys = [];
    let toCheck = null;
    Object.keys(groups).forEach((group) => {
      groupedKeys = groupedKeys.concat(groups[group]);
    });
    keys.forEach((key) => {
      toCheck = [
        key
      ].concat(aliases[key]);
      if (!toCheck.some((k) => groupedKeys.indexOf(k) !== -1)) {
        groups[defaultGroup].push(key);
      }
    });
    return groupedKeys;
  }
  __name(addUngroupedKeys, "addUngroupedKeys");
  function filterHiddenOptions(key) {
    return yargs.getOptions().hiddenOptions.indexOf(key) < 0 || yargs.parsed.argv[yargs.getOptions().showHiddenOpt];
  }
  __name(filterHiddenOptions, "filterHiddenOptions");
  self2.showHelp = (level) => {
    const logger2 = yargs.getInternalMethods().getLoggerInstance();
    if (!level) level = "error";
    const emit = typeof level === "function" ? level : logger2[level];
    emit(self2.help());
  };
  self2.functionDescription = (fn) => {
    const description = fn.name ? shim3.Parser.decamelize(fn.name, "-") : __("generated-value");
    return [
      "(",
      description,
      ")"
    ].join("");
  };
  self2.stringifiedValues = /* @__PURE__ */ __name(function stringifiedValues(values, separator) {
    let string = "";
    const sep = separator || ", ";
    const array = [].concat(values);
    if (!values || !array.length) return string;
    array.forEach((value2) => {
      if (string.length) string += sep;
      string += JSON.stringify(value2);
    });
    return string;
  }, "stringifiedValues");
  function defaultString(value2, defaultDescription) {
    let string = `[${__("default:")} `;
    if (value2 === void 0 && !defaultDescription) return null;
    if (defaultDescription) {
      string += defaultDescription;
    } else {
      switch (typeof value2) {
        case "string":
          string += `"${value2}"`;
          break;
        case "object":
          string += JSON.stringify(value2);
          break;
        default:
          string += value2;
      }
    }
    return `${string}]`;
  }
  __name(defaultString, "defaultString");
  function windowWidth() {
    const maxWidth2 = 80;
    if (shim3.process.stdColumns) {
      return Math.min(maxWidth2, shim3.process.stdColumns);
    } else {
      return maxWidth2;
    }
  }
  __name(windowWidth, "windowWidth");
  let version2 = null;
  self2.version = (ver) => {
    version2 = ver;
  };
  self2.showVersion = (level) => {
    const logger2 = yargs.getInternalMethods().getLoggerInstance();
    if (!level) level = "error";
    const emit = typeof level === "function" ? level : logger2[level];
    emit(version2);
  };
  self2.reset = /* @__PURE__ */ __name(function reset(localLookup) {
    failMessage = null;
    failureOutput = false;
    usages = [];
    usageDisabled = false;
    epilogs = [];
    examples = [];
    commands = [];
    descriptions = objFilter(descriptions, (k) => !localLookup[k]);
    return self2;
  }, "reset");
  const frozens = [];
  self2.freeze = /* @__PURE__ */ __name(function freeze() {
    frozens.push({
      failMessage,
      failureOutput,
      usages,
      usageDisabled,
      epilogs,
      examples,
      commands,
      descriptions
    });
  }, "freeze");
  self2.unfreeze = /* @__PURE__ */ __name(function unfreeze(defaultCommand = false) {
    const frozen = frozens.pop();
    if (!frozen) return;
    if (defaultCommand) {
      descriptions = {
        ...frozen.descriptions,
        ...descriptions
      };
      commands = [
        ...frozen.commands,
        ...commands
      ];
      usages = [
        ...frozen.usages,
        ...usages
      ];
      examples = [
        ...frozen.examples,
        ...examples
      ];
      epilogs = [
        ...frozen.epilogs,
        ...epilogs
      ];
    } else {
      ({ failMessage, failureOutput, usages, usageDisabled, epilogs, examples, commands, descriptions } = frozen);
    }
  }, "unfreeze");
  return self2;
}
function isIndentedText(text) {
  return typeof text === "object";
}
function addIndentation(text, indent) {
  return isIndentedText(text) ? {
    text: text.text,
    indentation: text.indentation + indent
  } : {
    text,
    indentation: indent
  };
}
function getIndentation(text) {
  return isIndentedText(text) ? text.indentation : 0;
}
function getText(text) {
  return isIndentedText(text) ? text.text : text;
}
var init_usage = __esm({
  "node_modules/yargs/build/lib/usage.js"() {
    "use strict";
    init_obj_filter();
    init_yerror();
    init_set_blocking();
    __name(isBoolean, "isBoolean");
    __name(usage, "usage");
    __name(isIndentedText, "isIndentedText");
    __name(addIndentation, "addIndentation");
    __name(getIndentation, "getIndentation");
    __name(getText, "getText");
  }
});

// node_modules/yargs/build/lib/completion-templates.js
var completionShTemplate, completionZshTemplate;
var init_completion_templates = __esm({
  "node_modules/yargs/build/lib/completion-templates.js"() {
    "use strict";
    completionShTemplate = `###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.bashrc
#    or {{app_path}} {{completion_command}} >> ~/.bash_profile on OSX.
#
_{{app_name}}_yargs_completions()
{
    local cur_word args type_list

    cur_word="\${COMP_WORDS[COMP_CWORD]}"
    args=("\${COMP_WORDS[@]}")

    # ask yargs to generate completions.
    type_list=$({{app_path}} --get-yargs-completions "\${args[@]}")

    COMPREPLY=( $(compgen -W "\${type_list}" -- \${cur_word}) )

    # if no match was found, fall back to filename completion
    if [ \${#COMPREPLY[@]} -eq 0 ]; then
      COMPREPLY=()
    fi

    return 0
}
complete -o bashdefault -o default -F _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
    completionZshTemplate = `#compdef {{app_name}}
###-begin-{{app_name}}-completions-###
#
# yargs command completion script
#
# Installation: {{app_path}} {{completion_command}} >> ~/.zshrc
#    or {{app_path}} {{completion_command}} >> ~/.zprofile on OSX.
#
_{{app_name}}_yargs_completions()
{
  local reply
  local si=$IFS
  IFS=$'
' reply=($(COMP_CWORD="$((CURRENT-1))" COMP_LINE="$BUFFER" COMP_POINT="$CURSOR" {{app_path}} --get-yargs-completions "\${words[@]}"))
  IFS=$si
  _describe 'values' reply
}
compdef _{{app_name}}_yargs_completions {{app_name}}
###-end-{{app_name}}-completions-###
`;
  }
});

// node_modules/yargs/build/lib/completion.js
function completion(yargs, usage2, command2, shim3) {
  return new Completion(yargs, usage2, command2, shim3);
}
function isSyncCompletionFunction(completionFunction) {
  return completionFunction.length < 3;
}
function isFallbackCompletionFunction(completionFunction) {
  return completionFunction.length > 3;
}
var Completion;
var init_completion = __esm({
  "node_modules/yargs/build/lib/completion.js"() {
    "use strict";
    init_command();
    init_common_types();
    init_completion_templates();
    init_is_promise();
    init_parse_command();
    Completion = class {
      static {
        __name(this, "Completion");
      }
      constructor(yargs, usage2, command2, shim3) {
        var _a2, _b2, _c2;
        this.yargs = yargs;
        this.usage = usage2;
        this.command = command2;
        this.shim = shim3;
        this.completionKey = "get-yargs-completions";
        this.aliases = null;
        this.customCompletionFunction = null;
        this.indexAfterLastReset = 0;
        this.zshShell = (_c2 = ((_a2 = this.shim.getEnv("SHELL")) === null || _a2 === void 0 ? void 0 : _a2.includes("zsh")) || ((_b2 = this.shim.getEnv("ZSH_NAME")) === null || _b2 === void 0 ? void 0 : _b2.includes("zsh"))) !== null && _c2 !== void 0 ? _c2 : false;
      }
      defaultCompletion(args, argv2, current, done) {
        const handlers = this.command.getCommandHandlers();
        for (let i = 0, ii = args.length; i < ii; ++i) {
          if (handlers[args[i]] && handlers[args[i]].builder) {
            const builder = handlers[args[i]].builder;
            if (isCommandBuilderCallback(builder)) {
              this.indexAfterLastReset = i + 1;
              const y = this.yargs.getInternalMethods().reset();
              builder(y, true);
              return y.argv;
            }
          }
        }
        const completions = [];
        this.commandCompletions(completions, args, current);
        this.optionCompletions(completions, args, argv2, current);
        this.choicesFromOptionsCompletions(completions, args, argv2, current);
        this.choicesFromPositionalsCompletions(completions, args, argv2, current);
        done(null, completions);
      }
      commandCompletions(completions, args, current) {
        const parentCommands = this.yargs.getInternalMethods().getContext().commands;
        if (!current.match(/^-/) && parentCommands[parentCommands.length - 1] !== current && !this.previousArgHasChoices(args)) {
          this.usage.getCommands().forEach((usageCommand) => {
            const commandName = parseCommand(usageCommand[0]).cmd;
            if (args.indexOf(commandName) === -1) {
              if (!this.zshShell) {
                completions.push(commandName);
              } else {
                const desc = usageCommand[1] || "";
                completions.push(commandName.replace(/:/g, "\\:") + ":" + desc);
              }
            }
          });
        }
      }
      optionCompletions(completions, args, argv2, current) {
        if ((current.match(/^-/) || current === "" && completions.length === 0) && !this.previousArgHasChoices(args)) {
          const options = this.yargs.getOptions();
          const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
          Object.keys(options.key).forEach((key) => {
            const negable = !!options.configuration["boolean-negation"] && options.boolean.includes(key);
            const isPositionalKey = positionalKeys.includes(key);
            if (!isPositionalKey && !options.hiddenOptions.includes(key) && !this.argsContainKey(args, key, negable)) {
              this.completeOptionKey(key, completions, current, negable && !!options.default[key]);
            }
          });
        }
      }
      choicesFromOptionsCompletions(completions, args, argv2, current) {
        if (this.previousArgHasChoices(args)) {
          const choices = this.getPreviousArgChoices(args);
          if (choices && choices.length > 0) {
            completions.push(...choices.map((c) => c.replace(/:/g, "\\:")));
          }
        }
      }
      choicesFromPositionalsCompletions(completions, args, argv2, current) {
        if (current === "" && completions.length > 0 && this.previousArgHasChoices(args)) {
          return;
        }
        const positionalKeys = this.yargs.getGroups()[this.usage.getPositionalGroupName()] || [];
        const offset = Math.max(this.indexAfterLastReset, this.yargs.getInternalMethods().getContext().commands.length + 1);
        const positionalKey = positionalKeys[argv2._.length - offset - 1];
        if (!positionalKey) {
          return;
        }
        const choices = this.yargs.getOptions().choices[positionalKey] || [];
        for (const choice of choices) {
          if (choice.startsWith(current)) {
            completions.push(choice.replace(/:/g, "\\:"));
          }
        }
      }
      getPreviousArgChoices(args) {
        if (args.length < 1) return;
        let previousArg = args[args.length - 1];
        let filter = "";
        if (!previousArg.startsWith("-") && args.length > 1) {
          filter = previousArg;
          previousArg = args[args.length - 2];
        }
        if (!previousArg.startsWith("-")) return;
        const previousArgKey = previousArg.replace(/^-+/, "");
        const options = this.yargs.getOptions();
        const possibleAliases = [
          previousArgKey,
          ...this.yargs.getAliases()[previousArgKey] || []
        ];
        let choices;
        for (const possibleAlias of possibleAliases) {
          if (Object.prototype.hasOwnProperty.call(options.key, possibleAlias) && Array.isArray(options.choices[possibleAlias])) {
            choices = options.choices[possibleAlias];
            break;
          }
        }
        if (choices) {
          return choices.filter((choice) => !filter || choice.startsWith(filter));
        }
      }
      previousArgHasChoices(args) {
        const choices = this.getPreviousArgChoices(args);
        return choices !== void 0 && choices.length > 0;
      }
      argsContainKey(args, key, negable) {
        const argsContains = /* @__PURE__ */ __name((s) => args.indexOf((/^[^0-9]$/.test(s) ? "-" : "--") + s) !== -1, "argsContains");
        if (argsContains(key)) return true;
        if (negable && argsContains(`no-${key}`)) return true;
        if (this.aliases) {
          for (const alias of this.aliases[key]) {
            if (argsContains(alias)) return true;
          }
        }
        return false;
      }
      completeOptionKey(key, completions, current, negable) {
        var _a2, _b2, _c2, _d;
        let keyWithDesc = key;
        if (this.zshShell) {
          const descs = this.usage.getDescriptions();
          const aliasKey = (_b2 = (_a2 = this === null || this === void 0 ? void 0 : this.aliases) === null || _a2 === void 0 ? void 0 : _a2[key]) === null || _b2 === void 0 ? void 0 : _b2.find((alias) => {
            const desc2 = descs[alias];
            return typeof desc2 === "string" && desc2.length > 0;
          });
          const descFromAlias = aliasKey ? descs[aliasKey] : void 0;
          const desc = (_d = (_c2 = descs[key]) !== null && _c2 !== void 0 ? _c2 : descFromAlias) !== null && _d !== void 0 ? _d : "";
          keyWithDesc = `${key.replace(/:/g, "\\:")}:${desc.replace("__yargsString__:", "").replace(/(\r\n|\n|\r)/gm, " ")}`;
        }
        const startsByTwoDashes = /* @__PURE__ */ __name((s) => /^--/.test(s), "startsByTwoDashes");
        const isShortOption = /* @__PURE__ */ __name((s) => /^[^0-9]$/.test(s), "isShortOption");
        const dashes = !startsByTwoDashes(current) && isShortOption(key) ? "-" : "--";
        completions.push(dashes + keyWithDesc);
        if (negable) {
          completions.push(dashes + "no-" + keyWithDesc);
        }
      }
      customCompletion(args, argv2, current, done) {
        assertNotStrictEqual(this.customCompletionFunction, null, this.shim);
        if (isSyncCompletionFunction(this.customCompletionFunction)) {
          const result2 = this.customCompletionFunction(current, argv2);
          if (isPromise(result2)) {
            return result2.then((list) => {
              this.shim.process.nextTick(() => {
                done(null, list);
              });
            }).catch((err) => {
              this.shim.process.nextTick(() => {
                done(err, void 0);
              });
            });
          }
          return done(null, result2);
        } else if (isFallbackCompletionFunction(this.customCompletionFunction)) {
          return this.customCompletionFunction(current, argv2, (onCompleted = done) => this.defaultCompletion(args, argv2, current, onCompleted), (completions) => {
            done(null, completions);
          });
        } else {
          return this.customCompletionFunction(current, argv2, (completions) => {
            done(null, completions);
          });
        }
      }
      getCompletion(args, done) {
        const current = args.length ? args[args.length - 1] : "";
        const argv2 = this.yargs.parse(args, true);
        const completionFunction = this.customCompletionFunction ? (argv3) => this.customCompletion(args, argv3, current, done) : (argv3) => this.defaultCompletion(args, argv3, current, done);
        return isPromise(argv2) ? argv2.then(completionFunction) : completionFunction(argv2);
      }
      generateCompletionScript($0, cmd) {
        let script = this.zshShell ? completionZshTemplate : completionShTemplate;
        const name = this.shim.path.basename($0);
        if ($0.match(/\.js$/)) $0 = `./${$0}`;
        script = script.replace(/{{app_name}}/g, name);
        script = script.replace(/{{completion_command}}/g, cmd);
        return script.replace(/{{app_path}}/g, $0);
      }
      registerFunction(fn) {
        this.customCompletionFunction = fn;
      }
      setParsed(parsed) {
        this.aliases = parsed.aliases;
      }
    };
    __name(completion, "completion");
    __name(isSyncCompletionFunction, "isSyncCompletionFunction");
    __name(isFallbackCompletionFunction, "isFallbackCompletionFunction");
  }
});

// node_modules/yargs/build/lib/utils/levenshtein.js
function levenshtein(a, b) {
  if (a.length === 0) return b.length;
  if (b.length === 0) return a.length;
  const matrix = [];
  let i;
  for (i = 0; i <= b.length; i++) {
    matrix[i] = [
      i
    ];
  }
  let j;
  for (j = 0; j <= a.length; j++) {
    matrix[0][j] = j;
  }
  for (i = 1; i <= b.length; i++) {
    for (j = 1; j <= a.length; j++) {
      if (b.charAt(i - 1) === a.charAt(j - 1)) {
        matrix[i][j] = matrix[i - 1][j - 1];
      } else {
        if (i > 1 && j > 1 && b.charAt(i - 2) === a.charAt(j - 1) && b.charAt(i - 1) === a.charAt(j - 2)) {
          matrix[i][j] = matrix[i - 2][j - 2] + 1;
        } else {
          matrix[i][j] = Math.min(matrix[i - 1][j - 1] + 1, Math.min(matrix[i][j - 1] + 1, matrix[i - 1][j] + 1));
        }
      }
    }
  }
  return matrix[b.length][a.length];
}
var init_levenshtein = __esm({
  "node_modules/yargs/build/lib/utils/levenshtein.js"() {
    "use strict";
    __name(levenshtein, "levenshtein");
  }
});

// node_modules/yargs/build/lib/validation.js
function validation(yargs, usage2, shim3) {
  const __ = shim3.y18n.__;
  const __n = shim3.y18n.__n;
  const self2 = {};
  self2.nonOptionCount = /* @__PURE__ */ __name(function nonOptionCount(argv2) {
    const demandedCommands = yargs.getDemandedCommands();
    const positionalCount = argv2._.length + (argv2["--"] ? argv2["--"].length : 0);
    const _s = positionalCount - yargs.getInternalMethods().getContext().commands.length;
    if (demandedCommands._ && (_s < demandedCommands._.min || _s > demandedCommands._.max)) {
      if (_s < demandedCommands._.min) {
        if (demandedCommands._.minMsg !== void 0) {
          usage2.fail(demandedCommands._.minMsg ? demandedCommands._.minMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.min.toString()) : null);
        } else {
          usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", _s, _s.toString(), demandedCommands._.min.toString()));
        }
      } else if (_s > demandedCommands._.max) {
        if (demandedCommands._.maxMsg !== void 0) {
          usage2.fail(demandedCommands._.maxMsg ? demandedCommands._.maxMsg.replace(/\$0/g, _s.toString()).replace(/\$1/, demandedCommands._.max.toString()) : null);
        } else {
          usage2.fail(__n("Too many non-option arguments: got %s, maximum of %s", "Too many non-option arguments: got %s, maximum of %s", _s, _s.toString(), demandedCommands._.max.toString()));
        }
      }
    }
  }, "nonOptionCount");
  self2.positionalCount = /* @__PURE__ */ __name(function positionalCount(required, observed) {
    if (observed < required) {
      usage2.fail(__n("Not enough non-option arguments: got %s, need at least %s", "Not enough non-option arguments: got %s, need at least %s", observed, observed + "", required + ""));
    }
  }, "positionalCount");
  self2.requiredArguments = /* @__PURE__ */ __name(function requiredArguments(argv2, demandedOptions) {
    let missing = null;
    for (const key of Object.keys(demandedOptions)) {
      if (!Object.prototype.hasOwnProperty.call(argv2, key) || typeof argv2[key] === "undefined") {
        missing = missing || {};
        missing[key] = demandedOptions[key];
      }
    }
    if (missing) {
      const customMsgs = [];
      for (const key of Object.keys(missing)) {
        const msg = missing[key];
        if (msg && customMsgs.indexOf(msg) < 0) {
          customMsgs.push(msg);
        }
      }
      const customMsg = customMsgs.length ? `
${customMsgs.join("\n")}` : "";
      usage2.fail(__n("Missing required argument: %s", "Missing required arguments: %s", Object.keys(missing).length, Object.keys(missing).join(", ") + customMsg));
    }
  }, "requiredArguments");
  self2.unknownArguments = /* @__PURE__ */ __name(function unknownArguments(argv2, aliases, positionalMap, isDefaultCommand, checkPositionals = true) {
    var _a2;
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    Object.keys(argv2).forEach((key) => {
      if (!specialKeys.includes(key) && !Object.prototype.hasOwnProperty.call(positionalMap, key) && !Object.prototype.hasOwnProperty.call(yargs.getInternalMethods().getParseContext(), key) && !self2.isValidAndSomeAliasIsNotNew(key, aliases)) {
        unknown.push(key);
      }
    });
    if (checkPositionals && (currentContext.commands.length > 0 || commandKeys.length > 0 || isDefaultCommand)) {
      argv2._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (checkPositionals) {
      const demandedCommands = yargs.getDemandedCommands();
      const maxNonOptDemanded = ((_a2 = demandedCommands._) === null || _a2 === void 0 ? void 0 : _a2.max) || 0;
      const expected = currentContext.commands.length + maxNonOptDemanded;
      if (expected < argv2._.length) {
        argv2._.slice(expected).forEach((key) => {
          key = String(key);
          if (!currentContext.commands.includes(key) && !unknown.includes(key)) {
            unknown.push(key);
          }
        });
      }
    }
    if (unknown.length) {
      usage2.fail(__n("Unknown argument: %s", "Unknown arguments: %s", unknown.length, unknown.map((s) => s.trim() ? s : `"${s}"`).join(", ")));
    }
  }, "unknownArguments");
  self2.unknownCommands = /* @__PURE__ */ __name(function unknownCommands(argv2) {
    const commandKeys = yargs.getInternalMethods().getCommandInstance().getCommands();
    const unknown = [];
    const currentContext = yargs.getInternalMethods().getContext();
    if (currentContext.commands.length > 0 || commandKeys.length > 0) {
      argv2._.slice(currentContext.commands.length).forEach((key) => {
        if (!commandKeys.includes("" + key)) {
          unknown.push("" + key);
        }
      });
    }
    if (unknown.length > 0) {
      usage2.fail(__n("Unknown command: %s", "Unknown commands: %s", unknown.length, unknown.join(", ")));
      return true;
    } else {
      return false;
    }
  }, "unknownCommands");
  self2.isValidAndSomeAliasIsNotNew = /* @__PURE__ */ __name(function isValidAndSomeAliasIsNotNew(key, aliases) {
    if (!Object.prototype.hasOwnProperty.call(aliases, key)) {
      return false;
    }
    const newAliases = yargs.parsed.newAliases;
    return [
      key,
      ...aliases[key]
    ].some((a) => !Object.prototype.hasOwnProperty.call(newAliases, a) || !newAliases[key]);
  }, "isValidAndSomeAliasIsNotNew");
  self2.limitedChoices = /* @__PURE__ */ __name(function limitedChoices(argv2) {
    const options = yargs.getOptions();
    const invalid = {};
    if (!Object.keys(options.choices).length) return;
    Object.keys(argv2).forEach((key) => {
      if (specialKeys.indexOf(key) === -1 && Object.prototype.hasOwnProperty.call(options.choices, key)) {
        [].concat(argv2[key]).forEach((value2) => {
          if (options.choices[key].indexOf(value2) === -1 && value2 !== void 0) {
            invalid[key] = (invalid[key] || []).concat(value2);
          }
        });
      }
    });
    const invalidKeys = Object.keys(invalid);
    if (!invalidKeys.length) return;
    let msg = __("Invalid values:");
    invalidKeys.forEach((key) => {
      msg += `
  ${__("Argument: %s, Given: %s, Choices: %s", key, usage2.stringifiedValues(invalid[key]), usage2.stringifiedValues(options.choices[key]))}`;
    });
    usage2.fail(msg);
  }, "limitedChoices");
  let implied = {};
  self2.implies = /* @__PURE__ */ __name(function implies(key, value2) {
    argsert("<string|object> [array|number|string]", [
      key,
      value2
    ], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        self2.implies(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!implied[key]) {
        implied[key] = [];
      }
      if (Array.isArray(value2)) {
        value2.forEach((i) => self2.implies(key, i));
      } else {
        assertNotStrictEqual(value2, void 0, shim3);
        implied[key].push(value2);
      }
    }
  }, "implies");
  self2.getImplied = /* @__PURE__ */ __name(function getImplied() {
    return implied;
  }, "getImplied");
  function keyExists(argv2, val) {
    const num = Number(val);
    val = isNaN(num) ? val : num;
    if (typeof val === "number") {
      val = argv2._.length >= val;
    } else if (val.match(/^--no-.+/)) {
      val = val.match(/^--no-(.+)/)[1];
      val = !Object.prototype.hasOwnProperty.call(argv2, val);
    } else {
      val = Object.prototype.hasOwnProperty.call(argv2, val);
    }
    return val;
  }
  __name(keyExists, "keyExists");
  self2.implications = /* @__PURE__ */ __name(function implications(argv2) {
    const implyFail = [];
    Object.keys(implied).forEach((key) => {
      const origKey = key;
      (implied[key] || []).forEach((value2) => {
        let key2 = origKey;
        const origValue = value2;
        key2 = keyExists(argv2, key2);
        value2 = keyExists(argv2, value2);
        if (key2 && !value2) {
          implyFail.push(` ${origKey} -> ${origValue}`);
        }
      });
    });
    if (implyFail.length) {
      let msg = `${__("Implications failed:")}
`;
      implyFail.forEach((value2) => {
        msg += value2;
      });
      usage2.fail(msg);
    }
  }, "implications");
  let conflicting = {};
  self2.conflicts = /* @__PURE__ */ __name(function conflicts(key, value2) {
    argsert("<string|object> [array|string]", [
      key,
      value2
    ], arguments.length);
    if (typeof key === "object") {
      Object.keys(key).forEach((k) => {
        self2.conflicts(k, key[k]);
      });
    } else {
      yargs.global(key);
      if (!conflicting[key]) {
        conflicting[key] = [];
      }
      if (Array.isArray(value2)) {
        value2.forEach((i) => self2.conflicts(key, i));
      } else {
        conflicting[key].push(value2);
      }
    }
  }, "conflicts");
  self2.getConflicting = () => conflicting;
  self2.conflicting = /* @__PURE__ */ __name(function conflictingFn(argv2) {
    Object.keys(argv2).forEach((key) => {
      if (conflicting[key]) {
        conflicting[key].forEach((value2) => {
          if (value2 && argv2[key] !== void 0 && argv2[value2] !== void 0) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value2));
          }
        });
      }
    });
    if (yargs.getInternalMethods().getParserConfiguration()["strip-dashed"]) {
      Object.keys(conflicting).forEach((key) => {
        conflicting[key].forEach((value2) => {
          if (value2 && argv2[shim3.Parser.camelCase(key)] !== void 0 && argv2[shim3.Parser.camelCase(value2)] !== void 0) {
            usage2.fail(__("Arguments %s and %s are mutually exclusive", key, value2));
          }
        });
      });
    }
  }, "conflictingFn");
  self2.recommendCommands = /* @__PURE__ */ __name(function recommendCommands(cmd, potentialCommands) {
    const threshold = 3;
    potentialCommands = potentialCommands.sort((a, b) => b.length - a.length);
    let recommended = null;
    let bestDistance = Infinity;
    for (let i = 0, candidate; (candidate = potentialCommands[i]) !== void 0; i++) {
      const d = levenshtein(cmd, candidate);
      if (d <= threshold && d < bestDistance) {
        bestDistance = d;
        recommended = candidate;
      }
    }
    if (recommended) usage2.fail(__("Did you mean %s?", recommended));
  }, "recommendCommands");
  self2.reset = /* @__PURE__ */ __name(function reset(localLookup) {
    implied = objFilter(implied, (k) => !localLookup[k]);
    conflicting = objFilter(conflicting, (k) => !localLookup[k]);
    return self2;
  }, "reset");
  const frozens = [];
  self2.freeze = /* @__PURE__ */ __name(function freeze() {
    frozens.push({
      implied,
      conflicting
    });
  }, "freeze");
  self2.unfreeze = /* @__PURE__ */ __name(function unfreeze() {
    const frozen = frozens.pop();
    assertNotStrictEqual(frozen, void 0, shim3);
    ({ implied, conflicting } = frozen);
  }, "unfreeze");
  return self2;
}
var specialKeys;
var init_validation = __esm({
  "node_modules/yargs/build/lib/validation.js"() {
    "use strict";
    init_argsert();
    init_common_types();
    init_levenshtein();
    init_obj_filter();
    specialKeys = [
      "$0",
      "--",
      "_"
    ];
    __name(validation, "validation");
  }
});

// node_modules/yargs/build/lib/utils/apply-extends.js
function applyExtends(config, cwd, mergeExtends, _shim) {
  shim2 = _shim;
  let defaultConfig = {};
  if (Object.prototype.hasOwnProperty.call(config, "extends")) {
    if (typeof config.extends !== "string") return defaultConfig;
    const isPath = /\.json|\..*rc$/.test(config.extends);
    let pathToDefault = null;
    if (!isPath) {
      try {
        pathToDefault = require.resolve(config.extends);
      } catch (_err) {
        return config;
      }
    } else {
      pathToDefault = getPathToDefaultConfig(cwd, config.extends);
    }
    checkForCircularExtends(pathToDefault);
    previouslyVisitedConfigs.push(pathToDefault);
    defaultConfig = isPath ? JSON.parse(shim2.readFileSync(pathToDefault, "utf8")) : require(config.extends);
    delete config.extends;
    defaultConfig = applyExtends(defaultConfig, shim2.path.dirname(pathToDefault), mergeExtends, shim2);
  }
  previouslyVisitedConfigs = [];
  return mergeExtends ? mergeDeep(defaultConfig, config) : Object.assign({}, defaultConfig, config);
}
function checkForCircularExtends(cfgPath) {
  if (previouslyVisitedConfigs.indexOf(cfgPath) > -1) {
    throw new YError(`Circular extended configurations: '${cfgPath}'.`);
  }
}
function getPathToDefaultConfig(cwd, pathToExtend) {
  return shim2.path.resolve(cwd, pathToExtend);
}
function mergeDeep(config1, config2) {
  const target = {};
  function isObject2(obj) {
    return obj && typeof obj === "object" && !Array.isArray(obj);
  }
  __name(isObject2, "isObject");
  Object.assign(target, config1);
  for (const key of Object.keys(config2)) {
    if (isObject2(config2[key]) && isObject2(target[key])) {
      target[key] = mergeDeep(config1[key], config2[key]);
    } else {
      target[key] = config2[key];
    }
  }
  return target;
}
var previouslyVisitedConfigs, shim2;
var init_apply_extends = __esm({
  "node_modules/yargs/build/lib/utils/apply-extends.js"() {
    "use strict";
    init_yerror();
    previouslyVisitedConfigs = [];
    __name(applyExtends, "applyExtends");
    __name(checkForCircularExtends, "checkForCircularExtends");
    __name(getPathToDefaultConfig, "getPathToDefaultConfig");
    __name(mergeDeep, "mergeDeep");
  }
});

// node_modules/yargs/build/lib/yargs-factory.js
function YargsFactory(_shim) {
  return (processArgs = [], cwd = _shim.process.cwd(), parentRequire) => {
    const yargs = new YargsInstance(processArgs, cwd, parentRequire, _shim);
    Object.defineProperty(yargs, "argv", {
      get: /* @__PURE__ */ __name(() => {
        return yargs.parse();
      }, "get"),
      enumerable: true
    });
    yargs.help();
    yargs.version();
    return yargs;
  };
}
function isYargsInstance(y) {
  return !!y && typeof y.getInternalMethods === "function";
}
var __classPrivateFieldSet, __classPrivateFieldGet, _YargsInstance_command, _YargsInstance_cwd, _YargsInstance_context, _YargsInstance_completion, _YargsInstance_completionCommand, _YargsInstance_defaultShowHiddenOpt, _YargsInstance_exitError, _YargsInstance_detectLocale, _YargsInstance_emittedWarnings, _YargsInstance_exitProcess, _YargsInstance_frozens, _YargsInstance_globalMiddleware, _YargsInstance_groups, _YargsInstance_hasOutput, _YargsInstance_helpOpt, _YargsInstance_isGlobalContext, _YargsInstance_logger, _YargsInstance_output, _YargsInstance_options, _YargsInstance_parentRequire, _YargsInstance_parserConfig, _YargsInstance_parseFn, _YargsInstance_parseContext, _YargsInstance_pkgs, _YargsInstance_preservedGroups, _YargsInstance_processArgs, _YargsInstance_recommendCommands, _YargsInstance_shim, _YargsInstance_strict, _YargsInstance_strictCommands, _YargsInstance_strictOptions, _YargsInstance_usage, _YargsInstance_usageConfig, _YargsInstance_versionOpt, _YargsInstance_validation, kCopyDoubleDash, kCreateLogger, kDeleteFromParserHintObject, kEmitWarning, kFreeze, kGetDollarZero, kGetParserConfiguration, kGetUsageConfiguration, kGuessLocale, kGuessVersion, kParsePositionalNumbers, kPkgUp, kPopulateParserHintArray, kPopulateParserHintSingleValueDictionary, kPopulateParserHintArrayDictionary, kPopulateParserHintDictionary, kSanitizeKey, kSetKey, kUnfreeze, kValidateAsync, kGetCommandInstance, kGetContext, kGetHasOutput, kGetLoggerInstance, kGetParseContext, kGetUsageInstance, kGetValidationInstance, kHasParseCallback, kIsGlobalContext, kPostProcess, kRebase, kReset, kRunYargsParserAndExecuteCommands, kRunValidation, kSetHasOutput, kTrackManuallySetKeys, YargsInstance;
var init_yargs_factory = __esm({
  "node_modules/yargs/build/lib/yargs-factory.js"() {
    "use strict";
    init_command();
    init_common_types();
    init_yerror();
    init_usage();
    init_argsert();
    init_completion();
    init_validation();
    init_obj_filter();
    init_apply_extends();
    init_middleware();
    init_is_promise();
    init_maybe_async_result();
    init_set_blocking();
    __classPrivateFieldSet = function(receiver, state, value2, kind, f) {
      if (kind === "m") throw new TypeError("Private method is not writable");
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
      return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
    };
    __classPrivateFieldGet = function(receiver, state, kind, f) {
      if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
      if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
      return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
    };
    __name(YargsFactory, "YargsFactory");
    kCopyDoubleDash = Symbol("copyDoubleDash");
    kCreateLogger = Symbol("copyDoubleDash");
    kDeleteFromParserHintObject = Symbol("deleteFromParserHintObject");
    kEmitWarning = Symbol("emitWarning");
    kFreeze = Symbol("freeze");
    kGetDollarZero = Symbol("getDollarZero");
    kGetParserConfiguration = Symbol("getParserConfiguration");
    kGetUsageConfiguration = Symbol("getUsageConfiguration");
    kGuessLocale = Symbol("guessLocale");
    kGuessVersion = Symbol("guessVersion");
    kParsePositionalNumbers = Symbol("parsePositionalNumbers");
    kPkgUp = Symbol("pkgUp");
    kPopulateParserHintArray = Symbol("populateParserHintArray");
    kPopulateParserHintSingleValueDictionary = Symbol("populateParserHintSingleValueDictionary");
    kPopulateParserHintArrayDictionary = Symbol("populateParserHintArrayDictionary");
    kPopulateParserHintDictionary = Symbol("populateParserHintDictionary");
    kSanitizeKey = Symbol("sanitizeKey");
    kSetKey = Symbol("setKey");
    kUnfreeze = Symbol("unfreeze");
    kValidateAsync = Symbol("validateAsync");
    kGetCommandInstance = Symbol("getCommandInstance");
    kGetContext = Symbol("getContext");
    kGetHasOutput = Symbol("getHasOutput");
    kGetLoggerInstance = Symbol("getLoggerInstance");
    kGetParseContext = Symbol("getParseContext");
    kGetUsageInstance = Symbol("getUsageInstance");
    kGetValidationInstance = Symbol("getValidationInstance");
    kHasParseCallback = Symbol("hasParseCallback");
    kIsGlobalContext = Symbol("isGlobalContext");
    kPostProcess = Symbol("postProcess");
    kRebase = Symbol("rebase");
    kReset = Symbol("reset");
    kRunYargsParserAndExecuteCommands = Symbol("runYargsParserAndExecuteCommands");
    kRunValidation = Symbol("runValidation");
    kSetHasOutput = Symbol("setHasOutput");
    kTrackManuallySetKeys = Symbol("kTrackManuallySetKeys");
    YargsInstance = class {
      static {
        __name(this, "YargsInstance");
      }
      constructor(processArgs = [], cwd, parentRequire, shim3) {
        this.customScriptName = false;
        this.parsed = false;
        _YargsInstance_command.set(this, void 0);
        _YargsInstance_cwd.set(this, void 0);
        _YargsInstance_context.set(this, {
          commands: [],
          fullCommands: []
        });
        _YargsInstance_completion.set(this, null);
        _YargsInstance_completionCommand.set(this, null);
        _YargsInstance_defaultShowHiddenOpt.set(this, "show-hidden");
        _YargsInstance_exitError.set(this, null);
        _YargsInstance_detectLocale.set(this, true);
        _YargsInstance_emittedWarnings.set(this, {});
        _YargsInstance_exitProcess.set(this, true);
        _YargsInstance_frozens.set(this, []);
        _YargsInstance_globalMiddleware.set(this, void 0);
        _YargsInstance_groups.set(this, {});
        _YargsInstance_hasOutput.set(this, false);
        _YargsInstance_helpOpt.set(this, null);
        _YargsInstance_isGlobalContext.set(this, true);
        _YargsInstance_logger.set(this, void 0);
        _YargsInstance_output.set(this, "");
        _YargsInstance_options.set(this, void 0);
        _YargsInstance_parentRequire.set(this, void 0);
        _YargsInstance_parserConfig.set(this, {});
        _YargsInstance_parseFn.set(this, null);
        _YargsInstance_parseContext.set(this, null);
        _YargsInstance_pkgs.set(this, {});
        _YargsInstance_preservedGroups.set(this, {});
        _YargsInstance_processArgs.set(this, void 0);
        _YargsInstance_recommendCommands.set(this, false);
        _YargsInstance_shim.set(this, void 0);
        _YargsInstance_strict.set(this, false);
        _YargsInstance_strictCommands.set(this, false);
        _YargsInstance_strictOptions.set(this, false);
        _YargsInstance_usage.set(this, void 0);
        _YargsInstance_usageConfig.set(this, {});
        _YargsInstance_versionOpt.set(this, null);
        _YargsInstance_validation.set(this, void 0);
        __classPrivateFieldSet(this, _YargsInstance_shim, shim3, "f");
        __classPrivateFieldSet(this, _YargsInstance_processArgs, processArgs, "f");
        __classPrivateFieldSet(this, _YargsInstance_cwd, cwd, "f");
        __classPrivateFieldSet(this, _YargsInstance_parentRequire, parentRequire, "f");
        __classPrivateFieldSet(this, _YargsInstance_globalMiddleware, new GlobalMiddleware(this), "f");
        this.$0 = this[kGetDollarZero]();
        this[kReset]();
        __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f"), "f");
        __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f"), "f");
        __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
        __classPrivateFieldSet(this, _YargsInstance_logger, this[kCreateLogger](), "f");
      }
      addHelpOpt(opt, msg) {
        const defaultHelpOpt = "help";
        argsert("[string|boolean] [string]", [
          opt,
          msg
        ], arguments.length);
        if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
          this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
          __classPrivateFieldSet(this, _YargsInstance_helpOpt, null, "f");
        }
        if (opt === false && msg === void 0) return this;
        __classPrivateFieldSet(this, _YargsInstance_helpOpt, typeof opt === "string" ? opt : defaultHelpOpt, "f");
        this.boolean(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"));
        this.describe(__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f"), msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show help"));
        return this;
      }
      help(opt, msg) {
        return this.addHelpOpt(opt, msg);
      }
      addShowHiddenOpt(opt, msg) {
        argsert("[string|boolean] [string]", [
          opt,
          msg
        ], arguments.length);
        if (opt === false && msg === void 0) return this;
        const showHiddenOpt = typeof opt === "string" ? opt : __classPrivateFieldGet(this, _YargsInstance_defaultShowHiddenOpt, "f");
        this.boolean(showHiddenOpt);
        this.describe(showHiddenOpt, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show hidden options"));
        __classPrivateFieldGet(this, _YargsInstance_options, "f").showHiddenOpt = showHiddenOpt;
        return this;
      }
      showHidden(opt, msg) {
        return this.addShowHiddenOpt(opt, msg);
      }
      alias(key, value2) {
        argsert("<object|string|array> [string|array]", [
          key,
          value2
        ], arguments.length);
        this[kPopulateParserHintArrayDictionary](this.alias.bind(this), "alias", key, value2);
        return this;
      }
      array(keys) {
        argsert("<array|string>", [
          keys
        ], arguments.length);
        this[kPopulateParserHintArray]("array", keys);
        this[kTrackManuallySetKeys](keys);
        return this;
      }
      boolean(keys) {
        argsert("<array|string>", [
          keys
        ], arguments.length);
        this[kPopulateParserHintArray]("boolean", keys);
        this[kTrackManuallySetKeys](keys);
        return this;
      }
      check(f, global2) {
        argsert("<function> [boolean]", [
          f,
          global2
        ], arguments.length);
        this.middleware((argv2, _yargs) => {
          return maybeAsyncResult(() => {
            return f(argv2, _yargs.getOptions());
          }, (result2) => {
            if (!result2) {
              __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(__classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__("Argument check failed: %s", f.toString()));
            } else if (typeof result2 === "string" || result2 instanceof Error) {
              __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(result2.toString(), result2);
            }
            return argv2;
          }, (err) => {
            __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message ? err.message : err.toString(), err);
            return argv2;
          });
        }, false, global2);
        return this;
      }
      choices(key, value2) {
        argsert("<object|string|array> [string|array]", [
          key,
          value2
        ], arguments.length);
        this[kPopulateParserHintArrayDictionary](this.choices.bind(this), "choices", key, value2);
        return this;
      }
      coerce(keys, value2) {
        argsert("<object|string|array> [function]", [
          keys,
          value2
        ], arguments.length);
        if (Array.isArray(keys)) {
          if (!value2) {
            throw new YError("coerce callback must be provided");
          }
          for (const key of keys) {
            this.coerce(key, value2);
          }
          return this;
        } else if (typeof keys === "object") {
          for (const key of Object.keys(keys)) {
            this.coerce(key, keys[key]);
          }
          return this;
        }
        if (!value2) {
          throw new YError("coerce callback must be provided");
        }
        __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addCoerceMiddleware((argv2, yargs) => {
          let aliases;
          const shouldCoerce = Object.prototype.hasOwnProperty.call(argv2, keys);
          if (!shouldCoerce) {
            return argv2;
          }
          return maybeAsyncResult(() => {
            aliases = yargs.getAliases();
            return value2(argv2[keys]);
          }, (result2) => {
            argv2[keys] = result2;
            const stripAliased = yargs.getInternalMethods().getParserConfiguration()["strip-aliased"];
            if (aliases[keys] && stripAliased !== true) {
              for (const alias of aliases[keys]) {
                argv2[alias] = result2;
              }
            }
            return argv2;
          }, (err) => {
            throw new YError(err.message);
          });
        }, keys);
        return this;
      }
      conflicts(key1, key2) {
        argsert("<string|object> [string|array]", [
          key1,
          key2
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicts(key1, key2);
        return this;
      }
      config(key = "config", msg, parseFn) {
        argsert("[object|string] [string|function] [function]", [
          key,
          msg,
          parseFn
        ], arguments.length);
        if (typeof key === "object" && !Array.isArray(key)) {
          key = applyExtends(key, __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
          __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(key);
          return this;
        }
        if (typeof msg === "function") {
          parseFn = msg;
          msg = void 0;
        }
        this.describe(key, msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Path to JSON config file"));
        (Array.isArray(key) ? key : [
          key
        ]).forEach((k) => {
          __classPrivateFieldGet(this, _YargsInstance_options, "f").config[k] = parseFn || true;
        });
        return this;
      }
      completion(cmd, desc, fn) {
        argsert("[string] [string|boolean|function] [function]", [
          cmd,
          desc,
          fn
        ], arguments.length);
        if (typeof desc === "function") {
          fn = desc;
          desc = void 0;
        }
        __classPrivateFieldSet(this, _YargsInstance_completionCommand, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion", "f");
        if (!desc && desc !== false) {
          desc = "generate completion script";
        }
        this.command(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"), desc);
        if (fn) __classPrivateFieldGet(this, _YargsInstance_completion, "f").registerFunction(fn);
        return this;
      }
      command(cmd, description, builder, handler, middlewares, deprecated) {
        argsert("<string|array|object> [string|boolean] [function|object] [function] [array] [boolean|string]", [
          cmd,
          description,
          builder,
          handler,
          middlewares,
          deprecated
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_command, "f").addHandler(cmd, description, builder, handler, middlewares, deprecated);
        return this;
      }
      commands(cmd, description, builder, handler, middlewares, deprecated) {
        return this.command(cmd, description, builder, handler, middlewares, deprecated);
      }
      commandDir(dir, opts) {
        argsert("<string> [object]", [
          dir,
          opts
        ], arguments.length);
        const req = __classPrivateFieldGet(this, _YargsInstance_parentRequire, "f") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").require;
        __classPrivateFieldGet(this, _YargsInstance_command, "f").addDirectory(dir, req, __classPrivateFieldGet(this, _YargsInstance_shim, "f").getCallerFile(), opts);
        return this;
      }
      count(keys) {
        argsert("<array|string>", [
          keys
        ], arguments.length);
        this[kPopulateParserHintArray]("count", keys);
        this[kTrackManuallySetKeys](keys);
        return this;
      }
      default(key, value2, defaultDescription) {
        argsert("<object|string|array> [*] [string]", [
          key,
          value2,
          defaultDescription
        ], arguments.length);
        if (defaultDescription) {
          assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
          __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = defaultDescription;
        }
        if (typeof value2 === "function") {
          assertSingleKey(key, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
          if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key]) __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = __classPrivateFieldGet(this, _YargsInstance_usage, "f").functionDescription(value2);
          value2 = value2.call();
        }
        this[kPopulateParserHintSingleValueDictionary](this.default.bind(this), "default", key, value2);
        return this;
      }
      defaults(key, value2, defaultDescription) {
        return this.default(key, value2, defaultDescription);
      }
      demandCommand(min = 1, max, minMsg, maxMsg) {
        argsert("[number] [number|string] [string|null|undefined] [string|null|undefined]", [
          min,
          max,
          minMsg,
          maxMsg
        ], arguments.length);
        if (typeof max !== "number") {
          minMsg = max;
          max = Infinity;
        }
        this.global("_", false);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands._ = {
          min,
          max,
          minMsg,
          maxMsg
        };
        return this;
      }
      demand(keys, max, msg) {
        if (Array.isArray(max)) {
          max.forEach((key) => {
            assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            this.demandOption(key, msg);
          });
          max = Infinity;
        } else if (typeof max !== "number") {
          msg = max;
          max = Infinity;
        }
        if (typeof keys === "number") {
          assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
          this.demandCommand(keys, max, msg, msg);
        } else if (Array.isArray(keys)) {
          keys.forEach((key) => {
            assertNotStrictEqual(msg, true, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
            this.demandOption(key, msg);
          });
        } else {
          if (typeof msg === "string") {
            this.demandOption(keys, msg);
          } else if (msg === true || typeof msg === "undefined") {
            this.demandOption(keys);
          }
        }
        return this;
      }
      demandOption(keys, msg) {
        argsert("<object|string|array> [string]", [
          keys,
          msg
        ], arguments.length);
        this[kPopulateParserHintSingleValueDictionary](this.demandOption.bind(this), "demandedOptions", keys, msg);
        return this;
      }
      deprecateOption(option, message) {
        argsert("<string> [string|boolean]", [
          option,
          message
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions[option] = message;
        return this;
      }
      describe(keys, description) {
        argsert("<object|string|array> [string]", [
          keys,
          description
        ], arguments.length);
        this[kSetKey](keys, true);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").describe(keys, description);
        return this;
      }
      detectLocale(detect) {
        argsert("<boolean>", [
          detect
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, detect, "f");
        return this;
      }
      env(prefix) {
        argsert("[string|boolean]", [
          prefix
        ], arguments.length);
        if (prefix === false) delete __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
        else __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix = prefix || "";
        return this;
      }
      epilogue(msg) {
        argsert("<string>", [
          msg
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").epilog(msg);
        return this;
      }
      epilog(msg) {
        return this.epilogue(msg);
      }
      example(cmd, description) {
        argsert("<string|array> [string]", [
          cmd,
          description
        ], arguments.length);
        if (Array.isArray(cmd)) {
          cmd.forEach((exampleParams) => this.example(...exampleParams));
        } else {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").example(cmd, description);
        }
        return this;
      }
      exit(code, err) {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        __classPrivateFieldSet(this, _YargsInstance_exitError, err, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.exit(code);
      }
      exitProcess(enabled = true) {
        argsert("[boolean]", [
          enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_exitProcess, enabled, "f");
        return this;
      }
      fail(f) {
        argsert("<function|boolean>", [
          f
        ], arguments.length);
        if (typeof f === "boolean" && f !== false) {
          throw new YError("Invalid first argument. Expected function or boolean 'false'");
        }
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").failFn(f);
        return this;
      }
      getAliases() {
        return this.parsed ? this.parsed.aliases : {};
      }
      async getCompletion(args, done) {
        argsert("<array> [function]", [
          args,
          done
        ], arguments.length);
        if (!done) {
          return new Promise((resolve5, reject) => {
            __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, (err, completions) => {
              if (err) reject(err);
              else resolve5(completions);
            });
          });
        } else {
          return __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(args, done);
        }
      }
      getDemandedOptions() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedOptions;
      }
      getDemandedCommands() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").demandedCommands;
      }
      getDeprecatedOptions() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_options, "f").deprecatedOptions;
      }
      getDetectLocale() {
        return __classPrivateFieldGet(this, _YargsInstance_detectLocale, "f");
      }
      getExitProcess() {
        return __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f");
      }
      getGroups() {
        return Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_groups, "f"), __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"));
      }
      getHelp() {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
          if (!this.parsed) {
            const parse5 = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), void 0, void 0, 0, true);
            if (isPromise(parse5)) {
              return parse5.then(() => {
                return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
              });
            }
          }
          const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
          if (isPromise(builderResponse)) {
            return builderResponse.then(() => {
              return __classPrivateFieldGet(this, _YargsInstance_usage, "f").help();
            });
          }
        }
        return Promise.resolve(__classPrivateFieldGet(this, _YargsInstance_usage, "f").help());
      }
      getOptions() {
        return __classPrivateFieldGet(this, _YargsInstance_options, "f");
      }
      getStrict() {
        return __classPrivateFieldGet(this, _YargsInstance_strict, "f");
      }
      getStrictCommands() {
        return __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f");
      }
      getStrictOptions() {
        return __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f");
      }
      global(globals, global2) {
        argsert("<string|array> [boolean]", [
          globals,
          global2
        ], arguments.length);
        globals = [].concat(globals);
        if (global2 !== false) {
          __classPrivateFieldGet(this, _YargsInstance_options, "f").local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local.filter((l) => globals.indexOf(l) === -1);
        } else {
          globals.forEach((g) => {
            if (!__classPrivateFieldGet(this, _YargsInstance_options, "f").local.includes(g)) __classPrivateFieldGet(this, _YargsInstance_options, "f").local.push(g);
          });
        }
        return this;
      }
      group(opts, groupName) {
        argsert("<string|array> <string>", [
          opts,
          groupName
        ], arguments.length);
        const existing = __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName] || __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName];
        if (__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName]) {
          delete __classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f")[groupName];
        }
        const seen = {};
        __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName] = (existing || []).concat(opts).filter((key) => {
          if (seen[key]) return false;
          return seen[key] = true;
        });
        return this;
      }
      hide(key) {
        argsert("<string>", [
          key
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_options, "f").hiddenOptions.push(key);
        return this;
      }
      implies(key, value2) {
        argsert("<string|object> [number|string|array]", [
          key,
          value2
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").implies(key, value2);
        return this;
      }
      locale(locale) {
        argsert("[string]", [
          locale
        ], arguments.length);
        if (locale === void 0) {
          this[kGuessLocale]();
          return __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.getLocale();
        }
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
        __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.setLocale(locale);
        return this;
      }
      middleware(callback, applyBeforeValidation, global2) {
        return __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").addMiddleware(callback, !!applyBeforeValidation, global2);
      }
      nargs(key, value2) {
        argsert("<string|object|array> [number]", [
          key,
          value2
        ], arguments.length);
        this[kPopulateParserHintSingleValueDictionary](this.nargs.bind(this), "narg", key, value2);
        return this;
      }
      normalize(keys) {
        argsert("<array|string>", [
          keys
        ], arguments.length);
        this[kPopulateParserHintArray]("normalize", keys);
        return this;
      }
      number(keys) {
        argsert("<array|string>", [
          keys
        ], arguments.length);
        this[kPopulateParserHintArray]("number", keys);
        this[kTrackManuallySetKeys](keys);
        return this;
      }
      option(key, opt) {
        argsert("<string|object> [object]", [
          key,
          opt
        ], arguments.length);
        if (typeof key === "object") {
          Object.keys(key).forEach((k) => {
            this.options(k, key[k]);
          });
        } else {
          if (typeof opt !== "object") {
            opt = {};
          }
          this[kTrackManuallySetKeys](key);
          if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && (key === "version" || (opt === null || opt === void 0 ? void 0 : opt.alias) === "version")) {
            this[kEmitWarning]([
              '"version" is a reserved word.',
              "Please do one of the following:",
              '- Disable version with `yargs.version(false)` if using "version" as an option',
              "- Use the built-in `yargs.version` method instead (if applicable)",
              "- Use a different option key",
              "https://yargs.js.org/docs/#api-reference-version"
            ].join("\n"), void 0, "versionWarning");
          }
          __classPrivateFieldGet(this, _YargsInstance_options, "f").key[key] = true;
          if (opt.alias) this.alias(key, opt.alias);
          const deprecate = opt.deprecate || opt.deprecated;
          if (deprecate) {
            this.deprecateOption(key, deprecate);
          }
          const demand = opt.demand || opt.required || opt.require;
          if (demand) {
            this.demand(key, demand);
          }
          if (opt.demandOption) {
            this.demandOption(key, typeof opt.demandOption === "string" ? opt.demandOption : void 0);
          }
          if (opt.conflicts) {
            this.conflicts(key, opt.conflicts);
          }
          if ("default" in opt) {
            this.default(key, opt.default);
          }
          if (opt.implies !== void 0) {
            this.implies(key, opt.implies);
          }
          if (opt.nargs !== void 0) {
            this.nargs(key, opt.nargs);
          }
          if (opt.config) {
            this.config(key, opt.configParser);
          }
          if (opt.normalize) {
            this.normalize(key);
          }
          if (opt.choices) {
            this.choices(key, opt.choices);
          }
          if (opt.coerce) {
            this.coerce(key, opt.coerce);
          }
          if (opt.group) {
            this.group(key, opt.group);
          }
          if (opt.boolean || opt.type === "boolean") {
            this.boolean(key);
            if (opt.alias) this.boolean(opt.alias);
          }
          if (opt.array || opt.type === "array") {
            this.array(key);
            if (opt.alias) this.array(opt.alias);
          }
          if (opt.number || opt.type === "number") {
            this.number(key);
            if (opt.alias) this.number(opt.alias);
          }
          if (opt.string || opt.type === "string") {
            this.string(key);
            if (opt.alias) this.string(opt.alias);
          }
          if (opt.count || opt.type === "count") {
            this.count(key);
          }
          if (typeof opt.global === "boolean") {
            this.global(key, opt.global);
          }
          if (opt.defaultDescription) {
            __classPrivateFieldGet(this, _YargsInstance_options, "f").defaultDescription[key] = opt.defaultDescription;
          }
          if (opt.skipValidation) {
            this.skipValidation(key);
          }
          const desc = opt.describe || opt.description || opt.desc;
          const descriptions = __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions();
          if (!Object.prototype.hasOwnProperty.call(descriptions, key) || typeof desc === "string") {
            this.describe(key, desc);
          }
          if (opt.hidden) {
            this.hide(key);
          }
          if (opt.requiresArg) {
            this.requiresArg(key);
          }
        }
        return this;
      }
      options(key, opt) {
        return this.option(key, opt);
      }
      parse(args, shortCircuit, _parseFn) {
        argsert("[string|array] [function|boolean|object] [function]", [
          args,
          shortCircuit,
          _parseFn
        ], arguments.length);
        this[kFreeze]();
        if (typeof args === "undefined") {
          args = __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
        }
        if (typeof shortCircuit === "object") {
          __classPrivateFieldSet(this, _YargsInstance_parseContext, shortCircuit, "f");
          shortCircuit = _parseFn;
        }
        if (typeof shortCircuit === "function") {
          __classPrivateFieldSet(this, _YargsInstance_parseFn, shortCircuit, "f");
          shortCircuit = false;
        }
        if (!shortCircuit) __classPrivateFieldSet(this, _YargsInstance_processArgs, args, "f");
        if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldSet(this, _YargsInstance_exitProcess, false, "f");
        const parsed = this[kRunYargsParserAndExecuteCommands](args, !!shortCircuit);
        const tmpParsed = this.parsed;
        __classPrivateFieldGet(this, _YargsInstance_completion, "f").setParsed(this.parsed);
        if (isPromise(parsed)) {
          return parsed.then((argv2) => {
            if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), argv2, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
            return argv2;
          }).catch((err) => {
            if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) {
              __classPrivateFieldGet(this, _YargsInstance_parseFn, "f")(err, this.parsed.argv, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
            }
            throw err;
          }).finally(() => {
            this[kUnfreeze]();
            this.parsed = tmpParsed;
          });
        } else {
          if (__classPrivateFieldGet(this, _YargsInstance_parseFn, "f")) __classPrivateFieldGet(this, _YargsInstance_parseFn, "f").call(this, __classPrivateFieldGet(this, _YargsInstance_exitError, "f"), parsed, __classPrivateFieldGet(this, _YargsInstance_output, "f"));
          this[kUnfreeze]();
          this.parsed = tmpParsed;
        }
        return parsed;
      }
      parseAsync(args, shortCircuit, _parseFn) {
        const maybePromise = this.parse(args, shortCircuit, _parseFn);
        return !isPromise(maybePromise) ? Promise.resolve(maybePromise) : maybePromise;
      }
      parseSync(args, shortCircuit, _parseFn) {
        const maybePromise = this.parse(args, shortCircuit, _parseFn);
        if (isPromise(maybePromise)) {
          throw new YError(".parseSync() must not be used with asynchronous builders, handlers, or middleware");
        }
        return maybePromise;
      }
      parserConfiguration(config) {
        argsert("<object>", [
          config
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_parserConfig, config, "f");
        return this;
      }
      pkgConf(key, rootPath) {
        argsert("<string> [string]", [
          key,
          rootPath
        ], arguments.length);
        let conf = null;
        const obj = this[kPkgUp](rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"));
        if (obj[key] && typeof obj[key] === "object") {
          conf = applyExtends(obj[key], rootPath || __classPrivateFieldGet(this, _YargsInstance_cwd, "f"), this[kGetParserConfiguration]()["deep-merge-config"] || false, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
          __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = (__classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || []).concat(conf);
        }
        return this;
      }
      positional(key, opts) {
        argsert("<string> <object>", [
          key,
          opts
        ], arguments.length);
        const supportedOpts = [
          "default",
          "defaultDescription",
          "implies",
          "normalize",
          "choices",
          "conflicts",
          "coerce",
          "type",
          "describe",
          "desc",
          "description",
          "alias"
        ];
        opts = objFilter(opts, (k, v) => {
          if (k === "type" && ![
            "string",
            "number",
            "boolean"
          ].includes(v)) return false;
          return supportedOpts.includes(k);
        });
        const fullCommand = __classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands[__classPrivateFieldGet(this, _YargsInstance_context, "f").fullCommands.length - 1];
        const parseOptions = fullCommand ? __classPrivateFieldGet(this, _YargsInstance_command, "f").cmdToParseOptions(fullCommand) : {
          array: [],
          alias: {},
          default: {},
          demand: {}
        };
        objectKeys(parseOptions).forEach((pk) => {
          const parseOption = parseOptions[pk];
          if (Array.isArray(parseOption)) {
            if (parseOption.indexOf(key) !== -1) opts[pk] = true;
          } else {
            if (parseOption[key] && !(pk in opts)) opts[pk] = parseOption[key];
          }
        });
        this.group(key, __classPrivateFieldGet(this, _YargsInstance_usage, "f").getPositionalGroupName());
        return this.option(key, opts);
      }
      recommendCommands(recommend = true) {
        argsert("[boolean]", [
          recommend
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_recommendCommands, recommend, "f");
        return this;
      }
      required(keys, max, msg) {
        return this.demand(keys, max, msg);
      }
      require(keys, max, msg) {
        return this.demand(keys, max, msg);
      }
      requiresArg(keys) {
        argsert("<array|string|object> [number]", [
          keys
        ], arguments.length);
        if (typeof keys === "string" && __classPrivateFieldGet(this, _YargsInstance_options, "f").narg[keys]) {
          return this;
        } else {
          this[kPopulateParserHintSingleValueDictionary](this.requiresArg.bind(this), "narg", keys, NaN);
        }
        return this;
      }
      showCompletionScript($0, cmd) {
        argsert("[string] [string]", [
          $0,
          cmd
        ], arguments.length);
        $0 = $0 || this.$0;
        __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(__classPrivateFieldGet(this, _YargsInstance_completion, "f").generateCompletionScript($0, cmd || __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") || "completion"));
        return this;
      }
      showHelp(level) {
        argsert("[string|function]", [
          level
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_usage, "f").hasCachedHelpMessage()) {
          if (!this.parsed) {
            const parse5 = this[kRunYargsParserAndExecuteCommands](__classPrivateFieldGet(this, _YargsInstance_processArgs, "f"), void 0, void 0, 0, true);
            if (isPromise(parse5)) {
              parse5.then(() => {
                __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
              });
              return this;
            }
          }
          const builderResponse = __classPrivateFieldGet(this, _YargsInstance_command, "f").runDefaultBuilderOn(this);
          if (isPromise(builderResponse)) {
            builderResponse.then(() => {
              __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
            });
            return this;
          }
        }
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelp(level);
        return this;
      }
      scriptName(scriptName) {
        this.customScriptName = true;
        this.$0 = scriptName;
        return this;
      }
      showHelpOnFail(enabled, message) {
        argsert("[boolean|string] [string]", [
          enabled,
          message
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showHelpOnFail(enabled, message);
        return this;
      }
      showVersion(level) {
        argsert("[string|function]", [
          level
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion(level);
        return this;
      }
      skipValidation(keys) {
        argsert("<array|string>", [
          keys
        ], arguments.length);
        this[kPopulateParserHintArray]("skipValidation", keys);
        return this;
      }
      strict(enabled) {
        argsert("[boolean]", [
          enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strict, enabled !== false, "f");
        return this;
      }
      strictCommands(enabled) {
        argsert("[boolean]", [
          enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strictCommands, enabled !== false, "f");
        return this;
      }
      strictOptions(enabled) {
        argsert("[boolean]", [
          enabled
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_strictOptions, enabled !== false, "f");
        return this;
      }
      string(keys) {
        argsert("<array|string>", [
          keys
        ], arguments.length);
        this[kPopulateParserHintArray]("string", keys);
        this[kTrackManuallySetKeys](keys);
        return this;
      }
      terminalWidth() {
        argsert([], 0);
        return __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.stdColumns;
      }
      updateLocale(obj) {
        return this.updateStrings(obj);
      }
      updateStrings(obj) {
        argsert("<object>", [
          obj
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_detectLocale, false, "f");
        __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.updateLocale(obj);
        return this;
      }
      usage(msg, description, builder, handler) {
        argsert("<string|null|undefined> [string|boolean] [function|object] [function]", [
          msg,
          description,
          builder,
          handler
        ], arguments.length);
        if (description !== void 0) {
          assertNotStrictEqual(msg, null, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
          if ((msg || "").match(/^\$0( |$)/)) {
            return this.command(msg, description, builder, handler);
          } else {
            throw new YError(".usage() description must start with $0 if being used as alias for .command()");
          }
        } else {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").usage(msg);
          return this;
        }
      }
      usageConfiguration(config) {
        argsert("<object>", [
          config
        ], arguments.length);
        __classPrivateFieldSet(this, _YargsInstance_usageConfig, config, "f");
        return this;
      }
      version(opt, msg, ver) {
        const defaultVersionOpt = "version";
        argsert("[boolean|string] [string] [string]", [
          opt,
          msg,
          ver
        ], arguments.length);
        if (__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f")) {
          this[kDeleteFromParserHintObject](__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(void 0);
          __classPrivateFieldSet(this, _YargsInstance_versionOpt, null, "f");
        }
        if (arguments.length === 0) {
          ver = this[kGuessVersion]();
          opt = defaultVersionOpt;
        } else if (arguments.length === 1) {
          if (opt === false) {
            return this;
          }
          ver = opt;
          opt = defaultVersionOpt;
        } else if (arguments.length === 2) {
          ver = msg;
          msg = void 0;
        }
        __classPrivateFieldSet(this, _YargsInstance_versionOpt, typeof opt === "string" ? opt : defaultVersionOpt, "f");
        msg = msg || __classPrivateFieldGet(this, _YargsInstance_usage, "f").deferY18nLookup("Show version number");
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").version(ver || void 0);
        this.boolean(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"));
        this.describe(__classPrivateFieldGet(this, _YargsInstance_versionOpt, "f"), msg);
        return this;
      }
      wrap(cols) {
        argsert("<number|null|undefined>", [
          cols
        ], arguments.length);
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").wrap(cols);
        return this;
      }
      [(_YargsInstance_command = /* @__PURE__ */ new WeakMap(), _YargsInstance_cwd = /* @__PURE__ */ new WeakMap(), _YargsInstance_context = /* @__PURE__ */ new WeakMap(), _YargsInstance_completion = /* @__PURE__ */ new WeakMap(), _YargsInstance_completionCommand = /* @__PURE__ */ new WeakMap(), _YargsInstance_defaultShowHiddenOpt = /* @__PURE__ */ new WeakMap(), _YargsInstance_exitError = /* @__PURE__ */ new WeakMap(), _YargsInstance_detectLocale = /* @__PURE__ */ new WeakMap(), _YargsInstance_emittedWarnings = /* @__PURE__ */ new WeakMap(), _YargsInstance_exitProcess = /* @__PURE__ */ new WeakMap(), _YargsInstance_frozens = /* @__PURE__ */ new WeakMap(), _YargsInstance_globalMiddleware = /* @__PURE__ */ new WeakMap(), _YargsInstance_groups = /* @__PURE__ */ new WeakMap(), _YargsInstance_hasOutput = /* @__PURE__ */ new WeakMap(), _YargsInstance_helpOpt = /* @__PURE__ */ new WeakMap(), _YargsInstance_isGlobalContext = /* @__PURE__ */ new WeakMap(), _YargsInstance_logger = /* @__PURE__ */ new WeakMap(), _YargsInstance_output = /* @__PURE__ */ new WeakMap(), _YargsInstance_options = /* @__PURE__ */ new WeakMap(), _YargsInstance_parentRequire = /* @__PURE__ */ new WeakMap(), _YargsInstance_parserConfig = /* @__PURE__ */ new WeakMap(), _YargsInstance_parseFn = /* @__PURE__ */ new WeakMap(), _YargsInstance_parseContext = /* @__PURE__ */ new WeakMap(), _YargsInstance_pkgs = /* @__PURE__ */ new WeakMap(), _YargsInstance_preservedGroups = /* @__PURE__ */ new WeakMap(), _YargsInstance_processArgs = /* @__PURE__ */ new WeakMap(), _YargsInstance_recommendCommands = /* @__PURE__ */ new WeakMap(), _YargsInstance_shim = /* @__PURE__ */ new WeakMap(), _YargsInstance_strict = /* @__PURE__ */ new WeakMap(), _YargsInstance_strictCommands = /* @__PURE__ */ new WeakMap(), _YargsInstance_strictOptions = /* @__PURE__ */ new WeakMap(), _YargsInstance_usage = /* @__PURE__ */ new WeakMap(), _YargsInstance_usageConfig = /* @__PURE__ */ new WeakMap(), _YargsInstance_versionOpt = /* @__PURE__ */ new WeakMap(), _YargsInstance_validation = /* @__PURE__ */ new WeakMap(), kCopyDoubleDash)](argv2) {
        if (!argv2._ || !argv2["--"]) return argv2;
        argv2._.push.apply(argv2._, argv2["--"]);
        try {
          delete argv2["--"];
        } catch (_err) {
        }
        return argv2;
      }
      [kCreateLogger]() {
        return {
          log: /* @__PURE__ */ __name((...args) => {
            if (!this[kHasParseCallback]()) console.log(...args);
            __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
            if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length) __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
            __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
          }, "log"),
          error: /* @__PURE__ */ __name((...args) => {
            if (!this[kHasParseCallback]()) console.error(...args);
            __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
            if (__classPrivateFieldGet(this, _YargsInstance_output, "f").length) __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + "\n", "f");
            __classPrivateFieldSet(this, _YargsInstance_output, __classPrivateFieldGet(this, _YargsInstance_output, "f") + args.join(" "), "f");
          }, "error")
        };
      }
      [kDeleteFromParserHintObject](optionKey) {
        objectKeys(__classPrivateFieldGet(this, _YargsInstance_options, "f")).forEach((hintKey) => {
          if (/* @__PURE__ */ ((key) => key === "configObjects")(hintKey)) return;
          const hint = __classPrivateFieldGet(this, _YargsInstance_options, "f")[hintKey];
          if (Array.isArray(hint)) {
            if (hint.includes(optionKey)) hint.splice(hint.indexOf(optionKey), 1);
          } else if (typeof hint === "object") {
            delete hint[optionKey];
          }
        });
        delete __classPrivateFieldGet(this, _YargsInstance_usage, "f").getDescriptions()[optionKey];
      }
      [kEmitWarning](warning, type, deduplicationId) {
        if (!__classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId]) {
          __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.emitWarning(warning, type);
          __classPrivateFieldGet(this, _YargsInstance_emittedWarnings, "f")[deduplicationId] = true;
        }
      }
      [kFreeze]() {
        __classPrivateFieldGet(this, _YargsInstance_frozens, "f").push({
          options: __classPrivateFieldGet(this, _YargsInstance_options, "f"),
          configObjects: __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects.slice(0),
          exitProcess: __classPrivateFieldGet(this, _YargsInstance_exitProcess, "f"),
          groups: __classPrivateFieldGet(this, _YargsInstance_groups, "f"),
          strict: __classPrivateFieldGet(this, _YargsInstance_strict, "f"),
          strictCommands: __classPrivateFieldGet(this, _YargsInstance_strictCommands, "f"),
          strictOptions: __classPrivateFieldGet(this, _YargsInstance_strictOptions, "f"),
          completionCommand: __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f"),
          output: __classPrivateFieldGet(this, _YargsInstance_output, "f"),
          exitError: __classPrivateFieldGet(this, _YargsInstance_exitError, "f"),
          hasOutput: __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f"),
          parsed: this.parsed,
          parseFn: __classPrivateFieldGet(this, _YargsInstance_parseFn, "f"),
          parseContext: __classPrivateFieldGet(this, _YargsInstance_parseContext, "f")
        });
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_command, "f").freeze();
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").freeze();
      }
      [kGetDollarZero]() {
        let $0 = "";
        let default$0;
        if (/\b(node|iojs|electron)(\.exe)?$/.test(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv()[0])) {
          default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(1, 2);
        } else {
          default$0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").process.argv().slice(0, 1);
        }
        $0 = default$0.map((x) => {
          const b = this[kRebase](__classPrivateFieldGet(this, _YargsInstance_cwd, "f"), x);
          return x.match(/^(\/|([a-zA-Z]:)?\\)/) && b.length < x.length ? b : x;
        }).join(" ").trim();
        if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_") && __classPrivateFieldGet(this, _YargsInstance_shim, "f").getProcessArgvBin() === __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_")) {
          $0 = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("_").replace(`${__classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(__classPrivateFieldGet(this, _YargsInstance_shim, "f").process.execPath())}/`, "");
        }
        return $0;
      }
      [kGetParserConfiguration]() {
        return __classPrivateFieldGet(this, _YargsInstance_parserConfig, "f");
      }
      [kGetUsageConfiguration]() {
        return __classPrivateFieldGet(this, _YargsInstance_usageConfig, "f");
      }
      [kGuessLocale]() {
        if (!__classPrivateFieldGet(this, _YargsInstance_detectLocale, "f")) return;
        const locale = __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_ALL") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LC_MESSAGES") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANG") || __classPrivateFieldGet(this, _YargsInstance_shim, "f").getEnv("LANGUAGE") || "en_US";
        this.locale(locale.replace(/[.:].*/, ""));
      }
      [kGuessVersion]() {
        const obj = this[kPkgUp]();
        return obj.version || "unknown";
      }
      [kParsePositionalNumbers](argv2) {
        const args = argv2["--"] ? argv2["--"] : argv2._;
        for (let i = 0, arg; (arg = args[i]) !== void 0; i++) {
          if (__classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.looksLikeNumber(arg) && Number.isSafeInteger(Math.floor(parseFloat(`${arg}`)))) {
            args[i] = Number(arg);
          }
        }
        return argv2;
      }
      [kPkgUp](rootPath) {
        const npath = rootPath || "*";
        if (__classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath]) return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
        let obj = {};
        try {
          let startDir = rootPath || __classPrivateFieldGet(this, _YargsInstance_shim, "f").mainFilename;
          if (!rootPath && __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.extname(startDir)) {
            startDir = __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.dirname(startDir);
          }
          const pkgJsonPath = __classPrivateFieldGet(this, _YargsInstance_shim, "f").findUp(startDir, (dir, names) => {
            if (names.includes("package.json")) {
              return "package.json";
            } else {
              return void 0;
            }
          });
          assertNotStrictEqual(pkgJsonPath, void 0, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
          obj = JSON.parse(__classPrivateFieldGet(this, _YargsInstance_shim, "f").readFileSync(pkgJsonPath, "utf8"));
        } catch (_noop) {
        }
        __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath] = obj || {};
        return __classPrivateFieldGet(this, _YargsInstance_pkgs, "f")[npath];
      }
      [kPopulateParserHintArray](type, keys) {
        keys = [].concat(keys);
        keys.forEach((key) => {
          key = this[kSanitizeKey](key);
          __classPrivateFieldGet(this, _YargsInstance_options, "f")[type].push(key);
        });
      }
      [kPopulateParserHintSingleValueDictionary](builder, type, key, value2) {
        this[kPopulateParserHintDictionary](builder, type, key, value2, (type2, key2, value3) => {
          __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = value3;
        });
      }
      [kPopulateParserHintArrayDictionary](builder, type, key, value2) {
        this[kPopulateParserHintDictionary](builder, type, key, value2, (type2, key2, value3) => {
          __classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[type2][key2] || []).concat(value3);
        });
      }
      [kPopulateParserHintDictionary](builder, type, key, value2, singleKeyHandler) {
        if (Array.isArray(key)) {
          key.forEach((k) => {
            builder(k, value2);
          });
        } else if (/* @__PURE__ */ ((key2) => typeof key2 === "object")(key)) {
          for (const k of objectKeys(key)) {
            builder(k, key[k]);
          }
        } else {
          singleKeyHandler(type, this[kSanitizeKey](key), value2);
        }
      }
      [kSanitizeKey](key) {
        if (key === "__proto__") return "___proto___";
        return key;
      }
      [kSetKey](key, set) {
        this[kPopulateParserHintSingleValueDictionary](this[kSetKey].bind(this), "key", key, set);
        return this;
      }
      [kUnfreeze]() {
        var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        const frozen = __classPrivateFieldGet(this, _YargsInstance_frozens, "f").pop();
        assertNotStrictEqual(frozen, void 0, __classPrivateFieldGet(this, _YargsInstance_shim, "f"));
        let configObjects;
        _a2 = this, _b2 = this, _c2 = this, _d = this, _e = this, _f = this, _g = this, _h = this, _j = this, _k = this, _l = this, _m = this, { options: {
          set value(_o) {
            __classPrivateFieldSet(_a2, _YargsInstance_options, _o, "f");
          }
        }.value, configObjects, exitProcess: {
          set value(_o) {
            __classPrivateFieldSet(_b2, _YargsInstance_exitProcess, _o, "f");
          }
        }.value, groups: {
          set value(_o) {
            __classPrivateFieldSet(_c2, _YargsInstance_groups, _o, "f");
          }
        }.value, output: {
          set value(_o) {
            __classPrivateFieldSet(_d, _YargsInstance_output, _o, "f");
          }
        }.value, exitError: {
          set value(_o) {
            __classPrivateFieldSet(_e, _YargsInstance_exitError, _o, "f");
          }
        }.value, hasOutput: {
          set value(_o) {
            __classPrivateFieldSet(_f, _YargsInstance_hasOutput, _o, "f");
          }
        }.value, parsed: this.parsed, strict: {
          set value(_o) {
            __classPrivateFieldSet(_g, _YargsInstance_strict, _o, "f");
          }
        }.value, strictCommands: {
          set value(_o) {
            __classPrivateFieldSet(_h, _YargsInstance_strictCommands, _o, "f");
          }
        }.value, strictOptions: {
          set value(_o) {
            __classPrivateFieldSet(_j, _YargsInstance_strictOptions, _o, "f");
          }
        }.value, completionCommand: {
          set value(_o) {
            __classPrivateFieldSet(_k, _YargsInstance_completionCommand, _o, "f");
          }
        }.value, parseFn: {
          set value(_o) {
            __classPrivateFieldSet(_l, _YargsInstance_parseFn, _o, "f");
          }
        }.value, parseContext: {
          set value(_o) {
            __classPrivateFieldSet(_m, _YargsInstance_parseContext, _o, "f");
          }
        }.value } = frozen;
        __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects = configObjects;
        __classPrivateFieldGet(this, _YargsInstance_usage, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_validation, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_command, "f").unfreeze();
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").unfreeze();
      }
      [kValidateAsync](validation2, argv2) {
        return maybeAsyncResult(argv2, (result2) => {
          validation2(result2);
          return result2;
        });
      }
      getInternalMethods() {
        return {
          getCommandInstance: this[kGetCommandInstance].bind(this),
          getContext: this[kGetContext].bind(this),
          getHasOutput: this[kGetHasOutput].bind(this),
          getLoggerInstance: this[kGetLoggerInstance].bind(this),
          getParseContext: this[kGetParseContext].bind(this),
          getParserConfiguration: this[kGetParserConfiguration].bind(this),
          getUsageConfiguration: this[kGetUsageConfiguration].bind(this),
          getUsageInstance: this[kGetUsageInstance].bind(this),
          getValidationInstance: this[kGetValidationInstance].bind(this),
          hasParseCallback: this[kHasParseCallback].bind(this),
          isGlobalContext: this[kIsGlobalContext].bind(this),
          postProcess: this[kPostProcess].bind(this),
          reset: this[kReset].bind(this),
          runValidation: this[kRunValidation].bind(this),
          runYargsParserAndExecuteCommands: this[kRunYargsParserAndExecuteCommands].bind(this),
          setHasOutput: this[kSetHasOutput].bind(this)
        };
      }
      [kGetCommandInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_command, "f");
      }
      [kGetContext]() {
        return __classPrivateFieldGet(this, _YargsInstance_context, "f");
      }
      [kGetHasOutput]() {
        return __classPrivateFieldGet(this, _YargsInstance_hasOutput, "f");
      }
      [kGetLoggerInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_logger, "f");
      }
      [kGetParseContext]() {
        return __classPrivateFieldGet(this, _YargsInstance_parseContext, "f") || {};
      }
      [kGetUsageInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_usage, "f");
      }
      [kGetValidationInstance]() {
        return __classPrivateFieldGet(this, _YargsInstance_validation, "f");
      }
      [kHasParseCallback]() {
        return !!__classPrivateFieldGet(this, _YargsInstance_parseFn, "f");
      }
      [kIsGlobalContext]() {
        return __classPrivateFieldGet(this, _YargsInstance_isGlobalContext, "f");
      }
      [kPostProcess](argv2, populateDoubleDash, calledFromCommand, runGlobalMiddleware) {
        if (calledFromCommand) return argv2;
        if (isPromise(argv2)) return argv2;
        if (!populateDoubleDash) {
          argv2 = this[kCopyDoubleDash](argv2);
        }
        const parsePositionalNumbers = this[kGetParserConfiguration]()["parse-positional-numbers"] || this[kGetParserConfiguration]()["parse-positional-numbers"] === void 0;
        if (parsePositionalNumbers) {
          argv2 = this[kParsePositionalNumbers](argv2);
        }
        if (runGlobalMiddleware) {
          argv2 = applyMiddleware(argv2, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
        }
        return argv2;
      }
      [kReset](aliases = {}) {
        __classPrivateFieldSet(this, _YargsInstance_options, __classPrivateFieldGet(this, _YargsInstance_options, "f") || {}, "f");
        const tmpOptions = {};
        tmpOptions.local = __classPrivateFieldGet(this, _YargsInstance_options, "f").local || [];
        tmpOptions.configObjects = __classPrivateFieldGet(this, _YargsInstance_options, "f").configObjects || [];
        const localLookup = {};
        tmpOptions.local.forEach((l) => {
          localLookup[l] = true;
          (aliases[l] || []).forEach((a) => {
            localLookup[a] = true;
          });
        });
        Object.assign(__classPrivateFieldGet(this, _YargsInstance_preservedGroups, "f"), Object.keys(__classPrivateFieldGet(this, _YargsInstance_groups, "f")).reduce((acc, groupName) => {
          const keys = __classPrivateFieldGet(this, _YargsInstance_groups, "f")[groupName].filter((key) => !(key in localLookup));
          if (keys.length > 0) {
            acc[groupName] = keys;
          }
          return acc;
        }, {}));
        __classPrivateFieldSet(this, _YargsInstance_groups, {}, "f");
        const arrayOptions = [
          "array",
          "boolean",
          "string",
          "skipValidation",
          "count",
          "normalize",
          "number",
          "hiddenOptions"
        ];
        const objectOptions = [
          "narg",
          "key",
          "alias",
          "default",
          "defaultDescription",
          "config",
          "choices",
          "demandedOptions",
          "demandedCommands",
          "deprecatedOptions"
        ];
        arrayOptions.forEach((k) => {
          tmpOptions[k] = (__classPrivateFieldGet(this, _YargsInstance_options, "f")[k] || []).filter((k2) => !localLookup[k2]);
        });
        objectOptions.forEach((k) => {
          tmpOptions[k] = objFilter(__classPrivateFieldGet(this, _YargsInstance_options, "f")[k], (k2) => !localLookup[k2]);
        });
        tmpOptions.envPrefix = __classPrivateFieldGet(this, _YargsInstance_options, "f").envPrefix;
        __classPrivateFieldSet(this, _YargsInstance_options, tmpOptions, "f");
        __classPrivateFieldSet(this, _YargsInstance_usage, __classPrivateFieldGet(this, _YargsInstance_usage, "f") ? __classPrivateFieldGet(this, _YargsInstance_usage, "f").reset(localLookup) : usage(this, __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldSet(this, _YargsInstance_validation, __classPrivateFieldGet(this, _YargsInstance_validation, "f") ? __classPrivateFieldGet(this, _YargsInstance_validation, "f").reset(localLookup) : validation(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldSet(this, _YargsInstance_command, __classPrivateFieldGet(this, _YargsInstance_command, "f") ? __classPrivateFieldGet(this, _YargsInstance_command, "f").reset() : command(__classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_validation, "f"), __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        if (!__classPrivateFieldGet(this, _YargsInstance_completion, "f")) __classPrivateFieldSet(this, _YargsInstance_completion, completion(this, __classPrivateFieldGet(this, _YargsInstance_usage, "f"), __classPrivateFieldGet(this, _YargsInstance_command, "f"), __classPrivateFieldGet(this, _YargsInstance_shim, "f")), "f");
        __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").reset();
        __classPrivateFieldSet(this, _YargsInstance_completionCommand, null, "f");
        __classPrivateFieldSet(this, _YargsInstance_output, "", "f");
        __classPrivateFieldSet(this, _YargsInstance_exitError, null, "f");
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, false, "f");
        this.parsed = false;
        return this;
      }
      [kRebase](base, dir) {
        return __classPrivateFieldGet(this, _YargsInstance_shim, "f").path.relative(base, dir);
      }
      [kRunYargsParserAndExecuteCommands](args, shortCircuit, calledFromCommand, commandIndex = 0, helpOnly = false) {
        let skipValidation = !!calledFromCommand || helpOnly;
        args = args || __classPrivateFieldGet(this, _YargsInstance_processArgs, "f");
        __classPrivateFieldGet(this, _YargsInstance_options, "f").__ = __classPrivateFieldGet(this, _YargsInstance_shim, "f").y18n.__;
        __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration = this[kGetParserConfiguration]();
        const populateDoubleDash = !!__classPrivateFieldGet(this, _YargsInstance_options, "f").configuration["populate--"];
        const config = Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f").configuration, {
          "populate--": true
        });
        const parsed = __classPrivateFieldGet(this, _YargsInstance_shim, "f").Parser.detailed(args, Object.assign({}, __classPrivateFieldGet(this, _YargsInstance_options, "f"), {
          configuration: {
            "parse-positional-numbers": false,
            ...config
          }
        }));
        const argv2 = Object.assign(parsed.argv, __classPrivateFieldGet(this, _YargsInstance_parseContext, "f"));
        let argvPromise = void 0;
        const aliases = parsed.aliases;
        let helpOptSet = false;
        let versionOptSet = false;
        Object.keys(argv2).forEach((key) => {
          if (key === __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f") && argv2[key]) {
            helpOptSet = true;
          } else if (key === __classPrivateFieldGet(this, _YargsInstance_versionOpt, "f") && argv2[key]) {
            versionOptSet = true;
          }
        });
        argv2.$0 = this.$0;
        this.parsed = parsed;
        if (commandIndex === 0) {
          __classPrivateFieldGet(this, _YargsInstance_usage, "f").clearCachedHelpMessage();
        }
        try {
          this[kGuessLocale]();
          if (shortCircuit) {
            return this[kPostProcess](argv2, populateDoubleDash, !!calledFromCommand, false);
          }
          if (__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")) {
            const helpCmds = [
              __classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")
            ].concat(aliases[__classPrivateFieldGet(this, _YargsInstance_helpOpt, "f")] || []).filter((k) => k.length > 1);
            if (helpCmds.includes("" + argv2._[argv2._.length - 1])) {
              argv2._.pop();
              helpOptSet = true;
            }
          }
          __classPrivateFieldSet(this, _YargsInstance_isGlobalContext, false, "f");
          const handlerKeys = __classPrivateFieldGet(this, _YargsInstance_command, "f").getCommands();
          const requestCompletions = __classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey in argv2;
          const skipRecommendation = helpOptSet || requestCompletions || helpOnly;
          if (argv2._.length) {
            if (handlerKeys.length) {
              let firstUnknownCommand;
              for (let i = commandIndex || 0, cmd; argv2._[i] !== void 0; i++) {
                cmd = String(argv2._[i]);
                if (handlerKeys.includes(cmd) && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
                  const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(cmd, this, parsed, i + 1, helpOnly, helpOptSet || versionOptSet || helpOnly);
                  return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
                } else if (!firstUnknownCommand && cmd !== __classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) {
                  firstUnknownCommand = cmd;
                  break;
                }
              }
              if (!__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && __classPrivateFieldGet(this, _YargsInstance_recommendCommands, "f") && firstUnknownCommand && !skipRecommendation) {
                __classPrivateFieldGet(this, _YargsInstance_validation, "f").recommendCommands(firstUnknownCommand, handlerKeys);
              }
            }
            if (__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f") && argv2._.includes(__classPrivateFieldGet(this, _YargsInstance_completionCommand, "f")) && !requestCompletions) {
              if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
              this.showCompletionScript();
              this.exit(0);
            }
          }
          if (__classPrivateFieldGet(this, _YargsInstance_command, "f").hasDefaultCommand() && !skipRecommendation) {
            const innerArgv = __classPrivateFieldGet(this, _YargsInstance_command, "f").runCommand(null, this, parsed, 0, helpOnly, helpOptSet || versionOptSet || helpOnly);
            return this[kPostProcess](innerArgv, populateDoubleDash, !!calledFromCommand, false);
          }
          if (requestCompletions) {
            if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
            args = [].concat(args);
            const completionArgs = args.slice(args.indexOf(`--${__classPrivateFieldGet(this, _YargsInstance_completion, "f").completionKey}`) + 1);
            __classPrivateFieldGet(this, _YargsInstance_completion, "f").getCompletion(completionArgs, (err, completions) => {
              if (err) throw new YError(err.message);
              (completions || []).forEach((completion2) => {
                __classPrivateFieldGet(this, _YargsInstance_logger, "f").log(completion2);
              });
              this.exit(0);
            });
            return this[kPostProcess](argv2, !populateDoubleDash, !!calledFromCommand, false);
          }
          if (!__classPrivateFieldGet(this, _YargsInstance_hasOutput, "f")) {
            if (helpOptSet) {
              if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
              skipValidation = true;
              this.showHelp("log");
              this.exit(0);
            } else if (versionOptSet) {
              if (__classPrivateFieldGet(this, _YargsInstance_exitProcess, "f")) setBlocking(true);
              skipValidation = true;
              __classPrivateFieldGet(this, _YargsInstance_usage, "f").showVersion("log");
              this.exit(0);
            }
          }
          if (!skipValidation && __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.length > 0) {
            skipValidation = Object.keys(argv2).some((key) => __classPrivateFieldGet(this, _YargsInstance_options, "f").skipValidation.indexOf(key) >= 0 && argv2[key] === true);
          }
          if (!skipValidation) {
            if (parsed.error) throw new YError(parsed.error.message);
            if (!requestCompletions) {
              const validation2 = this[kRunValidation](aliases, {}, parsed.error);
              if (!calledFromCommand) {
                argvPromise = applyMiddleware(argv2, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), true);
              }
              argvPromise = this[kValidateAsync](validation2, argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv2);
              if (isPromise(argvPromise) && !calledFromCommand) {
                argvPromise = argvPromise.then(() => {
                  return applyMiddleware(argv2, this, __classPrivateFieldGet(this, _YargsInstance_globalMiddleware, "f").getMiddleware(), false);
                });
              }
            }
          }
        } catch (err) {
          if (err instanceof YError) __classPrivateFieldGet(this, _YargsInstance_usage, "f").fail(err.message, err);
          else throw err;
        }
        return this[kPostProcess](argvPromise !== null && argvPromise !== void 0 ? argvPromise : argv2, populateDoubleDash, !!calledFromCommand, true);
      }
      [kRunValidation](aliases, positionalMap, parseErrors, isDefaultCommand) {
        const demandedOptions = {
          ...this.getDemandedOptions()
        };
        return (argv2) => {
          if (parseErrors) throw new YError(parseErrors.message);
          __classPrivateFieldGet(this, _YargsInstance_validation, "f").nonOptionCount(argv2);
          __classPrivateFieldGet(this, _YargsInstance_validation, "f").requiredArguments(argv2, demandedOptions);
          let failedStrictCommands = false;
          if (__classPrivateFieldGet(this, _YargsInstance_strictCommands, "f")) {
            failedStrictCommands = __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownCommands(argv2);
          }
          if (__classPrivateFieldGet(this, _YargsInstance_strict, "f") && !failedStrictCommands) {
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv2, aliases, positionalMap, !!isDefaultCommand);
          } else if (__classPrivateFieldGet(this, _YargsInstance_strictOptions, "f")) {
            __classPrivateFieldGet(this, _YargsInstance_validation, "f").unknownArguments(argv2, aliases, {}, false, false);
          }
          __classPrivateFieldGet(this, _YargsInstance_validation, "f").limitedChoices(argv2);
          __classPrivateFieldGet(this, _YargsInstance_validation, "f").implications(argv2);
          __classPrivateFieldGet(this, _YargsInstance_validation, "f").conflicting(argv2);
        };
      }
      [kSetHasOutput]() {
        __classPrivateFieldSet(this, _YargsInstance_hasOutput, true, "f");
      }
      [kTrackManuallySetKeys](keys) {
        if (typeof keys === "string") {
          __classPrivateFieldGet(this, _YargsInstance_options, "f").key[keys] = true;
        } else {
          for (const k of keys) {
            __classPrivateFieldGet(this, _YargsInstance_options, "f").key[k] = true;
          }
        }
      }
    };
    __name(isYargsInstance, "isYargsInstance");
  }
});

// node_modules/yargs/index.mjs
var Yargs, yargs_default;
var init_yargs = __esm({
  "node_modules/yargs/index.mjs"() {
    "use strict";
    init_esm();
    init_yargs_factory();
    Yargs = YargsFactory(esm_default);
    yargs_default = Yargs;
  }
});

// node_modules/yargs/helpers/helpers.mjs
var init_helpers = __esm({
  "node_modules/yargs/helpers/helpers.mjs"() {
    "use strict";
    init_apply_extends();
    init_process_argv();
    init_lib2();
    init_esm();
  }
});

// node_modules/zod/lib/index.mjs
function setErrorMap(map) {
  overrideErrorMap = map;
}
function getErrorMap() {
  return overrideErrorMap;
}
function addIssueToContext(ctx, issueData) {
  const overrideMap = getErrorMap();
  const issue = makeIssue({
    issueData,
    data: ctx.data,
    path: ctx.path,
    errorMaps: [
      ctx.common.contextualErrorMap,
      // contextual error map is first priority
      ctx.schemaErrorMap,
      // then schema-bound map if available
      overrideMap,
      // then global override map
      overrideMap === errorMap ? void 0 : errorMap
      // then global default map
    ].filter((x) => !!x)
  });
  ctx.common.issues.push(issue);
}
function __classPrivateFieldGet2(receiver, state, kind, f) {
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
}
function __classPrivateFieldSet2(receiver, state, value2, kind, f) {
  if (kind === "m") throw new TypeError("Private method is not writable");
  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind === "a" ? f.call(receiver, value2) : f ? f.value = value2 : state.set(receiver, value2), value2;
}
function processCreateParams(params2) {
  if (!params2)
    return {};
  const { errorMap: errorMap2, invalid_type_error, required_error, description } = params2;
  if (errorMap2 && (invalid_type_error || required_error)) {
    throw new Error(`Can't use "invalid_type_error" or "required_error" in conjunction with custom error map.`);
  }
  if (errorMap2)
    return { errorMap: errorMap2, description };
  const customMap = /* @__PURE__ */ __name((iss, ctx) => {
    var _a2, _b2;
    const { message } = params2;
    if (iss.code === "invalid_enum_value") {
      return { message: message !== null && message !== void 0 ? message : ctx.defaultError };
    }
    if (typeof ctx.data === "undefined") {
      return { message: (_a2 = message !== null && message !== void 0 ? message : required_error) !== null && _a2 !== void 0 ? _a2 : ctx.defaultError };
    }
    if (iss.code !== "invalid_type")
      return { message: ctx.defaultError };
    return { message: (_b2 = message !== null && message !== void 0 ? message : invalid_type_error) !== null && _b2 !== void 0 ? _b2 : ctx.defaultError };
  }, "customMap");
  return { errorMap: customMap, description };
}
function timeRegexSource(args) {
  let regex = `([01]\\d|2[0-3]):[0-5]\\d:[0-5]\\d`;
  if (args.precision) {
    regex = `${regex}\\.\\d{${args.precision}}`;
  } else if (args.precision == null) {
    regex = `${regex}(\\.\\d+)?`;
  }
  return regex;
}
function timeRegex(args) {
  return new RegExp(`^${timeRegexSource(args)}$`);
}
function datetimeRegex(args) {
  let regex = `${dateRegexSource}T${timeRegexSource(args)}`;
  const opts = [];
  opts.push(args.local ? `Z?` : `Z`);
  if (args.offset)
    opts.push(`([+-]\\d{2}:?\\d{2})`);
  regex = `${regex}(${opts.join("|")})`;
  return new RegExp(`^${regex}$`);
}
function isValidIP(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4Regex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6Regex.test(ip)) {
    return true;
  }
  return false;
}
function isValidJWT(jwt, alg) {
  if (!jwtRegex.test(jwt))
    return false;
  try {
    const [header] = jwt.split(".");
    const base64 = header.replace(/-/g, "+").replace(/_/g, "/").padEnd(header.length + (4 - header.length % 4) % 4, "=");
    const decoded = JSON.parse(atob(base64));
    if (typeof decoded !== "object" || decoded === null)
      return false;
    if (!decoded.typ || !decoded.alg)
      return false;
    if (alg && decoded.alg !== alg)
      return false;
    return true;
  } catch (_a2) {
    return false;
  }
}
function isValidCidr(ip, version2) {
  if ((version2 === "v4" || !version2) && ipv4CidrRegex.test(ip)) {
    return true;
  }
  if ((version2 === "v6" || !version2) && ipv6CidrRegex.test(ip)) {
    return true;
  }
  return false;
}
function floatSafeRemainder(val, step) {
  const valDecCount = (val.toString().split(".")[1] || "").length;
  const stepDecCount = (step.toString().split(".")[1] || "").length;
  const decCount = valDecCount > stepDecCount ? valDecCount : stepDecCount;
  const valInt = parseInt(val.toFixed(decCount).replace(".", ""));
  const stepInt = parseInt(step.toFixed(decCount).replace(".", ""));
  return valInt % stepInt / Math.pow(10, decCount);
}
function deepPartialify(schema) {
  if (schema instanceof ZodObject) {
    const newShape = {};
    for (const key in schema.shape) {
      const fieldSchema = schema.shape[key];
      newShape[key] = ZodOptional.create(deepPartialify(fieldSchema));
    }
    return new ZodObject({
      ...schema._def,
      shape: /* @__PURE__ */ __name(() => newShape, "shape")
    });
  } else if (schema instanceof ZodArray) {
    return new ZodArray({
      ...schema._def,
      type: deepPartialify(schema.element)
    });
  } else if (schema instanceof ZodOptional) {
    return ZodOptional.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodNullable) {
    return ZodNullable.create(deepPartialify(schema.unwrap()));
  } else if (schema instanceof ZodTuple) {
    return ZodTuple.create(schema.items.map((item) => deepPartialify(item)));
  } else {
    return schema;
  }
}
function mergeValues(a, b) {
  const aType = getParsedType(a);
  const bType = getParsedType(b);
  if (a === b) {
    return { valid: true, data: a };
  } else if (aType === ZodParsedType.object && bType === ZodParsedType.object) {
    const bKeys = util.objectKeys(b);
    const sharedKeys = util.objectKeys(a).filter((key) => bKeys.indexOf(key) !== -1);
    const newObj = { ...a, ...b };
    for (const key of sharedKeys) {
      const sharedValue = mergeValues(a[key], b[key]);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newObj[key] = sharedValue.data;
    }
    return { valid: true, data: newObj };
  } else if (aType === ZodParsedType.array && bType === ZodParsedType.array) {
    if (a.length !== b.length) {
      return { valid: false };
    }
    const newArray = [];
    for (let index = 0; index < a.length; index++) {
      const itemA = a[index];
      const itemB = b[index];
      const sharedValue = mergeValues(itemA, itemB);
      if (!sharedValue.valid) {
        return { valid: false };
      }
      newArray.push(sharedValue.data);
    }
    return { valid: true, data: newArray };
  } else if (aType === ZodParsedType.date && bType === ZodParsedType.date && +a === +b) {
    return { valid: true, data: a };
  } else {
    return { valid: false };
  }
}
function createZodEnum(values, params2) {
  return new ZodEnum({
    values,
    typeName: ZodFirstPartyTypeKind.ZodEnum,
    ...processCreateParams(params2)
  });
}
function cleanParams(params2, data) {
  const p = typeof params2 === "function" ? params2(data) : typeof params2 === "string" ? { message: params2 } : params2;
  const p2 = typeof p === "string" ? { message: p } : p;
  return p2;
}
function custom(check, _params = {}, fatal) {
  if (check)
    return ZodAny.create().superRefine((data, ctx) => {
      var _a2, _b2;
      const r = check(data);
      if (r instanceof Promise) {
        return r.then((r2) => {
          var _a3, _b3;
          if (!r2) {
            const params2 = cleanParams(_params, data);
            const _fatal = (_b3 = (_a3 = params2.fatal) !== null && _a3 !== void 0 ? _a3 : fatal) !== null && _b3 !== void 0 ? _b3 : true;
            ctx.addIssue({ code: "custom", ...params2, fatal: _fatal });
          }
        });
      }
      if (!r) {
        const params2 = cleanParams(_params, data);
        const _fatal = (_b2 = (_a2 = params2.fatal) !== null && _a2 !== void 0 ? _a2 : fatal) !== null && _b2 !== void 0 ? _b2 : true;
        ctx.addIssue({ code: "custom", ...params2, fatal: _fatal });
      }
      return;
    });
  return ZodAny.create();
}
var util, objectUtil, ZodParsedType, getParsedType, ZodIssueCode, quotelessJson, ZodError, errorMap, overrideErrorMap, makeIssue, EMPTY_PATH, ParseStatus, INVALID, DIRTY, OK, isAborted, isDirty, isValid, isAsync, errorUtil, _ZodEnum_cache, _ZodNativeEnum_cache, ParseInputLazyPath, handleResult, ZodType, cuidRegex, cuid2Regex, ulidRegex, uuidRegex, nanoidRegex, jwtRegex, durationRegex, emailRegex, _emojiRegex, emojiRegex, ipv4Regex, ipv4CidrRegex, ipv6Regex, ipv6CidrRegex, base64Regex, base64urlRegex, dateRegexSource, dateRegex, ZodString, ZodNumber, ZodBigInt, ZodBoolean, ZodDate, ZodSymbol, ZodUndefined, ZodNull, ZodAny, ZodUnknown, ZodNever, ZodVoid, ZodArray, ZodObject, ZodUnion, getDiscriminator, ZodDiscriminatedUnion, ZodIntersection, ZodTuple, ZodRecord, ZodMap, ZodSet, ZodFunction, ZodLazy, ZodLiteral, ZodEnum, ZodNativeEnum, ZodPromise, ZodEffects, ZodOptional, ZodNullable, ZodDefault, ZodCatch, ZodNaN, BRAND, ZodBranded, ZodPipeline, ZodReadonly, late, ZodFirstPartyTypeKind, instanceOfType, stringType, numberType, nanType, bigIntType, booleanType, dateType, symbolType, undefinedType, nullType, anyType, unknownType, neverType, voidType, arrayType, objectType, strictObjectType, unionType, discriminatedUnionType, intersectionType, tupleType, recordType, mapType, setType, functionType, lazyType, literalType, enumType, nativeEnumType, promiseType, effectsType, optionalType, nullableType, preprocessType, pipelineType, ostring, onumber, oboolean, coerce, NEVER, z;
var init_lib4 = __esm({
  "node_modules/zod/lib/index.mjs"() {
    "use strict";
    (function(util2) {
      util2.assertEqual = (val) => val;
      function assertIs(_arg) {
      }
      __name(assertIs, "assertIs");
      util2.assertIs = assertIs;
      function assertNever(_x) {
        throw new Error();
      }
      __name(assertNever, "assertNever");
      util2.assertNever = assertNever;
      util2.arrayToEnum = (items) => {
        const obj = {};
        for (const item of items) {
          obj[item] = item;
        }
        return obj;
      };
      util2.getValidEnumValues = (obj) => {
        const validKeys = util2.objectKeys(obj).filter((k) => typeof obj[obj[k]] !== "number");
        const filtered = {};
        for (const k of validKeys) {
          filtered[k] = obj[k];
        }
        return util2.objectValues(filtered);
      };
      util2.objectValues = (obj) => {
        return util2.objectKeys(obj).map(function(e) {
          return obj[e];
        });
      };
      util2.objectKeys = typeof Object.keys === "function" ? (obj) => Object.keys(obj) : (object) => {
        const keys = [];
        for (const key in object) {
          if (Object.prototype.hasOwnProperty.call(object, key)) {
            keys.push(key);
          }
        }
        return keys;
      };
      util2.find = (arr, checker) => {
        for (const item of arr) {
          if (checker(item))
            return item;
        }
        return void 0;
      };
      util2.isInteger = typeof Number.isInteger === "function" ? (val) => Number.isInteger(val) : (val) => typeof val === "number" && isFinite(val) && Math.floor(val) === val;
      function joinValues(array, separator = " | ") {
        return array.map((val) => typeof val === "string" ? `'${val}'` : val).join(separator);
      }
      __name(joinValues, "joinValues");
      util2.joinValues = joinValues;
      util2.jsonStringifyReplacer = (_, value2) => {
        if (typeof value2 === "bigint") {
          return value2.toString();
        }
        return value2;
      };
    })(util || (util = {}));
    (function(objectUtil2) {
      objectUtil2.mergeShapes = (first, second) => {
        return {
          ...first,
          ...second
          // second overwrites first
        };
      };
    })(objectUtil || (objectUtil = {}));
    ZodParsedType = util.arrayToEnum([
      "string",
      "nan",
      "number",
      "integer",
      "float",
      "boolean",
      "date",
      "bigint",
      "symbol",
      "function",
      "undefined",
      "null",
      "array",
      "object",
      "unknown",
      "promise",
      "void",
      "never",
      "map",
      "set"
    ]);
    getParsedType = /* @__PURE__ */ __name((data) => {
      const t = typeof data;
      switch (t) {
        case "undefined":
          return ZodParsedType.undefined;
        case "string":
          return ZodParsedType.string;
        case "number":
          return isNaN(data) ? ZodParsedType.nan : ZodParsedType.number;
        case "boolean":
          return ZodParsedType.boolean;
        case "function":
          return ZodParsedType.function;
        case "bigint":
          return ZodParsedType.bigint;
        case "symbol":
          return ZodParsedType.symbol;
        case "object":
          if (Array.isArray(data)) {
            return ZodParsedType.array;
          }
          if (data === null) {
            return ZodParsedType.null;
          }
          if (data.then && typeof data.then === "function" && data.catch && typeof data.catch === "function") {
            return ZodParsedType.promise;
          }
          if (typeof Map !== "undefined" && data instanceof Map) {
            return ZodParsedType.map;
          }
          if (typeof Set !== "undefined" && data instanceof Set) {
            return ZodParsedType.set;
          }
          if (typeof Date !== "undefined" && data instanceof Date) {
            return ZodParsedType.date;
          }
          return ZodParsedType.object;
        default:
          return ZodParsedType.unknown;
      }
    }, "getParsedType");
    ZodIssueCode = util.arrayToEnum([
      "invalid_type",
      "invalid_literal",
      "custom",
      "invalid_union",
      "invalid_union_discriminator",
      "invalid_enum_value",
      "unrecognized_keys",
      "invalid_arguments",
      "invalid_return_type",
      "invalid_date",
      "invalid_string",
      "too_small",
      "too_big",
      "invalid_intersection_types",
      "not_multiple_of",
      "not_finite"
    ]);
    quotelessJson = /* @__PURE__ */ __name((obj) => {
      const json = JSON.stringify(obj, null, 2);
      return json.replace(/"([^"]+)":/g, "$1:");
    }, "quotelessJson");
    ZodError = class _ZodError extends Error {
      static {
        __name(this, "ZodError");
      }
      get errors() {
        return this.issues;
      }
      constructor(issues) {
        super();
        this.issues = [];
        this.addIssue = (sub) => {
          this.issues = [...this.issues, sub];
        };
        this.addIssues = (subs = []) => {
          this.issues = [...this.issues, ...subs];
        };
        const actualProto = new.target.prototype;
        if (Object.setPrototypeOf) {
          Object.setPrototypeOf(this, actualProto);
        } else {
          this.__proto__ = actualProto;
        }
        this.name = "ZodError";
        this.issues = issues;
      }
      format(_mapper) {
        const mapper = _mapper || function(issue) {
          return issue.message;
        };
        const fieldErrors = { _errors: [] };
        const processError = /* @__PURE__ */ __name((error) => {
          for (const issue of error.issues) {
            if (issue.code === "invalid_union") {
              issue.unionErrors.map(processError);
            } else if (issue.code === "invalid_return_type") {
              processError(issue.returnTypeError);
            } else if (issue.code === "invalid_arguments") {
              processError(issue.argumentsError);
            } else if (issue.path.length === 0) {
              fieldErrors._errors.push(mapper(issue));
            } else {
              let curr = fieldErrors;
              let i = 0;
              while (i < issue.path.length) {
                const el = issue.path[i];
                const terminal = i === issue.path.length - 1;
                if (!terminal) {
                  curr[el] = curr[el] || { _errors: [] };
                } else {
                  curr[el] = curr[el] || { _errors: [] };
                  curr[el]._errors.push(mapper(issue));
                }
                curr = curr[el];
                i++;
              }
            }
          }
        }, "processError");
        processError(this);
        return fieldErrors;
      }
      static assert(value2) {
        if (!(value2 instanceof _ZodError)) {
          throw new Error(`Not a ZodError: ${value2}`);
        }
      }
      toString() {
        return this.message;
      }
      get message() {
        return JSON.stringify(this.issues, util.jsonStringifyReplacer, 2);
      }
      get isEmpty() {
        return this.issues.length === 0;
      }
      flatten(mapper = (issue) => issue.message) {
        const fieldErrors = {};
        const formErrors = [];
        for (const sub of this.issues) {
          if (sub.path.length > 0) {
            fieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];
            fieldErrors[sub.path[0]].push(mapper(sub));
          } else {
            formErrors.push(mapper(sub));
          }
        }
        return { formErrors, fieldErrors };
      }
      get formErrors() {
        return this.flatten();
      }
    };
    ZodError.create = (issues) => {
      const error = new ZodError(issues);
      return error;
    };
    errorMap = /* @__PURE__ */ __name((issue, _ctx) => {
      let message;
      switch (issue.code) {
        case ZodIssueCode.invalid_type:
          if (issue.received === ZodParsedType.undefined) {
            message = "Required";
          } else {
            message = `Expected ${issue.expected}, received ${issue.received}`;
          }
          break;
        case ZodIssueCode.invalid_literal:
          message = `Invalid literal value, expected ${JSON.stringify(issue.expected, util.jsonStringifyReplacer)}`;
          break;
        case ZodIssueCode.unrecognized_keys:
          message = `Unrecognized key(s) in object: ${util.joinValues(issue.keys, ", ")}`;
          break;
        case ZodIssueCode.invalid_union:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_union_discriminator:
          message = `Invalid discriminator value. Expected ${util.joinValues(issue.options)}`;
          break;
        case ZodIssueCode.invalid_enum_value:
          message = `Invalid enum value. Expected ${util.joinValues(issue.options)}, received '${issue.received}'`;
          break;
        case ZodIssueCode.invalid_arguments:
          message = `Invalid function arguments`;
          break;
        case ZodIssueCode.invalid_return_type:
          message = `Invalid function return type`;
          break;
        case ZodIssueCode.invalid_date:
          message = `Invalid date`;
          break;
        case ZodIssueCode.invalid_string:
          if (typeof issue.validation === "object") {
            if ("includes" in issue.validation) {
              message = `Invalid input: must include "${issue.validation.includes}"`;
              if (typeof issue.validation.position === "number") {
                message = `${message} at one or more positions greater than or equal to ${issue.validation.position}`;
              }
            } else if ("startsWith" in issue.validation) {
              message = `Invalid input: must start with "${issue.validation.startsWith}"`;
            } else if ("endsWith" in issue.validation) {
              message = `Invalid input: must end with "${issue.validation.endsWith}"`;
            } else {
              util.assertNever(issue.validation);
            }
          } else if (issue.validation !== "regex") {
            message = `Invalid ${issue.validation}`;
          } else {
            message = "Invalid";
          }
          break;
        case ZodIssueCode.too_small:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `more than`} ${issue.minimum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? "exactly" : issue.inclusive ? `at least` : `over`} ${issue.minimum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${issue.minimum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly equal to ` : issue.inclusive ? `greater than or equal to ` : `greater than `}${new Date(Number(issue.minimum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.too_big:
          if (issue.type === "array")
            message = `Array must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `less than`} ${issue.maximum} element(s)`;
          else if (issue.type === "string")
            message = `String must contain ${issue.exact ? `exactly` : issue.inclusive ? `at most` : `under`} ${issue.maximum} character(s)`;
          else if (issue.type === "number")
            message = `Number must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "bigint")
            message = `BigInt must be ${issue.exact ? `exactly` : issue.inclusive ? `less than or equal to` : `less than`} ${issue.maximum}`;
          else if (issue.type === "date")
            message = `Date must be ${issue.exact ? `exactly` : issue.inclusive ? `smaller than or equal to` : `smaller than`} ${new Date(Number(issue.maximum))}`;
          else
            message = "Invalid input";
          break;
        case ZodIssueCode.custom:
          message = `Invalid input`;
          break;
        case ZodIssueCode.invalid_intersection_types:
          message = `Intersection results could not be merged`;
          break;
        case ZodIssueCode.not_multiple_of:
          message = `Number must be a multiple of ${issue.multipleOf}`;
          break;
        case ZodIssueCode.not_finite:
          message = "Number must be finite";
          break;
        default:
          message = _ctx.defaultError;
          util.assertNever(issue);
      }
      return { message };
    }, "errorMap");
    overrideErrorMap = errorMap;
    __name(setErrorMap, "setErrorMap");
    __name(getErrorMap, "getErrorMap");
    makeIssue = /* @__PURE__ */ __name((params2) => {
      const { data, path, errorMaps, issueData } = params2;
      const fullPath = [...path, ...issueData.path || []];
      const fullIssue = {
        ...issueData,
        path: fullPath
      };
      if (issueData.message !== void 0) {
        return {
          ...issueData,
          path: fullPath,
          message: issueData.message
        };
      }
      let errorMessage = "";
      const maps = errorMaps.filter((m) => !!m).slice().reverse();
      for (const map of maps) {
        errorMessage = map(fullIssue, { data, defaultError: errorMessage }).message;
      }
      return {
        ...issueData,
        path: fullPath,
        message: errorMessage
      };
    }, "makeIssue");
    EMPTY_PATH = [];
    __name(addIssueToContext, "addIssueToContext");
    ParseStatus = class _ParseStatus {
      static {
        __name(this, "ParseStatus");
      }
      constructor() {
        this.value = "valid";
      }
      dirty() {
        if (this.value === "valid")
          this.value = "dirty";
      }
      abort() {
        if (this.value !== "aborted")
          this.value = "aborted";
      }
      static mergeArray(status, results) {
        const arrayValue = [];
        for (const s of results) {
          if (s.status === "aborted")
            return INVALID;
          if (s.status === "dirty")
            status.dirty();
          arrayValue.push(s.value);
        }
        return { status: status.value, value: arrayValue };
      }
      static async mergeObjectAsync(status, pairs) {
        const syncPairs = [];
        for (const pair of pairs) {
          const key = await pair.key;
          const value2 = await pair.value;
          syncPairs.push({
            key,
            value: value2
          });
        }
        return _ParseStatus.mergeObjectSync(status, syncPairs);
      }
      static mergeObjectSync(status, pairs) {
        const finalObject = {};
        for (const pair of pairs) {
          const { key, value: value2 } = pair;
          if (key.status === "aborted")
            return INVALID;
          if (value2.status === "aborted")
            return INVALID;
          if (key.status === "dirty")
            status.dirty();
          if (value2.status === "dirty")
            status.dirty();
          if (key.value !== "__proto__" && (typeof value2.value !== "undefined" || pair.alwaysSet)) {
            finalObject[key.value] = value2.value;
          }
        }
        return { status: status.value, value: finalObject };
      }
    };
    INVALID = Object.freeze({
      status: "aborted"
    });
    DIRTY = /* @__PURE__ */ __name((value2) => ({ status: "dirty", value: value2 }), "DIRTY");
    OK = /* @__PURE__ */ __name((value2) => ({ status: "valid", value: value2 }), "OK");
    isAborted = /* @__PURE__ */ __name((x) => x.status === "aborted", "isAborted");
    isDirty = /* @__PURE__ */ __name((x) => x.status === "dirty", "isDirty");
    isValid = /* @__PURE__ */ __name((x) => x.status === "valid", "isValid");
    isAsync = /* @__PURE__ */ __name((x) => typeof Promise !== "undefined" && x instanceof Promise, "isAsync");
    __name(__classPrivateFieldGet2, "__classPrivateFieldGet");
    __name(__classPrivateFieldSet2, "__classPrivateFieldSet");
    (function(errorUtil2) {
      errorUtil2.errToObj = (message) => typeof message === "string" ? { message } : message || {};
      errorUtil2.toString = (message) => typeof message === "string" ? message : message === null || message === void 0 ? void 0 : message.message;
    })(errorUtil || (errorUtil = {}));
    ParseInputLazyPath = class {
      static {
        __name(this, "ParseInputLazyPath");
      }
      constructor(parent, value2, path, key) {
        this._cachedPath = [];
        this.parent = parent;
        this.data = value2;
        this._path = path;
        this._key = key;
      }
      get path() {
        if (!this._cachedPath.length) {
          if (this._key instanceof Array) {
            this._cachedPath.push(...this._path, ...this._key);
          } else {
            this._cachedPath.push(...this._path, this._key);
          }
        }
        return this._cachedPath;
      }
    };
    handleResult = /* @__PURE__ */ __name((ctx, result2) => {
      if (isValid(result2)) {
        return { success: true, data: result2.value };
      } else {
        if (!ctx.common.issues.length) {
          throw new Error("Validation failed but no issues detected.");
        }
        return {
          success: false,
          get error() {
            if (this._error)
              return this._error;
            const error = new ZodError(ctx.common.issues);
            this._error = error;
            return this._error;
          }
        };
      }
    }, "handleResult");
    __name(processCreateParams, "processCreateParams");
    ZodType = class {
      static {
        __name(this, "ZodType");
      }
      get description() {
        return this._def.description;
      }
      _getType(input) {
        return getParsedType(input.data);
      }
      _getOrReturnCtx(input, ctx) {
        return ctx || {
          common: input.parent.common,
          data: input.data,
          parsedType: getParsedType(input.data),
          schemaErrorMap: this._def.errorMap,
          path: input.path,
          parent: input.parent
        };
      }
      _processInputParams(input) {
        return {
          status: new ParseStatus(),
          ctx: {
            common: input.parent.common,
            data: input.data,
            parsedType: getParsedType(input.data),
            schemaErrorMap: this._def.errorMap,
            path: input.path,
            parent: input.parent
          }
        };
      }
      _parseSync(input) {
        const result2 = this._parse(input);
        if (isAsync(result2)) {
          throw new Error("Synchronous parse encountered promise.");
        }
        return result2;
      }
      _parseAsync(input) {
        const result2 = this._parse(input);
        return Promise.resolve(result2);
      }
      parse(data, params2) {
        const result2 = this.safeParse(data, params2);
        if (result2.success)
          return result2.data;
        throw result2.error;
      }
      safeParse(data, params2) {
        var _a2;
        const ctx = {
          common: {
            issues: [],
            async: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.async) !== null && _a2 !== void 0 ? _a2 : false,
            contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap
          },
          path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const result2 = this._parseSync({ data, path: ctx.path, parent: ctx });
        return handleResult(ctx, result2);
      }
      "~validate"(data) {
        var _a2, _b2;
        const ctx = {
          common: {
            issues: [],
            async: !!this["~standard"].async
          },
          path: [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        if (!this["~standard"].async) {
          try {
            const result2 = this._parseSync({ data, path: [], parent: ctx });
            return isValid(result2) ? {
              value: result2.value
            } : {
              issues: ctx.common.issues
            };
          } catch (err) {
            if ((_b2 = (_a2 = err === null || err === void 0 ? void 0 : err.message) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase()) === null || _b2 === void 0 ? void 0 : _b2.includes("encountered")) {
              this["~standard"].async = true;
            }
            ctx.common = {
              issues: [],
              async: true
            };
          }
        }
        return this._parseAsync({ data, path: [], parent: ctx }).then((result2) => isValid(result2) ? {
          value: result2.value
        } : {
          issues: ctx.common.issues
        });
      }
      async parseAsync(data, params2) {
        const result2 = await this.safeParseAsync(data, params2);
        if (result2.success)
          return result2.data;
        throw result2.error;
      }
      async safeParseAsync(data, params2) {
        const ctx = {
          common: {
            issues: [],
            contextualErrorMap: params2 === null || params2 === void 0 ? void 0 : params2.errorMap,
            async: true
          },
          path: (params2 === null || params2 === void 0 ? void 0 : params2.path) || [],
          schemaErrorMap: this._def.errorMap,
          parent: null,
          data,
          parsedType: getParsedType(data)
        };
        const maybeAsyncResult2 = this._parse({ data, path: ctx.path, parent: ctx });
        const result2 = await (isAsync(maybeAsyncResult2) ? maybeAsyncResult2 : Promise.resolve(maybeAsyncResult2));
        return handleResult(ctx, result2);
      }
      refine(check, message) {
        const getIssueProperties = /* @__PURE__ */ __name((val) => {
          if (typeof message === "string" || typeof message === "undefined") {
            return { message };
          } else if (typeof message === "function") {
            return message(val);
          } else {
            return message;
          }
        }, "getIssueProperties");
        return this._refinement((val, ctx) => {
          const result2 = check(val);
          const setError = /* @__PURE__ */ __name(() => ctx.addIssue({
            code: ZodIssueCode.custom,
            ...getIssueProperties(val)
          }), "setError");
          if (typeof Promise !== "undefined" && result2 instanceof Promise) {
            return result2.then((data) => {
              if (!data) {
                setError();
                return false;
              } else {
                return true;
              }
            });
          }
          if (!result2) {
            setError();
            return false;
          } else {
            return true;
          }
        });
      }
      refinement(check, refinementData) {
        return this._refinement((val, ctx) => {
          if (!check(val)) {
            ctx.addIssue(typeof refinementData === "function" ? refinementData(val, ctx) : refinementData);
            return false;
          } else {
            return true;
          }
        });
      }
      _refinement(refinement) {
        return new ZodEffects({
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "refinement", refinement }
        });
      }
      superRefine(refinement) {
        return this._refinement(refinement);
      }
      constructor(def) {
        this.spa = this.safeParseAsync;
        this._def = def;
        this.parse = this.parse.bind(this);
        this.safeParse = this.safeParse.bind(this);
        this.parseAsync = this.parseAsync.bind(this);
        this.safeParseAsync = this.safeParseAsync.bind(this);
        this.spa = this.spa.bind(this);
        this.refine = this.refine.bind(this);
        this.refinement = this.refinement.bind(this);
        this.superRefine = this.superRefine.bind(this);
        this.optional = this.optional.bind(this);
        this.nullable = this.nullable.bind(this);
        this.nullish = this.nullish.bind(this);
        this.array = this.array.bind(this);
        this.promise = this.promise.bind(this);
        this.or = this.or.bind(this);
        this.and = this.and.bind(this);
        this.transform = this.transform.bind(this);
        this.brand = this.brand.bind(this);
        this.default = this.default.bind(this);
        this.catch = this.catch.bind(this);
        this.describe = this.describe.bind(this);
        this.pipe = this.pipe.bind(this);
        this.readonly = this.readonly.bind(this);
        this.isNullable = this.isNullable.bind(this);
        this.isOptional = this.isOptional.bind(this);
        this["~standard"] = {
          version: 1,
          vendor: "zod",
          validate: /* @__PURE__ */ __name((data) => this["~validate"](data), "validate")
        };
      }
      optional() {
        return ZodOptional.create(this, this._def);
      }
      nullable() {
        return ZodNullable.create(this, this._def);
      }
      nullish() {
        return this.nullable().optional();
      }
      array() {
        return ZodArray.create(this);
      }
      promise() {
        return ZodPromise.create(this, this._def);
      }
      or(option) {
        return ZodUnion.create([this, option], this._def);
      }
      and(incoming) {
        return ZodIntersection.create(this, incoming, this._def);
      }
      transform(transform) {
        return new ZodEffects({
          ...processCreateParams(this._def),
          schema: this,
          typeName: ZodFirstPartyTypeKind.ZodEffects,
          effect: { type: "transform", transform }
        });
      }
      default(def) {
        const defaultValueFunc = typeof def === "function" ? def : () => def;
        return new ZodDefault({
          ...processCreateParams(this._def),
          innerType: this,
          defaultValue: defaultValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodDefault
        });
      }
      brand() {
        return new ZodBranded({
          typeName: ZodFirstPartyTypeKind.ZodBranded,
          type: this,
          ...processCreateParams(this._def)
        });
      }
      catch(def) {
        const catchValueFunc = typeof def === "function" ? def : () => def;
        return new ZodCatch({
          ...processCreateParams(this._def),
          innerType: this,
          catchValue: catchValueFunc,
          typeName: ZodFirstPartyTypeKind.ZodCatch
        });
      }
      describe(description) {
        const This = this.constructor;
        return new This({
          ...this._def,
          description
        });
      }
      pipe(target) {
        return ZodPipeline.create(this, target);
      }
      readonly() {
        return ZodReadonly.create(this);
      }
      isOptional() {
        return this.safeParse(void 0).success;
      }
      isNullable() {
        return this.safeParse(null).success;
      }
    };
    cuidRegex = /^c[^\s-]{8,}$/i;
    cuid2Regex = /^[0-9a-z]+$/;
    ulidRegex = /^[0-9A-HJKMNP-TV-Z]{26}$/i;
    uuidRegex = /^[0-9a-fA-F]{8}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{4}\b-[0-9a-fA-F]{12}$/i;
    nanoidRegex = /^[a-z0-9_-]{21}$/i;
    jwtRegex = /^[A-Za-z0-9-_]+\.[A-Za-z0-9-_]+\.[A-Za-z0-9-_]*$/;
    durationRegex = /^[-+]?P(?!$)(?:(?:[-+]?\d+Y)|(?:[-+]?\d+[.,]\d+Y$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:(?:[-+]?\d+W)|(?:[-+]?\d+[.,]\d+W$))?(?:(?:[-+]?\d+D)|(?:[-+]?\d+[.,]\d+D$))?(?:T(?=[\d+-])(?:(?:[-+]?\d+H)|(?:[-+]?\d+[.,]\d+H$))?(?:(?:[-+]?\d+M)|(?:[-+]?\d+[.,]\d+M$))?(?:[-+]?\d+(?:[.,]\d+)?S)?)??$/;
    emailRegex = /^(?!\.)(?!.*\.\.)([A-Z0-9_'+\-\.]*)[A-Z0-9_+-]@([A-Z0-9][A-Z0-9\-]*\.)+[A-Z]{2,}$/i;
    _emojiRegex = `^(\\p{Extended_Pictographic}|\\p{Emoji_Component})+$`;
    ipv4Regex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])$/;
    ipv4CidrRegex = /^(?:(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\.){3}(?:25[0-5]|2[0-4][0-9]|1[0-9][0-9]|[1-9][0-9]|[0-9])\/(3[0-2]|[12]?[0-9])$/;
    ipv6Regex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$/;
    ipv6CidrRegex = /^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))\/(12[0-8]|1[01][0-9]|[1-9]?[0-9])$/;
    base64Regex = /^([0-9a-zA-Z+/]{4})*(([0-9a-zA-Z+/]{2}==)|([0-9a-zA-Z+/]{3}=))?$/;
    base64urlRegex = /^([0-9a-zA-Z-_]{4})*(([0-9a-zA-Z-_]{2}(==)?)|([0-9a-zA-Z-_]{3}(=)?))?$/;
    dateRegexSource = `((\\d\\d[2468][048]|\\d\\d[13579][26]|\\d\\d0[48]|[02468][048]00|[13579][26]00)-02-29|\\d{4}-((0[13578]|1[02])-(0[1-9]|[12]\\d|3[01])|(0[469]|11)-(0[1-9]|[12]\\d|30)|(02)-(0[1-9]|1\\d|2[0-8])))`;
    dateRegex = new RegExp(`^${dateRegexSource}$`);
    __name(timeRegexSource, "timeRegexSource");
    __name(timeRegex, "timeRegex");
    __name(datetimeRegex, "datetimeRegex");
    __name(isValidIP, "isValidIP");
    __name(isValidJWT, "isValidJWT");
    __name(isValidCidr, "isValidCidr");
    ZodString = class _ZodString extends ZodType {
      static {
        __name(this, "ZodString");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = String(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.string) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.string,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.length < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.length > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "string",
                inclusive: true,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "length") {
            const tooBig = input.data.length > check.value;
            const tooSmall = input.data.length < check.value;
            if (tooBig || tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              if (tooBig) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_big,
                  maximum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              } else if (tooSmall) {
                addIssueToContext(ctx, {
                  code: ZodIssueCode.too_small,
                  minimum: check.value,
                  type: "string",
                  inclusive: true,
                  exact: true,
                  message: check.message
                });
              }
              status.dirty();
            }
          } else if (check.kind === "email") {
            if (!emailRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "email",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "emoji") {
            if (!emojiRegex) {
              emojiRegex = new RegExp(_emojiRegex, "u");
            }
            if (!emojiRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "emoji",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "uuid") {
            if (!uuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "uuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "nanoid") {
            if (!nanoidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "nanoid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid") {
            if (!cuidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cuid2") {
            if (!cuid2Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cuid2",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ulid") {
            if (!ulidRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ulid",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "url") {
            try {
              new URL(input.data);
            } catch (_a2) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "regex") {
            check.regex.lastIndex = 0;
            const testResult = check.regex.test(input.data);
            if (!testResult) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "regex",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "trim") {
            input.data = input.data.trim();
          } else if (check.kind === "includes") {
            if (!input.data.includes(check.value, check.position)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { includes: check.value, position: check.position },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "toLowerCase") {
            input.data = input.data.toLowerCase();
          } else if (check.kind === "toUpperCase") {
            input.data = input.data.toUpperCase();
          } else if (check.kind === "startsWith") {
            if (!input.data.startsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { startsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "endsWith") {
            if (!input.data.endsWith(check.value)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: { endsWith: check.value },
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "datetime") {
            const regex = datetimeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "datetime",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "date") {
            const regex = dateRegex;
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "date",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "time") {
            const regex = timeRegex(check);
            if (!regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_string,
                validation: "time",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "duration") {
            if (!durationRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "duration",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "ip") {
            if (!isValidIP(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "ip",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "jwt") {
            if (!isValidJWT(input.data, check.alg)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "jwt",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "cidr") {
            if (!isValidCidr(input.data, check.version)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "cidr",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64") {
            if (!base64Regex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "base64url") {
            if (!base64urlRegex.test(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                validation: "base64url",
                code: ZodIssueCode.invalid_string,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _regex(regex, validation2, message) {
        return this.refinement((data) => regex.test(data), {
          validation: validation2,
          code: ZodIssueCode.invalid_string,
          ...errorUtil.errToObj(message)
        });
      }
      _addCheck(check) {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      email(message) {
        return this._addCheck({ kind: "email", ...errorUtil.errToObj(message) });
      }
      url(message) {
        return this._addCheck({ kind: "url", ...errorUtil.errToObj(message) });
      }
      emoji(message) {
        return this._addCheck({ kind: "emoji", ...errorUtil.errToObj(message) });
      }
      uuid(message) {
        return this._addCheck({ kind: "uuid", ...errorUtil.errToObj(message) });
      }
      nanoid(message) {
        return this._addCheck({ kind: "nanoid", ...errorUtil.errToObj(message) });
      }
      cuid(message) {
        return this._addCheck({ kind: "cuid", ...errorUtil.errToObj(message) });
      }
      cuid2(message) {
        return this._addCheck({ kind: "cuid2", ...errorUtil.errToObj(message) });
      }
      ulid(message) {
        return this._addCheck({ kind: "ulid", ...errorUtil.errToObj(message) });
      }
      base64(message) {
        return this._addCheck({ kind: "base64", ...errorUtil.errToObj(message) });
      }
      base64url(message) {
        return this._addCheck({
          kind: "base64url",
          ...errorUtil.errToObj(message)
        });
      }
      jwt(options) {
        return this._addCheck({ kind: "jwt", ...errorUtil.errToObj(options) });
      }
      ip(options) {
        return this._addCheck({ kind: "ip", ...errorUtil.errToObj(options) });
      }
      cidr(options) {
        return this._addCheck({ kind: "cidr", ...errorUtil.errToObj(options) });
      }
      datetime(options) {
        var _a2, _b2;
        if (typeof options === "string") {
          return this._addCheck({
            kind: "datetime",
            precision: null,
            offset: false,
            local: false,
            message: options
          });
        }
        return this._addCheck({
          kind: "datetime",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          offset: (_a2 = options === null || options === void 0 ? void 0 : options.offset) !== null && _a2 !== void 0 ? _a2 : false,
          local: (_b2 = options === null || options === void 0 ? void 0 : options.local) !== null && _b2 !== void 0 ? _b2 : false,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      date(message) {
        return this._addCheck({ kind: "date", message });
      }
      time(options) {
        if (typeof options === "string") {
          return this._addCheck({
            kind: "time",
            precision: null,
            message: options
          });
        }
        return this._addCheck({
          kind: "time",
          precision: typeof (options === null || options === void 0 ? void 0 : options.precision) === "undefined" ? null : options === null || options === void 0 ? void 0 : options.precision,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      duration(message) {
        return this._addCheck({ kind: "duration", ...errorUtil.errToObj(message) });
      }
      regex(regex, message) {
        return this._addCheck({
          kind: "regex",
          regex,
          ...errorUtil.errToObj(message)
        });
      }
      includes(value2, options) {
        return this._addCheck({
          kind: "includes",
          value: value2,
          position: options === null || options === void 0 ? void 0 : options.position,
          ...errorUtil.errToObj(options === null || options === void 0 ? void 0 : options.message)
        });
      }
      startsWith(value2, message) {
        return this._addCheck({
          kind: "startsWith",
          value: value2,
          ...errorUtil.errToObj(message)
        });
      }
      endsWith(value2, message) {
        return this._addCheck({
          kind: "endsWith",
          value: value2,
          ...errorUtil.errToObj(message)
        });
      }
      min(minLength, message) {
        return this._addCheck({
          kind: "min",
          value: minLength,
          ...errorUtil.errToObj(message)
        });
      }
      max(maxLength, message) {
        return this._addCheck({
          kind: "max",
          value: maxLength,
          ...errorUtil.errToObj(message)
        });
      }
      length(len, message) {
        return this._addCheck({
          kind: "length",
          value: len,
          ...errorUtil.errToObj(message)
        });
      }
      /**
       * Equivalent to `.min(1)`
       */
      nonempty(message) {
        return this.min(1, errorUtil.errToObj(message));
      }
      trim() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "trim" }]
        });
      }
      toLowerCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toLowerCase" }]
        });
      }
      toUpperCase() {
        return new _ZodString({
          ...this._def,
          checks: [...this._def.checks, { kind: "toUpperCase" }]
        });
      }
      get isDatetime() {
        return !!this._def.checks.find((ch) => ch.kind === "datetime");
      }
      get isDate() {
        return !!this._def.checks.find((ch) => ch.kind === "date");
      }
      get isTime() {
        return !!this._def.checks.find((ch) => ch.kind === "time");
      }
      get isDuration() {
        return !!this._def.checks.find((ch) => ch.kind === "duration");
      }
      get isEmail() {
        return !!this._def.checks.find((ch) => ch.kind === "email");
      }
      get isURL() {
        return !!this._def.checks.find((ch) => ch.kind === "url");
      }
      get isEmoji() {
        return !!this._def.checks.find((ch) => ch.kind === "emoji");
      }
      get isUUID() {
        return !!this._def.checks.find((ch) => ch.kind === "uuid");
      }
      get isNANOID() {
        return !!this._def.checks.find((ch) => ch.kind === "nanoid");
      }
      get isCUID() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid");
      }
      get isCUID2() {
        return !!this._def.checks.find((ch) => ch.kind === "cuid2");
      }
      get isULID() {
        return !!this._def.checks.find((ch) => ch.kind === "ulid");
      }
      get isIP() {
        return !!this._def.checks.find((ch) => ch.kind === "ip");
      }
      get isCIDR() {
        return !!this._def.checks.find((ch) => ch.kind === "cidr");
      }
      get isBase64() {
        return !!this._def.checks.find((ch) => ch.kind === "base64");
      }
      get isBase64url() {
        return !!this._def.checks.find((ch) => ch.kind === "base64url");
      }
      get minLength() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxLength() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodString.create = (params2) => {
      var _a2;
      return new ZodString({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodString,
        coerce: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a2 !== void 0 ? _a2 : false,
        ...processCreateParams(params2)
      });
    };
    __name(floatSafeRemainder, "floatSafeRemainder");
    ZodNumber = class _ZodNumber extends ZodType {
      static {
        __name(this, "ZodNumber");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
        this.step = this.multipleOf;
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Number(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.number) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.number,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "int") {
            if (!util.isInteger(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.invalid_type,
                expected: "integer",
                received: "float",
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                minimum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                maximum: check.value,
                type: "number",
                inclusive: check.inclusive,
                exact: false,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (floatSafeRemainder(input.data, check.value) !== 0) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "finite") {
            if (!Number.isFinite(input.data)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_finite,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      gte(value2, message) {
        return this.setLimit("min", value2, true, errorUtil.toString(message));
      }
      gt(value2, message) {
        return this.setLimit("min", value2, false, errorUtil.toString(message));
      }
      lte(value2, message) {
        return this.setLimit("max", value2, true, errorUtil.toString(message));
      }
      lt(value2, message) {
        return this.setLimit("max", value2, false, errorUtil.toString(message));
      }
      setLimit(kind, value2, inclusive, message) {
        return new _ZodNumber({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value: value2,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodNumber({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      int(message) {
        return this._addCheck({
          kind: "int",
          message: errorUtil.toString(message)
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: 0,
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value2, message) {
        return this._addCheck({
          kind: "multipleOf",
          value: value2,
          message: errorUtil.toString(message)
        });
      }
      finite(message) {
        return this._addCheck({
          kind: "finite",
          message: errorUtil.toString(message)
        });
      }
      safe(message) {
        return this._addCheck({
          kind: "min",
          inclusive: true,
          value: Number.MIN_SAFE_INTEGER,
          message: errorUtil.toString(message)
        })._addCheck({
          kind: "max",
          inclusive: true,
          value: Number.MAX_SAFE_INTEGER,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
      get isInt() {
        return !!this._def.checks.find((ch) => ch.kind === "int" || ch.kind === "multipleOf" && util.isInteger(ch.value));
      }
      get isFinite() {
        let max = null, min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "finite" || ch.kind === "int" || ch.kind === "multipleOf") {
            return true;
          } else if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          } else if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return Number.isFinite(min) && Number.isFinite(max);
      }
    };
    ZodNumber.create = (params2) => {
      return new ZodNumber({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodNumber,
        coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
        ...processCreateParams(params2)
      });
    };
    ZodBigInt = class _ZodBigInt extends ZodType {
      static {
        __name(this, "ZodBigInt");
      }
      constructor() {
        super(...arguments);
        this.min = this.gte;
        this.max = this.lte;
      }
      _parse(input) {
        if (this._def.coerce) {
          try {
            input.data = BigInt(input.data);
          } catch (_a2) {
            return this._getInvalidInput(input);
          }
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.bigint) {
          return this._getInvalidInput(input);
        }
        let ctx = void 0;
        const status = new ParseStatus();
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            const tooSmall = check.inclusive ? input.data < check.value : input.data <= check.value;
            if (tooSmall) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                type: "bigint",
                minimum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            const tooBig = check.inclusive ? input.data > check.value : input.data >= check.value;
            if (tooBig) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                type: "bigint",
                maximum: check.value,
                inclusive: check.inclusive,
                message: check.message
              });
              status.dirty();
            }
          } else if (check.kind === "multipleOf") {
            if (input.data % check.value !== BigInt(0)) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.not_multiple_of,
                multipleOf: check.value,
                message: check.message
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return { status: status.value, value: input.data };
      }
      _getInvalidInput(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.bigint,
          received: ctx.parsedType
        });
        return INVALID;
      }
      gte(value2, message) {
        return this.setLimit("min", value2, true, errorUtil.toString(message));
      }
      gt(value2, message) {
        return this.setLimit("min", value2, false, errorUtil.toString(message));
      }
      lte(value2, message) {
        return this.setLimit("max", value2, true, errorUtil.toString(message));
      }
      lt(value2, message) {
        return this.setLimit("max", value2, false, errorUtil.toString(message));
      }
      setLimit(kind, value2, inclusive, message) {
        return new _ZodBigInt({
          ...this._def,
          checks: [
            ...this._def.checks,
            {
              kind,
              value: value2,
              inclusive,
              message: errorUtil.toString(message)
            }
          ]
        });
      }
      _addCheck(check) {
        return new _ZodBigInt({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      positive(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      negative(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: false,
          message: errorUtil.toString(message)
        });
      }
      nonpositive(message) {
        return this._addCheck({
          kind: "max",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      nonnegative(message) {
        return this._addCheck({
          kind: "min",
          value: BigInt(0),
          inclusive: true,
          message: errorUtil.toString(message)
        });
      }
      multipleOf(value2, message) {
        return this._addCheck({
          kind: "multipleOf",
          value: value2,
          message: errorUtil.toString(message)
        });
      }
      get minValue() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min;
      }
      get maxValue() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max;
      }
    };
    ZodBigInt.create = (params2) => {
      var _a2;
      return new ZodBigInt({
        checks: [],
        typeName: ZodFirstPartyTypeKind.ZodBigInt,
        coerce: (_a2 = params2 === null || params2 === void 0 ? void 0 : params2.coerce) !== null && _a2 !== void 0 ? _a2 : false,
        ...processCreateParams(params2)
      });
    };
    ZodBoolean = class extends ZodType {
      static {
        __name(this, "ZodBoolean");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = Boolean(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.boolean) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.boolean,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodBoolean.create = (params2) => {
      return new ZodBoolean({
        typeName: ZodFirstPartyTypeKind.ZodBoolean,
        coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
        ...processCreateParams(params2)
      });
    };
    ZodDate = class _ZodDate extends ZodType {
      static {
        __name(this, "ZodDate");
      }
      _parse(input) {
        if (this._def.coerce) {
          input.data = new Date(input.data);
        }
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.date) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.date,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        if (isNaN(input.data.getTime())) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_date
          });
          return INVALID;
        }
        const status = new ParseStatus();
        let ctx = void 0;
        for (const check of this._def.checks) {
          if (check.kind === "min") {
            if (input.data.getTime() < check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_small,
                message: check.message,
                inclusive: true,
                exact: false,
                minimum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else if (check.kind === "max") {
            if (input.data.getTime() > check.value) {
              ctx = this._getOrReturnCtx(input, ctx);
              addIssueToContext(ctx, {
                code: ZodIssueCode.too_big,
                message: check.message,
                inclusive: true,
                exact: false,
                maximum: check.value,
                type: "date"
              });
              status.dirty();
            }
          } else {
            util.assertNever(check);
          }
        }
        return {
          status: status.value,
          value: new Date(input.data.getTime())
        };
      }
      _addCheck(check) {
        return new _ZodDate({
          ...this._def,
          checks: [...this._def.checks, check]
        });
      }
      min(minDate, message) {
        return this._addCheck({
          kind: "min",
          value: minDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      max(maxDate, message) {
        return this._addCheck({
          kind: "max",
          value: maxDate.getTime(),
          message: errorUtil.toString(message)
        });
      }
      get minDate() {
        let min = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "min") {
            if (min === null || ch.value > min)
              min = ch.value;
          }
        }
        return min != null ? new Date(min) : null;
      }
      get maxDate() {
        let max = null;
        for (const ch of this._def.checks) {
          if (ch.kind === "max") {
            if (max === null || ch.value < max)
              max = ch.value;
          }
        }
        return max != null ? new Date(max) : null;
      }
    };
    ZodDate.create = (params2) => {
      return new ZodDate({
        checks: [],
        coerce: (params2 === null || params2 === void 0 ? void 0 : params2.coerce) || false,
        typeName: ZodFirstPartyTypeKind.ZodDate,
        ...processCreateParams(params2)
      });
    };
    ZodSymbol = class extends ZodType {
      static {
        __name(this, "ZodSymbol");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.symbol) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.symbol,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodSymbol.create = (params2) => {
      return new ZodSymbol({
        typeName: ZodFirstPartyTypeKind.ZodSymbol,
        ...processCreateParams(params2)
      });
    };
    ZodUndefined = class extends ZodType {
      static {
        __name(this, "ZodUndefined");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.undefined,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodUndefined.create = (params2) => {
      return new ZodUndefined({
        typeName: ZodFirstPartyTypeKind.ZodUndefined,
        ...processCreateParams(params2)
      });
    };
    ZodNull = class extends ZodType {
      static {
        __name(this, "ZodNull");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.null) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.null,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodNull.create = (params2) => {
      return new ZodNull({
        typeName: ZodFirstPartyTypeKind.ZodNull,
        ...processCreateParams(params2)
      });
    };
    ZodAny = class extends ZodType {
      static {
        __name(this, "ZodAny");
      }
      constructor() {
        super(...arguments);
        this._any = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodAny.create = (params2) => {
      return new ZodAny({
        typeName: ZodFirstPartyTypeKind.ZodAny,
        ...processCreateParams(params2)
      });
    };
    ZodUnknown = class extends ZodType {
      static {
        __name(this, "ZodUnknown");
      }
      constructor() {
        super(...arguments);
        this._unknown = true;
      }
      _parse(input) {
        return OK(input.data);
      }
    };
    ZodUnknown.create = (params2) => {
      return new ZodUnknown({
        typeName: ZodFirstPartyTypeKind.ZodUnknown,
        ...processCreateParams(params2)
      });
    };
    ZodNever = class extends ZodType {
      static {
        __name(this, "ZodNever");
      }
      _parse(input) {
        const ctx = this._getOrReturnCtx(input);
        addIssueToContext(ctx, {
          code: ZodIssueCode.invalid_type,
          expected: ZodParsedType.never,
          received: ctx.parsedType
        });
        return INVALID;
      }
    };
    ZodNever.create = (params2) => {
      return new ZodNever({
        typeName: ZodFirstPartyTypeKind.ZodNever,
        ...processCreateParams(params2)
      });
    };
    ZodVoid = class extends ZodType {
      static {
        __name(this, "ZodVoid");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.undefined) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.void,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return OK(input.data);
      }
    };
    ZodVoid.create = (params2) => {
      return new ZodVoid({
        typeName: ZodFirstPartyTypeKind.ZodVoid,
        ...processCreateParams(params2)
      });
    };
    ZodArray = class _ZodArray extends ZodType {
      static {
        __name(this, "ZodArray");
      }
      _parse(input) {
        const { ctx, status } = this._processInputParams(input);
        const def = this._def;
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (def.exactLength !== null) {
          const tooBig = ctx.data.length > def.exactLength.value;
          const tooSmall = ctx.data.length < def.exactLength.value;
          if (tooBig || tooSmall) {
            addIssueToContext(ctx, {
              code: tooBig ? ZodIssueCode.too_big : ZodIssueCode.too_small,
              minimum: tooSmall ? def.exactLength.value : void 0,
              maximum: tooBig ? def.exactLength.value : void 0,
              type: "array",
              inclusive: true,
              exact: true,
              message: def.exactLength.message
            });
            status.dirty();
          }
        }
        if (def.minLength !== null) {
          if (ctx.data.length < def.minLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.minLength.message
            });
            status.dirty();
          }
        }
        if (def.maxLength !== null) {
          if (ctx.data.length > def.maxLength.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxLength.value,
              type: "array",
              inclusive: true,
              exact: false,
              message: def.maxLength.message
            });
            status.dirty();
          }
        }
        if (ctx.common.async) {
          return Promise.all([...ctx.data].map((item, i) => {
            return def.type._parseAsync(new ParseInputLazyPath(ctx, item, ctx.path, i));
          })).then((result3) => {
            return ParseStatus.mergeArray(status, result3);
          });
        }
        const result2 = [...ctx.data].map((item, i) => {
          return def.type._parseSync(new ParseInputLazyPath(ctx, item, ctx.path, i));
        });
        return ParseStatus.mergeArray(status, result2);
      }
      get element() {
        return this._def.type;
      }
      min(minLength, message) {
        return new _ZodArray({
          ...this._def,
          minLength: { value: minLength, message: errorUtil.toString(message) }
        });
      }
      max(maxLength, message) {
        return new _ZodArray({
          ...this._def,
          maxLength: { value: maxLength, message: errorUtil.toString(message) }
        });
      }
      length(len, message) {
        return new _ZodArray({
          ...this._def,
          exactLength: { value: len, message: errorUtil.toString(message) }
        });
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodArray.create = (schema, params2) => {
      return new ZodArray({
        type: schema,
        minLength: null,
        maxLength: null,
        exactLength: null,
        typeName: ZodFirstPartyTypeKind.ZodArray,
        ...processCreateParams(params2)
      });
    };
    __name(deepPartialify, "deepPartialify");
    ZodObject = class _ZodObject extends ZodType {
      static {
        __name(this, "ZodObject");
      }
      constructor() {
        super(...arguments);
        this._cached = null;
        this.nonstrict = this.passthrough;
        this.augment = this.extend;
      }
      _getCached() {
        if (this._cached !== null)
          return this._cached;
        const shape = this._def.shape();
        const keys = util.objectKeys(shape);
        return this._cached = { shape, keys };
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.object) {
          const ctx2 = this._getOrReturnCtx(input);
          addIssueToContext(ctx2, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx2.parsedType
          });
          return INVALID;
        }
        const { status, ctx } = this._processInputParams(input);
        const { shape, keys: shapeKeys } = this._getCached();
        const extraKeys = [];
        if (!(this._def.catchall instanceof ZodNever && this._def.unknownKeys === "strip")) {
          for (const key in ctx.data) {
            if (!shapeKeys.includes(key)) {
              extraKeys.push(key);
            }
          }
        }
        const pairs = [];
        for (const key of shapeKeys) {
          const keyValidator = shape[key];
          const value2 = ctx.data[key];
          pairs.push({
            key: { status: "valid", value: key },
            value: keyValidator._parse(new ParseInputLazyPath(ctx, value2, ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (this._def.catchall instanceof ZodNever) {
          const unknownKeys = this._def.unknownKeys;
          if (unknownKeys === "passthrough") {
            for (const key of extraKeys) {
              pairs.push({
                key: { status: "valid", value: key },
                value: { status: "valid", value: ctx.data[key] }
              });
            }
          } else if (unknownKeys === "strict") {
            if (extraKeys.length > 0) {
              addIssueToContext(ctx, {
                code: ZodIssueCode.unrecognized_keys,
                keys: extraKeys
              });
              status.dirty();
            }
          } else if (unknownKeys === "strip") ;
          else {
            throw new Error(`Internal ZodObject error: invalid unknownKeys value.`);
          }
        } else {
          const catchall = this._def.catchall;
          for (const key of extraKeys) {
            const value2 = ctx.data[key];
            pairs.push({
              key: { status: "valid", value: key },
              value: catchall._parse(
                new ParseInputLazyPath(ctx, value2, ctx.path, key)
                //, ctx.child(key), value, getParsedType(value)
              ),
              alwaysSet: key in ctx.data
            });
          }
        }
        if (ctx.common.async) {
          return Promise.resolve().then(async () => {
            const syncPairs = [];
            for (const pair of pairs) {
              const key = await pair.key;
              const value2 = await pair.value;
              syncPairs.push({
                key,
                value: value2,
                alwaysSet: pair.alwaysSet
              });
            }
            return syncPairs;
          }).then((syncPairs) => {
            return ParseStatus.mergeObjectSync(status, syncPairs);
          });
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get shape() {
        return this._def.shape();
      }
      strict(message) {
        errorUtil.errToObj;
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strict",
          ...message !== void 0 ? {
            errorMap: /* @__PURE__ */ __name((issue, ctx) => {
              var _a2, _b2, _c2, _d;
              const defaultError = (_c2 = (_b2 = (_a2 = this._def).errorMap) === null || _b2 === void 0 ? void 0 : _b2.call(_a2, issue, ctx).message) !== null && _c2 !== void 0 ? _c2 : ctx.defaultError;
              if (issue.code === "unrecognized_keys")
                return {
                  message: (_d = errorUtil.errToObj(message).message) !== null && _d !== void 0 ? _d : defaultError
                };
              return {
                message: defaultError
              };
            }, "errorMap")
          } : {}
        });
      }
      strip() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "strip"
        });
      }
      passthrough() {
        return new _ZodObject({
          ...this._def,
          unknownKeys: "passthrough"
        });
      }
      // const AugmentFactory =
      //   <Def extends ZodObjectDef>(def: Def) =>
      //   <Augmentation extends ZodRawShape>(
      //     augmentation: Augmentation
      //   ): ZodObject<
      //     extendShape<ReturnType<Def["shape"]>, Augmentation>,
      //     Def["unknownKeys"],
      //     Def["catchall"]
      //   > => {
      //     return new ZodObject({
      //       ...def,
      //       shape: () => ({
      //         ...def.shape(),
      //         ...augmentation,
      //       }),
      //     }) as any;
      //   };
      extend(augmentation) {
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...augmentation
          }), "shape")
        });
      }
      /**
       * Prior to zod@1.0.12 there was a bug in the
       * inferred type of merged objects. Please
       * upgrade if you are experiencing issues.
       */
      merge(merging) {
        const merged = new _ZodObject({
          unknownKeys: merging._def.unknownKeys,
          catchall: merging._def.catchall,
          shape: /* @__PURE__ */ __name(() => ({
            ...this._def.shape(),
            ...merging._def.shape()
          }), "shape"),
          typeName: ZodFirstPartyTypeKind.ZodObject
        });
        return merged;
      }
      // merge<
      //   Incoming extends AnyZodObject,
      //   Augmentation extends Incoming["shape"],
      //   NewOutput extends {
      //     [k in keyof Augmentation | keyof Output]: k extends keyof Augmentation
      //       ? Augmentation[k]["_output"]
      //       : k extends keyof Output
      //       ? Output[k]
      //       : never;
      //   },
      //   NewInput extends {
      //     [k in keyof Augmentation | keyof Input]: k extends keyof Augmentation
      //       ? Augmentation[k]["_input"]
      //       : k extends keyof Input
      //       ? Input[k]
      //       : never;
      //   }
      // >(
      //   merging: Incoming
      // ): ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"],
      //   NewOutput,
      //   NewInput
      // > {
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      setKey(key, schema) {
        return this.augment({ [key]: schema });
      }
      // merge<Incoming extends AnyZodObject>(
      //   merging: Incoming
      // ): //ZodObject<T & Incoming["_shape"], UnknownKeys, Catchall> = (merging) => {
      // ZodObject<
      //   extendShape<T, ReturnType<Incoming["_def"]["shape"]>>,
      //   Incoming["_def"]["unknownKeys"],
      //   Incoming["_def"]["catchall"]
      // > {
      //   // const mergedShape = objectUtil.mergeShapes(
      //   //   this._def.shape(),
      //   //   merging._def.shape()
      //   // );
      //   const merged: any = new ZodObject({
      //     unknownKeys: merging._def.unknownKeys,
      //     catchall: merging._def.catchall,
      //     shape: () =>
      //       objectUtil.mergeShapes(this._def.shape(), merging._def.shape()),
      //     typeName: ZodFirstPartyTypeKind.ZodObject,
      //   }) as any;
      //   return merged;
      // }
      catchall(index) {
        return new _ZodObject({
          ...this._def,
          catchall: index
        });
      }
      pick(mask) {
        const shape = {};
        util.objectKeys(mask).forEach((key) => {
          if (mask[key] && this.shape[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      omit(mask) {
        const shape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (!mask[key]) {
            shape[key] = this.shape[key];
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => shape, "shape")
        });
      }
      /**
       * @deprecated
       */
      deepPartial() {
        return deepPartialify(this);
      }
      partial(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          const fieldSchema = this.shape[key];
          if (mask && !mask[key]) {
            newShape[key] = fieldSchema;
          } else {
            newShape[key] = fieldSchema.optional();
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      required(mask) {
        const newShape = {};
        util.objectKeys(this.shape).forEach((key) => {
          if (mask && !mask[key]) {
            newShape[key] = this.shape[key];
          } else {
            const fieldSchema = this.shape[key];
            let newField = fieldSchema;
            while (newField instanceof ZodOptional) {
              newField = newField._def.innerType;
            }
            newShape[key] = newField;
          }
        });
        return new _ZodObject({
          ...this._def,
          shape: /* @__PURE__ */ __name(() => newShape, "shape")
        });
      }
      keyof() {
        return createZodEnum(util.objectKeys(this.shape));
      }
    };
    ZodObject.create = (shape, params2) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.strictCreate = (shape, params2) => {
      return new ZodObject({
        shape: /* @__PURE__ */ __name(() => shape, "shape"),
        unknownKeys: "strict",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodObject.lazycreate = (shape, params2) => {
      return new ZodObject({
        shape,
        unknownKeys: "strip",
        catchall: ZodNever.create(),
        typeName: ZodFirstPartyTypeKind.ZodObject,
        ...processCreateParams(params2)
      });
    };
    ZodUnion = class extends ZodType {
      static {
        __name(this, "ZodUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const options = this._def.options;
        function handleResults(results) {
          for (const result2 of results) {
            if (result2.result.status === "valid") {
              return result2.result;
            }
          }
          for (const result2 of results) {
            if (result2.result.status === "dirty") {
              ctx.common.issues.push(...result2.ctx.common.issues);
              return result2.result;
            }
          }
          const unionErrors = results.map((result2) => new ZodError(result2.ctx.common.issues));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
        __name(handleResults, "handleResults");
        if (ctx.common.async) {
          return Promise.all(options.map(async (option) => {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            return {
              result: await option._parseAsync({
                data: ctx.data,
                path: ctx.path,
                parent: childCtx
              }),
              ctx: childCtx
            };
          })).then(handleResults);
        } else {
          let dirty = void 0;
          const issues = [];
          for (const option of options) {
            const childCtx = {
              ...ctx,
              common: {
                ...ctx.common,
                issues: []
              },
              parent: null
            };
            const result2 = option._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: childCtx
            });
            if (result2.status === "valid") {
              return result2;
            } else if (result2.status === "dirty" && !dirty) {
              dirty = { result: result2, ctx: childCtx };
            }
            if (childCtx.common.issues.length) {
              issues.push(childCtx.common.issues);
            }
          }
          if (dirty) {
            ctx.common.issues.push(...dirty.ctx.common.issues);
            return dirty.result;
          }
          const unionErrors = issues.map((issues2) => new ZodError(issues2));
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union,
            unionErrors
          });
          return INVALID;
        }
      }
      get options() {
        return this._def.options;
      }
    };
    ZodUnion.create = (types, params2) => {
      return new ZodUnion({
        options: types,
        typeName: ZodFirstPartyTypeKind.ZodUnion,
        ...processCreateParams(params2)
      });
    };
    getDiscriminator = /* @__PURE__ */ __name((type) => {
      if (type instanceof ZodLazy) {
        return getDiscriminator(type.schema);
      } else if (type instanceof ZodEffects) {
        return getDiscriminator(type.innerType());
      } else if (type instanceof ZodLiteral) {
        return [type.value];
      } else if (type instanceof ZodEnum) {
        return type.options;
      } else if (type instanceof ZodNativeEnum) {
        return util.objectValues(type.enum);
      } else if (type instanceof ZodDefault) {
        return getDiscriminator(type._def.innerType);
      } else if (type instanceof ZodUndefined) {
        return [void 0];
      } else if (type instanceof ZodNull) {
        return [null];
      } else if (type instanceof ZodOptional) {
        return [void 0, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodNullable) {
        return [null, ...getDiscriminator(type.unwrap())];
      } else if (type instanceof ZodBranded) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodReadonly) {
        return getDiscriminator(type.unwrap());
      } else if (type instanceof ZodCatch) {
        return getDiscriminator(type._def.innerType);
      } else {
        return [];
      }
    }, "getDiscriminator");
    ZodDiscriminatedUnion = class _ZodDiscriminatedUnion extends ZodType {
      static {
        __name(this, "ZodDiscriminatedUnion");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const discriminator = this.discriminator;
        const discriminatorValue = ctx.data[discriminator];
        const option = this.optionsMap.get(discriminatorValue);
        if (!option) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_union_discriminator,
            options: Array.from(this.optionsMap.keys()),
            path: [discriminator]
          });
          return INVALID;
        }
        if (ctx.common.async) {
          return option._parseAsync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        } else {
          return option._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
        }
      }
      get discriminator() {
        return this._def.discriminator;
      }
      get options() {
        return this._def.options;
      }
      get optionsMap() {
        return this._def.optionsMap;
      }
      /**
       * The constructor of the discriminated union schema. Its behaviour is very similar to that of the normal z.union() constructor.
       * However, it only allows a union of objects, all of which need to share a discriminator property. This property must
       * have a different value for each object in the union.
       * @param discriminator the name of the discriminator property
       * @param types an array of object schemas
       * @param params
       */
      static create(discriminator, options, params2) {
        const optionsMap = /* @__PURE__ */ new Map();
        for (const type of options) {
          const discriminatorValues = getDiscriminator(type.shape[discriminator]);
          if (!discriminatorValues.length) {
            throw new Error(`A discriminator value for key \`${discriminator}\` could not be extracted from all schema options`);
          }
          for (const value2 of discriminatorValues) {
            if (optionsMap.has(value2)) {
              throw new Error(`Discriminator property ${String(discriminator)} has duplicate value ${String(value2)}`);
            }
            optionsMap.set(value2, type);
          }
        }
        return new _ZodDiscriminatedUnion({
          typeName: ZodFirstPartyTypeKind.ZodDiscriminatedUnion,
          discriminator,
          options,
          optionsMap,
          ...processCreateParams(params2)
        });
      }
    };
    __name(mergeValues, "mergeValues");
    ZodIntersection = class extends ZodType {
      static {
        __name(this, "ZodIntersection");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const handleParsed = /* @__PURE__ */ __name((parsedLeft, parsedRight) => {
          if (isAborted(parsedLeft) || isAborted(parsedRight)) {
            return INVALID;
          }
          const merged = mergeValues(parsedLeft.value, parsedRight.value);
          if (!merged.valid) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.invalid_intersection_types
            });
            return INVALID;
          }
          if (isDirty(parsedLeft) || isDirty(parsedRight)) {
            status.dirty();
          }
          return { status: status.value, value: merged.data };
        }, "handleParsed");
        if (ctx.common.async) {
          return Promise.all([
            this._def.left._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            }),
            this._def.right._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            })
          ]).then(([left2, right2]) => handleParsed(left2, right2));
        } else {
          return handleParsed(this._def.left._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }), this._def.right._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          }));
        }
      }
    };
    ZodIntersection.create = (left2, right2, params2) => {
      return new ZodIntersection({
        left: left2,
        right: right2,
        typeName: ZodFirstPartyTypeKind.ZodIntersection,
        ...processCreateParams(params2)
      });
    };
    ZodTuple = class _ZodTuple extends ZodType {
      static {
        __name(this, "ZodTuple");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.array) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.array,
            received: ctx.parsedType
          });
          return INVALID;
        }
        if (ctx.data.length < this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_small,
            minimum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          return INVALID;
        }
        const rest = this._def.rest;
        if (!rest && ctx.data.length > this._def.items.length) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.too_big,
            maximum: this._def.items.length,
            inclusive: true,
            exact: false,
            type: "array"
          });
          status.dirty();
        }
        const items = [...ctx.data].map((item, itemIndex) => {
          const schema = this._def.items[itemIndex] || this._def.rest;
          if (!schema)
            return null;
          return schema._parse(new ParseInputLazyPath(ctx, item, ctx.path, itemIndex));
        }).filter((x) => !!x);
        if (ctx.common.async) {
          return Promise.all(items).then((results) => {
            return ParseStatus.mergeArray(status, results);
          });
        } else {
          return ParseStatus.mergeArray(status, items);
        }
      }
      get items() {
        return this._def.items;
      }
      rest(rest) {
        return new _ZodTuple({
          ...this._def,
          rest
        });
      }
    };
    ZodTuple.create = (schemas, params2) => {
      if (!Array.isArray(schemas)) {
        throw new Error("You must pass an array of schemas to z.tuple([ ... ])");
      }
      return new ZodTuple({
        items: schemas,
        typeName: ZodFirstPartyTypeKind.ZodTuple,
        rest: null,
        ...processCreateParams(params2)
      });
    };
    ZodRecord = class _ZodRecord extends ZodType {
      static {
        __name(this, "ZodRecord");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.object) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.object,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const pairs = [];
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        for (const key in ctx.data) {
          pairs.push({
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, key)),
            value: valueType._parse(new ParseInputLazyPath(ctx, ctx.data[key], ctx.path, key)),
            alwaysSet: key in ctx.data
          });
        }
        if (ctx.common.async) {
          return ParseStatus.mergeObjectAsync(status, pairs);
        } else {
          return ParseStatus.mergeObjectSync(status, pairs);
        }
      }
      get element() {
        return this._def.valueType;
      }
      static create(first, second, third) {
        if (second instanceof ZodType) {
          return new _ZodRecord({
            keyType: first,
            valueType: second,
            typeName: ZodFirstPartyTypeKind.ZodRecord,
            ...processCreateParams(third)
          });
        }
        return new _ZodRecord({
          keyType: ZodString.create(),
          valueType: first,
          typeName: ZodFirstPartyTypeKind.ZodRecord,
          ...processCreateParams(second)
        });
      }
    };
    ZodMap = class extends ZodType {
      static {
        __name(this, "ZodMap");
      }
      get keySchema() {
        return this._def.keyType;
      }
      get valueSchema() {
        return this._def.valueType;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.map) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.map,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const keyType = this._def.keyType;
        const valueType = this._def.valueType;
        const pairs = [...ctx.data.entries()].map(([key, value2], index) => {
          return {
            key: keyType._parse(new ParseInputLazyPath(ctx, key, ctx.path, [index, "key"])),
            value: valueType._parse(new ParseInputLazyPath(ctx, value2, ctx.path, [index, "value"]))
          };
        });
        if (ctx.common.async) {
          const finalMap = /* @__PURE__ */ new Map();
          return Promise.resolve().then(async () => {
            for (const pair of pairs) {
              const key = await pair.key;
              const value2 = await pair.value;
              if (key.status === "aborted" || value2.status === "aborted") {
                return INVALID;
              }
              if (key.status === "dirty" || value2.status === "dirty") {
                status.dirty();
              }
              finalMap.set(key.value, value2.value);
            }
            return { status: status.value, value: finalMap };
          });
        } else {
          const finalMap = /* @__PURE__ */ new Map();
          for (const pair of pairs) {
            const key = pair.key;
            const value2 = pair.value;
            if (key.status === "aborted" || value2.status === "aborted") {
              return INVALID;
            }
            if (key.status === "dirty" || value2.status === "dirty") {
              status.dirty();
            }
            finalMap.set(key.value, value2.value);
          }
          return { status: status.value, value: finalMap };
        }
      }
    };
    ZodMap.create = (keyType, valueType, params2) => {
      return new ZodMap({
        valueType,
        keyType,
        typeName: ZodFirstPartyTypeKind.ZodMap,
        ...processCreateParams(params2)
      });
    };
    ZodSet = class _ZodSet extends ZodType {
      static {
        __name(this, "ZodSet");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.set) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.set,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const def = this._def;
        if (def.minSize !== null) {
          if (ctx.data.size < def.minSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_small,
              minimum: def.minSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.minSize.message
            });
            status.dirty();
          }
        }
        if (def.maxSize !== null) {
          if (ctx.data.size > def.maxSize.value) {
            addIssueToContext(ctx, {
              code: ZodIssueCode.too_big,
              maximum: def.maxSize.value,
              type: "set",
              inclusive: true,
              exact: false,
              message: def.maxSize.message
            });
            status.dirty();
          }
        }
        const valueType = this._def.valueType;
        function finalizeSet(elements2) {
          const parsedSet = /* @__PURE__ */ new Set();
          for (const element of elements2) {
            if (element.status === "aborted")
              return INVALID;
            if (element.status === "dirty")
              status.dirty();
            parsedSet.add(element.value);
          }
          return { status: status.value, value: parsedSet };
        }
        __name(finalizeSet, "finalizeSet");
        const elements = [...ctx.data.values()].map((item, i) => valueType._parse(new ParseInputLazyPath(ctx, item, ctx.path, i)));
        if (ctx.common.async) {
          return Promise.all(elements).then((elements2) => finalizeSet(elements2));
        } else {
          return finalizeSet(elements);
        }
      }
      min(minSize, message) {
        return new _ZodSet({
          ...this._def,
          minSize: { value: minSize, message: errorUtil.toString(message) }
        });
      }
      max(maxSize, message) {
        return new _ZodSet({
          ...this._def,
          maxSize: { value: maxSize, message: errorUtil.toString(message) }
        });
      }
      size(size, message) {
        return this.min(size, message).max(size, message);
      }
      nonempty(message) {
        return this.min(1, message);
      }
    };
    ZodSet.create = (valueType, params2) => {
      return new ZodSet({
        valueType,
        minSize: null,
        maxSize: null,
        typeName: ZodFirstPartyTypeKind.ZodSet,
        ...processCreateParams(params2)
      });
    };
    ZodFunction = class _ZodFunction extends ZodType {
      static {
        __name(this, "ZodFunction");
      }
      constructor() {
        super(...arguments);
        this.validate = this.implement;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.function) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.function,
            received: ctx.parsedType
          });
          return INVALID;
        }
        function makeArgsIssue(args, error) {
          return makeIssue({
            data: args,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_arguments,
              argumentsError: error
            }
          });
        }
        __name(makeArgsIssue, "makeArgsIssue");
        function makeReturnsIssue(returns, error) {
          return makeIssue({
            data: returns,
            path: ctx.path,
            errorMaps: [
              ctx.common.contextualErrorMap,
              ctx.schemaErrorMap,
              getErrorMap(),
              errorMap
            ].filter((x) => !!x),
            issueData: {
              code: ZodIssueCode.invalid_return_type,
              returnTypeError: error
            }
          });
        }
        __name(makeReturnsIssue, "makeReturnsIssue");
        const params2 = { errorMap: ctx.common.contextualErrorMap };
        const fn = ctx.data;
        if (this._def.returns instanceof ZodPromise) {
          const me = this;
          return OK(async function(...args) {
            const error = new ZodError([]);
            const parsedArgs = await me._def.args.parseAsync(args, params2).catch((e) => {
              error.addIssue(makeArgsIssue(args, e));
              throw error;
            });
            const result2 = await Reflect.apply(fn, this, parsedArgs);
            const parsedReturns = await me._def.returns._def.type.parseAsync(result2, params2).catch((e) => {
              error.addIssue(makeReturnsIssue(result2, e));
              throw error;
            });
            return parsedReturns;
          });
        } else {
          const me = this;
          return OK(function(...args) {
            const parsedArgs = me._def.args.safeParse(args, params2);
            if (!parsedArgs.success) {
              throw new ZodError([makeArgsIssue(args, parsedArgs.error)]);
            }
            const result2 = Reflect.apply(fn, this, parsedArgs.data);
            const parsedReturns = me._def.returns.safeParse(result2, params2);
            if (!parsedReturns.success) {
              throw new ZodError([makeReturnsIssue(result2, parsedReturns.error)]);
            }
            return parsedReturns.data;
          });
        }
      }
      parameters() {
        return this._def.args;
      }
      returnType() {
        return this._def.returns;
      }
      args(...items) {
        return new _ZodFunction({
          ...this._def,
          args: ZodTuple.create(items).rest(ZodUnknown.create())
        });
      }
      returns(returnType) {
        return new _ZodFunction({
          ...this._def,
          returns: returnType
        });
      }
      implement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      strictImplement(func) {
        const validatedFunc = this.parse(func);
        return validatedFunc;
      }
      static create(args, returns, params2) {
        return new _ZodFunction({
          args: args ? args : ZodTuple.create([]).rest(ZodUnknown.create()),
          returns: returns || ZodUnknown.create(),
          typeName: ZodFirstPartyTypeKind.ZodFunction,
          ...processCreateParams(params2)
        });
      }
    };
    ZodLazy = class extends ZodType {
      static {
        __name(this, "ZodLazy");
      }
      get schema() {
        return this._def.getter();
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const lazySchema = this._def.getter();
        return lazySchema._parse({ data: ctx.data, path: ctx.path, parent: ctx });
      }
    };
    ZodLazy.create = (getter, params2) => {
      return new ZodLazy({
        getter,
        typeName: ZodFirstPartyTypeKind.ZodLazy,
        ...processCreateParams(params2)
      });
    };
    ZodLiteral = class extends ZodType {
      static {
        __name(this, "ZodLiteral");
      }
      _parse(input) {
        if (input.data !== this._def.value) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_literal,
            expected: this._def.value
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
      get value() {
        return this._def.value;
      }
    };
    ZodLiteral.create = (value2, params2) => {
      return new ZodLiteral({
        value: value2,
        typeName: ZodFirstPartyTypeKind.ZodLiteral,
        ...processCreateParams(params2)
      });
    };
    __name(createZodEnum, "createZodEnum");
    ZodEnum = class _ZodEnum extends ZodType {
      static {
        __name(this, "ZodEnum");
      }
      constructor() {
        super(...arguments);
        _ZodEnum_cache.set(this, void 0);
      }
      _parse(input) {
        if (typeof input.data !== "string") {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet2(this, _ZodEnum_cache, "f")) {
          __classPrivateFieldSet2(this, _ZodEnum_cache, new Set(this._def.values), "f");
        }
        if (!__classPrivateFieldGet2(this, _ZodEnum_cache, "f").has(input.data)) {
          const ctx = this._getOrReturnCtx(input);
          const expectedValues = this._def.values;
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get options() {
        return this._def.values;
      }
      get enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Values() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      get Enum() {
        const enumValues = {};
        for (const val of this._def.values) {
          enumValues[val] = val;
        }
        return enumValues;
      }
      extract(values, newDef = this._def) {
        return _ZodEnum.create(values, {
          ...this._def,
          ...newDef
        });
      }
      exclude(values, newDef = this._def) {
        return _ZodEnum.create(this.options.filter((opt) => !values.includes(opt)), {
          ...this._def,
          ...newDef
        });
      }
    };
    _ZodEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodEnum.create = createZodEnum;
    ZodNativeEnum = class extends ZodType {
      static {
        __name(this, "ZodNativeEnum");
      }
      constructor() {
        super(...arguments);
        _ZodNativeEnum_cache.set(this, void 0);
      }
      _parse(input) {
        const nativeEnumValues = util.getValidEnumValues(this._def.values);
        const ctx = this._getOrReturnCtx(input);
        if (ctx.parsedType !== ZodParsedType.string && ctx.parsedType !== ZodParsedType.number) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            expected: util.joinValues(expectedValues),
            received: ctx.parsedType,
            code: ZodIssueCode.invalid_type
          });
          return INVALID;
        }
        if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache, "f")) {
          __classPrivateFieldSet2(this, _ZodNativeEnum_cache, new Set(util.getValidEnumValues(this._def.values)), "f");
        }
        if (!__classPrivateFieldGet2(this, _ZodNativeEnum_cache, "f").has(input.data)) {
          const expectedValues = util.objectValues(nativeEnumValues);
          addIssueToContext(ctx, {
            received: ctx.data,
            code: ZodIssueCode.invalid_enum_value,
            options: expectedValues
          });
          return INVALID;
        }
        return OK(input.data);
      }
      get enum() {
        return this._def.values;
      }
    };
    _ZodNativeEnum_cache = /* @__PURE__ */ new WeakMap();
    ZodNativeEnum.create = (values, params2) => {
      return new ZodNativeEnum({
        values,
        typeName: ZodFirstPartyTypeKind.ZodNativeEnum,
        ...processCreateParams(params2)
      });
    };
    ZodPromise = class extends ZodType {
      static {
        __name(this, "ZodPromise");
      }
      unwrap() {
        return this._def.type;
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        if (ctx.parsedType !== ZodParsedType.promise && ctx.common.async === false) {
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.promise,
            received: ctx.parsedType
          });
          return INVALID;
        }
        const promisified = ctx.parsedType === ZodParsedType.promise ? ctx.data : Promise.resolve(ctx.data);
        return OK(promisified.then((data) => {
          return this._def.type.parseAsync(data, {
            path: ctx.path,
            errorMap: ctx.common.contextualErrorMap
          });
        }));
      }
    };
    ZodPromise.create = (schema, params2) => {
      return new ZodPromise({
        type: schema,
        typeName: ZodFirstPartyTypeKind.ZodPromise,
        ...processCreateParams(params2)
      });
    };
    ZodEffects = class extends ZodType {
      static {
        __name(this, "ZodEffects");
      }
      innerType() {
        return this._def.schema;
      }
      sourceType() {
        return this._def.schema._def.typeName === ZodFirstPartyTypeKind.ZodEffects ? this._def.schema.sourceType() : this._def.schema;
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        const effect = this._def.effect || null;
        const checkCtx = {
          addIssue: /* @__PURE__ */ __name((arg) => {
            addIssueToContext(ctx, arg);
            if (arg.fatal) {
              status.abort();
            } else {
              status.dirty();
            }
          }, "addIssue"),
          get path() {
            return ctx.path;
          }
        };
        checkCtx.addIssue = checkCtx.addIssue.bind(checkCtx);
        if (effect.type === "preprocess") {
          const processed = effect.transform(ctx.data, checkCtx);
          if (ctx.common.async) {
            return Promise.resolve(processed).then(async (processed2) => {
              if (status.value === "aborted")
                return INVALID;
              const result2 = await this._def.schema._parseAsync({
                data: processed2,
                path: ctx.path,
                parent: ctx
              });
              if (result2.status === "aborted")
                return INVALID;
              if (result2.status === "dirty")
                return DIRTY(result2.value);
              if (status.value === "dirty")
                return DIRTY(result2.value);
              return result2;
            });
          } else {
            if (status.value === "aborted")
              return INVALID;
            const result2 = this._def.schema._parseSync({
              data: processed,
              path: ctx.path,
              parent: ctx
            });
            if (result2.status === "aborted")
              return INVALID;
            if (result2.status === "dirty")
              return DIRTY(result2.value);
            if (status.value === "dirty")
              return DIRTY(result2.value);
            return result2;
          }
        }
        if (effect.type === "refinement") {
          const executeRefinement = /* @__PURE__ */ __name((acc) => {
            const result2 = effect.refinement(acc, checkCtx);
            if (ctx.common.async) {
              return Promise.resolve(result2);
            }
            if (result2 instanceof Promise) {
              throw new Error("Async refinement encountered during synchronous parse operation. Use .parseAsync instead.");
            }
            return acc;
          }, "executeRefinement");
          if (ctx.common.async === false) {
            const inner = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inner.status === "aborted")
              return INVALID;
            if (inner.status === "dirty")
              status.dirty();
            executeRefinement(inner.value);
            return { status: status.value, value: inner.value };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((inner) => {
              if (inner.status === "aborted")
                return INVALID;
              if (inner.status === "dirty")
                status.dirty();
              return executeRefinement(inner.value).then(() => {
                return { status: status.value, value: inner.value };
              });
            });
          }
        }
        if (effect.type === "transform") {
          if (ctx.common.async === false) {
            const base = this._def.schema._parseSync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (!isValid(base))
              return base;
            const result2 = effect.transform(base.value, checkCtx);
            if (result2 instanceof Promise) {
              throw new Error(`Asynchronous transform encountered during synchronous parse operation. Use .parseAsync instead.`);
            }
            return { status: status.value, value: result2 };
          } else {
            return this._def.schema._parseAsync({ data: ctx.data, path: ctx.path, parent: ctx }).then((base) => {
              if (!isValid(base))
                return base;
              return Promise.resolve(effect.transform(base.value, checkCtx)).then((result2) => ({ status: status.value, value: result2 }));
            });
          }
        }
        util.assertNever(effect);
      }
    };
    ZodEffects.create = (schema, effect, params2) => {
      return new ZodEffects({
        schema,
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        effect,
        ...processCreateParams(params2)
      });
    };
    ZodEffects.createWithPreprocess = (preprocess, schema, params2) => {
      return new ZodEffects({
        schema,
        effect: { type: "preprocess", transform: preprocess },
        typeName: ZodFirstPartyTypeKind.ZodEffects,
        ...processCreateParams(params2)
      });
    };
    ZodOptional = class extends ZodType {
      static {
        __name(this, "ZodOptional");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.undefined) {
          return OK(void 0);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodOptional.create = (type, params2) => {
      return new ZodOptional({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodOptional,
        ...processCreateParams(params2)
      });
    };
    ZodNullable = class extends ZodType {
      static {
        __name(this, "ZodNullable");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType === ZodParsedType.null) {
          return OK(null);
        }
        return this._def.innerType._parse(input);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodNullable.create = (type, params2) => {
      return new ZodNullable({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodNullable,
        ...processCreateParams(params2)
      });
    };
    ZodDefault = class extends ZodType {
      static {
        __name(this, "ZodDefault");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        let data = ctx.data;
        if (ctx.parsedType === ZodParsedType.undefined) {
          data = this._def.defaultValue();
        }
        return this._def.innerType._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      removeDefault() {
        return this._def.innerType;
      }
    };
    ZodDefault.create = (type, params2) => {
      return new ZodDefault({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodDefault,
        defaultValue: typeof params2.default === "function" ? params2.default : () => params2.default,
        ...processCreateParams(params2)
      });
    };
    ZodCatch = class extends ZodType {
      static {
        __name(this, "ZodCatch");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const newCtx = {
          ...ctx,
          common: {
            ...ctx.common,
            issues: []
          }
        };
        const result2 = this._def.innerType._parse({
          data: newCtx.data,
          path: newCtx.path,
          parent: {
            ...newCtx
          }
        });
        if (isAsync(result2)) {
          return result2.then((result3) => {
            return {
              status: "valid",
              value: result3.status === "valid" ? result3.value : this._def.catchValue({
                get error() {
                  return new ZodError(newCtx.common.issues);
                },
                input: newCtx.data
              })
            };
          });
        } else {
          return {
            status: "valid",
            value: result2.status === "valid" ? result2.value : this._def.catchValue({
              get error() {
                return new ZodError(newCtx.common.issues);
              },
              input: newCtx.data
            })
          };
        }
      }
      removeCatch() {
        return this._def.innerType;
      }
    };
    ZodCatch.create = (type, params2) => {
      return new ZodCatch({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodCatch,
        catchValue: typeof params2.catch === "function" ? params2.catch : () => params2.catch,
        ...processCreateParams(params2)
      });
    };
    ZodNaN = class extends ZodType {
      static {
        __name(this, "ZodNaN");
      }
      _parse(input) {
        const parsedType = this._getType(input);
        if (parsedType !== ZodParsedType.nan) {
          const ctx = this._getOrReturnCtx(input);
          addIssueToContext(ctx, {
            code: ZodIssueCode.invalid_type,
            expected: ZodParsedType.nan,
            received: ctx.parsedType
          });
          return INVALID;
        }
        return { status: "valid", value: input.data };
      }
    };
    ZodNaN.create = (params2) => {
      return new ZodNaN({
        typeName: ZodFirstPartyTypeKind.ZodNaN,
        ...processCreateParams(params2)
      });
    };
    BRAND = Symbol("zod_brand");
    ZodBranded = class extends ZodType {
      static {
        __name(this, "ZodBranded");
      }
      _parse(input) {
        const { ctx } = this._processInputParams(input);
        const data = ctx.data;
        return this._def.type._parse({
          data,
          path: ctx.path,
          parent: ctx
        });
      }
      unwrap() {
        return this._def.type;
      }
    };
    ZodPipeline = class _ZodPipeline extends ZodType {
      static {
        __name(this, "ZodPipeline");
      }
      _parse(input) {
        const { status, ctx } = this._processInputParams(input);
        if (ctx.common.async) {
          const handleAsync = /* @__PURE__ */ __name(async () => {
            const inResult = await this._def.in._parseAsync({
              data: ctx.data,
              path: ctx.path,
              parent: ctx
            });
            if (inResult.status === "aborted")
              return INVALID;
            if (inResult.status === "dirty") {
              status.dirty();
              return DIRTY(inResult.value);
            } else {
              return this._def.out._parseAsync({
                data: inResult.value,
                path: ctx.path,
                parent: ctx
              });
            }
          }, "handleAsync");
          return handleAsync();
        } else {
          const inResult = this._def.in._parseSync({
            data: ctx.data,
            path: ctx.path,
            parent: ctx
          });
          if (inResult.status === "aborted")
            return INVALID;
          if (inResult.status === "dirty") {
            status.dirty();
            return {
              status: "dirty",
              value: inResult.value
            };
          } else {
            return this._def.out._parseSync({
              data: inResult.value,
              path: ctx.path,
              parent: ctx
            });
          }
        }
      }
      static create(a, b) {
        return new _ZodPipeline({
          in: a,
          out: b,
          typeName: ZodFirstPartyTypeKind.ZodPipeline
        });
      }
    };
    ZodReadonly = class extends ZodType {
      static {
        __name(this, "ZodReadonly");
      }
      _parse(input) {
        const result2 = this._def.innerType._parse(input);
        const freeze = /* @__PURE__ */ __name((data) => {
          if (isValid(data)) {
            data.value = Object.freeze(data.value);
          }
          return data;
        }, "freeze");
        return isAsync(result2) ? result2.then((data) => freeze(data)) : freeze(result2);
      }
      unwrap() {
        return this._def.innerType;
      }
    };
    ZodReadonly.create = (type, params2) => {
      return new ZodReadonly({
        innerType: type,
        typeName: ZodFirstPartyTypeKind.ZodReadonly,
        ...processCreateParams(params2)
      });
    };
    __name(cleanParams, "cleanParams");
    __name(custom, "custom");
    late = {
      object: ZodObject.lazycreate
    };
    (function(ZodFirstPartyTypeKind2) {
      ZodFirstPartyTypeKind2["ZodString"] = "ZodString";
      ZodFirstPartyTypeKind2["ZodNumber"] = "ZodNumber";
      ZodFirstPartyTypeKind2["ZodNaN"] = "ZodNaN";
      ZodFirstPartyTypeKind2["ZodBigInt"] = "ZodBigInt";
      ZodFirstPartyTypeKind2["ZodBoolean"] = "ZodBoolean";
      ZodFirstPartyTypeKind2["ZodDate"] = "ZodDate";
      ZodFirstPartyTypeKind2["ZodSymbol"] = "ZodSymbol";
      ZodFirstPartyTypeKind2["ZodUndefined"] = "ZodUndefined";
      ZodFirstPartyTypeKind2["ZodNull"] = "ZodNull";
      ZodFirstPartyTypeKind2["ZodAny"] = "ZodAny";
      ZodFirstPartyTypeKind2["ZodUnknown"] = "ZodUnknown";
      ZodFirstPartyTypeKind2["ZodNever"] = "ZodNever";
      ZodFirstPartyTypeKind2["ZodVoid"] = "ZodVoid";
      ZodFirstPartyTypeKind2["ZodArray"] = "ZodArray";
      ZodFirstPartyTypeKind2["ZodObject"] = "ZodObject";
      ZodFirstPartyTypeKind2["ZodUnion"] = "ZodUnion";
      ZodFirstPartyTypeKind2["ZodDiscriminatedUnion"] = "ZodDiscriminatedUnion";
      ZodFirstPartyTypeKind2["ZodIntersection"] = "ZodIntersection";
      ZodFirstPartyTypeKind2["ZodTuple"] = "ZodTuple";
      ZodFirstPartyTypeKind2["ZodRecord"] = "ZodRecord";
      ZodFirstPartyTypeKind2["ZodMap"] = "ZodMap";
      ZodFirstPartyTypeKind2["ZodSet"] = "ZodSet";
      ZodFirstPartyTypeKind2["ZodFunction"] = "ZodFunction";
      ZodFirstPartyTypeKind2["ZodLazy"] = "ZodLazy";
      ZodFirstPartyTypeKind2["ZodLiteral"] = "ZodLiteral";
      ZodFirstPartyTypeKind2["ZodEnum"] = "ZodEnum";
      ZodFirstPartyTypeKind2["ZodEffects"] = "ZodEffects";
      ZodFirstPartyTypeKind2["ZodNativeEnum"] = "ZodNativeEnum";
      ZodFirstPartyTypeKind2["ZodOptional"] = "ZodOptional";
      ZodFirstPartyTypeKind2["ZodNullable"] = "ZodNullable";
      ZodFirstPartyTypeKind2["ZodDefault"] = "ZodDefault";
      ZodFirstPartyTypeKind2["ZodCatch"] = "ZodCatch";
      ZodFirstPartyTypeKind2["ZodPromise"] = "ZodPromise";
      ZodFirstPartyTypeKind2["ZodBranded"] = "ZodBranded";
      ZodFirstPartyTypeKind2["ZodPipeline"] = "ZodPipeline";
      ZodFirstPartyTypeKind2["ZodReadonly"] = "ZodReadonly";
    })(ZodFirstPartyTypeKind || (ZodFirstPartyTypeKind = {}));
    instanceOfType = /* @__PURE__ */ __name((cls, params2 = {
      message: `Input not instance of ${cls.name}`
    }) => custom((data) => data instanceof cls, params2), "instanceOfType");
    stringType = ZodString.create;
    numberType = ZodNumber.create;
    nanType = ZodNaN.create;
    bigIntType = ZodBigInt.create;
    booleanType = ZodBoolean.create;
    dateType = ZodDate.create;
    symbolType = ZodSymbol.create;
    undefinedType = ZodUndefined.create;
    nullType = ZodNull.create;
    anyType = ZodAny.create;
    unknownType = ZodUnknown.create;
    neverType = ZodNever.create;
    voidType = ZodVoid.create;
    arrayType = ZodArray.create;
    objectType = ZodObject.create;
    strictObjectType = ZodObject.strictCreate;
    unionType = ZodUnion.create;
    discriminatedUnionType = ZodDiscriminatedUnion.create;
    intersectionType = ZodIntersection.create;
    tupleType = ZodTuple.create;
    recordType = ZodRecord.create;
    mapType = ZodMap.create;
    setType = ZodSet.create;
    functionType = ZodFunction.create;
    lazyType = ZodLazy.create;
    literalType = ZodLiteral.create;
    enumType = ZodEnum.create;
    nativeEnumType = ZodNativeEnum.create;
    promiseType = ZodPromise.create;
    effectsType = ZodEffects.create;
    optionalType = ZodOptional.create;
    nullableType = ZodNullable.create;
    preprocessType = ZodEffects.createWithPreprocess;
    pipelineType = ZodPipeline.create;
    ostring = /* @__PURE__ */ __name(() => stringType().optional(), "ostring");
    onumber = /* @__PURE__ */ __name(() => numberType().optional(), "onumber");
    oboolean = /* @__PURE__ */ __name(() => booleanType().optional(), "oboolean");
    coerce = {
      string: /* @__PURE__ */ __name((arg) => ZodString.create({ ...arg, coerce: true }), "string"),
      number: /* @__PURE__ */ __name((arg) => ZodNumber.create({ ...arg, coerce: true }), "number"),
      boolean: /* @__PURE__ */ __name((arg) => ZodBoolean.create({
        ...arg,
        coerce: true
      }), "boolean"),
      bigint: /* @__PURE__ */ __name((arg) => ZodBigInt.create({ ...arg, coerce: true }), "bigint"),
      date: /* @__PURE__ */ __name((arg) => ZodDate.create({ ...arg, coerce: true }), "date")
    };
    NEVER = INVALID;
    z = /* @__PURE__ */ Object.freeze({
      __proto__: null,
      defaultErrorMap: errorMap,
      setErrorMap,
      getErrorMap,
      makeIssue,
      EMPTY_PATH,
      addIssueToContext,
      ParseStatus,
      INVALID,
      DIRTY,
      OK,
      isAborted,
      isDirty,
      isValid,
      isAsync,
      get util() {
        return util;
      },
      get objectUtil() {
        return objectUtil;
      },
      ZodParsedType,
      getParsedType,
      ZodType,
      datetimeRegex,
      ZodString,
      ZodNumber,
      ZodBigInt,
      ZodBoolean,
      ZodDate,
      ZodSymbol,
      ZodUndefined,
      ZodNull,
      ZodAny,
      ZodUnknown,
      ZodNever,
      ZodVoid,
      ZodArray,
      ZodObject,
      ZodUnion,
      ZodDiscriminatedUnion,
      ZodIntersection,
      ZodTuple,
      ZodRecord,
      ZodMap,
      ZodSet,
      ZodFunction,
      ZodLazy,
      ZodLiteral,
      ZodEnum,
      ZodNativeEnum,
      ZodPromise,
      ZodEffects,
      ZodTransformer: ZodEffects,
      ZodOptional,
      ZodNullable,
      ZodDefault,
      ZodCatch,
      ZodNaN,
      BRAND,
      ZodBranded,
      ZodPipeline,
      ZodReadonly,
      custom,
      Schema: ZodType,
      ZodSchema: ZodType,
      late,
      get ZodFirstPartyTypeKind() {
        return ZodFirstPartyTypeKind;
      },
      coerce,
      any: anyType,
      array: arrayType,
      bigint: bigIntType,
      boolean: booleanType,
      date: dateType,
      discriminatedUnion: discriminatedUnionType,
      effect: effectsType,
      "enum": enumType,
      "function": functionType,
      "instanceof": instanceOfType,
      intersection: intersectionType,
      lazy: lazyType,
      literal: literalType,
      map: mapType,
      nan: nanType,
      nativeEnum: nativeEnumType,
      never: neverType,
      "null": nullType,
      nullable: nullableType,
      number: numberType,
      object: objectType,
      oboolean,
      onumber,
      optional: optionalType,
      ostring,
      pipeline: pipelineType,
      preprocess: preprocessType,
      promise: promiseType,
      record: recordType,
      set: setType,
      strictObject: strictObjectType,
      string: stringType,
      symbol: symbolType,
      transformer: effectsType,
      tuple: tupleType,
      "undefined": undefinedType,
      union: unionType,
      unknown: unknownType,
      "void": voidType,
      NEVER,
      ZodIssueCode,
      quotelessJson,
      ZodError
    });
  }
});

// package.json
var package_default;
var init_package = __esm({
  "package.json"() {
    package_default = {
      name: "autodroid-watcher-client",
      author: "luizfelipelaviola",
      version: "0.0.0",
      main: "./src/index.js",
      license: "MIT",
      engines: {
        node: "v22.14.0"
      },
      scripts: {
        dev: "tsx watch ./src/index.ts -e development",
        "dev:debug": "tsx --inspect-brk ./src/index.ts -e development",
        build: "tsup",
        lint: "run-p -c lint:*",
        "lint:eslint": "eslint '{src,test}/**/*.{ts,tsx}' --fix",
        "lint:tsc": "tsc --noEmit",
        prepare: "husky"
      },
      dependencies: {
        "@sentry/node": "^9.5.0",
        "@sentry/profiling-node": "^9.5.0",
        archiver: "^7.0.1",
        "async-retry": "^1.3.3",
        autodroid: "^0.4.1",
        axios: "^1.8.3",
        dayjs: "^1.11.13",
        dockerode: "^4.0.4",
        "form-data": "^4.0.2",
        glob: "^11.0.1",
        rimraf: "^6.0.1",
        semver: "^7.7.1",
        "socket.io": "^4.8.1",
        "socket.io-client": "^4.8.1",
        systeminformation: "^5.25.11",
        validator: "^13.12.0",
        winston: "^3.17.0",
        yargs: "^17.7.2",
        zod: "^3.24.2"
      },
      devDependencies: {
        "@commitlint/cli": "^19.8.0",
        "@commitlint/config-conventional": "^19.8.0",
        "@swc/core": "^1.11.9",
        "@swc/helpers": "^0.5.15",
        "@types/archiver": "^6.0.3",
        "@types/async-retry": "^1.4.9",
        "@types/dockerode": "^3.3.35",
        "@types/node": "^22.13.10",
        "@types/semver": "^7.5.8",
        "@types/validator": "^13.12.2",
        "@types/yargs": "^17.0.33",
        "@typescript-eslint/eslint-plugin": "^8.26.1",
        "@typescript-eslint/parser": "^8.26.1",
        "@vitest/coverage-v8": "^3.0.8",
        "@vitest/ui": "^3.0.8",
        commitizen: "^4.3.1",
        "cz-conventional-changelog": "^3.3.0",
        eslint: "^8.57.0",
        "eslint-config-airbnb-base": "^15.0.0",
        "eslint-config-prettier": "^9.1.0",
        "eslint-import-resolver-typescript": "3.8.7",
        "eslint-plugin-deprecation": "^3.0.0",
        "eslint-plugin-import": "^2.31.0",
        "eslint-plugin-import-helpers": "1",
        "eslint-plugin-prettier": "^5.2.3",
        "eslint-plugin-unicorn": "^56.0.0",
        globals: "^15.12.0",
        husky: "^9.1.7",
        "lint-staged": "^15.5.0",
        "npm-run-all": "^4.1.5",
        prettier: "^3.5.3",
        "regenerator-runtime": "^0.14.1",
        tsup: "^8.4.0",
        tsx: "^4.19.3",
        typescript: "5.8.2",
        "unplugin-swc": "^1.5.1",
        "vite-tsconfig-paths": "5.1.4",
        vitest: "^3.0.8"
      },
      commitlint: {
        extends: [
          "@commitlint/config-conventional"
        ]
      },
      config: {
        commitizen: {
          path: "./node_modules/cz-conventional-changelog"
        }
      },
      "lint-staged": {
        "**/*.{ts,tsx}": [
          "eslint --fix"
        ]
      }
    };
  }
});

// node_modules/logform/format.js
var require_format = __commonJS({
  "node_modules/logform/format.js"(exports2, module2) {
    "use strict";
    var InvalidFormatError = class InvalidFormatError2 extends Error {
      static {
        __name(this, "InvalidFormatError");
      }
      constructor(formatFn) {
        super(`Format functions must be synchronous taking a two arguments: (info, opts)
Found: ${formatFn.toString().split("\n")[0]}
`);
        Error.captureStackTrace(this, InvalidFormatError2);
      }
    };
    module2.exports = (formatFn) => {
      if (formatFn.length > 2) {
        throw new InvalidFormatError(formatFn);
      }
      function Format(options = {}) {
        this.options = options;
      }
      __name(Format, "Format");
      Format.prototype.transform = formatFn;
      function createFormatWrap(opts) {
        return new Format(opts);
      }
      __name(createFormatWrap, "createFormatWrap");
      createFormatWrap.Format = Format;
      return createFormatWrap;
    };
  }
});

// node_modules/@colors/colors/lib/styles.js
var require_styles = __commonJS({
  "node_modules/@colors/colors/lib/styles.js"(exports2, module2) {
    "use strict";
    var styles = {};
    module2["exports"] = styles;
    var codes = {
      reset: [
        0,
        0
      ],
      bold: [
        1,
        22
      ],
      dim: [
        2,
        22
      ],
      italic: [
        3,
        23
      ],
      underline: [
        4,
        24
      ],
      inverse: [
        7,
        27
      ],
      hidden: [
        8,
        28
      ],
      strikethrough: [
        9,
        29
      ],
      black: [
        30,
        39
      ],
      red: [
        31,
        39
      ],
      green: [
        32,
        39
      ],
      yellow: [
        33,
        39
      ],
      blue: [
        34,
        39
      ],
      magenta: [
        35,
        39
      ],
      cyan: [
        36,
        39
      ],
      white: [
        37,
        39
      ],
      gray: [
        90,
        39
      ],
      grey: [
        90,
        39
      ],
      brightRed: [
        91,
        39
      ],
      brightGreen: [
        92,
        39
      ],
      brightYellow: [
        93,
        39
      ],
      brightBlue: [
        94,
        39
      ],
      brightMagenta: [
        95,
        39
      ],
      brightCyan: [
        96,
        39
      ],
      brightWhite: [
        97,
        39
      ],
      bgBlack: [
        40,
        49
      ],
      bgRed: [
        41,
        49
      ],
      bgGreen: [
        42,
        49
      ],
      bgYellow: [
        43,
        49
      ],
      bgBlue: [
        44,
        49
      ],
      bgMagenta: [
        45,
        49
      ],
      bgCyan: [
        46,
        49
      ],
      bgWhite: [
        47,
        49
      ],
      bgGray: [
        100,
        49
      ],
      bgGrey: [
        100,
        49
      ],
      bgBrightRed: [
        101,
        49
      ],
      bgBrightGreen: [
        102,
        49
      ],
      bgBrightYellow: [
        103,
        49
      ],
      bgBrightBlue: [
        104,
        49
      ],
      bgBrightMagenta: [
        105,
        49
      ],
      bgBrightCyan: [
        106,
        49
      ],
      bgBrightWhite: [
        107,
        49
      ],
      // legacy styles for colors pre v1.0.0
      blackBG: [
        40,
        49
      ],
      redBG: [
        41,
        49
      ],
      greenBG: [
        42,
        49
      ],
      yellowBG: [
        43,
        49
      ],
      blueBG: [
        44,
        49
      ],
      magentaBG: [
        45,
        49
      ],
      cyanBG: [
        46,
        49
      ],
      whiteBG: [
        47,
        49
      ]
    };
    Object.keys(codes).forEach(function(key) {
      var val = codes[key];
      var style = styles[key] = [];
      style.open = "\x1B[" + val[0] + "m";
      style.close = "\x1B[" + val[1] + "m";
    });
  }
});

// node_modules/@colors/colors/lib/system/has-flag.js
var require_has_flag = __commonJS({
  "node_modules/@colors/colors/lib/system/has-flag.js"(exports2, module2) {
    "use strict";
    module2.exports = function(flag, argv2) {
      argv2 = argv2 || process.argv || [];
      var terminatorPos = argv2.indexOf("--");
      var prefix = /^-{1,2}/.test(flag) ? "" : "--";
      var pos = argv2.indexOf(prefix + flag);
      return pos !== -1 && (terminatorPos === -1 ? true : pos < terminatorPos);
    };
  }
});

// node_modules/@colors/colors/lib/system/supports-colors.js
var require_supports_colors = __commonJS({
  "node_modules/@colors/colors/lib/system/supports-colors.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var hasFlag = require_has_flag();
    var env2 = process.env;
    var forceColor = void 0;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false")) {
      forceColor = false;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = true;
    }
    if ("FORCE_COLOR" in env2) {
      forceColor = env2.FORCE_COLOR.length === 0 || parseInt(env2.FORCE_COLOR, 10) !== 0;
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    __name(translateLevel, "translateLevel");
    function supportsColor(stream) {
      if (forceColor === false) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (stream && !stream.isTTY && forceColor !== true) {
        return 0;
      }
      var min = forceColor ? 1 : 0;
      if (process.platform === "win32") {
        var osRelease = os.release().split(".");
        if (Number(process.versions.node.split(".")[0]) >= 8 && Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if ([
          "TRAVIS",
          "CIRCLECI",
          "APPVEYOR",
          "GITLAB_CI"
        ].some(function(sign) {
          return sign in env2;
        }) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if ("TERM_PROGRAM" in env2) {
        var version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Hyper":
            return 3;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      if (env2.TERM === "dumb") {
        return min;
      }
      return min;
    }
    __name(supportsColor, "supportsColor");
    function getSupportLevel(stream) {
      var level = supportsColor(stream);
      return translateLevel(level);
    }
    __name(getSupportLevel, "getSupportLevel");
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: getSupportLevel(process.stdout),
      stderr: getSupportLevel(process.stderr)
    };
  }
});

// node_modules/@colors/colors/lib/custom/trap.js
var require_trap = __commonJS({
  "node_modules/@colors/colors/lib/custom/trap.js"(exports2, module2) {
    "use strict";
    module2["exports"] = /* @__PURE__ */ __name(function runTheTrap(text, options) {
      var result2 = "";
      text = text || "Run the trap, drop the bass";
      text = text.split("");
      var trap = {
        a: [
          "@",
          "\u0104",
          "\u023A",
          "\u0245",
          "\u0394",
          "\u039B",
          "\u0414"
        ],
        b: [
          "\xDF",
          "\u0181",
          "\u0243",
          "\u026E",
          "\u03B2",
          "\u0E3F"
        ],
        c: [
          "\xA9",
          "\u023B",
          "\u03FE"
        ],
        d: [
          "\xD0",
          "\u018A",
          "\u0500",
          "\u0501",
          "\u0502",
          "\u0503"
        ],
        e: [
          "\xCB",
          "\u0115",
          "\u018E",
          "\u0258",
          "\u03A3",
          "\u03BE",
          "\u04BC",
          "\u0A6C"
        ],
        f: [
          "\u04FA"
        ],
        g: [
          "\u0262"
        ],
        h: [
          "\u0126",
          "\u0195",
          "\u04A2",
          "\u04BA",
          "\u04C7",
          "\u050A"
        ],
        i: [
          "\u0F0F"
        ],
        j: [
          "\u0134"
        ],
        k: [
          "\u0138",
          "\u04A0",
          "\u04C3",
          "\u051E"
        ],
        l: [
          "\u0139"
        ],
        m: [
          "\u028D",
          "\u04CD",
          "\u04CE",
          "\u0520",
          "\u0521",
          "\u0D69"
        ],
        n: [
          "\xD1",
          "\u014B",
          "\u019D",
          "\u0376",
          "\u03A0",
          "\u048A"
        ],
        o: [
          "\xD8",
          "\xF5",
          "\xF8",
          "\u01FE",
          "\u0298",
          "\u047A",
          "\u05DD",
          "\u06DD",
          "\u0E4F"
        ],
        p: [
          "\u01F7",
          "\u048E"
        ],
        q: [
          "\u09CD"
        ],
        r: [
          "\xAE",
          "\u01A6",
          "\u0210",
          "\u024C",
          "\u0280",
          "\u042F"
        ],
        s: [
          "\xA7",
          "\u03DE",
          "\u03DF",
          "\u03E8"
        ],
        t: [
          "\u0141",
          "\u0166",
          "\u0373"
        ],
        u: [
          "\u01B1",
          "\u054D"
        ],
        v: [
          "\u05D8"
        ],
        w: [
          "\u0428",
          "\u0460",
          "\u047C",
          "\u0D70"
        ],
        x: [
          "\u04B2",
          "\u04FE",
          "\u04FC",
          "\u04FD"
        ],
        y: [
          "\xA5",
          "\u04B0",
          "\u04CB"
        ],
        z: [
          "\u01B5",
          "\u0240"
        ]
      };
      text.forEach(function(c) {
        c = c.toLowerCase();
        var chars = trap[c] || [
          " "
        ];
        var rand = Math.floor(Math.random() * chars.length);
        if (typeof trap[c] !== "undefined") {
          result2 += trap[c][rand];
        } else {
          result2 += c;
        }
      });
      return result2;
    }, "runTheTrap");
  }
});

// node_modules/@colors/colors/lib/custom/zalgo.js
var require_zalgo = __commonJS({
  "node_modules/@colors/colors/lib/custom/zalgo.js"(exports2, module2) {
    "use strict";
    module2["exports"] = /* @__PURE__ */ __name(function zalgo(text, options) {
      text = text || "   he is here   ";
      var soul = {
        "up": [
          "\u030D",
          "\u030E",
          "\u0304",
          "\u0305",
          "\u033F",
          "\u0311",
          "\u0306",
          "\u0310",
          "\u0352",
          "\u0357",
          "\u0351",
          "\u0307",
          "\u0308",
          "\u030A",
          "\u0342",
          "\u0313",
          "\u0308",
          "\u034A",
          "\u034B",
          "\u034C",
          "\u0303",
          "\u0302",
          "\u030C",
          "\u0350",
          "\u0300",
          "\u0301",
          "\u030B",
          "\u030F",
          "\u0312",
          "\u0313",
          "\u0314",
          "\u033D",
          "\u0309",
          "\u0363",
          "\u0364",
          "\u0365",
          "\u0366",
          "\u0367",
          "\u0368",
          "\u0369",
          "\u036A",
          "\u036B",
          "\u036C",
          "\u036D",
          "\u036E",
          "\u036F",
          "\u033E",
          "\u035B",
          "\u0346",
          "\u031A"
        ],
        "down": [
          "\u0316",
          "\u0317",
          "\u0318",
          "\u0319",
          "\u031C",
          "\u031D",
          "\u031E",
          "\u031F",
          "\u0320",
          "\u0324",
          "\u0325",
          "\u0326",
          "\u0329",
          "\u032A",
          "\u032B",
          "\u032C",
          "\u032D",
          "\u032E",
          "\u032F",
          "\u0330",
          "\u0331",
          "\u0332",
          "\u0333",
          "\u0339",
          "\u033A",
          "\u033B",
          "\u033C",
          "\u0345",
          "\u0347",
          "\u0348",
          "\u0349",
          "\u034D",
          "\u034E",
          "\u0353",
          "\u0354",
          "\u0355",
          "\u0356",
          "\u0359",
          "\u035A",
          "\u0323"
        ],
        "mid": [
          "\u0315",
          "\u031B",
          "\u0300",
          "\u0301",
          "\u0358",
          "\u0321",
          "\u0322",
          "\u0327",
          "\u0328",
          "\u0334",
          "\u0335",
          "\u0336",
          "\u035C",
          "\u035D",
          "\u035E",
          "\u035F",
          "\u0360",
          "\u0362",
          "\u0338",
          "\u0337",
          "\u0361",
          " \u0489"
        ]
      };
      var all = [].concat(soul.up, soul.down, soul.mid);
      function randomNumber(range) {
        var r = Math.floor(Math.random() * range);
        return r;
      }
      __name(randomNumber, "randomNumber");
      function isChar(character) {
        var bool = false;
        all.filter(function(i) {
          bool = i === character;
        });
        return bool;
      }
      __name(isChar, "isChar");
      function heComes(text2, options2) {
        var result2 = "";
        var counts;
        var l;
        options2 = options2 || {};
        options2["up"] = typeof options2["up"] !== "undefined" ? options2["up"] : true;
        options2["mid"] = typeof options2["mid"] !== "undefined" ? options2["mid"] : true;
        options2["down"] = typeof options2["down"] !== "undefined" ? options2["down"] : true;
        options2["size"] = typeof options2["size"] !== "undefined" ? options2["size"] : "maxi";
        text2 = text2.split("");
        for (l in text2) {
          if (isChar(l)) {
            continue;
          }
          result2 = result2 + text2[l];
          counts = {
            "up": 0,
            "down": 0,
            "mid": 0
          };
          switch (options2.size) {
            case "mini":
              counts.up = randomNumber(8);
              counts.mid = randomNumber(2);
              counts.down = randomNumber(8);
              break;
            case "maxi":
              counts.up = randomNumber(16) + 3;
              counts.mid = randomNumber(4) + 1;
              counts.down = randomNumber(64) + 3;
              break;
            default:
              counts.up = randomNumber(8) + 1;
              counts.mid = randomNumber(6) / 2;
              counts.down = randomNumber(8) + 1;
              break;
          }
          var arr = [
            "up",
            "mid",
            "down"
          ];
          for (var d in arr) {
            var index = arr[d];
            for (var i = 0; i <= counts[index]; i++) {
              if (options2[index]) {
                result2 = result2 + soul[index][randomNumber(soul[index].length)];
              }
            }
          }
        }
        return result2;
      }
      __name(heComes, "heComes");
      return heComes(text, options);
    }, "zalgo");
  }
});

// node_modules/@colors/colors/lib/maps/america.js
var require_america = __commonJS({
  "node_modules/@colors/colors/lib/maps/america.js"(exports2, module2) {
    "use strict";
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        if (letter === " ") return letter;
        switch (i % 3) {
          case 0:
            return colors.red(letter);
          case 1:
            return colors.white(letter);
          case 2:
            return colors.blue(letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/zebra.js
var require_zebra = __commonJS({
  "node_modules/@colors/colors/lib/maps/zebra.js"(exports2, module2) {
    "use strict";
    module2["exports"] = function(colors) {
      return function(letter, i, exploded) {
        return i % 2 === 0 ? letter : colors.inverse(letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/rainbow.js
var require_rainbow = __commonJS({
  "node_modules/@colors/colors/lib/maps/rainbow.js"(exports2, module2) {
    "use strict";
    module2["exports"] = function(colors) {
      var rainbowColors = [
        "red",
        "yellow",
        "green",
        "blue",
        "magenta"
      ];
      return function(letter, i, exploded) {
        if (letter === " ") {
          return letter;
        } else {
          return colors[rainbowColors[i++ % rainbowColors.length]](letter);
        }
      };
    };
  }
});

// node_modules/@colors/colors/lib/maps/random.js
var require_random = __commonJS({
  "node_modules/@colors/colors/lib/maps/random.js"(exports2, module2) {
    "use strict";
    module2["exports"] = function(colors) {
      var available = [
        "underline",
        "inverse",
        "grey",
        "yellow",
        "red",
        "green",
        "blue",
        "white",
        "cyan",
        "magenta",
        "brightYellow",
        "brightRed",
        "brightGreen",
        "brightBlue",
        "brightWhite",
        "brightCyan",
        "brightMagenta"
      ];
      return function(letter, i, exploded) {
        return letter === " " ? letter : colors[available[Math.round(Math.random() * (available.length - 2))]](letter);
      };
    };
  }
});

// node_modules/@colors/colors/lib/colors.js
var require_colors = __commonJS({
  "node_modules/@colors/colors/lib/colors.js"(exports2, module2) {
    "use strict";
    var colors = {};
    module2["exports"] = colors;
    colors.themes = {};
    var util2 = require("util");
    var ansiStyles = colors.styles = require_styles();
    var defineProps = Object.defineProperties;
    var newLineRegex = new RegExp(/[\r\n]+/g);
    colors.supportsColor = require_supports_colors().supportsColor;
    if (typeof colors.enabled === "undefined") {
      colors.enabled = colors.supportsColor() !== false;
    }
    colors.enable = function() {
      colors.enabled = true;
    };
    colors.disable = function() {
      colors.enabled = false;
    };
    colors.stripColors = colors.strip = function(str) {
      return ("" + str).replace(/\x1B\[\d+m/g, "");
    };
    var stylize = colors.stylize = /* @__PURE__ */ __name(function stylize2(str, style) {
      if (!colors.enabled) {
        return str + "";
      }
      var styleMap = ansiStyles[style];
      if (!styleMap && style in colors) {
        return colors[style](str);
      }
      return styleMap.open + str + styleMap.close;
    }, "stylize");
    var matchOperatorsRe = /[|\\{}()[\]^$+*?.]/g;
    var escapeStringRegexp = /* @__PURE__ */ __name(function(str) {
      if (typeof str !== "string") {
        throw new TypeError("Expected a string");
      }
      return str.replace(matchOperatorsRe, "\\$&");
    }, "escapeStringRegexp");
    function build(_styles) {
      var builder = /* @__PURE__ */ __name(function builder2() {
        return applyStyle.apply(builder2, arguments);
      }, "builder");
      builder._styles = _styles;
      builder.__proto__ = proto;
      return builder;
    }
    __name(build, "build");
    var styles = function() {
      var ret = {};
      ansiStyles.grey = ansiStyles.gray;
      Object.keys(ansiStyles).forEach(function(key) {
        ansiStyles[key].closeRe = new RegExp(escapeStringRegexp(ansiStyles[key].close), "g");
        ret[key] = {
          get: /* @__PURE__ */ __name(function() {
            return build(this._styles.concat(key));
          }, "get")
        };
      });
      return ret;
    }();
    var proto = defineProps(/* @__PURE__ */ __name(function colors2() {
    }, "colors"), styles);
    function applyStyle() {
      var args = Array.prototype.slice.call(arguments);
      var str = args.map(function(arg) {
        if (arg != null && arg.constructor === String) {
          return arg;
        } else {
          return util2.inspect(arg);
        }
      }).join(" ");
      if (!colors.enabled || !str) {
        return str;
      }
      var newLinesPresent = str.indexOf("\n") != -1;
      var nestedStyles = this._styles;
      var i = nestedStyles.length;
      while (i--) {
        var code = ansiStyles[nestedStyles[i]];
        str = code.open + str.replace(code.closeRe, code.open) + code.close;
        if (newLinesPresent) {
          str = str.replace(newLineRegex, function(match) {
            return code.close + match + code.open;
          });
        }
      }
      return str;
    }
    __name(applyStyle, "applyStyle");
    colors.setTheme = function(theme) {
      if (typeof theme === "string") {
        console.log("colors.setTheme now only accepts an object, not a string.  If you are trying to set a theme from a file, it is now your (the caller's) responsibility to require the file.  The old syntax looked like colors.setTheme(__dirname + '/../themes/generic-logging.js'); The new syntax looks like colors.setTheme(require(__dirname + '/../themes/generic-logging.js'));");
        return;
      }
      for (var style in theme) {
        (function(style2) {
          colors[style2] = function(str) {
            if (typeof theme[style2] === "object") {
              var out = str;
              for (var i in theme[style2]) {
                out = colors[theme[style2][i]](out);
              }
              return out;
            }
            return colors[theme[style2]](str);
          };
        })(style);
      }
    };
    function init() {
      var ret = {};
      Object.keys(styles).forEach(function(name) {
        ret[name] = {
          get: /* @__PURE__ */ __name(function() {
            return build([
              name
            ]);
          }, "get")
        };
      });
      return ret;
    }
    __name(init, "init");
    var sequencer = /* @__PURE__ */ __name(function sequencer2(map2, str) {
      var exploded = str.split("");
      exploded = exploded.map(map2);
      return exploded.join("");
    }, "sequencer");
    colors.trap = require_trap();
    colors.zalgo = require_zalgo();
    colors.maps = {};
    colors.maps.america = require_america()(colors);
    colors.maps.zebra = require_zebra()(colors);
    colors.maps.rainbow = require_rainbow()(colors);
    colors.maps.random = require_random()(colors);
    for (map in colors.maps) {
      (function(map2) {
        colors[map2] = function(str) {
          return sequencer(colors.maps[map2], str);
        };
      })(map);
    }
    var map;
    defineProps(colors, init());
  }
});

// node_modules/@colors/colors/safe.js
var require_safe = __commonJS({
  "node_modules/@colors/colors/safe.js"(exports2, module2) {
    "use strict";
    var colors = require_colors();
    module2["exports"] = colors;
  }
});

// node_modules/triple-beam/config/cli.js
var require_cli = __commonJS({
  "node_modules/triple-beam/config/cli.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      help: 2,
      data: 3,
      info: 4,
      debug: 5,
      prompt: 6,
      verbose: 7,
      input: 8,
      silly: 9
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      help: "cyan",
      data: "grey",
      info: "green",
      debug: "blue",
      prompt: "grey",
      verbose: "cyan",
      input: "grey",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/npm.js
var require_npm = __commonJS({
  "node_modules/triple-beam/config/npm.js"(exports2) {
    "use strict";
    exports2.levels = {
      error: 0,
      warn: 1,
      info: 2,
      http: 3,
      verbose: 4,
      debug: 5,
      silly: 6
    };
    exports2.colors = {
      error: "red",
      warn: "yellow",
      info: "green",
      http: "green",
      verbose: "cyan",
      debug: "blue",
      silly: "magenta"
    };
  }
});

// node_modules/triple-beam/config/syslog.js
var require_syslog = __commonJS({
  "node_modules/triple-beam/config/syslog.js"(exports2) {
    "use strict";
    exports2.levels = {
      emerg: 0,
      alert: 1,
      crit: 2,
      error: 3,
      warning: 4,
      notice: 5,
      info: 6,
      debug: 7
    };
    exports2.colors = {
      emerg: "red",
      alert: "yellow",
      crit: "red",
      error: "red",
      warning: "red",
      notice: "yellow",
      info: "green",
      debug: "blue"
    };
  }
});

// node_modules/triple-beam/config/index.js
var require_config = __commonJS({
  "node_modules/triple-beam/config/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "cli", {
      value: require_cli()
    });
    Object.defineProperty(exports2, "npm", {
      value: require_npm()
    });
    Object.defineProperty(exports2, "syslog", {
      value: require_syslog()
    });
  }
});

// node_modules/triple-beam/index.js
var require_triple_beam = __commonJS({
  "node_modules/triple-beam/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "LEVEL", {
      value: Symbol.for("level")
    });
    Object.defineProperty(exports2, "MESSAGE", {
      value: Symbol.for("message")
    });
    Object.defineProperty(exports2, "SPLAT", {
      value: Symbol.for("splat")
    });
    Object.defineProperty(exports2, "configs", {
      value: require_config()
    });
  }
});

// node_modules/logform/colorize.js
var require_colorize = __commonJS({
  "node_modules/logform/colorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var { LEVEL, MESSAGE } = require_triple_beam();
    colors.enabled = true;
    var hasSpace = /\s+/;
    var Colorizer = class Colorizer2 {
      static {
        __name(this, "Colorizer");
      }
      constructor(opts = {}) {
        if (opts.colors) {
          this.addColors(opts.colors);
        }
        this.options = opts;
      }
      /*
      * Adds the colors Object to the set of allColors
      * known by the Colorizer
      *
      * @param {Object} colors Set of color mappings to add.
      */
      static addColors(clrs) {
        const nextColors = Object.keys(clrs).reduce((acc, level) => {
          acc[level] = hasSpace.test(clrs[level]) ? clrs[level].split(hasSpace) : clrs[level];
          return acc;
        }, {});
        Colorizer2.allColors = Object.assign({}, Colorizer2.allColors || {}, nextColors);
        return Colorizer2.allColors;
      }
      /*
      * Adds the colors Object to the set of allColors
      * known by the Colorizer
      *
      * @param {Object} colors Set of color mappings to add.
      */
      addColors(clrs) {
        return Colorizer2.addColors(clrs);
      }
      /*
      * function colorize (lookup, level, message)
      * Performs multi-step colorization using @colors/colors/safe
      */
      colorize(lookup2, level, message) {
        if (typeof message === "undefined") {
          message = level;
        }
        if (!Array.isArray(Colorizer2.allColors[lookup2])) {
          return colors[Colorizer2.allColors[lookup2]](message);
        }
        for (let i = 0, len = Colorizer2.allColors[lookup2].length; i < len; i++) {
          message = colors[Colorizer2.allColors[lookup2][i]](message);
        }
        return message;
      }
      /*
      * function transform (info, opts)
      * Attempts to colorize the { level, message } of the given
      * `logform` info object.
      */
      transform(info, opts) {
        if (opts.all && typeof info[MESSAGE] === "string") {
          info[MESSAGE] = this.colorize(info[LEVEL], info.level, info[MESSAGE]);
        }
        if (opts.level || opts.all || !opts.message) {
          info.level = this.colorize(info[LEVEL], info.level);
        }
        if (opts.all || opts.message) {
          info.message = this.colorize(info[LEVEL], info.level, info.message);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Colorizer(opts);
    module2.exports.Colorizer = module2.exports.Format = Colorizer;
  }
});

// node_modules/logform/levels.js
var require_levels = __commonJS({
  "node_modules/logform/levels.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    module2.exports = (config) => {
      Colorizer.addColors(config.colors || config);
      return config;
    };
  }
});

// node_modules/logform/align.js
var require_align = __commonJS({
  "node_modules/logform/align.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    module2.exports = format5((info) => {
      info.message = `	${info.message}`;
      return info;
    });
  }
});

// node_modules/logform/errors.js
var require_errors = __commonJS({
  "node_modules/logform/errors.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    var { LEVEL, MESSAGE } = require_triple_beam();
    module2.exports = format5((einfo, { stack, cause }) => {
      if (einfo instanceof Error) {
        const info = Object.assign({}, einfo, {
          level: einfo.level,
          [LEVEL]: einfo[LEVEL] || einfo.level,
          message: einfo.message,
          [MESSAGE]: einfo[MESSAGE] || einfo.message
        });
        if (stack) info.stack = einfo.stack;
        if (cause) info.cause = einfo.cause;
        return info;
      }
      if (!(einfo.message instanceof Error)) return einfo;
      const err = einfo.message;
      Object.assign(einfo, err);
      einfo.message = err.message;
      einfo[MESSAGE] = err.message;
      if (stack) einfo.stack = err.stack;
      if (cause) einfo.cause = err.cause;
      return einfo;
    });
  }
});

// node_modules/logform/pad-levels.js
var require_pad_levels = __commonJS({
  "node_modules/logform/pad-levels.js"(exports2, module2) {
    "use strict";
    var { configs, LEVEL, MESSAGE } = require_triple_beam();
    var Padder = class Padder2 {
      static {
        __name(this, "Padder");
      }
      constructor(opts = {
        levels: configs.npm.levels
      }) {
        this.paddings = Padder2.paddingForLevels(opts.levels, opts.filler);
        this.options = opts;
      }
      /**
      * Returns the maximum length of keys in the specified `levels` Object.
      * @param  {Object} levels Set of all levels to calculate longest level against.
      * @returns {Number} Maximum length of the longest level string.
      */
      static getLongestLevel(levels) {
        const lvls = Object.keys(levels).map((level) => level.length);
        return Math.max(...lvls);
      }
      /**
      * Returns the padding for the specified `level` assuming that the
      * maximum length of all levels it's associated with is `maxLength`.
      * @param  {String} level Level to calculate padding for.
      * @param  {String} filler Repeatable text to use for padding.
      * @param  {Number} maxLength Length of the longest level
      * @returns {String} Padding string for the `level`
      */
      static paddingForLevel(level, filler, maxLength) {
        const targetLen = maxLength + 1 - level.length;
        const rep = Math.floor(targetLen / filler.length);
        const padding = `${filler}${filler.repeat(rep)}`;
        return padding.slice(0, targetLen);
      }
      /**
      * Returns an object with the string paddings for the given `levels`
      * using the specified `filler`.
      * @param  {Object} levels Set of all levels to calculate padding for.
      * @param  {String} filler Repeatable text to use for padding.
      * @returns {Object} Mapping of level to desired padding.
      */
      static paddingForLevels(levels, filler = " ") {
        const maxLength = Padder2.getLongestLevel(levels);
        return Object.keys(levels).reduce((acc, level) => {
          acc[level] = Padder2.paddingForLevel(level, filler, maxLength);
          return acc;
        }, {});
      }
      /**
      * Prepends the padding onto the `message` based on the `LEVEL` of
      * the `info`. This is based on the behavior of `winston@2` which also
      * prepended the level onto the message.
      *
      * See: https://github.com/winstonjs/winston/blob/2.x/lib/winston/logger.js#L198-L201
      *
      * @param  {Info} info Logform info object
      * @param  {Object} opts Options passed along to this instance.
      * @returns {Info} Modified logform info object.
      */
      transform(info, opts) {
        info.message = `${this.paddings[info[LEVEL]]}${info.message}`;
        if (info[MESSAGE]) {
          info[MESSAGE] = `${this.paddings[info[LEVEL]]}${info[MESSAGE]}`;
        }
        return info;
      }
    };
    module2.exports = (opts) => new Padder(opts);
    module2.exports.Padder = module2.exports.Format = Padder;
  }
});

// node_modules/logform/cli.js
var require_cli2 = __commonJS({
  "node_modules/logform/cli.js"(exports2, module2) {
    "use strict";
    var { Colorizer } = require_colorize();
    var { Padder } = require_pad_levels();
    var { configs, MESSAGE } = require_triple_beam();
    var CliFormat = class CliFormat {
      static {
        __name(this, "CliFormat");
      }
      constructor(opts = {}) {
        if (!opts.levels) {
          opts.levels = configs.cli.levels;
        }
        this.colorizer = new Colorizer(opts);
        this.padder = new Padder(opts);
        this.options = opts;
      }
      /*
      * function transform (info, opts)
      * Attempts to both:
      * 1. Pad the { level }
      * 2. Colorize the { level, message }
      * of the given `logform` info object depending on the `opts`.
      */
      transform(info, opts) {
        this.colorizer.transform(this.padder.transform(info, opts), opts);
        info[MESSAGE] = `${info.level}:${info.message}`;
        return info;
      }
    };
    module2.exports = (opts) => new CliFormat(opts);
    module2.exports.Format = CliFormat;
  }
});

// node_modules/logform/combine.js
var require_combine = __commonJS({
  "node_modules/logform/combine.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    function cascade(formats) {
      if (!formats.every(isValidFormat)) {
        return;
      }
      return (info) => {
        let obj = info;
        for (let i = 0; i < formats.length; i++) {
          obj = formats[i].transform(obj, formats[i].options);
          if (!obj) {
            return false;
          }
        }
        return obj;
      };
    }
    __name(cascade, "cascade");
    function isValidFormat(fmt) {
      if (typeof fmt.transform !== "function") {
        throw new Error([
          "No transform function found on format. Did you create a format instance?",
          "const myFormat = format(formatFn);",
          "const instance = myFormat();"
        ].join("\n"));
      }
      return true;
    }
    __name(isValidFormat, "isValidFormat");
    module2.exports = (...formats) => {
      const combinedFormat = format5(cascade(formats));
      const instance = combinedFormat();
      instance.Format = combinedFormat.Format;
      return instance;
    };
    module2.exports.cascade = cascade;
  }
});

// node_modules/safe-stable-stringify/index.js
var require_safe_stable_stringify = __commonJS({
  "node_modules/safe-stable-stringify/index.js"(exports2, module2) {
    "use strict";
    var { hasOwnProperty } = Object.prototype;
    var stringify2 = configure();
    stringify2.configure = configure;
    stringify2.stringify = stringify2;
    stringify2.default = stringify2;
    exports2.stringify = stringify2;
    exports2.configure = configure;
    module2.exports = stringify2;
    var strEscapeSequencesRegExp = /[\u0000-\u001f\u0022\u005c\ud800-\udfff]/;
    function strEscape(str) {
      if (str.length < 5e3 && !strEscapeSequencesRegExp.test(str)) {
        return `"${str}"`;
      }
      return JSON.stringify(str);
    }
    __name(strEscape, "strEscape");
    function sort(array, comparator) {
      if (array.length > 200 || comparator) {
        return array.sort(comparator);
      }
      for (let i = 1; i < array.length; i++) {
        const currentValue = array[i];
        let position = i;
        while (position !== 0 && array[position - 1] > currentValue) {
          array[position] = array[position - 1];
          position--;
        }
        array[position] = currentValue;
      }
      return array;
    }
    __name(sort, "sort");
    var typedArrayPrototypeGetSymbolToStringTag = Object.getOwnPropertyDescriptor(Object.getPrototypeOf(Object.getPrototypeOf(new Int8Array())), Symbol.toStringTag).get;
    function isTypedArrayWithEntries(value2) {
      return typedArrayPrototypeGetSymbolToStringTag.call(value2) !== void 0 && value2.length !== 0;
    }
    __name(isTypedArrayWithEntries, "isTypedArrayWithEntries");
    function stringifyTypedArray(array, separator, maximumBreadth) {
      if (array.length < maximumBreadth) {
        maximumBreadth = array.length;
      }
      const whitespace = separator === "," ? "" : " ";
      let res = `"0":${whitespace}${array[0]}`;
      for (let i = 1; i < maximumBreadth; i++) {
        res += `${separator}"${i}":${whitespace}${array[i]}`;
      }
      return res;
    }
    __name(stringifyTypedArray, "stringifyTypedArray");
    function getCircularValueOption(options) {
      if (hasOwnProperty.call(options, "circularValue")) {
        const circularValue = options.circularValue;
        if (typeof circularValue === "string") {
          return `"${circularValue}"`;
        }
        if (circularValue == null) {
          return circularValue;
        }
        if (circularValue === Error || circularValue === TypeError) {
          return {
            toString() {
              throw new TypeError("Converting circular structure to JSON");
            }
          };
        }
        throw new TypeError('The "circularValue" argument must be of type string or the value null or undefined');
      }
      return '"[Circular]"';
    }
    __name(getCircularValueOption, "getCircularValueOption");
    function getDeterministicOption(options) {
      let value2;
      if (hasOwnProperty.call(options, "deterministic")) {
        value2 = options.deterministic;
        if (typeof value2 !== "boolean" && typeof value2 !== "function") {
          throw new TypeError('The "deterministic" argument must be of type boolean or comparator function');
        }
      }
      return value2 === void 0 ? true : value2;
    }
    __name(getDeterministicOption, "getDeterministicOption");
    function getBooleanOption(options, key) {
      let value2;
      if (hasOwnProperty.call(options, key)) {
        value2 = options[key];
        if (typeof value2 !== "boolean") {
          throw new TypeError(`The "${key}" argument must be of type boolean`);
        }
      }
      return value2 === void 0 ? true : value2;
    }
    __name(getBooleanOption, "getBooleanOption");
    function getPositiveIntegerOption(options, key) {
      let value2;
      if (hasOwnProperty.call(options, key)) {
        value2 = options[key];
        if (typeof value2 !== "number") {
          throw new TypeError(`The "${key}" argument must be of type number`);
        }
        if (!Number.isInteger(value2)) {
          throw new TypeError(`The "${key}" argument must be an integer`);
        }
        if (value2 < 1) {
          throw new RangeError(`The "${key}" argument must be >= 1`);
        }
      }
      return value2 === void 0 ? Infinity : value2;
    }
    __name(getPositiveIntegerOption, "getPositiveIntegerOption");
    function getItemCount(number) {
      if (number === 1) {
        return "1 item";
      }
      return `${number} items`;
    }
    __name(getItemCount, "getItemCount");
    function getUniqueReplacerSet(replacerArray) {
      const replacerSet = /* @__PURE__ */ new Set();
      for (const value2 of replacerArray) {
        if (typeof value2 === "string" || typeof value2 === "number") {
          replacerSet.add(String(value2));
        }
      }
      return replacerSet;
    }
    __name(getUniqueReplacerSet, "getUniqueReplacerSet");
    function getStrictOption(options) {
      if (hasOwnProperty.call(options, "strict")) {
        const value2 = options.strict;
        if (typeof value2 !== "boolean") {
          throw new TypeError('The "strict" argument must be of type boolean');
        }
        if (value2) {
          return (value3) => {
            let message = `Object can not safely be stringified. Received type ${typeof value3}`;
            if (typeof value3 !== "function") message += ` (${value3.toString()})`;
            throw new Error(message);
          };
        }
      }
    }
    __name(getStrictOption, "getStrictOption");
    function configure(options) {
      options = {
        ...options
      };
      const fail = getStrictOption(options);
      if (fail) {
        if (options.bigint === void 0) {
          options.bigint = false;
        }
        if (!("circularValue" in options)) {
          options.circularValue = Error;
        }
      }
      const circularValue = getCircularValueOption(options);
      const bigint = getBooleanOption(options, "bigint");
      const deterministic = getDeterministicOption(options);
      const comparator = typeof deterministic === "function" ? deterministic : void 0;
      const maximumDepth = getPositiveIntegerOption(options, "maximumDepth");
      const maximumBreadth = getPositiveIntegerOption(options, "maximumBreadth");
      function stringifyFnReplacer(key, parent, stack, replacer, spacer, indentation) {
        let value2 = parent[key];
        if (typeof value2 === "object" && value2 !== null && typeof value2.toJSON === "function") {
          value2 = value2.toJSON(key);
        }
        value2 = replacer.call(parent, key, value2);
        switch (typeof value2) {
          case "string":
            return strEscape(value2);
          case "object": {
            if (value2 === null) {
              return "null";
            }
            if (stack.indexOf(value2) !== -1) {
              return circularValue;
            }
            let res = "";
            let join = ",";
            const originalIndentation = indentation;
            if (Array.isArray(value2)) {
              if (value2.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value2);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value2.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyFnReplacer(String(i), value2, stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyFnReplacer(String(i), value2, stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value2.length - 1 > maximumBreadth) {
                const removedKeys = value2.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value2);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let whitespace = "";
            let separator = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            const maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (deterministic && !isTypedArrayWithEntries(value2)) {
              keys = sort(keys, comparator);
            }
            stack.push(value2);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyFnReplacer(key2, value2, stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":${whitespace}"${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value2) ? String(value2) : fail ? fail(value2) : "null";
          case "boolean":
            return value2 === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value2);
            }
          // fallthrough
          default:
            return fail ? fail(value2) : void 0;
        }
      }
      __name(stringifyFnReplacer, "stringifyFnReplacer");
      function stringifyArrayReplacer(key, value2, stack, replacer, spacer, indentation) {
        if (typeof value2 === "object" && value2 !== null && typeof value2.toJSON === "function") {
          value2 = value2.toJSON(key);
        }
        switch (typeof value2) {
          case "string":
            return strEscape(value2);
          case "object": {
            if (value2 === null) {
              return "null";
            }
            if (stack.indexOf(value2) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            let res = "";
            let join = ",";
            if (Array.isArray(value2)) {
              if (value2.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value2);
              if (spacer !== "") {
                indentation += spacer;
                res += `
${indentation}`;
                join = `,
${indentation}`;
              }
              const maximumValuesToStringify = Math.min(value2.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyArrayReplacer(String(i), value2[i], stack, replacer, spacer, indentation);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += join;
              }
              const tmp = stringifyArrayReplacer(String(i), value2[i], stack, replacer, spacer, indentation);
              res += tmp !== void 0 ? tmp : "null";
              if (value2.length - 1 > maximumBreadth) {
                const removedKeys = value2.length - maximumBreadth - 1;
                res += `${join}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              if (spacer !== "") {
                res += `
${originalIndentation}`;
              }
              stack.pop();
              return `[${res}]`;
            }
            stack.push(value2);
            let whitespace = "";
            if (spacer !== "") {
              indentation += spacer;
              join = `,
${indentation}`;
              whitespace = " ";
            }
            let separator = "";
            for (const key2 of replacer) {
              const tmp = stringifyArrayReplacer(key2, value2[key2], stack, replacer, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${whitespace}${tmp}`;
                separator = join;
              }
            }
            if (spacer !== "" && separator.length > 1) {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value2) ? String(value2) : fail ? fail(value2) : "null";
          case "boolean":
            return value2 === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value2);
            }
          // fallthrough
          default:
            return fail ? fail(value2) : void 0;
        }
      }
      __name(stringifyArrayReplacer, "stringifyArrayReplacer");
      function stringifyIndent(key, value2, stack, spacer, indentation) {
        switch (typeof value2) {
          case "string":
            return strEscape(value2);
          case "object": {
            if (value2 === null) {
              return "null";
            }
            if (typeof value2.toJSON === "function") {
              value2 = value2.toJSON(key);
              if (typeof value2 !== "object") {
                return stringifyIndent(key, value2, stack, spacer, indentation);
              }
              if (value2 === null) {
                return "null";
              }
            }
            if (stack.indexOf(value2) !== -1) {
              return circularValue;
            }
            const originalIndentation = indentation;
            if (Array.isArray(value2)) {
              if (value2.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value2);
              indentation += spacer;
              let res2 = `
${indentation}`;
              const join2 = `,
${indentation}`;
              const maximumValuesToStringify = Math.min(value2.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifyIndent(String(i), value2[i], stack, spacer, indentation);
                res2 += tmp2 !== void 0 ? tmp2 : "null";
                res2 += join2;
              }
              const tmp = stringifyIndent(String(i), value2[i], stack, spacer, indentation);
              res2 += tmp !== void 0 ? tmp : "null";
              if (value2.length - 1 > maximumBreadth) {
                const removedKeys = value2.length - maximumBreadth - 1;
                res2 += `${join2}"... ${getItemCount(removedKeys)} not stringified"`;
              }
              res2 += `
${originalIndentation}`;
              stack.pop();
              return `[${res2}]`;
            }
            let keys = Object.keys(value2);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            indentation += spacer;
            const join = `,
${indentation}`;
            let res = "";
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (isTypedArrayWithEntries(value2)) {
              res += stringifyTypedArray(value2, join, maximumBreadth);
              keys = keys.slice(value2.length);
              maximumPropertiesToStringify -= value2.length;
              separator = join;
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value2);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifyIndent(key2, value2[key2], stack, spacer, indentation);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}: ${tmp}`;
                separator = join;
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...": "${getItemCount(removedKeys)} not stringified"`;
              separator = join;
            }
            if (separator !== "") {
              res = `
${indentation}${res}
${originalIndentation}`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value2) ? String(value2) : fail ? fail(value2) : "null";
          case "boolean":
            return value2 === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value2);
            }
          // fallthrough
          default:
            return fail ? fail(value2) : void 0;
        }
      }
      __name(stringifyIndent, "stringifyIndent");
      function stringifySimple(key, value2, stack) {
        switch (typeof value2) {
          case "string":
            return strEscape(value2);
          case "object": {
            if (value2 === null) {
              return "null";
            }
            if (typeof value2.toJSON === "function") {
              value2 = value2.toJSON(key);
              if (typeof value2 !== "object") {
                return stringifySimple(key, value2, stack);
              }
              if (value2 === null) {
                return "null";
              }
            }
            if (stack.indexOf(value2) !== -1) {
              return circularValue;
            }
            let res = "";
            const hasLength = value2.length !== void 0;
            if (hasLength && Array.isArray(value2)) {
              if (value2.length === 0) {
                return "[]";
              }
              if (maximumDepth < stack.length + 1) {
                return '"[Array]"';
              }
              stack.push(value2);
              const maximumValuesToStringify = Math.min(value2.length, maximumBreadth);
              let i = 0;
              for (; i < maximumValuesToStringify - 1; i++) {
                const tmp2 = stringifySimple(String(i), value2[i], stack);
                res += tmp2 !== void 0 ? tmp2 : "null";
                res += ",";
              }
              const tmp = stringifySimple(String(i), value2[i], stack);
              res += tmp !== void 0 ? tmp : "null";
              if (value2.length - 1 > maximumBreadth) {
                const removedKeys = value2.length - maximumBreadth - 1;
                res += `,"... ${getItemCount(removedKeys)} not stringified"`;
              }
              stack.pop();
              return `[${res}]`;
            }
            let keys = Object.keys(value2);
            const keyLength = keys.length;
            if (keyLength === 0) {
              return "{}";
            }
            if (maximumDepth < stack.length + 1) {
              return '"[Object]"';
            }
            let separator = "";
            let maximumPropertiesToStringify = Math.min(keyLength, maximumBreadth);
            if (hasLength && isTypedArrayWithEntries(value2)) {
              res += stringifyTypedArray(value2, ",", maximumBreadth);
              keys = keys.slice(value2.length);
              maximumPropertiesToStringify -= value2.length;
              separator = ",";
            }
            if (deterministic) {
              keys = sort(keys, comparator);
            }
            stack.push(value2);
            for (let i = 0; i < maximumPropertiesToStringify; i++) {
              const key2 = keys[i];
              const tmp = stringifySimple(key2, value2[key2], stack);
              if (tmp !== void 0) {
                res += `${separator}${strEscape(key2)}:${tmp}`;
                separator = ",";
              }
            }
            if (keyLength > maximumBreadth) {
              const removedKeys = keyLength - maximumBreadth;
              res += `${separator}"...":"${getItemCount(removedKeys)} not stringified"`;
            }
            stack.pop();
            return `{${res}}`;
          }
          case "number":
            return isFinite(value2) ? String(value2) : fail ? fail(value2) : "null";
          case "boolean":
            return value2 === true ? "true" : "false";
          case "undefined":
            return void 0;
          case "bigint":
            if (bigint) {
              return String(value2);
            }
          // fallthrough
          default:
            return fail ? fail(value2) : void 0;
        }
      }
      __name(stringifySimple, "stringifySimple");
      function stringify3(value2, replacer, space) {
        if (arguments.length > 1) {
          let spacer = "";
          if (typeof space === "number") {
            spacer = " ".repeat(Math.min(space, 10));
          } else if (typeof space === "string") {
            spacer = space.slice(0, 10);
          }
          if (replacer != null) {
            if (typeof replacer === "function") {
              return stringifyFnReplacer("", {
                "": value2
              }, [], replacer, spacer, "");
            }
            if (Array.isArray(replacer)) {
              return stringifyArrayReplacer("", value2, [], getUniqueReplacerSet(replacer), spacer, "");
            }
          }
          if (spacer.length !== 0) {
            return stringifyIndent("", value2, [], spacer, "");
          }
        }
        return stringifySimple("", value2, []);
      }
      __name(stringify3, "stringify");
      return stringify3;
    }
    __name(configure, "configure");
  }
});

// node_modules/logform/json.js
var require_json = __commonJS({
  "node_modules/logform/json.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    var { MESSAGE } = require_triple_beam();
    var stringify2 = require_safe_stable_stringify();
    function replacer(key, value2) {
      if (typeof value2 === "bigint") return value2.toString();
      return value2;
    }
    __name(replacer, "replacer");
    module2.exports = format5((info, opts) => {
      const jsonStringify = stringify2.configure(opts);
      info[MESSAGE] = jsonStringify(info, opts.replacer || replacer, opts.space);
      return info;
    });
  }
});

// node_modules/logform/label.js
var require_label = __commonJS({
  "node_modules/logform/label.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    module2.exports = format5((info, opts) => {
      if (opts.message) {
        info.message = `[${opts.label}] ${info.message}`;
        return info;
      }
      info.label = opts.label;
      return info;
    });
  }
});

// node_modules/logform/logstash.js
var require_logstash = __commonJS({
  "node_modules/logform/logstash.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format5((info) => {
      const logstash = {};
      if (info.message) {
        logstash["@message"] = info.message;
        delete info.message;
      }
      if (info.timestamp) {
        logstash["@timestamp"] = info.timestamp;
        delete info.timestamp;
      }
      logstash["@fields"] = info;
      info[MESSAGE] = jsonStringify(logstash);
      return info;
    });
  }
});

// node_modules/logform/metadata.js
var require_metadata = __commonJS({
  "node_modules/logform/metadata.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    function fillExcept(info, fillExceptKeys, metadataKey) {
      const savedKeys = fillExceptKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      const metadata = Object.keys(info).reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      Object.assign(info, savedKeys, {
        [metadataKey]: metadata
      });
      return info;
    }
    __name(fillExcept, "fillExcept");
    function fillWith(info, fillWithKeys, metadataKey) {
      info[metadataKey] = fillWithKeys.reduce((acc, key) => {
        acc[key] = info[key];
        delete info[key];
        return acc;
      }, {});
      return info;
    }
    __name(fillWith, "fillWith");
    module2.exports = format5((info, opts = {}) => {
      let metadataKey = "metadata";
      if (opts.key) {
        metadataKey = opts.key;
      }
      let fillExceptKeys = [];
      if (!opts.fillExcept && !opts.fillWith) {
        fillExceptKeys.push("level");
        fillExceptKeys.push("message");
      }
      if (opts.fillExcept) {
        fillExceptKeys = opts.fillExcept;
      }
      if (fillExceptKeys.length > 0) {
        return fillExcept(info, fillExceptKeys, metadataKey);
      }
      if (opts.fillWith) {
        return fillWith(info, opts.fillWith, metadataKey);
      }
      return info;
    });
  }
});

// node_modules/ms/index.js
var require_ms = __commonJS({
  "node_modules/ms/index.js"(exports2, module2) {
    "use strict";
    var s = 1e3;
    var m = s * 60;
    var h = m * 60;
    var d = h * 24;
    var w = d * 7;
    var y = d * 365.25;
    module2.exports = function(val, options) {
      options = options || {};
      var type = typeof val;
      if (type === "string" && val.length > 0) {
        return parse5(val);
      } else if (type === "number" && isFinite(val)) {
        return options.long ? fmtLong(val) : fmtShort(val);
      }
      throw new Error("val is not a non-empty string or a valid number. val=" + JSON.stringify(val));
    };
    function parse5(str) {
      str = String(str);
      if (str.length > 100) {
        return;
      }
      var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(str);
      if (!match) {
        return;
      }
      var n = parseFloat(match[1]);
      var type = (match[2] || "ms").toLowerCase();
      switch (type) {
        case "years":
        case "year":
        case "yrs":
        case "yr":
        case "y":
          return n * y;
        case "weeks":
        case "week":
        case "w":
          return n * w;
        case "days":
        case "day":
        case "d":
          return n * d;
        case "hours":
        case "hour":
        case "hrs":
        case "hr":
        case "h":
          return n * h;
        case "minutes":
        case "minute":
        case "mins":
        case "min":
        case "m":
          return n * m;
        case "seconds":
        case "second":
        case "secs":
        case "sec":
        case "s":
          return n * s;
        case "milliseconds":
        case "millisecond":
        case "msecs":
        case "msec":
        case "ms":
          return n;
        default:
          return void 0;
      }
    }
    __name(parse5, "parse");
    function fmtShort(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return Math.round(ms / d) + "d";
      }
      if (msAbs >= h) {
        return Math.round(ms / h) + "h";
      }
      if (msAbs >= m) {
        return Math.round(ms / m) + "m";
      }
      if (msAbs >= s) {
        return Math.round(ms / s) + "s";
      }
      return ms + "ms";
    }
    __name(fmtShort, "fmtShort");
    function fmtLong(ms) {
      var msAbs = Math.abs(ms);
      if (msAbs >= d) {
        return plural(ms, msAbs, d, "day");
      }
      if (msAbs >= h) {
        return plural(ms, msAbs, h, "hour");
      }
      if (msAbs >= m) {
        return plural(ms, msAbs, m, "minute");
      }
      if (msAbs >= s) {
        return plural(ms, msAbs, s, "second");
      }
      return ms + " ms";
    }
    __name(fmtLong, "fmtLong");
    function plural(ms, msAbs, n, name) {
      var isPlural = msAbs >= n * 1.5;
      return Math.round(ms / n) + " " + name + (isPlural ? "s" : "");
    }
    __name(plural, "plural");
  }
});

// node_modules/logform/ms.js
var require_ms2 = __commonJS({
  "node_modules/logform/ms.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    var ms = require_ms();
    module2.exports = format5((info) => {
      const curr = +/* @__PURE__ */ new Date();
      exports2.diff = curr - (exports2.prevTime || curr);
      exports2.prevTime = curr;
      info.ms = `+${ms(exports2.diff)}`;
      return info;
    });
  }
});

// node_modules/logform/pretty-print.js
var require_pretty_print = __commonJS({
  "node_modules/logform/pretty-print.js"(exports2, module2) {
    "use strict";
    var inspect2 = require("util").inspect;
    var format5 = require_format();
    var { LEVEL, MESSAGE, SPLAT } = require_triple_beam();
    module2.exports = format5((info, opts = {}) => {
      const stripped = Object.assign({}, info);
      delete stripped[LEVEL];
      delete stripped[MESSAGE];
      delete stripped[SPLAT];
      info[MESSAGE] = inspect2(stripped, false, opts.depth || null, opts.colorize);
      return info;
    });
  }
});

// node_modules/logform/printf.js
var require_printf = __commonJS({
  "node_modules/logform/printf.js"(exports2, module2) {
    "use strict";
    var { MESSAGE } = require_triple_beam();
    var Printf = class Printf {
      static {
        __name(this, "Printf");
      }
      constructor(templateFn) {
        this.template = templateFn;
      }
      transform(info) {
        info[MESSAGE] = this.template(info);
        return info;
      }
    };
    module2.exports = (opts) => new Printf(opts);
    module2.exports.Printf = module2.exports.Format = Printf;
  }
});

// node_modules/logform/simple.js
var require_simple = __commonJS({
  "node_modules/logform/simple.js"(exports2, module2) {
    "use strict";
    var format5 = require_format();
    var { MESSAGE } = require_triple_beam();
    var jsonStringify = require_safe_stable_stringify();
    module2.exports = format5((info) => {
      const stringifiedRest = jsonStringify(Object.assign({}, info, {
        level: void 0,
        message: void 0,
        splat: void 0
      }));
      const padding = info.padding && info.padding[info.level] || "";
      if (stringifiedRest !== "{}") {
        info[MESSAGE] = `${info.level}:${padding} ${info.message} ${stringifiedRest}`;
      } else {
        info[MESSAGE] = `${info.level}:${padding} ${info.message}`;
      }
      return info;
    });
  }
});

// node_modules/logform/splat.js
var require_splat = __commonJS({
  "node_modules/logform/splat.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var { SPLAT } = require_triple_beam();
    var formatRegExp = /%[scdjifoO%]/g;
    var escapedPercent = /%%/g;
    var Splatter = class Splatter {
      static {
        __name(this, "Splatter");
      }
      constructor(opts) {
        this.options = opts;
      }
      /**
       * Check to see if tokens <= splat.length, assign { splat, meta } into the
       * `info` accordingly, and write to this instance.
       *
       * @param  {Info} info Logform info message.
       * @param  {String[]} tokens Set of string interpolation tokens.
       * @returns {Info} Modified info message
       * @private
       */
      _splat(info, tokens) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat || [];
        const percents = msg.match(escapedPercent);
        const escapes = percents && percents.length || 0;
        const expectedSplat = tokens.length - escapes;
        const extraSplat = expectedSplat - splat.length;
        const metas = extraSplat < 0 ? splat.splice(extraSplat, -1 * extraSplat) : [];
        const metalen = metas.length;
        if (metalen) {
          for (let i = 0; i < metalen; i++) {
            Object.assign(info, metas[i]);
          }
        }
        info.message = util2.format(msg, ...splat);
        return info;
      }
      /**
      * Transforms the `info` message by using `util.format` to complete
      * any `info.message` provided it has string interpolation tokens.
      * If no tokens exist then `info` is immutable.
      *
      * @param  {Info} info Logform info message.
      * @param  {Object} opts Options for this instance.
      * @returns {Info} Modified info message
      */
      transform(info) {
        const msg = info.message;
        const splat = info[SPLAT] || info.splat;
        if (!splat || !splat.length) {
          return info;
        }
        const tokens = msg && msg.match && msg.match(formatRegExp);
        if (!tokens && (splat || splat.length)) {
          const metas = splat.length > 1 ? splat.splice(0) : splat;
          const metalen = metas.length;
          if (metalen) {
            for (let i = 0; i < metalen; i++) {
              Object.assign(info, metas[i]);
            }
          }
          return info;
        }
        if (tokens) {
          return this._splat(info, tokens);
        }
        return info;
      }
    };
    module2.exports = (opts) => new Splatter(opts);
  }
});

// node_modules/fecha/lib/fecha.js
var fecha_exports = {};
__export(fecha_exports, {
  assign: () => assign,
  default: () => fecha_default,
  defaultI18n: () => defaultI18n,
  format: () => format3,
  parse: () => parse,
  setGlobalDateI18n: () => setGlobalDateI18n,
  setGlobalDateMasks: () => setGlobalDateMasks
});
function shorten(arr, sLen) {
  var newArr = [];
  for (var i = 0, len = arr.length; i < len; i++) {
    newArr.push(arr[i].substr(0, sLen));
  }
  return newArr;
}
function assign(origObj) {
  var args = [];
  for (var _i = 1; _i < arguments.length; _i++) {
    args[_i - 1] = arguments[_i];
  }
  for (var _a2 = 0, args_1 = args; _a2 < args_1.length; _a2++) {
    var obj = args_1[_a2];
    for (var key in obj) {
      origObj[key] = obj[key];
    }
  }
  return origObj;
}
function parse(dateStr, format5, i18n) {
  if (i18n === void 0) {
    i18n = {};
  }
  if (typeof format5 !== "string") {
    throw new Error("Invalid format in fecha parse");
  }
  format5 = globalMasks[format5] || format5;
  if (dateStr.length > 1e3) {
    return null;
  }
  var today = /* @__PURE__ */ new Date();
  var dateInfo = {
    year: today.getFullYear(),
    month: 0,
    day: 1,
    hour: 0,
    minute: 0,
    second: 0,
    millisecond: 0,
    isPm: null,
    timezoneOffset: null
  };
  var parseInfo = [];
  var literals = [];
  var newFormat = format5.replace(literal, function($0, $1) {
    literals.push(regexEscape($1));
    return "@@@";
  });
  var specifiedFields = {};
  var requiredFields = {};
  newFormat = regexEscape(newFormat).replace(token, function($0) {
    var info = parseFlags[$0];
    var field2 = info[0], regex = info[1], requiredField = info[3];
    if (specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " specified twice in format");
    }
    specifiedFields[field2] = true;
    if (requiredField) {
      requiredFields[requiredField] = true;
    }
    parseInfo.push(info);
    return "(" + regex + ")";
  });
  Object.keys(requiredFields).forEach(function(field2) {
    if (!specifiedFields[field2]) {
      throw new Error("Invalid format. " + field2 + " is required in specified format");
    }
  });
  newFormat = newFormat.replace(/@@@/g, function() {
    return literals.shift();
  });
  var matches = dateStr.match(new RegExp(newFormat, "i"));
  if (!matches) {
    return null;
  }
  var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
  for (var i = 1; i < matches.length; i++) {
    var _a2 = parseInfo[i - 1], field = _a2[0], parser2 = _a2[2];
    var value2 = parser2 ? parser2(matches[i], combinedI18nSettings) : +matches[i];
    if (value2 == null) {
      return null;
    }
    dateInfo[field] = value2;
  }
  if (dateInfo.isPm === 1 && dateInfo.hour != null && +dateInfo.hour !== 12) {
    dateInfo.hour = +dateInfo.hour + 12;
  } else if (dateInfo.isPm === 0 && +dateInfo.hour === 12) {
    dateInfo.hour = 0;
  }
  var dateTZ;
  if (dateInfo.timezoneOffset == null) {
    dateTZ = new Date(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute, dateInfo.second, dateInfo.millisecond);
    var validateFields = [
      [
        "month",
        "getMonth"
      ],
      [
        "day",
        "getDate"
      ],
      [
        "hour",
        "getHours"
      ],
      [
        "minute",
        "getMinutes"
      ],
      [
        "second",
        "getSeconds"
      ]
    ];
    for (var i = 0, len = validateFields.length; i < len; i++) {
      if (specifiedFields[validateFields[i][0]] && dateInfo[validateFields[i][0]] !== dateTZ[validateFields[i][1]]()) {
        return null;
      }
    }
  } else {
    dateTZ = new Date(Date.UTC(dateInfo.year, dateInfo.month, dateInfo.day, dateInfo.hour, dateInfo.minute - dateInfo.timezoneOffset, dateInfo.second, dateInfo.millisecond));
    if (dateInfo.month > 11 || dateInfo.month < 0 || dateInfo.day > 31 || dateInfo.day < 1 || dateInfo.hour > 23 || dateInfo.hour < 0 || dateInfo.minute > 59 || dateInfo.minute < 0 || dateInfo.second > 59 || dateInfo.second < 0) {
      return null;
    }
  }
  return dateTZ;
}
var token, twoDigitsOptional, twoDigits, threeDigits, fourDigits, word, literal, monthUpdate, dayNames, monthNames, monthNamesShort, dayNamesShort, defaultI18n, globalI18n, setGlobalDateI18n, regexEscape, pad, formatFlags, monthParse, emptyDigits, emptyWord, amPm, timezoneOffset, parseFlags, globalMasks, setGlobalDateMasks, format3, fecha, fecha_default;
var init_fecha = __esm({
  "node_modules/fecha/lib/fecha.js"() {
    "use strict";
    token = /d{1,4}|M{1,4}|YY(?:YY)?|S{1,3}|Do|ZZ|Z|([HhMsDm])\1?|[aA]|"[^"]*"|'[^']*'/g;
    twoDigitsOptional = "\\d\\d?";
    twoDigits = "\\d\\d";
    threeDigits = "\\d{3}";
    fourDigits = "\\d{4}";
    word = "[^\\s]+";
    literal = /\[([^]*?)\]/gm;
    __name(shorten, "shorten");
    monthUpdate = /* @__PURE__ */ __name(function(arrName) {
      return function(v, i18n) {
        var lowerCaseArr = i18n[arrName].map(function(v2) {
          return v2.toLowerCase();
        });
        var index = lowerCaseArr.indexOf(v.toLowerCase());
        if (index > -1) {
          return index;
        }
        return null;
      };
    }, "monthUpdate");
    __name(assign, "assign");
    dayNames = [
      "Sunday",
      "Monday",
      "Tuesday",
      "Wednesday",
      "Thursday",
      "Friday",
      "Saturday"
    ];
    monthNames = [
      "January",
      "February",
      "March",
      "April",
      "May",
      "June",
      "July",
      "August",
      "September",
      "October",
      "November",
      "December"
    ];
    monthNamesShort = shorten(monthNames, 3);
    dayNamesShort = shorten(dayNames, 3);
    defaultI18n = {
      dayNamesShort,
      dayNames,
      monthNamesShort,
      monthNames,
      amPm: [
        "am",
        "pm"
      ],
      DoFn: /* @__PURE__ */ __name(function(dayOfMonth) {
        return dayOfMonth + [
          "th",
          "st",
          "nd",
          "rd"
        ][dayOfMonth % 10 > 3 ? 0 : (dayOfMonth - dayOfMonth % 10 !== 10 ? 1 : 0) * dayOfMonth % 10];
      }, "DoFn")
    };
    globalI18n = assign({}, defaultI18n);
    setGlobalDateI18n = /* @__PURE__ */ __name(function(i18n) {
      return globalI18n = assign(globalI18n, i18n);
    }, "setGlobalDateI18n");
    regexEscape = /* @__PURE__ */ __name(function(str) {
      return str.replace(/[|\\{()[^$+*?.-]/g, "\\$&");
    }, "regexEscape");
    pad = /* @__PURE__ */ __name(function(val, len) {
      if (len === void 0) {
        len = 2;
      }
      val = String(val);
      while (val.length < len) {
        val = "0" + val;
      }
      return val;
    }, "pad");
    formatFlags = {
      D: /* @__PURE__ */ __name(function(dateObj) {
        return String(dateObj.getDate());
      }, "D"),
      DD: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getDate());
      }, "DD"),
      Do: /* @__PURE__ */ __name(function(dateObj, i18n) {
        return i18n.DoFn(dateObj.getDate());
      }, "Do"),
      d: /* @__PURE__ */ __name(function(dateObj) {
        return String(dateObj.getDay());
      }, "d"),
      dd: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getDay());
      }, "dd"),
      ddd: /* @__PURE__ */ __name(function(dateObj, i18n) {
        return i18n.dayNamesShort[dateObj.getDay()];
      }, "ddd"),
      dddd: /* @__PURE__ */ __name(function(dateObj, i18n) {
        return i18n.dayNames[dateObj.getDay()];
      }, "dddd"),
      M: /* @__PURE__ */ __name(function(dateObj) {
        return String(dateObj.getMonth() + 1);
      }, "M"),
      MM: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getMonth() + 1);
      }, "MM"),
      MMM: /* @__PURE__ */ __name(function(dateObj, i18n) {
        return i18n.monthNamesShort[dateObj.getMonth()];
      }, "MMM"),
      MMMM: /* @__PURE__ */ __name(function(dateObj, i18n) {
        return i18n.monthNames[dateObj.getMonth()];
      }, "MMMM"),
      YY: /* @__PURE__ */ __name(function(dateObj) {
        return pad(String(dateObj.getFullYear()), 4).substr(2);
      }, "YY"),
      YYYY: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getFullYear(), 4);
      }, "YYYY"),
      h: /* @__PURE__ */ __name(function(dateObj) {
        return String(dateObj.getHours() % 12 || 12);
      }, "h"),
      hh: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getHours() % 12 || 12);
      }, "hh"),
      H: /* @__PURE__ */ __name(function(dateObj) {
        return String(dateObj.getHours());
      }, "H"),
      HH: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getHours());
      }, "HH"),
      m: /* @__PURE__ */ __name(function(dateObj) {
        return String(dateObj.getMinutes());
      }, "m"),
      mm: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getMinutes());
      }, "mm"),
      s: /* @__PURE__ */ __name(function(dateObj) {
        return String(dateObj.getSeconds());
      }, "s"),
      ss: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getSeconds());
      }, "ss"),
      S: /* @__PURE__ */ __name(function(dateObj) {
        return String(Math.round(dateObj.getMilliseconds() / 100));
      }, "S"),
      SS: /* @__PURE__ */ __name(function(dateObj) {
        return pad(Math.round(dateObj.getMilliseconds() / 10), 2);
      }, "SS"),
      SSS: /* @__PURE__ */ __name(function(dateObj) {
        return pad(dateObj.getMilliseconds(), 3);
      }, "SSS"),
      a: /* @__PURE__ */ __name(function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0] : i18n.amPm[1];
      }, "a"),
      A: /* @__PURE__ */ __name(function(dateObj, i18n) {
        return dateObj.getHours() < 12 ? i18n.amPm[0].toUpperCase() : i18n.amPm[1].toUpperCase();
      }, "A"),
      ZZ: /* @__PURE__ */ __name(function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60) * 100 + Math.abs(offset) % 60, 4);
      }, "ZZ"),
      Z: /* @__PURE__ */ __name(function(dateObj) {
        var offset = dateObj.getTimezoneOffset();
        return (offset > 0 ? "-" : "+") + pad(Math.floor(Math.abs(offset) / 60), 2) + ":" + pad(Math.abs(offset) % 60, 2);
      }, "Z")
    };
    monthParse = /* @__PURE__ */ __name(function(v) {
      return +v - 1;
    }, "monthParse");
    emptyDigits = [
      null,
      twoDigitsOptional
    ];
    emptyWord = [
      null,
      word
    ];
    amPm = [
      "isPm",
      word,
      function(v, i18n) {
        var val = v.toLowerCase();
        if (val === i18n.amPm[0]) {
          return 0;
        } else if (val === i18n.amPm[1]) {
          return 1;
        }
        return null;
      }
    ];
    timezoneOffset = [
      "timezoneOffset",
      "[^\\s]*?[\\+\\-]\\d\\d:?\\d\\d|[^\\s]*?Z?",
      function(v) {
        var parts2 = (v + "").match(/([+-]|\d\d)/gi);
        if (parts2) {
          var minutes = +parts2[1] * 60 + parseInt(parts2[2], 10);
          return parts2[0] === "+" ? minutes : -minutes;
        }
        return 0;
      }
    ];
    parseFlags = {
      D: [
        "day",
        twoDigitsOptional
      ],
      DD: [
        "day",
        twoDigits
      ],
      Do: [
        "day",
        twoDigitsOptional + word,
        function(v) {
          return parseInt(v, 10);
        }
      ],
      M: [
        "month",
        twoDigitsOptional,
        monthParse
      ],
      MM: [
        "month",
        twoDigits,
        monthParse
      ],
      YY: [
        "year",
        twoDigits,
        function(v) {
          var now = /* @__PURE__ */ new Date();
          var cent = +("" + now.getFullYear()).substr(0, 2);
          return +("" + (+v > 68 ? cent - 1 : cent) + v);
        }
      ],
      h: [
        "hour",
        twoDigitsOptional,
        void 0,
        "isPm"
      ],
      hh: [
        "hour",
        twoDigits,
        void 0,
        "isPm"
      ],
      H: [
        "hour",
        twoDigitsOptional
      ],
      HH: [
        "hour",
        twoDigits
      ],
      m: [
        "minute",
        twoDigitsOptional
      ],
      mm: [
        "minute",
        twoDigits
      ],
      s: [
        "second",
        twoDigitsOptional
      ],
      ss: [
        "second",
        twoDigits
      ],
      YYYY: [
        "year",
        fourDigits
      ],
      S: [
        "millisecond",
        "\\d",
        function(v) {
          return +v * 100;
        }
      ],
      SS: [
        "millisecond",
        twoDigits,
        function(v) {
          return +v * 10;
        }
      ],
      SSS: [
        "millisecond",
        threeDigits
      ],
      d: emptyDigits,
      dd: emptyDigits,
      ddd: emptyWord,
      dddd: emptyWord,
      MMM: [
        "month",
        word,
        monthUpdate("monthNamesShort")
      ],
      MMMM: [
        "month",
        word,
        monthUpdate("monthNames")
      ],
      a: amPm,
      A: amPm,
      ZZ: timezoneOffset,
      Z: timezoneOffset
    };
    globalMasks = {
      default: "ddd MMM DD YYYY HH:mm:ss",
      shortDate: "M/D/YY",
      mediumDate: "MMM D, YYYY",
      longDate: "MMMM D, YYYY",
      fullDate: "dddd, MMMM D, YYYY",
      isoDate: "YYYY-MM-DD",
      isoDateTime: "YYYY-MM-DDTHH:mm:ssZ",
      shortTime: "HH:mm",
      mediumTime: "HH:mm:ss",
      longTime: "HH:mm:ss.SSS"
    };
    setGlobalDateMasks = /* @__PURE__ */ __name(function(masks) {
      return assign(globalMasks, masks);
    }, "setGlobalDateMasks");
    format3 = /* @__PURE__ */ __name(function(dateObj, mask, i18n) {
      if (mask === void 0) {
        mask = globalMasks["default"];
      }
      if (i18n === void 0) {
        i18n = {};
      }
      if (typeof dateObj === "number") {
        dateObj = new Date(dateObj);
      }
      if (Object.prototype.toString.call(dateObj) !== "[object Date]" || isNaN(dateObj.getTime())) {
        throw new Error("Invalid Date pass to format");
      }
      mask = globalMasks[mask] || mask;
      var literals = [];
      mask = mask.replace(literal, function($0, $1) {
        literals.push($1);
        return "@@@";
      });
      var combinedI18nSettings = assign(assign({}, globalI18n), i18n);
      mask = mask.replace(token, function($0) {
        return formatFlags[$0](dateObj, combinedI18nSettings);
      });
      return mask.replace(/@@@/g, function() {
        return literals.shift();
      });
    }, "format");
    __name(parse, "parse");
    fecha = {
      format: format3,
      parse,
      defaultI18n,
      setGlobalDateI18n,
      setGlobalDateMasks
    };
    fecha_default = fecha;
  }
});

// node_modules/logform/timestamp.js
var require_timestamp = __commonJS({
  "node_modules/logform/timestamp.js"(exports2, module2) {
    "use strict";
    var fecha2 = (init_fecha(), __toCommonJS(fecha_exports));
    var format5 = require_format();
    module2.exports = format5((info, opts = {}) => {
      if (opts.format) {
        info.timestamp = typeof opts.format === "function" ? opts.format() : fecha2.format(/* @__PURE__ */ new Date(), opts.format);
      }
      if (!info.timestamp) {
        info.timestamp = (/* @__PURE__ */ new Date()).toISOString();
      }
      if (opts.alias) {
        info[opts.alias] = info.timestamp;
      }
      return info;
    });
  }
});

// node_modules/logform/uncolorize.js
var require_uncolorize = __commonJS({
  "node_modules/logform/uncolorize.js"(exports2, module2) {
    "use strict";
    var colors = require_safe();
    var format5 = require_format();
    var { MESSAGE } = require_triple_beam();
    module2.exports = format5((info, opts) => {
      if (opts.level !== false) {
        info.level = colors.strip(info.level);
      }
      if (opts.message !== false) {
        info.message = colors.strip(String(info.message));
      }
      if (opts.raw !== false && info[MESSAGE]) {
        info[MESSAGE] = colors.strip(String(info[MESSAGE]));
      }
      return info;
    });
  }
});

// node_modules/logform/index.js
var require_logform = __commonJS({
  "node_modules/logform/index.js"(exports2) {
    "use strict";
    var format5 = exports2.format = require_format();
    exports2.levels = require_levels();
    function exposeFormat(name, requireFormat) {
      Object.defineProperty(format5, name, {
        get() {
          return requireFormat();
        },
        configurable: true
      });
    }
    __name(exposeFormat, "exposeFormat");
    exposeFormat("align", function() {
      return require_align();
    });
    exposeFormat("errors", function() {
      return require_errors();
    });
    exposeFormat("cli", function() {
      return require_cli2();
    });
    exposeFormat("combine", function() {
      return require_combine();
    });
    exposeFormat("colorize", function() {
      return require_colorize();
    });
    exposeFormat("json", function() {
      return require_json();
    });
    exposeFormat("label", function() {
      return require_label();
    });
    exposeFormat("logstash", function() {
      return require_logstash();
    });
    exposeFormat("metadata", function() {
      return require_metadata();
    });
    exposeFormat("ms", function() {
      return require_ms2();
    });
    exposeFormat("padLevels", function() {
      return require_pad_levels();
    });
    exposeFormat("prettyPrint", function() {
      return require_pretty_print();
    });
    exposeFormat("printf", function() {
      return require_printf();
    });
    exposeFormat("simple", function() {
      return require_simple();
    });
    exposeFormat("splat", function() {
      return require_splat();
    });
    exposeFormat("timestamp", function() {
      return require_timestamp();
    });
    exposeFormat("uncolorize", function() {
      return require_uncolorize();
    });
  }
});

// node_modules/winston/lib/winston/common.js
var require_common = __commonJS({
  "node_modules/winston/lib/winston/common.js"(exports2) {
    "use strict";
    var { format: format5 } = require("util");
    exports2.warn = {
      deprecated(prop) {
        return () => {
          throw new Error(format5("{ %s } was removed in winston@3.0.0.", prop));
        };
      },
      useFormat(prop) {
        return () => {
          throw new Error([
            format5("{ %s } was removed in winston@3.0.0.", prop),
            "Use a custom winston.format = winston.format(function) instead."
          ].join("\n"));
        };
      },
      forFunctions(obj, type, props) {
        props.forEach((prop) => {
          obj[prop] = exports2.warn[type](prop);
        });
      },
      forProperties(obj, type, props) {
        props.forEach((prop) => {
          const notice = exports2.warn[type](prop);
          Object.defineProperty(obj, prop, {
            get: notice,
            set: notice
          });
        });
      }
    };
  }
});

// node_modules/winston/package.json
var require_package = __commonJS({
  "node_modules/winston/package.json"(exports2, module2) {
    module2.exports = {
      name: "winston",
      description: "A logger for just about everything.",
      version: "3.17.0",
      author: "Charlie Robbins <charlie.robbins@gmail.com>",
      maintainers: [
        "David Hyde <dabh@alumni.stanford.edu>"
      ],
      repository: {
        type: "git",
        url: "https://github.com/winstonjs/winston.git"
      },
      keywords: [
        "winston",
        "logger",
        "logging",
        "logs",
        "sysadmin",
        "bunyan",
        "pino",
        "loglevel",
        "tools",
        "json",
        "stream"
      ],
      dependencies: {
        "@dabh/diagnostics": "^2.0.2",
        "@colors/colors": "^1.6.0",
        async: "^3.2.3",
        "is-stream": "^2.0.0",
        logform: "^2.7.0",
        "one-time": "^1.0.0",
        "readable-stream": "^3.4.0",
        "safe-stable-stringify": "^2.3.1",
        "stack-trace": "0.0.x",
        "triple-beam": "^1.3.0",
        "winston-transport": "^4.9.0"
      },
      devDependencies: {
        "@babel/cli": "^7.23.9",
        "@babel/core": "^7.24.0",
        "@babel/preset-env": "^7.24.0",
        "@dabh/eslint-config-populist": "^4.4.0",
        "@types/node": "^20.11.24",
        "abstract-winston-transport": "^0.5.1",
        assume: "^2.2.0",
        "cross-spawn-async": "^2.2.5",
        eslint: "^8.57.0",
        hock: "^1.4.1",
        mocha: "^10.3.0",
        nyc: "^17.1.0",
        rimraf: "5.0.1",
        split2: "^4.1.0",
        "std-mocks": "^2.0.0",
        through2: "^4.0.2",
        "winston-compat": "^0.1.5"
      },
      main: "./lib/winston.js",
      browser: "./dist/winston",
      types: "./index.d.ts",
      scripts: {
        lint: "eslint lib/*.js lib/winston/*.js lib/winston/**/*.js --resolve-plugins-relative-to ./node_modules/@dabh/eslint-config-populist",
        test: "rimraf test/fixtures/logs/* && mocha",
        "test:coverage": "nyc npm run test:unit",
        "test:unit": "mocha test/unit",
        "test:integration": "mocha test/integration",
        build: "rimraf dist && babel lib -d dist",
        prepublishOnly: "npm run build"
      },
      engines: {
        node: ">= 12.0.0"
      },
      license: "MIT"
    };
  }
});

// node_modules/util-deprecate/node.js
var require_node = __commonJS({
  "node_modules/util-deprecate/node.js"(exports2, module2) {
    "use strict";
    module2.exports = require("util").deprecate;
  }
});

// node_modules/readable-stream/lib/internal/streams/stream.js
var require_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/stream.js"(exports2, module2) {
    "use strict";
    module2.exports = require("stream");
  }
});

// node_modules/readable-stream/lib/internal/streams/destroy.js
var require_destroy = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/destroy.js"(exports2, module2) {
    "use strict";
    function destroy(err, cb) {
      var _this = this;
      var readableDestroyed = this._readableState && this._readableState.destroyed;
      var writableDestroyed = this._writableState && this._writableState.destroyed;
      if (readableDestroyed || writableDestroyed) {
        if (cb) {
          cb(err);
        } else if (err) {
          if (!this._writableState) {
            process.nextTick(emitErrorNT, this, err);
          } else if (!this._writableState.errorEmitted) {
            this._writableState.errorEmitted = true;
            process.nextTick(emitErrorNT, this, err);
          }
        }
        return this;
      }
      if (this._readableState) {
        this._readableState.destroyed = true;
      }
      if (this._writableState) {
        this._writableState.destroyed = true;
      }
      this._destroy(err || null, function(err2) {
        if (!cb && err2) {
          if (!_this._writableState) {
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else if (!_this._writableState.errorEmitted) {
            _this._writableState.errorEmitted = true;
            process.nextTick(emitErrorAndCloseNT, _this, err2);
          } else {
            process.nextTick(emitCloseNT, _this);
          }
        } else if (cb) {
          process.nextTick(emitCloseNT, _this);
          cb(err2);
        } else {
          process.nextTick(emitCloseNT, _this);
        }
      });
      return this;
    }
    __name(destroy, "destroy");
    function emitErrorAndCloseNT(self2, err) {
      emitErrorNT(self2, err);
      emitCloseNT(self2);
    }
    __name(emitErrorAndCloseNT, "emitErrorAndCloseNT");
    function emitCloseNT(self2) {
      if (self2._writableState && !self2._writableState.emitClose) return;
      if (self2._readableState && !self2._readableState.emitClose) return;
      self2.emit("close");
    }
    __name(emitCloseNT, "emitCloseNT");
    function undestroy() {
      if (this._readableState) {
        this._readableState.destroyed = false;
        this._readableState.reading = false;
        this._readableState.ended = false;
        this._readableState.endEmitted = false;
      }
      if (this._writableState) {
        this._writableState.destroyed = false;
        this._writableState.ended = false;
        this._writableState.ending = false;
        this._writableState.finalCalled = false;
        this._writableState.prefinished = false;
        this._writableState.finished = false;
        this._writableState.errorEmitted = false;
      }
    }
    __name(undestroy, "undestroy");
    function emitErrorNT(self2, err) {
      self2.emit("error", err);
    }
    __name(emitErrorNT, "emitErrorNT");
    function errorOrDestroy(stream, err) {
      var rState = stream._readableState;
      var wState = stream._writableState;
      if (rState && rState.autoDestroy || wState && wState.autoDestroy) stream.destroy(err);
      else stream.emit("error", err);
    }
    __name(errorOrDestroy, "errorOrDestroy");
    module2.exports = {
      destroy,
      undestroy,
      errorOrDestroy
    };
  }
});

// node_modules/readable-stream/errors.js
var require_errors2 = __commonJS({
  "node_modules/readable-stream/errors.js"(exports2, module2) {
    "use strict";
    var codes = {};
    function createErrorType(code, message, Base2) {
      if (!Base2) {
        Base2 = Error;
      }
      function getMessage(arg1, arg2, arg3) {
        if (typeof message === "string") {
          return message;
        } else {
          return message(arg1, arg2, arg3);
        }
      }
      __name(getMessage, "getMessage");
      let NodeError = class NodeError extends Base2 {
        static {
          __name(this, "NodeError");
        }
        constructor(arg1, arg2, arg3) {
          super(getMessage(arg1, arg2, arg3));
        }
      };
      NodeError.prototype.name = Base2.name;
      NodeError.prototype.code = code;
      codes[code] = NodeError;
    }
    __name(createErrorType, "createErrorType");
    function oneOf(expected, thing) {
      if (Array.isArray(expected)) {
        const len = expected.length;
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        } else {
          return `of ${thing} ${expected[0]}`;
        }
      } else {
        return `of ${thing} ${String(expected)}`;
      }
    }
    __name(oneOf, "oneOf");
    function startsWith(str, search, pos) {
      return str.substr(!pos || pos < 0 ? 0 : +pos, search.length) === search;
    }
    __name(startsWith, "startsWith");
    function endsWith(str, search, this_len) {
      if (this_len === void 0 || this_len > str.length) {
        this_len = str.length;
      }
      return str.substring(this_len - search.length, this_len) === search;
    }
    __name(endsWith, "endsWith");
    function includes(str, search, start) {
      if (typeof start !== "number") {
        start = 0;
      }
      if (start + search.length > str.length) {
        return false;
      } else {
        return str.indexOf(search, start) !== -1;
      }
    }
    __name(includes, "includes");
    createErrorType("ERR_INVALID_OPT_VALUE", function(name, value2) {
      return 'The value "' + value2 + '" is invalid for option "' + name + '"';
    }, TypeError);
    createErrorType("ERR_INVALID_ARG_TYPE", function(name, expected, actual) {
      let determiner;
      if (typeof expected === "string" && startsWith(expected, "not ")) {
        determiner = "must not be";
        expected = expected.replace(/^not /, "");
      } else {
        determiner = "must be";
      }
      let msg;
      if (endsWith(name, " argument")) {
        msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
      } else {
        const type = includes(name, ".") ? "property" : "argument";
        msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
      }
      msg += `. Received type ${typeof actual}`;
      return msg;
    }, TypeError);
    createErrorType("ERR_STREAM_PUSH_AFTER_EOF", "stream.push() after EOF");
    createErrorType("ERR_METHOD_NOT_IMPLEMENTED", function(name) {
      return "The " + name + " method is not implemented";
    });
    createErrorType("ERR_STREAM_PREMATURE_CLOSE", "Premature close");
    createErrorType("ERR_STREAM_DESTROYED", function(name) {
      return "Cannot call " + name + " after a stream was destroyed";
    });
    createErrorType("ERR_MULTIPLE_CALLBACK", "Callback called multiple times");
    createErrorType("ERR_STREAM_CANNOT_PIPE", "Cannot pipe, not readable");
    createErrorType("ERR_STREAM_WRITE_AFTER_END", "write after end");
    createErrorType("ERR_STREAM_NULL_VALUES", "May not write null values to stream", TypeError);
    createErrorType("ERR_UNKNOWN_ENCODING", function(arg) {
      return "Unknown encoding: " + arg;
    }, TypeError);
    createErrorType("ERR_STREAM_UNSHIFT_AFTER_END_EVENT", "stream.unshift() after end event");
    module2.exports.codes = codes;
  }
});

// node_modules/readable-stream/lib/internal/streams/state.js
var require_state = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/state.js"(exports2, module2) {
    "use strict";
    var ERR_INVALID_OPT_VALUE = require_errors2().codes.ERR_INVALID_OPT_VALUE;
    function highWaterMarkFrom(options, isDuplex, duplexKey) {
      return options.highWaterMark != null ? options.highWaterMark : isDuplex ? options[duplexKey] : null;
    }
    __name(highWaterMarkFrom, "highWaterMarkFrom");
    function getHighWaterMark(state, options, duplexKey, isDuplex) {
      var hwm = highWaterMarkFrom(options, isDuplex, duplexKey);
      if (hwm != null) {
        if (!(isFinite(hwm) && Math.floor(hwm) === hwm) || hwm < 0) {
          var name = isDuplex ? duplexKey : "highWaterMark";
          throw new ERR_INVALID_OPT_VALUE(name, hwm);
        }
        return Math.floor(hwm);
      }
      return state.objectMode ? 16 : 16 * 1024;
    }
    __name(getHighWaterMark, "getHighWaterMark");
    module2.exports = {
      getHighWaterMark
    };
  }
});

// node_modules/inherits/inherits_browser.js
var require_inherits_browser = __commonJS({
  "node_modules/inherits/inherits_browser.js"(exports2, module2) {
    "use strict";
    if (typeof Object.create === "function") {
      module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          ctor.prototype = Object.create(superCtor.prototype, {
            constructor: {
              value: ctor,
              enumerable: false,
              writable: true,
              configurable: true
            }
          });
        }
      }, "inherits");
    } else {
      module2.exports = /* @__PURE__ */ __name(function inherits(ctor, superCtor) {
        if (superCtor) {
          ctor.super_ = superCtor;
          var TempCtor = /* @__PURE__ */ __name(function() {
          }, "TempCtor");
          TempCtor.prototype = superCtor.prototype;
          ctor.prototype = new TempCtor();
          ctor.prototype.constructor = ctor;
        }
      }, "inherits");
    }
  }
});

// node_modules/inherits/inherits.js
var require_inherits = __commonJS({
  "node_modules/inherits/inherits.js"(exports2, module2) {
    "use strict";
    try {
      util2 = require("util");
      if (typeof util2.inherits !== "function") throw "";
      module2.exports = util2.inherits;
    } catch (e) {
      module2.exports = require_inherits_browser();
    }
    var util2;
  }
});

// node_modules/readable-stream/lib/internal/streams/buffer_list.js
var require_buffer_list = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/buffer_list.js"(exports2, module2) {
    "use strict";
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value2) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _classCallCheck(instance, Constructor) {
      if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
      }
    }
    __name(_classCallCheck, "_classCallCheck");
    function _defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor);
      }
    }
    __name(_defineProperties, "_defineProperties");
    function _createClass(Constructor, protoProps, staticProps) {
      if (protoProps) _defineProperties(Constructor.prototype, protoProps);
      if (staticProps) _defineProperties(Constructor, staticProps);
      Object.defineProperty(Constructor, "prototype", {
        writable: false
      });
      return Constructor;
    }
    __name(_createClass, "_createClass");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var _require = require("buffer");
    var Buffer2 = _require.Buffer;
    var _require2 = require("util");
    var inspect2 = _require2.inspect;
    var custom2 = inspect2 && inspect2.custom || "inspect";
    function copyBuffer(src, target, offset) {
      Buffer2.prototype.copy.call(src, target, offset);
    }
    __name(copyBuffer, "copyBuffer");
    module2.exports = /* @__PURE__ */ function() {
      function BufferList() {
        _classCallCheck(this, BufferList);
        this.head = null;
        this.tail = null;
        this.length = 0;
      }
      __name(BufferList, "BufferList");
      _createClass(BufferList, [
        {
          key: "push",
          value: /* @__PURE__ */ __name(function push(v) {
            var entry = {
              data: v,
              next: null
            };
            if (this.length > 0) this.tail.next = entry;
            else this.head = entry;
            this.tail = entry;
            ++this.length;
          }, "push")
        },
        {
          key: "unshift",
          value: /* @__PURE__ */ __name(function unshift(v) {
            var entry = {
              data: v,
              next: this.head
            };
            if (this.length === 0) this.tail = entry;
            this.head = entry;
            ++this.length;
          }, "unshift")
        },
        {
          key: "shift",
          value: /* @__PURE__ */ __name(function shift() {
            if (this.length === 0) return;
            var ret = this.head.data;
            if (this.length === 1) this.head = this.tail = null;
            else this.head = this.head.next;
            --this.length;
            return ret;
          }, "shift")
        },
        {
          key: "clear",
          value: /* @__PURE__ */ __name(function clear() {
            this.head = this.tail = null;
            this.length = 0;
          }, "clear")
        },
        {
          key: "join",
          value: /* @__PURE__ */ __name(function join(s) {
            if (this.length === 0) return "";
            var p = this.head;
            var ret = "" + p.data;
            while (p = p.next) ret += s + p.data;
            return ret;
          }, "join")
        },
        {
          key: "concat",
          value: /* @__PURE__ */ __name(function concat(n) {
            if (this.length === 0) return Buffer2.alloc(0);
            var ret = Buffer2.allocUnsafe(n >>> 0);
            var p = this.head;
            var i = 0;
            while (p) {
              copyBuffer(p.data, ret, i);
              i += p.data.length;
              p = p.next;
            }
            return ret;
          }, "concat")
        },
        {
          key: "consume",
          value: /* @__PURE__ */ __name(function consume(n, hasStrings) {
            var ret;
            if (n < this.head.data.length) {
              ret = this.head.data.slice(0, n);
              this.head.data = this.head.data.slice(n);
            } else if (n === this.head.data.length) {
              ret = this.shift();
            } else {
              ret = hasStrings ? this._getString(n) : this._getBuffer(n);
            }
            return ret;
          }, "consume")
        },
        {
          key: "first",
          value: /* @__PURE__ */ __name(function first() {
            return this.head.data;
          }, "first")
        },
        {
          key: "_getString",
          value: /* @__PURE__ */ __name(function _getString(n) {
            var p = this.head;
            var c = 1;
            var ret = p.data;
            n -= ret.length;
            while (p = p.next) {
              var str = p.data;
              var nb = n > str.length ? str.length : n;
              if (nb === str.length) ret += str;
              else ret += str.slice(0, n);
              n -= nb;
              if (n === 0) {
                if (nb === str.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = str.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }, "_getString")
        },
        {
          key: "_getBuffer",
          value: /* @__PURE__ */ __name(function _getBuffer(n) {
            var ret = Buffer2.allocUnsafe(n);
            var p = this.head;
            var c = 1;
            p.data.copy(ret);
            n -= p.data.length;
            while (p = p.next) {
              var buf = p.data;
              var nb = n > buf.length ? buf.length : n;
              buf.copy(ret, ret.length - n, 0, nb);
              n -= nb;
              if (n === 0) {
                if (nb === buf.length) {
                  ++c;
                  if (p.next) this.head = p.next;
                  else this.head = this.tail = null;
                } else {
                  this.head = p;
                  p.data = buf.slice(nb);
                }
                break;
              }
              ++c;
            }
            this.length -= c;
            return ret;
          }, "_getBuffer")
        },
        {
          key: custom2,
          value: /* @__PURE__ */ __name(function value2(_, options) {
            return inspect2(this, _objectSpread(_objectSpread({}, options), {}, {
              // Only inspect one level.
              depth: 0,
              // It should not recurse.
              customInspect: false
            }));
          }, "value")
        }
      ]);
      return BufferList;
    }();
  }
});

// node_modules/string_decoder/node_modules/safe-buffer/index.js
var require_safe_buffer = __commonJS({
  "node_modules/string_decoder/node_modules/safe-buffer/index.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    function copyProps(src, dst) {
      for (var key in src) {
        dst[key] = src[key];
      }
    }
    __name(copyProps, "copyProps");
    if (Buffer2.from && Buffer2.alloc && Buffer2.allocUnsafe && Buffer2.allocUnsafeSlow) {
      module2.exports = buffer;
    } else {
      copyProps(buffer, exports2);
      exports2.Buffer = SafeBuffer;
    }
    function SafeBuffer(arg, encodingOrOffset, length) {
      return Buffer2(arg, encodingOrOffset, length);
    }
    __name(SafeBuffer, "SafeBuffer");
    SafeBuffer.prototype = Object.create(Buffer2.prototype);
    copyProps(Buffer2, SafeBuffer);
    SafeBuffer.from = function(arg, encodingOrOffset, length) {
      if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
      }
      return Buffer2(arg, encodingOrOffset, length);
    };
    SafeBuffer.alloc = function(size, fill, encoding) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      var buf = Buffer2(size);
      if (fill !== void 0) {
        if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
      } else {
        buf.fill(0);
      }
      return buf;
    };
    SafeBuffer.allocUnsafe = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return Buffer2(size);
    };
    SafeBuffer.allocUnsafeSlow = function(size) {
      if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
      }
      return buffer.SlowBuffer(size);
    };
  }
});

// node_modules/string_decoder/lib/string_decoder.js
var require_string_decoder = __commonJS({
  "node_modules/string_decoder/lib/string_decoder.js"(exports2) {
    "use strict";
    var Buffer2 = require_safe_buffer().Buffer;
    var isEncoding = Buffer2.isEncoding || function(encoding) {
      encoding = "" + encoding;
      switch (encoding && encoding.toLowerCase()) {
        case "hex":
        case "utf8":
        case "utf-8":
        case "ascii":
        case "binary":
        case "base64":
        case "ucs2":
        case "ucs-2":
        case "utf16le":
        case "utf-16le":
        case "raw":
          return true;
        default:
          return false;
      }
    };
    function _normalizeEncoding(enc) {
      if (!enc) return "utf8";
      var retried;
      while (true) {
        switch (enc) {
          case "utf8":
          case "utf-8":
            return "utf8";
          case "ucs2":
          case "ucs-2":
          case "utf16le":
          case "utf-16le":
            return "utf16le";
          case "latin1":
          case "binary":
            return "latin1";
          case "base64":
          case "ascii":
          case "hex":
            return enc;
          default:
            if (retried) return;
            enc = ("" + enc).toLowerCase();
            retried = true;
        }
      }
    }
    __name(_normalizeEncoding, "_normalizeEncoding");
    function normalizeEncoding(enc) {
      var nenc = _normalizeEncoding(enc);
      if (typeof nenc !== "string" && (Buffer2.isEncoding === isEncoding || !isEncoding(enc))) throw new Error("Unknown encoding: " + enc);
      return nenc || enc;
    }
    __name(normalizeEncoding, "normalizeEncoding");
    exports2.StringDecoder = StringDecoder;
    function StringDecoder(encoding) {
      this.encoding = normalizeEncoding(encoding);
      var nb;
      switch (this.encoding) {
        case "utf16le":
          this.text = utf16Text;
          this.end = utf16End;
          nb = 4;
          break;
        case "utf8":
          this.fillLast = utf8FillLast;
          nb = 4;
          break;
        case "base64":
          this.text = base64Text;
          this.end = base64End;
          nb = 3;
          break;
        default:
          this.write = simpleWrite;
          this.end = simpleEnd;
          return;
      }
      this.lastNeed = 0;
      this.lastTotal = 0;
      this.lastChar = Buffer2.allocUnsafe(nb);
    }
    __name(StringDecoder, "StringDecoder");
    StringDecoder.prototype.write = function(buf) {
      if (buf.length === 0) return "";
      var r;
      var i;
      if (this.lastNeed) {
        r = this.fillLast(buf);
        if (r === void 0) return "";
        i = this.lastNeed;
        this.lastNeed = 0;
      } else {
        i = 0;
      }
      if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
      return r || "";
    };
    StringDecoder.prototype.end = utf8End;
    StringDecoder.prototype.text = utf8Text;
    StringDecoder.prototype.fillLast = function(buf) {
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
      this.lastNeed -= buf.length;
    };
    function utf8CheckByte(byte) {
      if (byte <= 127) return 0;
      else if (byte >> 5 === 6) return 2;
      else if (byte >> 4 === 14) return 3;
      else if (byte >> 3 === 30) return 4;
      return byte >> 6 === 2 ? -1 : -2;
    }
    __name(utf8CheckByte, "utf8CheckByte");
    function utf8CheckIncomplete(self2, buf, i) {
      var j = buf.length - 1;
      if (j < i) return 0;
      var nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 1;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) self2.lastNeed = nb - 2;
        return nb;
      }
      if (--j < i || nb === -2) return 0;
      nb = utf8CheckByte(buf[j]);
      if (nb >= 0) {
        if (nb > 0) {
          if (nb === 2) nb = 0;
          else self2.lastNeed = nb - 3;
        }
        return nb;
      }
      return 0;
    }
    __name(utf8CheckIncomplete, "utf8CheckIncomplete");
    function utf8CheckExtraBytes(self2, buf, p) {
      if ((buf[0] & 192) !== 128) {
        self2.lastNeed = 0;
        return "\uFFFD";
      }
      if (self2.lastNeed > 1 && buf.length > 1) {
        if ((buf[1] & 192) !== 128) {
          self2.lastNeed = 1;
          return "\uFFFD";
        }
        if (self2.lastNeed > 2 && buf.length > 2) {
          if ((buf[2] & 192) !== 128) {
            self2.lastNeed = 2;
            return "\uFFFD";
          }
        }
      }
    }
    __name(utf8CheckExtraBytes, "utf8CheckExtraBytes");
    function utf8FillLast(buf) {
      var p = this.lastTotal - this.lastNeed;
      var r = utf8CheckExtraBytes(this, buf, p);
      if (r !== void 0) return r;
      if (this.lastNeed <= buf.length) {
        buf.copy(this.lastChar, p, 0, this.lastNeed);
        return this.lastChar.toString(this.encoding, 0, this.lastTotal);
      }
      buf.copy(this.lastChar, p, 0, buf.length);
      this.lastNeed -= buf.length;
    }
    __name(utf8FillLast, "utf8FillLast");
    function utf8Text(buf, i) {
      var total = utf8CheckIncomplete(this, buf, i);
      if (!this.lastNeed) return buf.toString("utf8", i);
      this.lastTotal = total;
      var end = buf.length - (total - this.lastNeed);
      buf.copy(this.lastChar, 0, end);
      return buf.toString("utf8", i, end);
    }
    __name(utf8Text, "utf8Text");
    function utf8End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + "\uFFFD";
      return r;
    }
    __name(utf8End, "utf8End");
    function utf16Text(buf, i) {
      if ((buf.length - i) % 2 === 0) {
        var r = buf.toString("utf16le", i);
        if (r) {
          var c = r.charCodeAt(r.length - 1);
          if (c >= 55296 && c <= 56319) {
            this.lastNeed = 2;
            this.lastTotal = 4;
            this.lastChar[0] = buf[buf.length - 2];
            this.lastChar[1] = buf[buf.length - 1];
            return r.slice(0, -1);
          }
        }
        return r;
      }
      this.lastNeed = 1;
      this.lastTotal = 2;
      this.lastChar[0] = buf[buf.length - 1];
      return buf.toString("utf16le", i, buf.length - 1);
    }
    __name(utf16Text, "utf16Text");
    function utf16End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) {
        var end = this.lastTotal - this.lastNeed;
        return r + this.lastChar.toString("utf16le", 0, end);
      }
      return r;
    }
    __name(utf16End, "utf16End");
    function base64Text(buf, i) {
      var n = (buf.length - i) % 3;
      if (n === 0) return buf.toString("base64", i);
      this.lastNeed = 3 - n;
      this.lastTotal = 3;
      if (n === 1) {
        this.lastChar[0] = buf[buf.length - 1];
      } else {
        this.lastChar[0] = buf[buf.length - 2];
        this.lastChar[1] = buf[buf.length - 1];
      }
      return buf.toString("base64", i, buf.length - n);
    }
    __name(base64Text, "base64Text");
    function base64End(buf) {
      var r = buf && buf.length ? this.write(buf) : "";
      if (this.lastNeed) return r + this.lastChar.toString("base64", 0, 3 - this.lastNeed);
      return r;
    }
    __name(base64End, "base64End");
    function simpleWrite(buf) {
      return buf.toString(this.encoding);
    }
    __name(simpleWrite, "simpleWrite");
    function simpleEnd(buf) {
      return buf && buf.length ? this.write(buf) : "";
    }
    __name(simpleEnd, "simpleEnd");
  }
});

// node_modules/readable-stream/lib/internal/streams/end-of-stream.js
var require_end_of_stream = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/end-of-stream.js"(exports2, module2) {
    "use strict";
    var ERR_STREAM_PREMATURE_CLOSE = require_errors2().codes.ERR_STREAM_PREMATURE_CLOSE;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }
        callback.apply(this, args);
      };
    }
    __name(once, "once");
    function noop() {
    }
    __name(noop, "noop");
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function eos(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var onlegacyfinish = /* @__PURE__ */ __name(function onlegacyfinish2() {
        if (!stream.writable) onfinish();
      }, "onlegacyfinish");
      var writableEnded = stream._writableState && stream._writableState.finished;
      var onfinish = /* @__PURE__ */ __name(function onfinish2() {
        writable = false;
        writableEnded = true;
        if (!readable) callback.call(stream);
      }, "onfinish");
      var readableEnded = stream._readableState && stream._readableState.endEmitted;
      var onend = /* @__PURE__ */ __name(function onend2() {
        readable = false;
        readableEnded = true;
        if (!writable) callback.call(stream);
      }, "onend");
      var onerror = /* @__PURE__ */ __name(function onerror2(err) {
        callback.call(stream, err);
      }, "onerror");
      var onclose = /* @__PURE__ */ __name(function onclose2() {
        var err;
        if (readable && !readableEnded) {
          if (!stream._readableState || !stream._readableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
        if (writable && !writableEnded) {
          if (!stream._writableState || !stream._writableState.ended) err = new ERR_STREAM_PREMATURE_CLOSE();
          return callback.call(stream, err);
        }
      }, "onclose");
      var onrequest = /* @__PURE__ */ __name(function onrequest2() {
        stream.req.on("finish", onfinish);
      }, "onrequest");
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !stream._writableState) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }
    __name(eos, "eos");
    module2.exports = eos;
  }
});

// node_modules/readable-stream/lib/internal/streams/async_iterator.js
var require_async_iterator = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/async_iterator.js"(exports2, module2) {
    "use strict";
    var _Object$setPrototypeO;
    function _defineProperty(obj, key, value2) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var finished = require_end_of_stream();
    var kLastResolve = Symbol("lastResolve");
    var kLastReject = Symbol("lastReject");
    var kError = Symbol("error");
    var kEnded = Symbol("ended");
    var kLastPromise = Symbol("lastPromise");
    var kHandlePromise = Symbol("handlePromise");
    var kStream = Symbol("stream");
    function createIterResult(value2, done) {
      return {
        value: value2,
        done
      };
    }
    __name(createIterResult, "createIterResult");
    function readAndResolve(iter) {
      var resolve5 = iter[kLastResolve];
      if (resolve5 !== null) {
        var data = iter[kStream].read();
        if (data !== null) {
          iter[kLastPromise] = null;
          iter[kLastResolve] = null;
          iter[kLastReject] = null;
          resolve5(createIterResult(data, false));
        }
      }
    }
    __name(readAndResolve, "readAndResolve");
    function onReadable(iter) {
      process.nextTick(readAndResolve, iter);
    }
    __name(onReadable, "onReadable");
    function wrapForNext(lastPromise, iter) {
      return function(resolve5, reject) {
        lastPromise.then(function() {
          if (iter[kEnded]) {
            resolve5(createIterResult(void 0, true));
            return;
          }
          iter[kHandlePromise](resolve5, reject);
        }, reject);
      };
    }
    __name(wrapForNext, "wrapForNext");
    var AsyncIteratorPrototype = Object.getPrototypeOf(function() {
    });
    var ReadableStreamAsyncIteratorPrototype = Object.setPrototypeOf((_Object$setPrototypeO = {
      get stream() {
        return this[kStream];
      },
      next: /* @__PURE__ */ __name(function next() {
        var _this = this;
        var error = this[kError];
        if (error !== null) {
          return Promise.reject(error);
        }
        if (this[kEnded]) {
          return Promise.resolve(createIterResult(void 0, true));
        }
        if (this[kStream].destroyed) {
          return new Promise(function(resolve5, reject) {
            process.nextTick(function() {
              if (_this[kError]) {
                reject(_this[kError]);
              } else {
                resolve5(createIterResult(void 0, true));
              }
            });
          });
        }
        var lastPromise = this[kLastPromise];
        var promise;
        if (lastPromise) {
          promise = new Promise(wrapForNext(lastPromise, this));
        } else {
          var data = this[kStream].read();
          if (data !== null) {
            return Promise.resolve(createIterResult(data, false));
          }
          promise = new Promise(this[kHandlePromise]);
        }
        this[kLastPromise] = promise;
        return promise;
      }, "next")
    }, _defineProperty(_Object$setPrototypeO, Symbol.asyncIterator, function() {
      return this;
    }), _defineProperty(_Object$setPrototypeO, "return", /* @__PURE__ */ __name(function _return() {
      var _this2 = this;
      return new Promise(function(resolve5, reject) {
        _this2[kStream].destroy(null, function(err) {
          if (err) {
            reject(err);
            return;
          }
          resolve5(createIterResult(void 0, true));
        });
      });
    }, "_return")), _Object$setPrototypeO), AsyncIteratorPrototype);
    var createReadableStreamAsyncIterator = /* @__PURE__ */ __name(function createReadableStreamAsyncIterator2(stream) {
      var _Object$create;
      var iterator = Object.create(ReadableStreamAsyncIteratorPrototype, (_Object$create = {}, _defineProperty(_Object$create, kStream, {
        value: stream,
        writable: true
      }), _defineProperty(_Object$create, kLastResolve, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kLastReject, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kError, {
        value: null,
        writable: true
      }), _defineProperty(_Object$create, kEnded, {
        value: stream._readableState.endEmitted,
        writable: true
      }), _defineProperty(_Object$create, kHandlePromise, {
        value: /* @__PURE__ */ __name(function value2(resolve5, reject) {
          var data = iterator[kStream].read();
          if (data) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            resolve5(createIterResult(data, false));
          } else {
            iterator[kLastResolve] = resolve5;
            iterator[kLastReject] = reject;
          }
        }, "value"),
        writable: true
      }), _Object$create));
      iterator[kLastPromise] = null;
      finished(stream, function(err) {
        if (err && err.code !== "ERR_STREAM_PREMATURE_CLOSE") {
          var reject = iterator[kLastReject];
          if (reject !== null) {
            iterator[kLastPromise] = null;
            iterator[kLastResolve] = null;
            iterator[kLastReject] = null;
            reject(err);
          }
          iterator[kError] = err;
          return;
        }
        var resolve5 = iterator[kLastResolve];
        if (resolve5 !== null) {
          iterator[kLastPromise] = null;
          iterator[kLastResolve] = null;
          iterator[kLastReject] = null;
          resolve5(createIterResult(void 0, true));
        }
        iterator[kEnded] = true;
      });
      stream.on("readable", onReadable.bind(null, iterator));
      return iterator;
    }, "createReadableStreamAsyncIterator");
    module2.exports = createReadableStreamAsyncIterator;
  }
});

// node_modules/readable-stream/lib/internal/streams/from.js
var require_from = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/from.js"(exports2, module2) {
    "use strict";
    function asyncGeneratorStep(gen, resolve5, reject, _next, _throw, key, arg) {
      try {
        var info = gen[key](arg);
        var value2 = info.value;
      } catch (error) {
        reject(error);
        return;
      }
      if (info.done) {
        resolve5(value2);
      } else {
        Promise.resolve(value2).then(_next, _throw);
      }
    }
    __name(asyncGeneratorStep, "asyncGeneratorStep");
    function _asyncToGenerator(fn) {
      return function() {
        var self2 = this, args = arguments;
        return new Promise(function(resolve5, reject) {
          var gen = fn.apply(self2, args);
          function _next(value2) {
            asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "next", value2);
          }
          __name(_next, "_next");
          function _throw(err) {
            asyncGeneratorStep(gen, resolve5, reject, _next, _throw, "throw", err);
          }
          __name(_throw, "_throw");
          _next(void 0);
        });
      };
    }
    __name(_asyncToGenerator, "_asyncToGenerator");
    function ownKeys(object, enumerableOnly) {
      var keys = Object.keys(object);
      if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
          return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
      }
      return keys;
    }
    __name(ownKeys, "ownKeys");
    function _objectSpread(target) {
      for (var i = 1; i < arguments.length; i++) {
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), true).forEach(function(key) {
          _defineProperty(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
          Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
      }
      return target;
    }
    __name(_objectSpread, "_objectSpread");
    function _defineProperty(obj, key, value2) {
      key = _toPropertyKey(key);
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value2,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value2;
      }
      return obj;
    }
    __name(_defineProperty, "_defineProperty");
    function _toPropertyKey(arg) {
      var key = _toPrimitive(arg, "string");
      return typeof key === "symbol" ? key : String(key);
    }
    __name(_toPropertyKey, "_toPropertyKey");
    function _toPrimitive(input, hint) {
      if (typeof input !== "object" || input === null) return input;
      var prim = input[Symbol.toPrimitive];
      if (prim !== void 0) {
        var res = prim.call(input, hint || "default");
        if (typeof res !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
      }
      return (hint === "string" ? String : Number)(input);
    }
    __name(_toPrimitive, "_toPrimitive");
    var ERR_INVALID_ARG_TYPE = require_errors2().codes.ERR_INVALID_ARG_TYPE;
    function from(Readable, iterable, opts) {
      var iterator;
      if (iterable && typeof iterable.next === "function") {
        iterator = iterable;
      } else if (iterable && iterable[Symbol.asyncIterator]) iterator = iterable[Symbol.asyncIterator]();
      else if (iterable && iterable[Symbol.iterator]) iterator = iterable[Symbol.iterator]();
      else throw new ERR_INVALID_ARG_TYPE("iterable", [
        "Iterable"
      ], iterable);
      var readable = new Readable(_objectSpread({
        objectMode: true
      }, opts));
      var reading = false;
      readable._read = function() {
        if (!reading) {
          reading = true;
          next();
        }
      };
      function next() {
        return _next2.apply(this, arguments);
      }
      __name(next, "next");
      function _next2() {
        _next2 = _asyncToGenerator(function* () {
          try {
            var _yield$iterator$next = yield iterator.next(), value2 = _yield$iterator$next.value, done = _yield$iterator$next.done;
            if (done) {
              readable.push(null);
            } else if (readable.push(yield value2)) {
              next();
            } else {
              reading = false;
            }
          } catch (err) {
            readable.destroy(err);
          }
        });
        return _next2.apply(this, arguments);
      }
      __name(_next2, "_next2");
      return readable;
    }
    __name(from, "from");
    module2.exports = from;
  }
});

// node_modules/readable-stream/lib/_stream_readable.js
var require_stream_readable = __commonJS({
  "node_modules/readable-stream/lib/_stream_readable.js"(exports2, module2) {
    "use strict";
    module2.exports = Readable;
    var Duplex;
    Readable.ReadableState = ReadableState;
    var EE = require("events").EventEmitter;
    var EElistenerCount = /* @__PURE__ */ __name(function EElistenerCount2(emitter, type) {
      return emitter.listeners(type).length;
    }, "EElistenerCount");
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var debugUtil = require("util");
    var debug12;
    if (debugUtil && debugUtil.debuglog) {
      debug12 = debugUtil.debuglog("stream");
    } else {
      debug12 = /* @__PURE__ */ __name(function debug13() {
      }, "debug");
    }
    var BufferList = require_buffer_list();
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_STREAM_PUSH_AFTER_EOF = _require$codes.ERR_STREAM_PUSH_AFTER_EOF;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_STREAM_UNSHIFT_AFTER_END_EVENT = _require$codes.ERR_STREAM_UNSHIFT_AFTER_END_EVENT;
    var StringDecoder;
    var createReadableStreamAsyncIterator;
    var from;
    require_inherits()(Readable, Stream);
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    var kProxyEvents = [
      "error",
      "close",
      "destroy",
      "pause",
      "resume"
    ];
    function prependListener(emitter, event, fn) {
      if (typeof emitter.prependListener === "function") return emitter.prependListener(event, fn);
      if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);
      else if (Array.isArray(emitter._events[event])) emitter._events[event].unshift(fn);
      else emitter._events[event] = [
        fn,
        emitter._events[event]
      ];
    }
    __name(prependListener, "prependListener");
    function ReadableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "readableHighWaterMark", isDuplex);
      this.buffer = new BufferList();
      this.length = 0;
      this.pipes = null;
      this.pipesCount = 0;
      this.flowing = null;
      this.ended = false;
      this.endEmitted = false;
      this.reading = false;
      this.sync = true;
      this.needReadable = false;
      this.emittedReadable = false;
      this.readableListening = false;
      this.resumeScheduled = false;
      this.paused = true;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.destroyed = false;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.awaitDrain = 0;
      this.readingMore = false;
      this.decoder = null;
      this.encoding = null;
      if (options.encoding) {
        if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
        this.decoder = new StringDecoder(options.encoding);
        this.encoding = options.encoding;
      }
    }
    __name(ReadableState, "ReadableState");
    function Readable(options) {
      Duplex = Duplex || require_stream_duplex();
      if (!(this instanceof Readable)) return new Readable(options);
      var isDuplex = this instanceof Duplex;
      this._readableState = new ReadableState(options, this, isDuplex);
      this.readable = true;
      if (options) {
        if (typeof options.read === "function") this._read = options.read;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
      }
      Stream.call(this);
    }
    __name(Readable, "Readable");
    Object.defineProperty(Readable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        if (this._readableState === void 0) {
          return false;
        }
        return this._readableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value2) {
        if (!this._readableState) {
          return;
        }
        this._readableState.destroyed = value2;
      }, "set")
    });
    Readable.prototype.destroy = destroyImpl.destroy;
    Readable.prototype._undestroy = destroyImpl.undestroy;
    Readable.prototype._destroy = function(err, cb) {
      cb(err);
    };
    Readable.prototype.push = function(chunk, encoding) {
      var state = this._readableState;
      var skipChunkCheck;
      if (!state.objectMode) {
        if (typeof chunk === "string") {
          encoding = encoding || state.defaultEncoding;
          if (encoding !== state.encoding) {
            chunk = Buffer2.from(chunk, encoding);
            encoding = "";
          }
          skipChunkCheck = true;
        }
      } else {
        skipChunkCheck = true;
      }
      return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
    };
    Readable.prototype.unshift = function(chunk) {
      return readableAddChunk(this, chunk, null, true, false);
    };
    function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
      debug12("readableAddChunk", chunk);
      var state = stream._readableState;
      if (chunk === null) {
        state.reading = false;
        onEofChunk(stream, state);
      } else {
        var er;
        if (!skipChunkCheck) er = chunkInvalid(state, chunk);
        if (er) {
          errorOrDestroy(stream, er);
        } else if (state.objectMode || chunk && chunk.length > 0) {
          if (typeof chunk !== "string" && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer2.prototype) {
            chunk = _uint8ArrayToBuffer(chunk);
          }
          if (addToFront) {
            if (state.endEmitted) errorOrDestroy(stream, new ERR_STREAM_UNSHIFT_AFTER_END_EVENT());
            else addChunk(stream, state, chunk, true);
          } else if (state.ended) {
            errorOrDestroy(stream, new ERR_STREAM_PUSH_AFTER_EOF());
          } else if (state.destroyed) {
            return false;
          } else {
            state.reading = false;
            if (state.decoder && !encoding) {
              chunk = state.decoder.write(chunk);
              if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);
              else maybeReadMore(stream, state);
            } else {
              addChunk(stream, state, chunk, false);
            }
          }
        } else if (!addToFront) {
          state.reading = false;
          maybeReadMore(stream, state);
        }
      }
      return !state.ended && (state.length < state.highWaterMark || state.length === 0);
    }
    __name(readableAddChunk, "readableAddChunk");
    function addChunk(stream, state, chunk, addToFront) {
      if (state.flowing && state.length === 0 && !state.sync) {
        state.awaitDrain = 0;
        stream.emit("data", chunk);
      } else {
        state.length += state.objectMode ? 1 : chunk.length;
        if (addToFront) state.buffer.unshift(chunk);
        else state.buffer.push(chunk);
        if (state.needReadable) emitReadable(stream);
      }
      maybeReadMore(stream, state);
    }
    __name(addChunk, "addChunk");
    function chunkInvalid(state, chunk) {
      var er;
      if (!_isUint8Array(chunk) && typeof chunk !== "string" && chunk !== void 0 && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", [
          "string",
          "Buffer",
          "Uint8Array"
        ], chunk);
      }
      return er;
    }
    __name(chunkInvalid, "chunkInvalid");
    Readable.prototype.isPaused = function() {
      return this._readableState.flowing === false;
    };
    Readable.prototype.setEncoding = function(enc) {
      if (!StringDecoder) StringDecoder = require_string_decoder().StringDecoder;
      var decoder = new StringDecoder(enc);
      this._readableState.decoder = decoder;
      this._readableState.encoding = this._readableState.decoder.encoding;
      var p = this._readableState.buffer.head;
      var content = "";
      while (p !== null) {
        content += decoder.write(p.data);
        p = p.next;
      }
      this._readableState.buffer.clear();
      if (content !== "") this._readableState.buffer.push(content);
      this._readableState.length = content.length;
      return this;
    };
    var MAX_HWM = 1073741824;
    function computeNewHighWaterMark(n) {
      if (n >= MAX_HWM) {
        n = MAX_HWM;
      } else {
        n--;
        n |= n >>> 1;
        n |= n >>> 2;
        n |= n >>> 4;
        n |= n >>> 8;
        n |= n >>> 16;
        n++;
      }
      return n;
    }
    __name(computeNewHighWaterMark, "computeNewHighWaterMark");
    function howMuchToRead(n, state) {
      if (n <= 0 || state.length === 0 && state.ended) return 0;
      if (state.objectMode) return 1;
      if (n !== n) {
        if (state.flowing && state.length) return state.buffer.head.data.length;
        else return state.length;
      }
      if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
      if (n <= state.length) return n;
      if (!state.ended) {
        state.needReadable = true;
        return 0;
      }
      return state.length;
    }
    __name(howMuchToRead, "howMuchToRead");
    Readable.prototype.read = function(n) {
      debug12("read", n);
      n = parseInt(n, 10);
      var state = this._readableState;
      var nOrig = n;
      if (n !== 0) state.emittedReadable = false;
      if (n === 0 && state.needReadable && ((state.highWaterMark !== 0 ? state.length >= state.highWaterMark : state.length > 0) || state.ended)) {
        debug12("read: emitReadable", state.length, state.ended);
        if (state.length === 0 && state.ended) endReadable(this);
        else emitReadable(this);
        return null;
      }
      n = howMuchToRead(n, state);
      if (n === 0 && state.ended) {
        if (state.length === 0) endReadable(this);
        return null;
      }
      var doRead = state.needReadable;
      debug12("need readable", doRead);
      if (state.length === 0 || state.length - n < state.highWaterMark) {
        doRead = true;
        debug12("length less than watermark", doRead);
      }
      if (state.ended || state.reading) {
        doRead = false;
        debug12("reading or ended", doRead);
      } else if (doRead) {
        debug12("do read");
        state.reading = true;
        state.sync = true;
        if (state.length === 0) state.needReadable = true;
        this._read(state.highWaterMark);
        state.sync = false;
        if (!state.reading) n = howMuchToRead(nOrig, state);
      }
      var ret;
      if (n > 0) ret = fromList(n, state);
      else ret = null;
      if (ret === null) {
        state.needReadable = state.length <= state.highWaterMark;
        n = 0;
      } else {
        state.length -= n;
        state.awaitDrain = 0;
      }
      if (state.length === 0) {
        if (!state.ended) state.needReadable = true;
        if (nOrig !== n && state.ended) endReadable(this);
      }
      if (ret !== null) this.emit("data", ret);
      return ret;
    };
    function onEofChunk(stream, state) {
      debug12("onEofChunk");
      if (state.ended) return;
      if (state.decoder) {
        var chunk = state.decoder.end();
        if (chunk && chunk.length) {
          state.buffer.push(chunk);
          state.length += state.objectMode ? 1 : chunk.length;
        }
      }
      state.ended = true;
      if (state.sync) {
        emitReadable(stream);
      } else {
        state.needReadable = false;
        if (!state.emittedReadable) {
          state.emittedReadable = true;
          emitReadable_(stream);
        }
      }
    }
    __name(onEofChunk, "onEofChunk");
    function emitReadable(stream) {
      var state = stream._readableState;
      debug12("emitReadable", state.needReadable, state.emittedReadable);
      state.needReadable = false;
      if (!state.emittedReadable) {
        debug12("emitReadable", state.flowing);
        state.emittedReadable = true;
        process.nextTick(emitReadable_, stream);
      }
    }
    __name(emitReadable, "emitReadable");
    function emitReadable_(stream) {
      var state = stream._readableState;
      debug12("emitReadable_", state.destroyed, state.length, state.ended);
      if (!state.destroyed && (state.length || state.ended)) {
        stream.emit("readable");
        state.emittedReadable = false;
      }
      state.needReadable = !state.flowing && !state.ended && state.length <= state.highWaterMark;
      flow(stream);
    }
    __name(emitReadable_, "emitReadable_");
    function maybeReadMore(stream, state) {
      if (!state.readingMore) {
        state.readingMore = true;
        process.nextTick(maybeReadMore_, stream, state);
      }
    }
    __name(maybeReadMore, "maybeReadMore");
    function maybeReadMore_(stream, state) {
      while (!state.reading && !state.ended && (state.length < state.highWaterMark || state.flowing && state.length === 0)) {
        var len = state.length;
        debug12("maybeReadMore read 0");
        stream.read(0);
        if (len === state.length) break;
      }
      state.readingMore = false;
    }
    __name(maybeReadMore_, "maybeReadMore_");
    Readable.prototype._read = function(n) {
      errorOrDestroy(this, new ERR_METHOD_NOT_IMPLEMENTED("_read()"));
    };
    Readable.prototype.pipe = function(dest, pipeOpts) {
      var src = this;
      var state = this._readableState;
      switch (state.pipesCount) {
        case 0:
          state.pipes = dest;
          break;
        case 1:
          state.pipes = [
            state.pipes,
            dest
          ];
          break;
        default:
          state.pipes.push(dest);
          break;
      }
      state.pipesCount += 1;
      debug12("pipe count=%d opts=%j", state.pipesCount, pipeOpts);
      var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
      var endFn = doEnd ? onend : unpipe;
      if (state.endEmitted) process.nextTick(endFn);
      else src.once("end", endFn);
      dest.on("unpipe", onunpipe);
      function onunpipe(readable, unpipeInfo) {
        debug12("onunpipe");
        if (readable === src) {
          if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
            unpipeInfo.hasUnpiped = true;
            cleanup();
          }
        }
      }
      __name(onunpipe, "onunpipe");
      function onend() {
        debug12("onend");
        dest.end();
      }
      __name(onend, "onend");
      var ondrain = pipeOnDrain(src);
      dest.on("drain", ondrain);
      var cleanedUp = false;
      function cleanup() {
        debug12("cleanup");
        dest.removeListener("close", onclose);
        dest.removeListener("finish", onfinish);
        dest.removeListener("drain", ondrain);
        dest.removeListener("error", onerror);
        dest.removeListener("unpipe", onunpipe);
        src.removeListener("end", onend);
        src.removeListener("end", unpipe);
        src.removeListener("data", ondata);
        cleanedUp = true;
        if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
      }
      __name(cleanup, "cleanup");
      src.on("data", ondata);
      function ondata(chunk) {
        debug12("ondata");
        var ret = dest.write(chunk);
        debug12("dest.write", ret);
        if (ret === false) {
          if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
            debug12("false write response, pause", state.awaitDrain);
            state.awaitDrain++;
          }
          src.pause();
        }
      }
      __name(ondata, "ondata");
      function onerror(er) {
        debug12("onerror", er);
        unpipe();
        dest.removeListener("error", onerror);
        if (EElistenerCount(dest, "error") === 0) errorOrDestroy(dest, er);
      }
      __name(onerror, "onerror");
      prependListener(dest, "error", onerror);
      function onclose() {
        dest.removeListener("finish", onfinish);
        unpipe();
      }
      __name(onclose, "onclose");
      dest.once("close", onclose);
      function onfinish() {
        debug12("onfinish");
        dest.removeListener("close", onclose);
        unpipe();
      }
      __name(onfinish, "onfinish");
      dest.once("finish", onfinish);
      function unpipe() {
        debug12("unpipe");
        src.unpipe(dest);
      }
      __name(unpipe, "unpipe");
      dest.emit("pipe", src);
      if (!state.flowing) {
        debug12("pipe resume");
        src.resume();
      }
      return dest;
    };
    function pipeOnDrain(src) {
      return /* @__PURE__ */ __name(function pipeOnDrainFunctionResult() {
        var state = src._readableState;
        debug12("pipeOnDrain", state.awaitDrain);
        if (state.awaitDrain) state.awaitDrain--;
        if (state.awaitDrain === 0 && EElistenerCount(src, "data")) {
          state.flowing = true;
          flow(src);
        }
      }, "pipeOnDrainFunctionResult");
    }
    __name(pipeOnDrain, "pipeOnDrain");
    Readable.prototype.unpipe = function(dest) {
      var state = this._readableState;
      var unpipeInfo = {
        hasUnpiped: false
      };
      if (state.pipesCount === 0) return this;
      if (state.pipesCount === 1) {
        if (dest && dest !== state.pipes) return this;
        if (!dest) dest = state.pipes;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        if (dest) dest.emit("unpipe", this, unpipeInfo);
        return this;
      }
      if (!dest) {
        var dests = state.pipes;
        var len = state.pipesCount;
        state.pipes = null;
        state.pipesCount = 0;
        state.flowing = false;
        for (var i = 0; i < len; i++) dests[i].emit("unpipe", this, {
          hasUnpiped: false
        });
        return this;
      }
      var index = indexOf(state.pipes, dest);
      if (index === -1) return this;
      state.pipes.splice(index, 1);
      state.pipesCount -= 1;
      if (state.pipesCount === 1) state.pipes = state.pipes[0];
      dest.emit("unpipe", this, unpipeInfo);
      return this;
    };
    Readable.prototype.on = function(ev, fn) {
      var res = Stream.prototype.on.call(this, ev, fn);
      var state = this._readableState;
      if (ev === "data") {
        state.readableListening = this.listenerCount("readable") > 0;
        if (state.flowing !== false) this.resume();
      } else if (ev === "readable") {
        if (!state.endEmitted && !state.readableListening) {
          state.readableListening = state.needReadable = true;
          state.flowing = false;
          state.emittedReadable = false;
          debug12("on readable", state.length, state.reading);
          if (state.length) {
            emitReadable(this);
          } else if (!state.reading) {
            process.nextTick(nReadingNextTick, this);
          }
        }
      }
      return res;
    };
    Readable.prototype.addListener = Readable.prototype.on;
    Readable.prototype.removeListener = function(ev, fn) {
      var res = Stream.prototype.removeListener.call(this, ev, fn);
      if (ev === "readable") {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    Readable.prototype.removeAllListeners = function(ev) {
      var res = Stream.prototype.removeAllListeners.apply(this, arguments);
      if (ev === "readable" || ev === void 0) {
        process.nextTick(updateReadableListening, this);
      }
      return res;
    };
    function updateReadableListening(self1) {
      var state = self1._readableState;
      state.readableListening = self1.listenerCount("readable") > 0;
      if (state.resumeScheduled && !state.paused) {
        state.flowing = true;
      } else if (self1.listenerCount("data") > 0) {
        self1.resume();
      }
    }
    __name(updateReadableListening, "updateReadableListening");
    function nReadingNextTick(self1) {
      debug12("readable nexttick read 0");
      self1.read(0);
    }
    __name(nReadingNextTick, "nReadingNextTick");
    Readable.prototype.resume = function() {
      var state = this._readableState;
      if (!state.flowing) {
        debug12("resume");
        state.flowing = !state.readableListening;
        resume(this, state);
      }
      state.paused = false;
      return this;
    };
    function resume(stream, state) {
      if (!state.resumeScheduled) {
        state.resumeScheduled = true;
        process.nextTick(resume_, stream, state);
      }
    }
    __name(resume, "resume");
    function resume_(stream, state) {
      debug12("resume", state.reading);
      if (!state.reading) {
        stream.read(0);
      }
      state.resumeScheduled = false;
      stream.emit("resume");
      flow(stream);
      if (state.flowing && !state.reading) stream.read(0);
    }
    __name(resume_, "resume_");
    Readable.prototype.pause = function() {
      debug12("call pause flowing=%j", this._readableState.flowing);
      if (this._readableState.flowing !== false) {
        debug12("pause");
        this._readableState.flowing = false;
        this.emit("pause");
      }
      this._readableState.paused = true;
      return this;
    };
    function flow(stream) {
      var state = stream._readableState;
      debug12("flow", state.flowing);
      while (state.flowing && stream.read() !== null) ;
    }
    __name(flow, "flow");
    Readable.prototype.wrap = function(stream) {
      var _this = this;
      var state = this._readableState;
      var paused = false;
      stream.on("end", function() {
        debug12("wrapped end");
        if (state.decoder && !state.ended) {
          var chunk = state.decoder.end();
          if (chunk && chunk.length) _this.push(chunk);
        }
        _this.push(null);
      });
      stream.on("data", function(chunk) {
        debug12("wrapped data");
        if (state.decoder) chunk = state.decoder.write(chunk);
        if (state.objectMode && (chunk === null || chunk === void 0)) return;
        else if (!state.objectMode && (!chunk || !chunk.length)) return;
        var ret = _this.push(chunk);
        if (!ret) {
          paused = true;
          stream.pause();
        }
      });
      for (var i in stream) {
        if (this[i] === void 0 && typeof stream[i] === "function") {
          this[i] = (/* @__PURE__ */ __name(function methodWrap(method) {
            return /* @__PURE__ */ __name(function methodWrapReturnFunction() {
              return stream[method].apply(stream, arguments);
            }, "methodWrapReturnFunction");
          }, "methodWrap"))(i);
        }
      }
      for (var n = 0; n < kProxyEvents.length; n++) {
        stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
      }
      this._read = function(n2) {
        debug12("wrapped _read", n2);
        if (paused) {
          paused = false;
          stream.resume();
        }
      };
      return this;
    };
    if (typeof Symbol === "function") {
      Readable.prototype[Symbol.asyncIterator] = function() {
        if (createReadableStreamAsyncIterator === void 0) {
          createReadableStreamAsyncIterator = require_async_iterator();
        }
        return createReadableStreamAsyncIterator(this);
      };
    }
    Object.defineProperty(Readable.prototype, "readableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._readableState.highWaterMark;
      }, "get")
    });
    Object.defineProperty(Readable.prototype, "readableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._readableState && this._readableState.buffer;
      }, "get")
    });
    Object.defineProperty(Readable.prototype, "readableFlowing", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._readableState.flowing;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(state) {
        if (this._readableState) {
          this._readableState.flowing = state;
        }
      }, "set")
    });
    Readable._fromList = fromList;
    Object.defineProperty(Readable.prototype, "readableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._readableState.length;
      }, "get")
    });
    function fromList(n, state) {
      if (state.length === 0) return null;
      var ret;
      if (state.objectMode) ret = state.buffer.shift();
      else if (!n || n >= state.length) {
        if (state.decoder) ret = state.buffer.join("");
        else if (state.buffer.length === 1) ret = state.buffer.first();
        else ret = state.buffer.concat(state.length);
        state.buffer.clear();
      } else {
        ret = state.buffer.consume(n, state.decoder);
      }
      return ret;
    }
    __name(fromList, "fromList");
    function endReadable(stream) {
      var state = stream._readableState;
      debug12("endReadable", state.endEmitted);
      if (!state.endEmitted) {
        state.ended = true;
        process.nextTick(endReadableNT, state, stream);
      }
    }
    __name(endReadable, "endReadable");
    function endReadableNT(state, stream) {
      debug12("endReadableNT", state.endEmitted, state.length);
      if (!state.endEmitted && state.length === 0) {
        state.endEmitted = true;
        stream.readable = false;
        stream.emit("end");
        if (state.autoDestroy) {
          var wState = stream._writableState;
          if (!wState || wState.autoDestroy && wState.finished) {
            stream.destroy();
          }
        }
      }
    }
    __name(endReadableNT, "endReadableNT");
    if (typeof Symbol === "function") {
      Readable.from = function(iterable, opts) {
        if (from === void 0) {
          from = require_from();
        }
        return from(Readable, iterable, opts);
      };
    }
    function indexOf(xs, x) {
      for (var i = 0, l = xs.length; i < l; i++) {
        if (xs[i] === x) return i;
      }
      return -1;
    }
    __name(indexOf, "indexOf");
  }
});

// node_modules/readable-stream/lib/_stream_duplex.js
var require_stream_duplex = __commonJS({
  "node_modules/readable-stream/lib/_stream_duplex.js"(exports2, module2) {
    "use strict";
    var objectKeys2 = Object.keys || function(obj) {
      var keys2 = [];
      for (var key in obj) keys2.push(key);
      return keys2;
    };
    module2.exports = Duplex;
    var Readable = require_stream_readable();
    var Writable = require_stream_writable();
    require_inherits()(Duplex, Readable);
    {
      keys = objectKeys2(Writable.prototype);
      for (v = 0; v < keys.length; v++) {
        method = keys[v];
        if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
      }
    }
    var keys;
    var method;
    var v;
    function Duplex(options) {
      if (!(this instanceof Duplex)) return new Duplex(options);
      Readable.call(this, options);
      Writable.call(this, options);
      this.allowHalfOpen = true;
      if (options) {
        if (options.readable === false) this.readable = false;
        if (options.writable === false) this.writable = false;
        if (options.allowHalfOpen === false) {
          this.allowHalfOpen = false;
          this.once("end", onend);
        }
      }
    }
    __name(Duplex, "Duplex");
    Object.defineProperty(Duplex.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState.highWaterMark;
      }, "get")
    });
    Object.defineProperty(Duplex.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState && this._writableState.getBuffer();
      }, "get")
    });
    Object.defineProperty(Duplex.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState.length;
      }, "get")
    });
    function onend() {
      if (this._writableState.ended) return;
      process.nextTick(onEndNT, this);
    }
    __name(onend, "onend");
    function onEndNT(self2) {
      self2.end();
    }
    __name(onEndNT, "onEndNT");
    Object.defineProperty(Duplex.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return false;
        }
        return this._readableState.destroyed && this._writableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value2) {
        if (this._readableState === void 0 || this._writableState === void 0) {
          return;
        }
        this._readableState.destroyed = value2;
        this._writableState.destroyed = value2;
      }, "set")
    });
  }
});

// node_modules/readable-stream/lib/_stream_writable.js
var require_stream_writable = __commonJS({
  "node_modules/readable-stream/lib/_stream_writable.js"(exports2, module2) {
    "use strict";
    module2.exports = Writable;
    function CorkedRequest(state) {
      var _this = this;
      this.next = null;
      this.entry = null;
      this.finish = function() {
        onCorkedFinish(_this, state);
      };
    }
    __name(CorkedRequest, "CorkedRequest");
    var Duplex;
    Writable.WritableState = WritableState;
    var internalUtil = {
      deprecate: require_node()
    };
    var Stream = require_stream();
    var Buffer2 = require("buffer").Buffer;
    var OurUint8Array = (typeof global !== "undefined" ? global : typeof window !== "undefined" ? window : typeof self !== "undefined" ? self : {}).Uint8Array || function() {
    };
    function _uint8ArrayToBuffer(chunk) {
      return Buffer2.from(chunk);
    }
    __name(_uint8ArrayToBuffer, "_uint8ArrayToBuffer");
    function _isUint8Array(obj) {
      return Buffer2.isBuffer(obj) || obj instanceof OurUint8Array;
    }
    __name(_isUint8Array, "_isUint8Array");
    var destroyImpl = require_destroy();
    var _require = require_state();
    var getHighWaterMark = _require.getHighWaterMark;
    var _require$codes = require_errors2().codes;
    var ERR_INVALID_ARG_TYPE = _require$codes.ERR_INVALID_ARG_TYPE;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_STREAM_CANNOT_PIPE = _require$codes.ERR_STREAM_CANNOT_PIPE;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    var ERR_STREAM_NULL_VALUES = _require$codes.ERR_STREAM_NULL_VALUES;
    var ERR_STREAM_WRITE_AFTER_END = _require$codes.ERR_STREAM_WRITE_AFTER_END;
    var ERR_UNKNOWN_ENCODING = _require$codes.ERR_UNKNOWN_ENCODING;
    var errorOrDestroy = destroyImpl.errorOrDestroy;
    require_inherits()(Writable, Stream);
    function nop() {
    }
    __name(nop, "nop");
    function WritableState(options, stream, isDuplex) {
      Duplex = Duplex || require_stream_duplex();
      options = options || {};
      if (typeof isDuplex !== "boolean") isDuplex = stream instanceof Duplex;
      this.objectMode = !!options.objectMode;
      if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
      this.highWaterMark = getHighWaterMark(this, options, "writableHighWaterMark", isDuplex);
      this.finalCalled = false;
      this.needDrain = false;
      this.ending = false;
      this.ended = false;
      this.finished = false;
      this.destroyed = false;
      var noDecode = options.decodeStrings === false;
      this.decodeStrings = !noDecode;
      this.defaultEncoding = options.defaultEncoding || "utf8";
      this.length = 0;
      this.writing = false;
      this.corked = 0;
      this.sync = true;
      this.bufferProcessing = false;
      this.onwrite = function(er) {
        onwrite(stream, er);
      };
      this.writecb = null;
      this.writelen = 0;
      this.bufferedRequest = null;
      this.lastBufferedRequest = null;
      this.pendingcb = 0;
      this.prefinished = false;
      this.errorEmitted = false;
      this.emitClose = options.emitClose !== false;
      this.autoDestroy = !!options.autoDestroy;
      this.bufferedRequestCount = 0;
      this.corkedRequestsFree = new CorkedRequest(this);
    }
    __name(WritableState, "WritableState");
    WritableState.prototype.getBuffer = /* @__PURE__ */ __name(function getBuffer() {
      var current = this.bufferedRequest;
      var out = [];
      while (current) {
        out.push(current);
        current = current.next;
      }
      return out;
    }, "getBuffer");
    (function() {
      try {
        Object.defineProperty(WritableState.prototype, "buffer", {
          get: internalUtil.deprecate(/* @__PURE__ */ __name(function writableStateBufferGetter() {
            return this.getBuffer();
          }, "writableStateBufferGetter"), "_writableState.buffer is deprecated. Use _writableState.getBuffer instead.", "DEP0003")
        });
      } catch (_) {
      }
    })();
    var realHasInstance;
    if (typeof Symbol === "function" && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === "function") {
      realHasInstance = Function.prototype[Symbol.hasInstance];
      Object.defineProperty(Writable, Symbol.hasInstance, {
        value: /* @__PURE__ */ __name(function value2(object) {
          if (realHasInstance.call(this, object)) return true;
          if (this !== Writable) return false;
          return object && object._writableState instanceof WritableState;
        }, "value")
      });
    } else {
      realHasInstance = /* @__PURE__ */ __name(function realHasInstance2(object) {
        return object instanceof this;
      }, "realHasInstance");
    }
    function Writable(options) {
      Duplex = Duplex || require_stream_duplex();
      var isDuplex = this instanceof Duplex;
      if (!isDuplex && !realHasInstance.call(Writable, this)) return new Writable(options);
      this._writableState = new WritableState(options, this, isDuplex);
      this.writable = true;
      if (options) {
        if (typeof options.write === "function") this._write = options.write;
        if (typeof options.writev === "function") this._writev = options.writev;
        if (typeof options.destroy === "function") this._destroy = options.destroy;
        if (typeof options.final === "function") this._final = options.final;
      }
      Stream.call(this);
    }
    __name(Writable, "Writable");
    Writable.prototype.pipe = function() {
      errorOrDestroy(this, new ERR_STREAM_CANNOT_PIPE());
    };
    function writeAfterEnd(stream, cb) {
      var er = new ERR_STREAM_WRITE_AFTER_END();
      errorOrDestroy(stream, er);
      process.nextTick(cb, er);
    }
    __name(writeAfterEnd, "writeAfterEnd");
    function validChunk(stream, state, chunk, cb) {
      var er;
      if (chunk === null) {
        er = new ERR_STREAM_NULL_VALUES();
      } else if (typeof chunk !== "string" && !state.objectMode) {
        er = new ERR_INVALID_ARG_TYPE("chunk", [
          "string",
          "Buffer"
        ], chunk);
      }
      if (er) {
        errorOrDestroy(stream, er);
        process.nextTick(cb, er);
        return false;
      }
      return true;
    }
    __name(validChunk, "validChunk");
    Writable.prototype.write = function(chunk, encoding, cb) {
      var state = this._writableState;
      var ret = false;
      var isBuf = !state.objectMode && _isUint8Array(chunk);
      if (isBuf && !Buffer2.isBuffer(chunk)) {
        chunk = _uint8ArrayToBuffer(chunk);
      }
      if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (isBuf) encoding = "buffer";
      else if (!encoding) encoding = state.defaultEncoding;
      if (typeof cb !== "function") cb = nop;
      if (state.ending) writeAfterEnd(this, cb);
      else if (isBuf || validChunk(this, state, chunk, cb)) {
        state.pendingcb++;
        ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
      }
      return ret;
    };
    Writable.prototype.cork = function() {
      this._writableState.corked++;
    };
    Writable.prototype.uncork = function() {
      var state = this._writableState;
      if (state.corked) {
        state.corked--;
        if (!state.writing && !state.corked && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
      }
    };
    Writable.prototype.setDefaultEncoding = /* @__PURE__ */ __name(function setDefaultEncoding(encoding) {
      if (typeof encoding === "string") encoding = encoding.toLowerCase();
      if (!([
        "hex",
        "utf8",
        "utf-8",
        "ascii",
        "binary",
        "base64",
        "ucs2",
        "ucs-2",
        "utf16le",
        "utf-16le",
        "raw"
      ].indexOf((encoding + "").toLowerCase()) > -1)) throw new ERR_UNKNOWN_ENCODING(encoding);
      this._writableState.defaultEncoding = encoding;
      return this;
    }, "setDefaultEncoding");
    Object.defineProperty(Writable.prototype, "writableBuffer", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState && this._writableState.getBuffer();
      }, "get")
    });
    function decodeChunk(state, chunk, encoding) {
      if (!state.objectMode && state.decodeStrings !== false && typeof chunk === "string") {
        chunk = Buffer2.from(chunk, encoding);
      }
      return chunk;
    }
    __name(decodeChunk, "decodeChunk");
    Object.defineProperty(Writable.prototype, "writableHighWaterMark", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState.highWaterMark;
      }, "get")
    });
    function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
      if (!isBuf) {
        var newChunk = decodeChunk(state, chunk, encoding);
        if (chunk !== newChunk) {
          isBuf = true;
          encoding = "buffer";
          chunk = newChunk;
        }
      }
      var len = state.objectMode ? 1 : chunk.length;
      state.length += len;
      var ret = state.length < state.highWaterMark;
      if (!ret) state.needDrain = true;
      if (state.writing || state.corked) {
        var last = state.lastBufferedRequest;
        state.lastBufferedRequest = {
          chunk,
          encoding,
          isBuf,
          callback: cb,
          next: null
        };
        if (last) {
          last.next = state.lastBufferedRequest;
        } else {
          state.bufferedRequest = state.lastBufferedRequest;
        }
        state.bufferedRequestCount += 1;
      } else {
        doWrite(stream, state, false, len, chunk, encoding, cb);
      }
      return ret;
    }
    __name(writeOrBuffer, "writeOrBuffer");
    function doWrite(stream, state, writev, len, chunk, encoding, cb) {
      state.writelen = len;
      state.writecb = cb;
      state.writing = true;
      state.sync = true;
      if (state.destroyed) state.onwrite(new ERR_STREAM_DESTROYED("write"));
      else if (writev) stream._writev(chunk, state.onwrite);
      else stream._write(chunk, encoding, state.onwrite);
      state.sync = false;
    }
    __name(doWrite, "doWrite");
    function onwriteError(stream, state, sync, er, cb) {
      --state.pendingcb;
      if (sync) {
        process.nextTick(cb, er);
        process.nextTick(finishMaybe, stream, state);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
      } else {
        cb(er);
        stream._writableState.errorEmitted = true;
        errorOrDestroy(stream, er);
        finishMaybe(stream, state);
      }
    }
    __name(onwriteError, "onwriteError");
    function onwriteStateUpdate(state) {
      state.writing = false;
      state.writecb = null;
      state.length -= state.writelen;
      state.writelen = 0;
    }
    __name(onwriteStateUpdate, "onwriteStateUpdate");
    function onwrite(stream, er) {
      var state = stream._writableState;
      var sync = state.sync;
      var cb = state.writecb;
      if (typeof cb !== "function") throw new ERR_MULTIPLE_CALLBACK();
      onwriteStateUpdate(state);
      if (er) onwriteError(stream, state, sync, er, cb);
      else {
        var finished = needFinish(state) || stream.destroyed;
        if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
          clearBuffer(stream, state);
        }
        if (sync) {
          process.nextTick(afterWrite, stream, state, finished, cb);
        } else {
          afterWrite(stream, state, finished, cb);
        }
      }
    }
    __name(onwrite, "onwrite");
    function afterWrite(stream, state, finished, cb) {
      if (!finished) onwriteDrain(stream, state);
      state.pendingcb--;
      cb();
      finishMaybe(stream, state);
    }
    __name(afterWrite, "afterWrite");
    function onwriteDrain(stream, state) {
      if (state.length === 0 && state.needDrain) {
        state.needDrain = false;
        stream.emit("drain");
      }
    }
    __name(onwriteDrain, "onwriteDrain");
    function clearBuffer(stream, state) {
      state.bufferProcessing = true;
      var entry = state.bufferedRequest;
      if (stream._writev && entry && entry.next) {
        var l = state.bufferedRequestCount;
        var buffer = new Array(l);
        var holder = state.corkedRequestsFree;
        holder.entry = entry;
        var count = 0;
        var allBuffers = true;
        while (entry) {
          buffer[count] = entry;
          if (!entry.isBuf) allBuffers = false;
          entry = entry.next;
          count += 1;
        }
        buffer.allBuffers = allBuffers;
        doWrite(stream, state, true, state.length, buffer, "", holder.finish);
        state.pendingcb++;
        state.lastBufferedRequest = null;
        if (holder.next) {
          state.corkedRequestsFree = holder.next;
          holder.next = null;
        } else {
          state.corkedRequestsFree = new CorkedRequest(state);
        }
        state.bufferedRequestCount = 0;
      } else {
        while (entry) {
          var chunk = entry.chunk;
          var encoding = entry.encoding;
          var cb = entry.callback;
          var len = state.objectMode ? 1 : chunk.length;
          doWrite(stream, state, false, len, chunk, encoding, cb);
          entry = entry.next;
          state.bufferedRequestCount--;
          if (state.writing) {
            break;
          }
        }
        if (entry === null) state.lastBufferedRequest = null;
      }
      state.bufferedRequest = entry;
      state.bufferProcessing = false;
    }
    __name(clearBuffer, "clearBuffer");
    Writable.prototype._write = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_write()"));
    };
    Writable.prototype._writev = null;
    Writable.prototype.end = function(chunk, encoding, cb) {
      var state = this._writableState;
      if (typeof chunk === "function") {
        cb = chunk;
        chunk = null;
        encoding = null;
      } else if (typeof encoding === "function") {
        cb = encoding;
        encoding = null;
      }
      if (chunk !== null && chunk !== void 0) this.write(chunk, encoding);
      if (state.corked) {
        state.corked = 1;
        this.uncork();
      }
      if (!state.ending) endWritable(this, state, cb);
      return this;
    };
    Object.defineProperty(Writable.prototype, "writableLength", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        return this._writableState.length;
      }, "get")
    });
    function needFinish(state) {
      return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
    }
    __name(needFinish, "needFinish");
    function callFinal(stream, state) {
      stream._final(function(err) {
        state.pendingcb--;
        if (err) {
          errorOrDestroy(stream, err);
        }
        state.prefinished = true;
        stream.emit("prefinish");
        finishMaybe(stream, state);
      });
    }
    __name(callFinal, "callFinal");
    function prefinish(stream, state) {
      if (!state.prefinished && !state.finalCalled) {
        if (typeof stream._final === "function" && !state.destroyed) {
          state.pendingcb++;
          state.finalCalled = true;
          process.nextTick(callFinal, stream, state);
        } else {
          state.prefinished = true;
          stream.emit("prefinish");
        }
      }
    }
    __name(prefinish, "prefinish");
    function finishMaybe(stream, state) {
      var need = needFinish(state);
      if (need) {
        prefinish(stream, state);
        if (state.pendingcb === 0) {
          state.finished = true;
          stream.emit("finish");
          if (state.autoDestroy) {
            var rState = stream._readableState;
            if (!rState || rState.autoDestroy && rState.endEmitted) {
              stream.destroy();
            }
          }
        }
      }
      return need;
    }
    __name(finishMaybe, "finishMaybe");
    function endWritable(stream, state, cb) {
      state.ending = true;
      finishMaybe(stream, state);
      if (cb) {
        if (state.finished) process.nextTick(cb);
        else stream.once("finish", cb);
      }
      state.ended = true;
      stream.writable = false;
    }
    __name(endWritable, "endWritable");
    function onCorkedFinish(corkReq, state, err) {
      var entry = corkReq.entry;
      corkReq.entry = null;
      while (entry) {
        var cb = entry.callback;
        state.pendingcb--;
        cb(err);
        entry = entry.next;
      }
      state.corkedRequestsFree.next = corkReq;
    }
    __name(onCorkedFinish, "onCorkedFinish");
    Object.defineProperty(Writable.prototype, "destroyed", {
      // making it explicit this property is not enumerable
      // because otherwise some prototype manipulation in
      // userland will fail
      enumerable: false,
      get: /* @__PURE__ */ __name(function get() {
        if (this._writableState === void 0) {
          return false;
        }
        return this._writableState.destroyed;
      }, "get"),
      set: /* @__PURE__ */ __name(function set(value2) {
        if (!this._writableState) {
          return;
        }
        this._writableState.destroyed = value2;
      }, "set")
    });
    Writable.prototype.destroy = destroyImpl.destroy;
    Writable.prototype._undestroy = destroyImpl.undestroy;
    Writable.prototype._destroy = function(err, cb) {
      cb(err);
    };
  }
});

// node_modules/winston-transport/modern.js
var require_modern = __commonJS({
  "node_modules/winston-transport/modern.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var Writable = require_stream_writable();
    var { LEVEL } = require_triple_beam();
    var TransportStream = module2.exports = /* @__PURE__ */ __name(function TransportStream2(options = {}) {
      Writable.call(this, {
        objectMode: true,
        highWaterMark: options.highWaterMark
      });
      this.format = options.format;
      this.level = options.level;
      this.handleExceptions = options.handleExceptions;
      this.handleRejections = options.handleRejections;
      this.silent = options.silent;
      if (options.log) this.log = options.log;
      if (options.logv) this.logv = options.logv;
      if (options.close) this.close = options.close;
      this.once("pipe", (logger2) => {
        this.levels = logger2.levels;
        this.parent = logger2;
      });
      this.once("unpipe", (src) => {
        if (src === this.parent) {
          this.parent = null;
          if (this.close) {
            this.close();
          }
        }
      });
    }, "TransportStream");
    util2.inherits(TransportStream, Writable);
    TransportStream.prototype._write = /* @__PURE__ */ __name(function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      const level = this.level || this.parent && this.parent.level;
      if (!level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (info && !this.format) {
          return this.log(info, callback);
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, info), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          callback();
          if (errState) throw errState;
          return;
        }
        return this.log(transformed, callback);
      }
      this._writableState.sync = false;
      return callback(null);
    }, "_write");
    TransportStream.prototype._writev = /* @__PURE__ */ __name(function _writev(chunks, callback) {
      if (this.logv) {
        const infos = chunks.filter(this._accept, this);
        if (!infos.length) {
          return callback(null);
        }
        return this.logv(infos, callback);
      }
      for (let i = 0; i < chunks.length; i++) {
        if (!this._accept(chunks[i])) continue;
        if (chunks[i].chunk && !this.format) {
          this.log(chunks[i].chunk, chunks[i].callback);
          continue;
        }
        let errState;
        let transformed;
        try {
          transformed = this.format.transform(Object.assign({}, chunks[i].chunk), this.format.options);
        } catch (err) {
          errState = err;
        }
        if (errState || !transformed) {
          chunks[i].callback();
          if (errState) {
            callback(null);
            throw errState;
          }
        } else {
          this.log(transformed, chunks[i].callback);
        }
      }
      return callback(null);
    }, "_writev");
    TransportStream.prototype._accept = /* @__PURE__ */ __name(function _accept(write) {
      const info = write.chunk;
      if (this.silent) {
        return false;
      }
      const level = this.level || this.parent && this.parent.level;
      if (info.exception === true || !level || this.levels[level] >= this.levels[info[LEVEL]]) {
        if (this.handleExceptions || info.exception !== true) {
          return true;
        }
      }
      return false;
    }, "_accept");
    TransportStream.prototype._nop = /* @__PURE__ */ __name(function _nop() {
      return void 0;
    }, "_nop");
  }
});

// node_modules/winston-transport/legacy.js
var require_legacy = __commonJS({
  "node_modules/winston-transport/legacy.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var { LEVEL } = require_triple_beam();
    var TransportStream = require_modern();
    var LegacyTransportStream = module2.exports = /* @__PURE__ */ __name(function LegacyTransportStream2(options = {}) {
      TransportStream.call(this, options);
      if (!options.transport || typeof options.transport.log !== "function") {
        throw new Error("Invalid transport, must be an object with a log method.");
      }
      this.transport = options.transport;
      this.level = this.level || options.transport.level;
      this.handleExceptions = this.handleExceptions || options.transport.handleExceptions;
      this._deprecated();
      function transportError(err) {
        this.emit("error", err, this.transport);
      }
      __name(transportError, "transportError");
      if (!this.transport.__winstonError) {
        this.transport.__winstonError = transportError.bind(this);
        this.transport.on("error", this.transport.__winstonError);
      }
    }, "LegacyTransportStream");
    util2.inherits(LegacyTransportStream, TransportStream);
    LegacyTransportStream.prototype._write = /* @__PURE__ */ __name(function _write(info, enc, callback) {
      if (this.silent || info.exception === true && !this.handleExceptions) {
        return callback(null);
      }
      if (!this.level || this.levels[this.level] >= this.levels[info[LEVEL]]) {
        this.transport.log(info[LEVEL], info.message, info, this._nop);
      }
      callback(null);
    }, "_write");
    LegacyTransportStream.prototype._writev = /* @__PURE__ */ __name(function _writev(chunks, callback) {
      for (let i = 0; i < chunks.length; i++) {
        if (this._accept(chunks[i])) {
          this.transport.log(chunks[i].chunk[LEVEL], chunks[i].chunk.message, chunks[i].chunk, this._nop);
          chunks[i].callback();
        }
      }
      return callback(null);
    }, "_writev");
    LegacyTransportStream.prototype._deprecated = /* @__PURE__ */ __name(function _deprecated() {
      console.error([
        `${this.transport.name} is a legacy winston transport. Consider upgrading: `,
        "- Upgrade docs: https://github.com/winstonjs/winston/blob/master/UPGRADE-3.0.md"
      ].join("\n"));
    }, "_deprecated");
    LegacyTransportStream.prototype.close = /* @__PURE__ */ __name(function close() {
      if (this.transport.close) {
        this.transport.close();
      }
      if (this.transport.__winstonError) {
        this.transport.removeListener("error", this.transport.__winstonError);
        this.transport.__winstonError = null;
      }
    }, "close");
  }
});

// node_modules/winston-transport/index.js
var require_winston_transport = __commonJS({
  "node_modules/winston-transport/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_modern();
    module2.exports.LegacyTransportStream = require_legacy();
  }
});

// node_modules/winston/lib/winston/transports/console.js
var require_console = __commonJS({
  "node_modules/winston/lib/winston/transports/console.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var { LEVEL, MESSAGE } = require_triple_beam();
    var TransportStream = require_winston_transport();
    module2.exports = class Console extends TransportStream {
      static {
        __name(this, "Console");
      }
      /**
      * Constructor function for the Console transport object responsible for
      * persisting log messages and metadata to a terminal or TTY.
      * @param {!Object} [options={}] - Options for this instance.
      */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "console";
        this.stderrLevels = this._stringArrayToSet(options.stderrLevels);
        this.consoleWarnLevels = this._stringArrayToSet(options.consoleWarnLevels);
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.forceConsole = options.forceConsole || false;
        this._consoleLog = console.log.bind(console);
        this._consoleWarn = console.warn.bind(console);
        this._consoleError = console.error.bind(console);
        this.setMaxListeners(30);
      }
      /**
      * Core logging method exposed to Winston.
      * @param {Object} info - TODO: add param description.
      * @param {Function} callback - TODO: add param description.
      * @returns {undefined}
      */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.stderrLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            this._consoleError(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        } else if (this.consoleWarnLevels[info[LEVEL]]) {
          if (console._stderr && !this.forceConsole) {
            console._stderr.write(`${info[MESSAGE]}${this.eol}`);
          } else {
            this._consoleWarn(info[MESSAGE]);
          }
          if (callback) {
            callback();
          }
          return;
        }
        if (console._stdout && !this.forceConsole) {
          console._stdout.write(`${info[MESSAGE]}${this.eol}`);
        } else {
          this._consoleLog(info[MESSAGE]);
        }
        if (callback) {
          callback();
        }
      }
      /**
      * Returns a Set-like object with strArray's elements as keys (each with the
      * value true).
      * @param {Array} strArray - Array of Set-elements as strings.
      * @param {?string} [errMsg] - Custom error message thrown on invalid input.
      * @returns {Object} - TODO: add return description.
      * @private
      */
      _stringArrayToSet(strArray, errMsg) {
        if (!strArray) return {};
        errMsg = errMsg || "Cannot make set from type other than Array of string elements";
        if (!Array.isArray(strArray)) {
          throw new Error(errMsg);
        }
        return strArray.reduce((set, el) => {
          if (typeof el !== "string") {
            throw new Error(errMsg);
          }
          set[el] = true;
          return set;
        }, {});
      }
    };
  }
});

// node_modules/async/internal/isArrayLike.js
var require_isArrayLike = __commonJS({
  "node_modules/async/internal/isArrayLike.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = isArrayLike;
    function isArrayLike(value2) {
      return value2 && typeof value2.length === "number" && value2.length >= 0 && value2.length % 1 === 0;
    }
    __name(isArrayLike, "isArrayLike");
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/initialParams.js
var require_initialParams = __commonJS({
  "node_modules/async/internal/initialParams.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(fn) {
      return function(...args) {
        var callback = args.pop();
        return fn.call(this, args, callback);
      };
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/setImmediate.js
var require_setImmediate = __commonJS({
  "node_modules/async/internal/setImmediate.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.fallback = fallback;
    exports2.wrap = wrap2;
    var hasQueueMicrotask = exports2.hasQueueMicrotask = typeof queueMicrotask === "function" && queueMicrotask;
    var hasSetImmediate = exports2.hasSetImmediate = typeof setImmediate === "function" && setImmediate;
    var hasNextTick = exports2.hasNextTick = typeof process === "object" && typeof process.nextTick === "function";
    function fallback(fn) {
      setTimeout(fn, 0);
    }
    __name(fallback, "fallback");
    function wrap2(defer) {
      return (fn, ...args) => defer(() => fn(...args));
    }
    __name(wrap2, "wrap");
    var _defer;
    if (hasQueueMicrotask) {
      _defer = queueMicrotask;
    } else if (hasSetImmediate) {
      _defer = setImmediate;
    } else if (hasNextTick) {
      _defer = process.nextTick;
    } else {
      _defer = fallback;
    }
    exports2.default = wrap2(_defer);
  }
});

// node_modules/async/asyncify.js
var require_asyncify = __commonJS({
  "node_modules/async/asyncify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncify;
    var _initialParams = require_initialParams();
    var _initialParams2 = _interopRequireDefault(_initialParams);
    var _setImmediate = require_setImmediate();
    var _setImmediate2 = _interopRequireDefault(_setImmediate);
    var _wrapAsync = require_wrapAsync();
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function asyncify(func) {
      if ((0, _wrapAsync.isAsync)(func)) {
        return function(...args) {
          const callback = args.pop();
          const promise = func.apply(this, args);
          return handlePromise(promise, callback);
        };
      }
      return (0, _initialParams2.default)(function(args, callback) {
        var result2;
        try {
          result2 = func.apply(this, args);
        } catch (e) {
          return callback(e);
        }
        if (result2 && typeof result2.then === "function") {
          return handlePromise(result2, callback);
        } else {
          callback(null, result2);
        }
      });
    }
    __name(asyncify, "asyncify");
    function handlePromise(promise, callback) {
      return promise.then((value2) => {
        invokeCallback(callback, null, value2);
      }, (err) => {
        invokeCallback(callback, err && (err instanceof Error || err.message) ? err : new Error(err));
      });
    }
    __name(handlePromise, "handlePromise");
    function invokeCallback(callback, error, value2) {
      try {
        callback(error, value2);
      } catch (err) {
        (0, _setImmediate2.default)((e) => {
          throw e;
        }, err);
      }
    }
    __name(invokeCallback, "invokeCallback");
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/wrapAsync.js
var require_wrapAsync = __commonJS({
  "node_modules/async/internal/wrapAsync.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.isAsyncIterable = exports2.isAsyncGenerator = exports2.isAsync = void 0;
    var _asyncify = require_asyncify();
    var _asyncify2 = _interopRequireDefault(_asyncify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function isAsync2(fn) {
      return fn[Symbol.toStringTag] === "AsyncFunction";
    }
    __name(isAsync2, "isAsync");
    function isAsyncGenerator(fn) {
      return fn[Symbol.toStringTag] === "AsyncGenerator";
    }
    __name(isAsyncGenerator, "isAsyncGenerator");
    function isAsyncIterable(obj) {
      return typeof obj[Symbol.asyncIterator] === "function";
    }
    __name(isAsyncIterable, "isAsyncIterable");
    function wrapAsync(asyncFn) {
      if (typeof asyncFn !== "function") throw new Error("expected a function");
      return isAsync2(asyncFn) ? (0, _asyncify2.default)(asyncFn) : asyncFn;
    }
    __name(wrapAsync, "wrapAsync");
    exports2.default = wrapAsync;
    exports2.isAsync = isAsync2;
    exports2.isAsyncGenerator = isAsyncGenerator;
    exports2.isAsyncIterable = isAsyncIterable;
  }
});

// node_modules/async/internal/awaitify.js
var require_awaitify = __commonJS({
  "node_modules/async/internal/awaitify.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = awaitify;
    function awaitify(asyncFn, arity) {
      if (!arity) arity = asyncFn.length;
      if (!arity) throw new Error("arity is undefined");
      function awaitable(...args) {
        if (typeof args[arity - 1] === "function") {
          return asyncFn.apply(this, args);
        }
        return new Promise((resolve5, reject) => {
          args[arity - 1] = (err, ...cbArgs) => {
            if (err) return reject(err);
            resolve5(cbArgs.length > 1 ? cbArgs : cbArgs[0]);
          };
          asyncFn.apply(this, args);
        });
      }
      __name(awaitable, "awaitable");
      return awaitable;
    }
    __name(awaitify, "awaitify");
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/parallel.js
var require_parallel = __commonJS({
  "node_modules/async/internal/parallel.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    exports2.default = (0, _awaitify2.default)((eachfn, tasks, callback) => {
      var results = (0, _isArrayLike2.default)(tasks) ? [] : {};
      eachfn(tasks, (task, key, taskCb) => {
        (0, _wrapAsync2.default)(task)((err, ...result2) => {
          if (result2.length < 2) {
            [result2] = result2;
          }
          results[key] = result2;
          taskCb(err);
        });
      }, (err) => callback(err, results));
    }, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/once.js
var require_once = __commonJS({
  "node_modules/async/internal/once.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = once;
    function once(fn) {
      function wrapper(...args) {
        if (fn === null) return;
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      }
      __name(wrapper, "wrapper");
      Object.assign(wrapper, fn);
      return wrapper;
    }
    __name(once, "once");
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/getIterator.js
var require_getIterator = __commonJS({
  "node_modules/async/internal/getIterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = function(coll) {
      return coll[Symbol.iterator] && coll[Symbol.iterator]();
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/iterator.js
var require_iterator = __commonJS({
  "node_modules/async/internal/iterator.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = createIterator;
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _getIterator = require_getIterator();
    var _getIterator2 = _interopRequireDefault(_getIterator);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function createArrayIterator(coll) {
      var i = -1;
      var len = coll.length;
      return /* @__PURE__ */ __name(function next() {
        return ++i < len ? {
          value: coll[i],
          key: i
        } : null;
      }, "next");
    }
    __name(createArrayIterator, "createArrayIterator");
    function createES2015Iterator(iterator) {
      var i = -1;
      return /* @__PURE__ */ __name(function next() {
        var item = iterator.next();
        if (item.done) return null;
        i++;
        return {
          value: item.value,
          key: i
        };
      }, "next");
    }
    __name(createES2015Iterator, "createES2015Iterator");
    function createObjectIterator(obj) {
      var okeys = obj ? Object.keys(obj) : [];
      var i = -1;
      var len = okeys.length;
      return /* @__PURE__ */ __name(function next() {
        var key = okeys[++i];
        if (key === "__proto__") {
          return next();
        }
        return i < len ? {
          value: obj[key],
          key
        } : null;
      }, "next");
    }
    __name(createObjectIterator, "createObjectIterator");
    function createIterator(coll) {
      if ((0, _isArrayLike2.default)(coll)) {
        return createArrayIterator(coll);
      }
      var iterator = (0, _getIterator2.default)(coll);
      return iterator ? createES2015Iterator(iterator) : createObjectIterator(coll);
    }
    __name(createIterator, "createIterator");
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/onlyOnce.js
var require_onlyOnce = __commonJS({
  "node_modules/async/internal/onlyOnce.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = onlyOnce;
    function onlyOnce(fn) {
      return function(...args) {
        if (fn === null) throw new Error("Callback was already called.");
        var callFn = fn;
        fn = null;
        callFn.apply(this, args);
      };
    }
    __name(onlyOnce, "onlyOnce");
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/breakLoop.js
var require_breakLoop = __commonJS({
  "node_modules/async/internal/breakLoop.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var breakLoop = {};
    exports2.default = breakLoop;
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/asyncEachOfLimit.js
var require_asyncEachOfLimit = __commonJS({
  "node_modules/async/internal/asyncEachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = asyncEachOfLimit;
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function asyncEachOfLimit(generator, limit, iteratee, callback) {
      let done = false;
      let canceled = false;
      let awaiting = false;
      let running = 0;
      let idx = 0;
      function replenish() {
        if (running >= limit || awaiting || done) return;
        awaiting = true;
        generator.next().then(({ value: value2, done: iterDone }) => {
          if (canceled || done) return;
          awaiting = false;
          if (iterDone) {
            done = true;
            if (running <= 0) {
              callback(null);
            }
            return;
          }
          running++;
          iteratee(value2, idx, iterateeCallback);
          idx++;
          replenish();
        }).catch(handleError);
      }
      __name(replenish, "replenish");
      function iterateeCallback(err, result2) {
        running -= 1;
        if (canceled) return;
        if (err) return handleError(err);
        if (err === false) {
          done = true;
          canceled = true;
          return;
        }
        if (result2 === _breakLoop2.default || done && running <= 0) {
          done = true;
          return callback(null);
        }
        replenish();
      }
      __name(iterateeCallback, "iterateeCallback");
      function handleError(err) {
        if (canceled) return;
        awaiting = false;
        done = true;
        callback(err);
      }
      __name(handleError, "handleError");
      replenish();
    }
    __name(asyncEachOfLimit, "asyncEachOfLimit");
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/eachOfLimit.js
var require_eachOfLimit = __commonJS({
  "node_modules/async/internal/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _iterator = require_iterator();
    var _iterator2 = _interopRequireDefault(_iterator);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _asyncEachOfLimit = require_asyncEachOfLimit();
    var _asyncEachOfLimit2 = _interopRequireDefault(_asyncEachOfLimit);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    exports2.default = (limit) => {
      return (obj, iteratee, callback) => {
        callback = (0, _once2.default)(callback);
        if (limit <= 0) {
          throw new RangeError("concurrency limit cannot be less than 1");
        }
        if (!obj) {
          return callback(null);
        }
        if ((0, _wrapAsync.isAsyncGenerator)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj, limit, iteratee, callback);
        }
        if ((0, _wrapAsync.isAsyncIterable)(obj)) {
          return (0, _asyncEachOfLimit2.default)(obj[Symbol.asyncIterator](), limit, iteratee, callback);
        }
        var nextElem = (0, _iterator2.default)(obj);
        var done = false;
        var canceled = false;
        var running = 0;
        var looping = false;
        function iterateeCallback(err, value2) {
          if (canceled) return;
          running -= 1;
          if (err) {
            done = true;
            callback(err);
          } else if (err === false) {
            done = true;
            canceled = true;
          } else if (value2 === _breakLoop2.default || done && running <= 0) {
            done = true;
            return callback(null);
          } else if (!looping) {
            replenish();
          }
        }
        __name(iterateeCallback, "iterateeCallback");
        function replenish() {
          looping = true;
          while (running < limit && !done) {
            var elem = nextElem();
            if (elem === null) {
              done = true;
              if (running <= 0) {
                callback(null);
              }
              return;
            }
            running += 1;
            iteratee(elem.value, elem.key, (0, _onlyOnce2.default)(iterateeCallback));
          }
          looping = false;
        }
        __name(replenish, "replenish");
        replenish();
      };
    };
    module2.exports = exports2.default;
  }
});

// node_modules/async/eachOfLimit.js
var require_eachOfLimit2 = __commonJS({
  "node_modules/async/eachOfLimit.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit2 = require_eachOfLimit();
    var _eachOfLimit3 = _interopRequireDefault(_eachOfLimit2);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function eachOfLimit(coll, limit, iteratee, callback) {
      return (0, _eachOfLimit3.default)(limit)(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    __name(eachOfLimit, "eachOfLimit");
    exports2.default = (0, _awaitify2.default)(eachOfLimit, 4);
    module2.exports = exports2.default;
  }
});

// node_modules/async/eachOfSeries.js
var require_eachOfSeries = __commonJS({
  "node_modules/async/eachOfSeries.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function eachOfSeries(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, 1, iteratee, callback);
    }
    __name(eachOfSeries, "eachOfSeries");
    exports2.default = (0, _awaitify2.default)(eachOfSeries, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/series.js
var require_series = __commonJS({
  "node_modules/async/series.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = series;
    var _parallel2 = require_parallel();
    var _parallel3 = _interopRequireDefault(_parallel2);
    var _eachOfSeries = require_eachOfSeries();
    var _eachOfSeries2 = _interopRequireDefault(_eachOfSeries);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function series(tasks, callback) {
      return (0, _parallel3.default)(_eachOfSeries2.default, tasks, callback);
    }
    __name(series, "series");
    module2.exports = exports2.default;
  }
});

// node_modules/readable-stream/lib/_stream_transform.js
var require_stream_transform = __commonJS({
  "node_modules/readable-stream/lib/_stream_transform.js"(exports2, module2) {
    "use strict";
    module2.exports = Transform;
    var _require$codes = require_errors2().codes;
    var ERR_METHOD_NOT_IMPLEMENTED = _require$codes.ERR_METHOD_NOT_IMPLEMENTED;
    var ERR_MULTIPLE_CALLBACK = _require$codes.ERR_MULTIPLE_CALLBACK;
    var ERR_TRANSFORM_ALREADY_TRANSFORMING = _require$codes.ERR_TRANSFORM_ALREADY_TRANSFORMING;
    var ERR_TRANSFORM_WITH_LENGTH_0 = _require$codes.ERR_TRANSFORM_WITH_LENGTH_0;
    var Duplex = require_stream_duplex();
    require_inherits()(Transform, Duplex);
    function afterTransform(er, data) {
      var ts = this._transformState;
      ts.transforming = false;
      var cb = ts.writecb;
      if (cb === null) {
        return this.emit("error", new ERR_MULTIPLE_CALLBACK());
      }
      ts.writechunk = null;
      ts.writecb = null;
      if (data != null)
        this.push(data);
      cb(er);
      var rs = this._readableState;
      rs.reading = false;
      if (rs.needReadable || rs.length < rs.highWaterMark) {
        this._read(rs.highWaterMark);
      }
    }
    __name(afterTransform, "afterTransform");
    function Transform(options) {
      if (!(this instanceof Transform)) return new Transform(options);
      Duplex.call(this, options);
      this._transformState = {
        afterTransform: afterTransform.bind(this),
        needTransform: false,
        transforming: false,
        writecb: null,
        writechunk: null,
        writeencoding: null
      };
      this._readableState.needReadable = true;
      this._readableState.sync = false;
      if (options) {
        if (typeof options.transform === "function") this._transform = options.transform;
        if (typeof options.flush === "function") this._flush = options.flush;
      }
      this.on("prefinish", prefinish);
    }
    __name(Transform, "Transform");
    function prefinish() {
      var _this = this;
      if (typeof this._flush === "function" && !this._readableState.destroyed) {
        this._flush(function(er, data) {
          done(_this, er, data);
        });
      } else {
        done(this, null, null);
      }
    }
    __name(prefinish, "prefinish");
    Transform.prototype.push = function(chunk, encoding) {
      this._transformState.needTransform = false;
      return Duplex.prototype.push.call(this, chunk, encoding);
    };
    Transform.prototype._transform = function(chunk, encoding, cb) {
      cb(new ERR_METHOD_NOT_IMPLEMENTED("_transform()"));
    };
    Transform.prototype._write = function(chunk, encoding, cb) {
      var ts = this._transformState;
      ts.writecb = cb;
      ts.writechunk = chunk;
      ts.writeencoding = encoding;
      if (!ts.transforming) {
        var rs = this._readableState;
        if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
      }
    };
    Transform.prototype._read = function(n) {
      var ts = this._transformState;
      if (ts.writechunk !== null && !ts.transforming) {
        ts.transforming = true;
        this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
      } else {
        ts.needTransform = true;
      }
    };
    Transform.prototype._destroy = function(err, cb) {
      Duplex.prototype._destroy.call(this, err, function(err2) {
        cb(err2);
      });
    };
    function done(stream, er, data) {
      if (er) return stream.emit("error", er);
      if (data != null)
        stream.push(data);
      if (stream._writableState.length) throw new ERR_TRANSFORM_WITH_LENGTH_0();
      if (stream._transformState.transforming) throw new ERR_TRANSFORM_ALREADY_TRANSFORMING();
      return stream.push(null);
    }
    __name(done, "done");
  }
});

// node_modules/readable-stream/lib/_stream_passthrough.js
var require_stream_passthrough = __commonJS({
  "node_modules/readable-stream/lib/_stream_passthrough.js"(exports2, module2) {
    "use strict";
    module2.exports = PassThrough;
    var Transform = require_stream_transform();
    require_inherits()(PassThrough, Transform);
    function PassThrough(options) {
      if (!(this instanceof PassThrough)) return new PassThrough(options);
      Transform.call(this, options);
    }
    __name(PassThrough, "PassThrough");
    PassThrough.prototype._transform = function(chunk, encoding, cb) {
      cb(null, chunk);
    };
  }
});

// node_modules/readable-stream/lib/internal/streams/pipeline.js
var require_pipeline = __commonJS({
  "node_modules/readable-stream/lib/internal/streams/pipeline.js"(exports2, module2) {
    "use strict";
    var eos;
    function once(callback) {
      var called = false;
      return function() {
        if (called) return;
        called = true;
        callback.apply(void 0, arguments);
      };
    }
    __name(once, "once");
    var _require$codes = require_errors2().codes;
    var ERR_MISSING_ARGS = _require$codes.ERR_MISSING_ARGS;
    var ERR_STREAM_DESTROYED = _require$codes.ERR_STREAM_DESTROYED;
    function noop(err) {
      if (err) throw err;
    }
    __name(noop, "noop");
    function isRequest(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }
    __name(isRequest, "isRequest");
    function destroyer(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      if (eos === void 0) eos = require_end_of_stream();
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isRequest(stream)) return stream.abort();
        if (typeof stream.destroy === "function") return stream.destroy();
        callback(err || new ERR_STREAM_DESTROYED("pipe"));
      };
    }
    __name(destroyer, "destroyer");
    function call(fn) {
      fn();
    }
    __name(call, "call");
    function pipe(from, to) {
      return from.pipe(to);
    }
    __name(pipe, "pipe");
    function popCallback(streams) {
      if (!streams.length) return noop;
      if (typeof streams[streams.length - 1] !== "function") return noop;
      return streams.pop();
    }
    __name(popCallback, "popCallback");
    function pipeline() {
      for (var _len = arguments.length, streams = new Array(_len), _key = 0; _key < _len; _key++) {
        streams[_key] = arguments[_key];
      }
      var callback = popCallback(streams);
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) {
        throw new ERR_MISSING_ARGS("streams");
      }
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }
    __name(pipeline, "pipeline");
    module2.exports = pipeline;
  }
});

// node_modules/readable-stream/readable.js
var require_readable = __commonJS({
  "node_modules/readable-stream/readable.js"(exports2, module2) {
    "use strict";
    var Stream = require("stream");
    if (process.env.READABLE_STREAM === "disable" && Stream) {
      module2.exports = Stream.Readable;
      Object.assign(module2.exports, Stream);
      module2.exports.Stream = Stream;
    } else {
      exports2 = module2.exports = require_stream_readable();
      exports2.Stream = Stream || exports2;
      exports2.Readable = exports2;
      exports2.Writable = require_stream_writable();
      exports2.Duplex = require_stream_duplex();
      exports2.Transform = require_stream_transform();
      exports2.PassThrough = require_stream_passthrough();
      exports2.finished = require_end_of_stream();
      exports2.pipeline = require_pipeline();
    }
  }
});

// node_modules/@dabh/diagnostics/diagnostics.js
var require_diagnostics = __commonJS({
  "node_modules/@dabh/diagnostics/diagnostics.js"(exports2, module2) {
    "use strict";
    var adapters = [];
    var modifiers = [];
    var logger2 = /* @__PURE__ */ __name(function devnull() {
    }, "devnull");
    function use(adapter) {
      if (~adapters.indexOf(adapter)) return false;
      adapters.push(adapter);
      return true;
    }
    __name(use, "use");
    function set(custom2) {
      logger2 = custom2;
    }
    __name(set, "set");
    function enabled(namespace) {
      var async = [];
      for (var i = 0; i < adapters.length; i++) {
        if (adapters[i].async) {
          async.push(adapters[i]);
          continue;
        }
        if (adapters[i](namespace)) return true;
      }
      if (!async.length) return false;
      return new Promise(/* @__PURE__ */ __name(function pinky(resolve5) {
        Promise.all(async.map(/* @__PURE__ */ __name(function prebind(fn) {
          return fn(namespace);
        }, "prebind"))).then(/* @__PURE__ */ __name(function resolved(values) {
          resolve5(values.some(Boolean));
        }, "resolved"));
      }, "pinky"));
    }
    __name(enabled, "enabled");
    function modify(fn) {
      if (~modifiers.indexOf(fn)) return false;
      modifiers.push(fn);
      return true;
    }
    __name(modify, "modify");
    function write() {
      logger2.apply(logger2, arguments);
    }
    __name(write, "write");
    function process2(message) {
      for (var i = 0; i < modifiers.length; i++) {
        message = modifiers[i].apply(modifiers[i], arguments);
      }
      return message;
    }
    __name(process2, "process");
    function introduce(fn, options) {
      var has = Object.prototype.hasOwnProperty;
      for (var key in options) {
        if (has.call(options, key)) {
          fn[key] = options[key];
        }
      }
      return fn;
    }
    __name(introduce, "introduce");
    function nope(options) {
      options.enabled = false;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(/* @__PURE__ */ __name(function diagnopes() {
        return false;
      }, "diagnopes"), options);
    }
    __name(nope, "nope");
    function yep(options) {
      function diagnostics() {
        var args = Array.prototype.slice.call(arguments, 0);
        write.call(write, options, process2(args, options));
        return true;
      }
      __name(diagnostics, "diagnostics");
      options.enabled = true;
      options.modify = modify;
      options.set = set;
      options.use = use;
      return introduce(diagnostics, options);
    }
    __name(yep, "yep");
    module2.exports = /* @__PURE__ */ __name(function create(diagnostics) {
      diagnostics.introduce = introduce;
      diagnostics.enabled = enabled;
      diagnostics.process = process2;
      diagnostics.modify = modify;
      diagnostics.write = write;
      diagnostics.nope = nope;
      diagnostics.yep = yep;
      diagnostics.set = set;
      diagnostics.use = use;
      return diagnostics;
    }, "create");
  }
});

// node_modules/@dabh/diagnostics/node/production.js
var require_production = __commonJS({
  "node_modules/@dabh/diagnostics/node/production.js"(exports2, module2) {
    "use strict";
    var create = require_diagnostics();
    var diagnostics = create(/* @__PURE__ */ __name(function prod(namespace, options) {
      options = options || {};
      options.namespace = namespace;
      options.prod = true;
      options.dev = false;
      if (!(options.force || prod.force)) return prod.nope(options);
      return prod.yep(options);
    }, "prod"));
    module2.exports = diagnostics;
  }
});

// node_modules/color-name/index.js
var require_color_name = __commonJS({
  "node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [
        240,
        248,
        255
      ],
      "antiquewhite": [
        250,
        235,
        215
      ],
      "aqua": [
        0,
        255,
        255
      ],
      "aquamarine": [
        127,
        255,
        212
      ],
      "azure": [
        240,
        255,
        255
      ],
      "beige": [
        245,
        245,
        220
      ],
      "bisque": [
        255,
        228,
        196
      ],
      "black": [
        0,
        0,
        0
      ],
      "blanchedalmond": [
        255,
        235,
        205
      ],
      "blue": [
        0,
        0,
        255
      ],
      "blueviolet": [
        138,
        43,
        226
      ],
      "brown": [
        165,
        42,
        42
      ],
      "burlywood": [
        222,
        184,
        135
      ],
      "cadetblue": [
        95,
        158,
        160
      ],
      "chartreuse": [
        127,
        255,
        0
      ],
      "chocolate": [
        210,
        105,
        30
      ],
      "coral": [
        255,
        127,
        80
      ],
      "cornflowerblue": [
        100,
        149,
        237
      ],
      "cornsilk": [
        255,
        248,
        220
      ],
      "crimson": [
        220,
        20,
        60
      ],
      "cyan": [
        0,
        255,
        255
      ],
      "darkblue": [
        0,
        0,
        139
      ],
      "darkcyan": [
        0,
        139,
        139
      ],
      "darkgoldenrod": [
        184,
        134,
        11
      ],
      "darkgray": [
        169,
        169,
        169
      ],
      "darkgreen": [
        0,
        100,
        0
      ],
      "darkgrey": [
        169,
        169,
        169
      ],
      "darkkhaki": [
        189,
        183,
        107
      ],
      "darkmagenta": [
        139,
        0,
        139
      ],
      "darkolivegreen": [
        85,
        107,
        47
      ],
      "darkorange": [
        255,
        140,
        0
      ],
      "darkorchid": [
        153,
        50,
        204
      ],
      "darkred": [
        139,
        0,
        0
      ],
      "darksalmon": [
        233,
        150,
        122
      ],
      "darkseagreen": [
        143,
        188,
        143
      ],
      "darkslateblue": [
        72,
        61,
        139
      ],
      "darkslategray": [
        47,
        79,
        79
      ],
      "darkslategrey": [
        47,
        79,
        79
      ],
      "darkturquoise": [
        0,
        206,
        209
      ],
      "darkviolet": [
        148,
        0,
        211
      ],
      "deeppink": [
        255,
        20,
        147
      ],
      "deepskyblue": [
        0,
        191,
        255
      ],
      "dimgray": [
        105,
        105,
        105
      ],
      "dimgrey": [
        105,
        105,
        105
      ],
      "dodgerblue": [
        30,
        144,
        255
      ],
      "firebrick": [
        178,
        34,
        34
      ],
      "floralwhite": [
        255,
        250,
        240
      ],
      "forestgreen": [
        34,
        139,
        34
      ],
      "fuchsia": [
        255,
        0,
        255
      ],
      "gainsboro": [
        220,
        220,
        220
      ],
      "ghostwhite": [
        248,
        248,
        255
      ],
      "gold": [
        255,
        215,
        0
      ],
      "goldenrod": [
        218,
        165,
        32
      ],
      "gray": [
        128,
        128,
        128
      ],
      "green": [
        0,
        128,
        0
      ],
      "greenyellow": [
        173,
        255,
        47
      ],
      "grey": [
        128,
        128,
        128
      ],
      "honeydew": [
        240,
        255,
        240
      ],
      "hotpink": [
        255,
        105,
        180
      ],
      "indianred": [
        205,
        92,
        92
      ],
      "indigo": [
        75,
        0,
        130
      ],
      "ivory": [
        255,
        255,
        240
      ],
      "khaki": [
        240,
        230,
        140
      ],
      "lavender": [
        230,
        230,
        250
      ],
      "lavenderblush": [
        255,
        240,
        245
      ],
      "lawngreen": [
        124,
        252,
        0
      ],
      "lemonchiffon": [
        255,
        250,
        205
      ],
      "lightblue": [
        173,
        216,
        230
      ],
      "lightcoral": [
        240,
        128,
        128
      ],
      "lightcyan": [
        224,
        255,
        255
      ],
      "lightgoldenrodyellow": [
        250,
        250,
        210
      ],
      "lightgray": [
        211,
        211,
        211
      ],
      "lightgreen": [
        144,
        238,
        144
      ],
      "lightgrey": [
        211,
        211,
        211
      ],
      "lightpink": [
        255,
        182,
        193
      ],
      "lightsalmon": [
        255,
        160,
        122
      ],
      "lightseagreen": [
        32,
        178,
        170
      ],
      "lightskyblue": [
        135,
        206,
        250
      ],
      "lightslategray": [
        119,
        136,
        153
      ],
      "lightslategrey": [
        119,
        136,
        153
      ],
      "lightsteelblue": [
        176,
        196,
        222
      ],
      "lightyellow": [
        255,
        255,
        224
      ],
      "lime": [
        0,
        255,
        0
      ],
      "limegreen": [
        50,
        205,
        50
      ],
      "linen": [
        250,
        240,
        230
      ],
      "magenta": [
        255,
        0,
        255
      ],
      "maroon": [
        128,
        0,
        0
      ],
      "mediumaquamarine": [
        102,
        205,
        170
      ],
      "mediumblue": [
        0,
        0,
        205
      ],
      "mediumorchid": [
        186,
        85,
        211
      ],
      "mediumpurple": [
        147,
        112,
        219
      ],
      "mediumseagreen": [
        60,
        179,
        113
      ],
      "mediumslateblue": [
        123,
        104,
        238
      ],
      "mediumspringgreen": [
        0,
        250,
        154
      ],
      "mediumturquoise": [
        72,
        209,
        204
      ],
      "mediumvioletred": [
        199,
        21,
        133
      ],
      "midnightblue": [
        25,
        25,
        112
      ],
      "mintcream": [
        245,
        255,
        250
      ],
      "mistyrose": [
        255,
        228,
        225
      ],
      "moccasin": [
        255,
        228,
        181
      ],
      "navajowhite": [
        255,
        222,
        173
      ],
      "navy": [
        0,
        0,
        128
      ],
      "oldlace": [
        253,
        245,
        230
      ],
      "olive": [
        128,
        128,
        0
      ],
      "olivedrab": [
        107,
        142,
        35
      ],
      "orange": [
        255,
        165,
        0
      ],
      "orangered": [
        255,
        69,
        0
      ],
      "orchid": [
        218,
        112,
        214
      ],
      "palegoldenrod": [
        238,
        232,
        170
      ],
      "palegreen": [
        152,
        251,
        152
      ],
      "paleturquoise": [
        175,
        238,
        238
      ],
      "palevioletred": [
        219,
        112,
        147
      ],
      "papayawhip": [
        255,
        239,
        213
      ],
      "peachpuff": [
        255,
        218,
        185
      ],
      "peru": [
        205,
        133,
        63
      ],
      "pink": [
        255,
        192,
        203
      ],
      "plum": [
        221,
        160,
        221
      ],
      "powderblue": [
        176,
        224,
        230
      ],
      "purple": [
        128,
        0,
        128
      ],
      "rebeccapurple": [
        102,
        51,
        153
      ],
      "red": [
        255,
        0,
        0
      ],
      "rosybrown": [
        188,
        143,
        143
      ],
      "royalblue": [
        65,
        105,
        225
      ],
      "saddlebrown": [
        139,
        69,
        19
      ],
      "salmon": [
        250,
        128,
        114
      ],
      "sandybrown": [
        244,
        164,
        96
      ],
      "seagreen": [
        46,
        139,
        87
      ],
      "seashell": [
        255,
        245,
        238
      ],
      "sienna": [
        160,
        82,
        45
      ],
      "silver": [
        192,
        192,
        192
      ],
      "skyblue": [
        135,
        206,
        235
      ],
      "slateblue": [
        106,
        90,
        205
      ],
      "slategray": [
        112,
        128,
        144
      ],
      "slategrey": [
        112,
        128,
        144
      ],
      "snow": [
        255,
        250,
        250
      ],
      "springgreen": [
        0,
        255,
        127
      ],
      "steelblue": [
        70,
        130,
        180
      ],
      "tan": [
        210,
        180,
        140
      ],
      "teal": [
        0,
        128,
        128
      ],
      "thistle": [
        216,
        191,
        216
      ],
      "tomato": [
        255,
        99,
        71
      ],
      "turquoise": [
        64,
        224,
        208
      ],
      "violet": [
        238,
        130,
        238
      ],
      "wheat": [
        245,
        222,
        179
      ],
      "white": [
        255,
        255,
        255
      ],
      "whitesmoke": [
        245,
        245,
        245
      ],
      "yellow": [
        255,
        255,
        0
      ],
      "yellowgreen": [
        154,
        205,
        50
      ]
    };
  }
});

// node_modules/simple-swizzle/node_modules/is-arrayish/index.js
var require_is_arrayish = __commonJS({
  "node_modules/simple-swizzle/node_modules/is-arrayish/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name(function isArrayish(obj) {
      if (!obj || typeof obj === "string") {
        return false;
      }
      return obj instanceof Array || Array.isArray(obj) || obj.length >= 0 && (obj.splice instanceof Function || Object.getOwnPropertyDescriptor(obj, obj.length - 1) && obj.constructor.name !== "String");
    }, "isArrayish");
  }
});

// node_modules/simple-swizzle/index.js
var require_simple_swizzle = __commonJS({
  "node_modules/simple-swizzle/index.js"(exports2, module2) {
    "use strict";
    var isArrayish = require_is_arrayish();
    var concat = Array.prototype.concat;
    var slice = Array.prototype.slice;
    var swizzle = module2.exports = /* @__PURE__ */ __name(function swizzle2(args) {
      var results = [];
      for (var i = 0, len = args.length; i < len; i++) {
        var arg = args[i];
        if (isArrayish(arg)) {
          results = concat.call(results, slice.call(arg));
        } else {
          results.push(arg);
        }
      }
      return results;
    }, "swizzle");
    swizzle.wrap = function(fn) {
      return function() {
        return fn(swizzle(arguments));
      };
    };
  }
});

// node_modules/color-string/index.js
var require_color_string = __commonJS({
  "node_modules/color-string/index.js"(exports2, module2) {
    "use strict";
    var colorNames = require_color_name();
    var swizzle = require_simple_swizzle();
    var hasOwnProperty = Object.hasOwnProperty;
    var reverseNames = /* @__PURE__ */ Object.create(null);
    for (name in colorNames) {
      if (hasOwnProperty.call(colorNames, name)) {
        reverseNames[colorNames[name]] = name;
      }
    }
    var name;
    var cs = module2.exports = {
      to: {},
      get: {}
    };
    cs.get = function(string) {
      var prefix = string.substring(0, 3).toLowerCase();
      var val;
      var model;
      switch (prefix) {
        case "hsl":
          val = cs.get.hsl(string);
          model = "hsl";
          break;
        case "hwb":
          val = cs.get.hwb(string);
          model = "hwb";
          break;
        default:
          val = cs.get.rgb(string);
          model = "rgb";
          break;
      }
      if (!val) {
        return null;
      }
      return {
        model,
        value: val
      };
    };
    cs.get.rgb = function(string) {
      if (!string) {
        return null;
      }
      var abbr = /^#([a-f0-9]{3,4})$/i;
      var hex = /^#([a-f0-9]{6})([a-f0-9]{2})?$/i;
      var rgba = /^rgba?\(\s*([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)(?=[\s,])\s*(?:,\s*)?([+-]?\d+)\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var per = /^rgba?\(\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*,?\s*([+-]?[\d\.]+)\%\s*(?:[,|\/]\s*([+-]?[\d\.]+)(%?)\s*)?\)$/;
      var keyword = /^(\w+)$/;
      var rgb = [
        0,
        0,
        0,
        1
      ];
      var match;
      var i;
      var hexAlpha;
      if (match = string.match(hex)) {
        hexAlpha = match[2];
        match = match[1];
        for (i = 0; i < 3; i++) {
          var i2 = i * 2;
          rgb[i] = parseInt(match.slice(i2, i2 + 2), 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha, 16) / 255;
        }
      } else if (match = string.match(abbr)) {
        match = match[1];
        hexAlpha = match[3];
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i] + match[i], 16);
        }
        if (hexAlpha) {
          rgb[3] = parseInt(hexAlpha + hexAlpha, 16) / 255;
        }
      } else if (match = string.match(rgba)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = parseInt(match[i + 1], 0);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(per)) {
        for (i = 0; i < 3; i++) {
          rgb[i] = Math.round(parseFloat(match[i + 1]) * 2.55);
        }
        if (match[4]) {
          if (match[5]) {
            rgb[3] = parseFloat(match[4]) * 0.01;
          } else {
            rgb[3] = parseFloat(match[4]);
          }
        }
      } else if (match = string.match(keyword)) {
        if (match[1] === "transparent") {
          return [
            0,
            0,
            0,
            0
          ];
        }
        if (!hasOwnProperty.call(colorNames, match[1])) {
          return null;
        }
        rgb = colorNames[match[1]];
        rgb[3] = 1;
        return rgb;
      } else {
        return null;
      }
      for (i = 0; i < 3; i++) {
        rgb[i] = clamp(rgb[i], 0, 255);
      }
      rgb[3] = clamp(rgb[3], 0, 1);
      return rgb;
    };
    cs.get.hsl = function(string) {
      if (!string) {
        return null;
      }
      var hsl = /^hsla?\(\s*([+-]?(?:\d{0,3}\.)?\d+)(?:deg)?\s*,?\s*([+-]?[\d\.]+)%\s*,?\s*([+-]?[\d\.]+)%\s*(?:[,|\/]\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hsl);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var s = clamp(parseFloat(match[2]), 0, 100);
        var l = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [
          h,
          s,
          l,
          a
        ];
      }
      return null;
    };
    cs.get.hwb = function(string) {
      if (!string) {
        return null;
      }
      var hwb = /^hwb\(\s*([+-]?\d{0,3}(?:\.\d+)?)(?:deg)?\s*,\s*([+-]?[\d\.]+)%\s*,\s*([+-]?[\d\.]+)%\s*(?:,\s*([+-]?(?=\.\d|\d)(?:0|[1-9]\d*)?(?:\.\d*)?(?:[eE][+-]?\d+)?)\s*)?\)$/;
      var match = string.match(hwb);
      if (match) {
        var alpha = parseFloat(match[4]);
        var h = (parseFloat(match[1]) % 360 + 360) % 360;
        var w = clamp(parseFloat(match[2]), 0, 100);
        var b = clamp(parseFloat(match[3]), 0, 100);
        var a = clamp(isNaN(alpha) ? 1 : alpha, 0, 1);
        return [
          h,
          w,
          b,
          a
        ];
      }
      return null;
    };
    cs.to.hex = function() {
      var rgba = swizzle(arguments);
      return "#" + hexDouble(rgba[0]) + hexDouble(rgba[1]) + hexDouble(rgba[2]) + (rgba[3] < 1 ? hexDouble(Math.round(rgba[3] * 255)) : "");
    };
    cs.to.rgb = function() {
      var rgba = swizzle(arguments);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ")" : "rgba(" + Math.round(rgba[0]) + ", " + Math.round(rgba[1]) + ", " + Math.round(rgba[2]) + ", " + rgba[3] + ")";
    };
    cs.to.rgb.percent = function() {
      var rgba = swizzle(arguments);
      var r = Math.round(rgba[0] / 255 * 100);
      var g = Math.round(rgba[1] / 255 * 100);
      var b = Math.round(rgba[2] / 255 * 100);
      return rgba.length < 4 || rgba[3] === 1 ? "rgb(" + r + "%, " + g + "%, " + b + "%)" : "rgba(" + r + "%, " + g + "%, " + b + "%, " + rgba[3] + ")";
    };
    cs.to.hsl = function() {
      var hsla = swizzle(arguments);
      return hsla.length < 4 || hsla[3] === 1 ? "hsl(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%)" : "hsla(" + hsla[0] + ", " + hsla[1] + "%, " + hsla[2] + "%, " + hsla[3] + ")";
    };
    cs.to.hwb = function() {
      var hwba = swizzle(arguments);
      var a = "";
      if (hwba.length >= 4 && hwba[3] !== 1) {
        a = ", " + hwba[3];
      }
      return "hwb(" + hwba[0] + ", " + hwba[1] + "%, " + hwba[2] + "%" + a + ")";
    };
    cs.to.keyword = function(rgb) {
      return reverseNames[rgb.slice(0, 3)];
    };
    function clamp(num, min, max) {
      return Math.min(Math.max(min, num), max);
    }
    __name(clamp, "clamp");
    function hexDouble(num) {
      var str = Math.round(num).toString(16).toUpperCase();
      return str.length < 2 ? "0" + str : str;
    }
    __name(hexDouble, "hexDouble");
  }
});

// node_modules/color-convert/node_modules/color-name/index.js
var require_color_name2 = __commonJS({
  "node_modules/color-convert/node_modules/color-name/index.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      "aliceblue": [
        240,
        248,
        255
      ],
      "antiquewhite": [
        250,
        235,
        215
      ],
      "aqua": [
        0,
        255,
        255
      ],
      "aquamarine": [
        127,
        255,
        212
      ],
      "azure": [
        240,
        255,
        255
      ],
      "beige": [
        245,
        245,
        220
      ],
      "bisque": [
        255,
        228,
        196
      ],
      "black": [
        0,
        0,
        0
      ],
      "blanchedalmond": [
        255,
        235,
        205
      ],
      "blue": [
        0,
        0,
        255
      ],
      "blueviolet": [
        138,
        43,
        226
      ],
      "brown": [
        165,
        42,
        42
      ],
      "burlywood": [
        222,
        184,
        135
      ],
      "cadetblue": [
        95,
        158,
        160
      ],
      "chartreuse": [
        127,
        255,
        0
      ],
      "chocolate": [
        210,
        105,
        30
      ],
      "coral": [
        255,
        127,
        80
      ],
      "cornflowerblue": [
        100,
        149,
        237
      ],
      "cornsilk": [
        255,
        248,
        220
      ],
      "crimson": [
        220,
        20,
        60
      ],
      "cyan": [
        0,
        255,
        255
      ],
      "darkblue": [
        0,
        0,
        139
      ],
      "darkcyan": [
        0,
        139,
        139
      ],
      "darkgoldenrod": [
        184,
        134,
        11
      ],
      "darkgray": [
        169,
        169,
        169
      ],
      "darkgreen": [
        0,
        100,
        0
      ],
      "darkgrey": [
        169,
        169,
        169
      ],
      "darkkhaki": [
        189,
        183,
        107
      ],
      "darkmagenta": [
        139,
        0,
        139
      ],
      "darkolivegreen": [
        85,
        107,
        47
      ],
      "darkorange": [
        255,
        140,
        0
      ],
      "darkorchid": [
        153,
        50,
        204
      ],
      "darkred": [
        139,
        0,
        0
      ],
      "darksalmon": [
        233,
        150,
        122
      ],
      "darkseagreen": [
        143,
        188,
        143
      ],
      "darkslateblue": [
        72,
        61,
        139
      ],
      "darkslategray": [
        47,
        79,
        79
      ],
      "darkslategrey": [
        47,
        79,
        79
      ],
      "darkturquoise": [
        0,
        206,
        209
      ],
      "darkviolet": [
        148,
        0,
        211
      ],
      "deeppink": [
        255,
        20,
        147
      ],
      "deepskyblue": [
        0,
        191,
        255
      ],
      "dimgray": [
        105,
        105,
        105
      ],
      "dimgrey": [
        105,
        105,
        105
      ],
      "dodgerblue": [
        30,
        144,
        255
      ],
      "firebrick": [
        178,
        34,
        34
      ],
      "floralwhite": [
        255,
        250,
        240
      ],
      "forestgreen": [
        34,
        139,
        34
      ],
      "fuchsia": [
        255,
        0,
        255
      ],
      "gainsboro": [
        220,
        220,
        220
      ],
      "ghostwhite": [
        248,
        248,
        255
      ],
      "gold": [
        255,
        215,
        0
      ],
      "goldenrod": [
        218,
        165,
        32
      ],
      "gray": [
        128,
        128,
        128
      ],
      "green": [
        0,
        128,
        0
      ],
      "greenyellow": [
        173,
        255,
        47
      ],
      "grey": [
        128,
        128,
        128
      ],
      "honeydew": [
        240,
        255,
        240
      ],
      "hotpink": [
        255,
        105,
        180
      ],
      "indianred": [
        205,
        92,
        92
      ],
      "indigo": [
        75,
        0,
        130
      ],
      "ivory": [
        255,
        255,
        240
      ],
      "khaki": [
        240,
        230,
        140
      ],
      "lavender": [
        230,
        230,
        250
      ],
      "lavenderblush": [
        255,
        240,
        245
      ],
      "lawngreen": [
        124,
        252,
        0
      ],
      "lemonchiffon": [
        255,
        250,
        205
      ],
      "lightblue": [
        173,
        216,
        230
      ],
      "lightcoral": [
        240,
        128,
        128
      ],
      "lightcyan": [
        224,
        255,
        255
      ],
      "lightgoldenrodyellow": [
        250,
        250,
        210
      ],
      "lightgray": [
        211,
        211,
        211
      ],
      "lightgreen": [
        144,
        238,
        144
      ],
      "lightgrey": [
        211,
        211,
        211
      ],
      "lightpink": [
        255,
        182,
        193
      ],
      "lightsalmon": [
        255,
        160,
        122
      ],
      "lightseagreen": [
        32,
        178,
        170
      ],
      "lightskyblue": [
        135,
        206,
        250
      ],
      "lightslategray": [
        119,
        136,
        153
      ],
      "lightslategrey": [
        119,
        136,
        153
      ],
      "lightsteelblue": [
        176,
        196,
        222
      ],
      "lightyellow": [
        255,
        255,
        224
      ],
      "lime": [
        0,
        255,
        0
      ],
      "limegreen": [
        50,
        205,
        50
      ],
      "linen": [
        250,
        240,
        230
      ],
      "magenta": [
        255,
        0,
        255
      ],
      "maroon": [
        128,
        0,
        0
      ],
      "mediumaquamarine": [
        102,
        205,
        170
      ],
      "mediumblue": [
        0,
        0,
        205
      ],
      "mediumorchid": [
        186,
        85,
        211
      ],
      "mediumpurple": [
        147,
        112,
        219
      ],
      "mediumseagreen": [
        60,
        179,
        113
      ],
      "mediumslateblue": [
        123,
        104,
        238
      ],
      "mediumspringgreen": [
        0,
        250,
        154
      ],
      "mediumturquoise": [
        72,
        209,
        204
      ],
      "mediumvioletred": [
        199,
        21,
        133
      ],
      "midnightblue": [
        25,
        25,
        112
      ],
      "mintcream": [
        245,
        255,
        250
      ],
      "mistyrose": [
        255,
        228,
        225
      ],
      "moccasin": [
        255,
        228,
        181
      ],
      "navajowhite": [
        255,
        222,
        173
      ],
      "navy": [
        0,
        0,
        128
      ],
      "oldlace": [
        253,
        245,
        230
      ],
      "olive": [
        128,
        128,
        0
      ],
      "olivedrab": [
        107,
        142,
        35
      ],
      "orange": [
        255,
        165,
        0
      ],
      "orangered": [
        255,
        69,
        0
      ],
      "orchid": [
        218,
        112,
        214
      ],
      "palegoldenrod": [
        238,
        232,
        170
      ],
      "palegreen": [
        152,
        251,
        152
      ],
      "paleturquoise": [
        175,
        238,
        238
      ],
      "palevioletred": [
        219,
        112,
        147
      ],
      "papayawhip": [
        255,
        239,
        213
      ],
      "peachpuff": [
        255,
        218,
        185
      ],
      "peru": [
        205,
        133,
        63
      ],
      "pink": [
        255,
        192,
        203
      ],
      "plum": [
        221,
        160,
        221
      ],
      "powderblue": [
        176,
        224,
        230
      ],
      "purple": [
        128,
        0,
        128
      ],
      "rebeccapurple": [
        102,
        51,
        153
      ],
      "red": [
        255,
        0,
        0
      ],
      "rosybrown": [
        188,
        143,
        143
      ],
      "royalblue": [
        65,
        105,
        225
      ],
      "saddlebrown": [
        139,
        69,
        19
      ],
      "salmon": [
        250,
        128,
        114
      ],
      "sandybrown": [
        244,
        164,
        96
      ],
      "seagreen": [
        46,
        139,
        87
      ],
      "seashell": [
        255,
        245,
        238
      ],
      "sienna": [
        160,
        82,
        45
      ],
      "silver": [
        192,
        192,
        192
      ],
      "skyblue": [
        135,
        206,
        235
      ],
      "slateblue": [
        106,
        90,
        205
      ],
      "slategray": [
        112,
        128,
        144
      ],
      "slategrey": [
        112,
        128,
        144
      ],
      "snow": [
        255,
        250,
        250
      ],
      "springgreen": [
        0,
        255,
        127
      ],
      "steelblue": [
        70,
        130,
        180
      ],
      "tan": [
        210,
        180,
        140
      ],
      "teal": [
        0,
        128,
        128
      ],
      "thistle": [
        216,
        191,
        216
      ],
      "tomato": [
        255,
        99,
        71
      ],
      "turquoise": [
        64,
        224,
        208
      ],
      "violet": [
        238,
        130,
        238
      ],
      "wheat": [
        245,
        222,
        179
      ],
      "white": [
        255,
        255,
        255
      ],
      "whitesmoke": [
        245,
        245,
        245
      ],
      "yellow": [
        255,
        255,
        0
      ],
      "yellowgreen": [
        154,
        205,
        50
      ]
    };
  }
});

// node_modules/color-convert/conversions.js
var require_conversions = __commonJS({
  "node_modules/color-convert/conversions.js"(exports2, module2) {
    "use strict";
    var cssKeywords = require_color_name2();
    var reverseKeywords = {};
    for (key in cssKeywords) {
      if (cssKeywords.hasOwnProperty(key)) {
        reverseKeywords[cssKeywords[key]] = key;
      }
    }
    var key;
    var convert = module2.exports = {
      rgb: {
        channels: 3,
        labels: "rgb"
      },
      hsl: {
        channels: 3,
        labels: "hsl"
      },
      hsv: {
        channels: 3,
        labels: "hsv"
      },
      hwb: {
        channels: 3,
        labels: "hwb"
      },
      cmyk: {
        channels: 4,
        labels: "cmyk"
      },
      xyz: {
        channels: 3,
        labels: "xyz"
      },
      lab: {
        channels: 3,
        labels: "lab"
      },
      lch: {
        channels: 3,
        labels: "lch"
      },
      hex: {
        channels: 1,
        labels: [
          "hex"
        ]
      },
      keyword: {
        channels: 1,
        labels: [
          "keyword"
        ]
      },
      ansi16: {
        channels: 1,
        labels: [
          "ansi16"
        ]
      },
      ansi256: {
        channels: 1,
        labels: [
          "ansi256"
        ]
      },
      hcg: {
        channels: 3,
        labels: [
          "h",
          "c",
          "g"
        ]
      },
      apple: {
        channels: 3,
        labels: [
          "r16",
          "g16",
          "b16"
        ]
      },
      gray: {
        channels: 1,
        labels: [
          "gray"
        ]
      }
    };
    for (model in convert) {
      if (convert.hasOwnProperty(model)) {
        if (!("channels" in convert[model])) {
          throw new Error("missing channels property: " + model);
        }
        if (!("labels" in convert[model])) {
          throw new Error("missing channel labels property: " + model);
        }
        if (convert[model].labels.length !== convert[model].channels) {
          throw new Error("channel and label counts mismatch: " + model);
        }
        channels = convert[model].channels;
        labels = convert[model].labels;
        delete convert[model].channels;
        delete convert[model].labels;
        Object.defineProperty(convert[model], "channels", {
          value: channels
        });
        Object.defineProperty(convert[model], "labels", {
          value: labels
        });
      }
    }
    var channels;
    var labels;
    var model;
    convert.rgb.hsl = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var min = Math.min(r, g, b);
      var max = Math.max(r, g, b);
      var delta = max - min;
      var h;
      var s;
      var l;
      if (max === min) {
        h = 0;
      } else if (r === max) {
        h = (g - b) / delta;
      } else if (g === max) {
        h = 2 + (b - r) / delta;
      } else if (b === max) {
        h = 4 + (r - g) / delta;
      }
      h = Math.min(h * 60, 360);
      if (h < 0) {
        h += 360;
      }
      l = (min + max) / 2;
      if (max === min) {
        s = 0;
      } else if (l <= 0.5) {
        s = delta / (max + min);
      } else {
        s = delta / (2 - max - min);
      }
      return [
        h,
        s * 100,
        l * 100
      ];
    };
    convert.rgb.hsv = function(rgb) {
      var rdif;
      var gdif;
      var bdif;
      var h;
      var s;
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var v = Math.max(r, g, b);
      var diff = v - Math.min(r, g, b);
      var diffc = /* @__PURE__ */ __name(function(c) {
        return (v - c) / 6 / diff + 1 / 2;
      }, "diffc");
      if (diff === 0) {
        h = s = 0;
      } else {
        s = diff / v;
        rdif = diffc(r);
        gdif = diffc(g);
        bdif = diffc(b);
        if (r === v) {
          h = bdif - gdif;
        } else if (g === v) {
          h = 1 / 3 + rdif - bdif;
        } else if (b === v) {
          h = 2 / 3 + gdif - rdif;
        }
        if (h < 0) {
          h += 1;
        } else if (h > 1) {
          h -= 1;
        }
      }
      return [
        h * 360,
        s * 100,
        v * 100
      ];
    };
    convert.rgb.hwb = function(rgb) {
      var r = rgb[0];
      var g = rgb[1];
      var b = rgb[2];
      var h = convert.rgb.hsl(rgb)[0];
      var w = 1 / 255 * Math.min(r, Math.min(g, b));
      b = 1 - 1 / 255 * Math.max(r, Math.max(g, b));
      return [
        h,
        w * 100,
        b * 100
      ];
    };
    convert.rgb.cmyk = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var c;
      var m;
      var y;
      var k;
      k = Math.min(1 - r, 1 - g, 1 - b);
      c = (1 - r - k) / (1 - k) || 0;
      m = (1 - g - k) / (1 - k) || 0;
      y = (1 - b - k) / (1 - k) || 0;
      return [
        c * 100,
        m * 100,
        y * 100,
        k * 100
      ];
    };
    function comparativeDistance(x, y) {
      return Math.pow(x[0] - y[0], 2) + Math.pow(x[1] - y[1], 2) + Math.pow(x[2] - y[2], 2);
    }
    __name(comparativeDistance, "comparativeDistance");
    convert.rgb.keyword = function(rgb) {
      var reversed = reverseKeywords[rgb];
      if (reversed) {
        return reversed;
      }
      var currentClosestDistance = Infinity;
      var currentClosestKeyword;
      for (var keyword in cssKeywords) {
        if (cssKeywords.hasOwnProperty(keyword)) {
          var value2 = cssKeywords[keyword];
          var distance = comparativeDistance(rgb, value2);
          if (distance < currentClosestDistance) {
            currentClosestDistance = distance;
            currentClosestKeyword = keyword;
          }
        }
      }
      return currentClosestKeyword;
    };
    convert.keyword.rgb = function(keyword) {
      return cssKeywords[keyword];
    };
    convert.rgb.xyz = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
      g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
      b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
      var x = r * 0.4124 + g * 0.3576 + b * 0.1805;
      var y = r * 0.2126 + g * 0.7152 + b * 0.0722;
      var z2 = r * 0.0193 + g * 0.1192 + b * 0.9505;
      return [
        x * 100,
        y * 100,
        z2 * 100
      ];
    };
    convert.rgb.lab = function(rgb) {
      var xyz = convert.rgb.xyz(rgb);
      var x = xyz[0];
      var y = xyz[1];
      var z2 = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z2 /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z2);
      return [
        l,
        a,
        b
      ];
    };
    convert.hsl.rgb = function(hsl) {
      var h = hsl[0] / 360;
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var t1;
      var t2;
      var t3;
      var rgb;
      var val;
      if (s === 0) {
        val = l * 255;
        return [
          val,
          val,
          val
        ];
      }
      if (l < 0.5) {
        t2 = l * (1 + s);
      } else {
        t2 = l + s - l * s;
      }
      t1 = 2 * l - t2;
      rgb = [
        0,
        0,
        0
      ];
      for (var i = 0; i < 3; i++) {
        t3 = h + 1 / 3 * -(i - 1);
        if (t3 < 0) {
          t3++;
        }
        if (t3 > 1) {
          t3--;
        }
        if (6 * t3 < 1) {
          val = t1 + (t2 - t1) * 6 * t3;
        } else if (2 * t3 < 1) {
          val = t2;
        } else if (3 * t3 < 2) {
          val = t1 + (t2 - t1) * (2 / 3 - t3) * 6;
        } else {
          val = t1;
        }
        rgb[i] = val * 255;
      }
      return rgb;
    };
    convert.hsl.hsv = function(hsl) {
      var h = hsl[0];
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var smin = s;
      var lmin = Math.max(l, 0.01);
      var sv;
      var v;
      l *= 2;
      s *= l <= 1 ? l : 2 - l;
      smin *= lmin <= 1 ? lmin : 2 - lmin;
      v = (l + s) / 2;
      sv = l === 0 ? 2 * smin / (lmin + smin) : 2 * s / (l + s);
      return [
        h,
        sv * 100,
        v * 100
      ];
    };
    convert.hsv.rgb = function(hsv) {
      var h = hsv[0] / 60;
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var hi = Math.floor(h) % 6;
      var f = h - Math.floor(h);
      var p = 255 * v * (1 - s);
      var q = 255 * v * (1 - s * f);
      var t = 255 * v * (1 - s * (1 - f));
      v *= 255;
      switch (hi) {
        case 0:
          return [
            v,
            t,
            p
          ];
        case 1:
          return [
            q,
            v,
            p
          ];
        case 2:
          return [
            p,
            v,
            t
          ];
        case 3:
          return [
            p,
            q,
            v
          ];
        case 4:
          return [
            t,
            p,
            v
          ];
        case 5:
          return [
            v,
            p,
            q
          ];
      }
    };
    convert.hsv.hsl = function(hsv) {
      var h = hsv[0];
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var vmin = Math.max(v, 0.01);
      var lmin;
      var sl;
      var l;
      l = (2 - s) * v;
      lmin = (2 - s) * vmin;
      sl = s * vmin;
      sl /= lmin <= 1 ? lmin : 2 - lmin;
      sl = sl || 0;
      l /= 2;
      return [
        h,
        sl * 100,
        l * 100
      ];
    };
    convert.hwb.rgb = function(hwb) {
      var h = hwb[0] / 360;
      var wh = hwb[1] / 100;
      var bl = hwb[2] / 100;
      var ratio = wh + bl;
      var i;
      var v;
      var f;
      var n;
      if (ratio > 1) {
        wh /= ratio;
        bl /= ratio;
      }
      i = Math.floor(6 * h);
      v = 1 - bl;
      f = 6 * h - i;
      if ((i & 1) !== 0) {
        f = 1 - f;
      }
      n = wh + f * (v - wh);
      var r;
      var g;
      var b;
      switch (i) {
        default:
        case 6:
        case 0:
          r = v;
          g = n;
          b = wh;
          break;
        case 1:
          r = n;
          g = v;
          b = wh;
          break;
        case 2:
          r = wh;
          g = v;
          b = n;
          break;
        case 3:
          r = wh;
          g = n;
          b = v;
          break;
        case 4:
          r = n;
          g = wh;
          b = v;
          break;
        case 5:
          r = v;
          g = wh;
          b = n;
          break;
      }
      return [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.cmyk.rgb = function(cmyk) {
      var c = cmyk[0] / 100;
      var m = cmyk[1] / 100;
      var y = cmyk[2] / 100;
      var k = cmyk[3] / 100;
      var r;
      var g;
      var b;
      r = 1 - Math.min(1, c * (1 - k) + k);
      g = 1 - Math.min(1, m * (1 - k) + k);
      b = 1 - Math.min(1, y * (1 - k) + k);
      return [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.xyz.rgb = function(xyz) {
      var x = xyz[0] / 100;
      var y = xyz[1] / 100;
      var z2 = xyz[2] / 100;
      var r;
      var g;
      var b;
      r = x * 3.2406 + y * -1.5372 + z2 * -0.4986;
      g = x * -0.9689 + y * 1.8758 + z2 * 0.0415;
      b = x * 0.0557 + y * -0.204 + z2 * 1.057;
      r = r > 31308e-7 ? 1.055 * Math.pow(r, 1 / 2.4) - 0.055 : r * 12.92;
      g = g > 31308e-7 ? 1.055 * Math.pow(g, 1 / 2.4) - 0.055 : g * 12.92;
      b = b > 31308e-7 ? 1.055 * Math.pow(b, 1 / 2.4) - 0.055 : b * 12.92;
      r = Math.min(Math.max(0, r), 1);
      g = Math.min(Math.max(0, g), 1);
      b = Math.min(Math.max(0, b), 1);
      return [
        r * 255,
        g * 255,
        b * 255
      ];
    };
    convert.xyz.lab = function(xyz) {
      var x = xyz[0];
      var y = xyz[1];
      var z2 = xyz[2];
      var l;
      var a;
      var b;
      x /= 95.047;
      y /= 100;
      z2 /= 108.883;
      x = x > 8856e-6 ? Math.pow(x, 1 / 3) : 7.787 * x + 16 / 116;
      y = y > 8856e-6 ? Math.pow(y, 1 / 3) : 7.787 * y + 16 / 116;
      z2 = z2 > 8856e-6 ? Math.pow(z2, 1 / 3) : 7.787 * z2 + 16 / 116;
      l = 116 * y - 16;
      a = 500 * (x - y);
      b = 200 * (y - z2);
      return [
        l,
        a,
        b
      ];
    };
    convert.lab.xyz = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var x;
      var y;
      var z2;
      y = (l + 16) / 116;
      x = a / 500 + y;
      z2 = y - b / 200;
      var y2 = Math.pow(y, 3);
      var x2 = Math.pow(x, 3);
      var z22 = Math.pow(z2, 3);
      y = y2 > 8856e-6 ? y2 : (y - 16 / 116) / 7.787;
      x = x2 > 8856e-6 ? x2 : (x - 16 / 116) / 7.787;
      z2 = z22 > 8856e-6 ? z22 : (z2 - 16 / 116) / 7.787;
      x *= 95.047;
      y *= 100;
      z2 *= 108.883;
      return [
        x,
        y,
        z2
      ];
    };
    convert.lab.lch = function(lab) {
      var l = lab[0];
      var a = lab[1];
      var b = lab[2];
      var hr;
      var h;
      var c;
      hr = Math.atan2(b, a);
      h = hr * 360 / 2 / Math.PI;
      if (h < 0) {
        h += 360;
      }
      c = Math.sqrt(a * a + b * b);
      return [
        l,
        c,
        h
      ];
    };
    convert.lch.lab = function(lch) {
      var l = lch[0];
      var c = lch[1];
      var h = lch[2];
      var a;
      var b;
      var hr;
      hr = h / 360 * 2 * Math.PI;
      a = c * Math.cos(hr);
      b = c * Math.sin(hr);
      return [
        l,
        a,
        b
      ];
    };
    convert.rgb.ansi16 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      var value2 = 1 in arguments ? arguments[1] : convert.rgb.hsv(args)[2];
      value2 = Math.round(value2 / 50);
      if (value2 === 0) {
        return 30;
      }
      var ansi2 = 30 + (Math.round(b / 255) << 2 | Math.round(g / 255) << 1 | Math.round(r / 255));
      if (value2 === 2) {
        ansi2 += 60;
      }
      return ansi2;
    };
    convert.hsv.ansi16 = function(args) {
      return convert.rgb.ansi16(convert.hsv.rgb(args), args[2]);
    };
    convert.rgb.ansi256 = function(args) {
      var r = args[0];
      var g = args[1];
      var b = args[2];
      if (r === g && g === b) {
        if (r < 8) {
          return 16;
        }
        if (r > 248) {
          return 231;
        }
        return Math.round((r - 8) / 247 * 24) + 232;
      }
      var ansi2 = 16 + 36 * Math.round(r / 255 * 5) + 6 * Math.round(g / 255 * 5) + Math.round(b / 255 * 5);
      return ansi2;
    };
    convert.ansi16.rgb = function(args) {
      var color = args % 10;
      if (color === 0 || color === 7) {
        if (args > 50) {
          color += 3.5;
        }
        color = color / 10.5 * 255;
        return [
          color,
          color,
          color
        ];
      }
      var mult = (~~(args > 50) + 1) * 0.5;
      var r = (color & 1) * mult * 255;
      var g = (color >> 1 & 1) * mult * 255;
      var b = (color >> 2 & 1) * mult * 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.ansi256.rgb = function(args) {
      if (args >= 232) {
        var c = (args - 232) * 10 + 8;
        return [
          c,
          c,
          c
        ];
      }
      args -= 16;
      var rem;
      var r = Math.floor(args / 36) / 5 * 255;
      var g = Math.floor((rem = args % 36) / 6) / 5 * 255;
      var b = rem % 6 / 5 * 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.rgb.hex = function(args) {
      var integer = ((Math.round(args[0]) & 255) << 16) + ((Math.round(args[1]) & 255) << 8) + (Math.round(args[2]) & 255);
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.hex.rgb = function(args) {
      var match = args.toString(16).match(/[a-f0-9]{6}|[a-f0-9]{3}/i);
      if (!match) {
        return [
          0,
          0,
          0
        ];
      }
      var colorString = match[0];
      if (match[0].length === 3) {
        colorString = colorString.split("").map(function(char) {
          return char + char;
        }).join("");
      }
      var integer = parseInt(colorString, 16);
      var r = integer >> 16 & 255;
      var g = integer >> 8 & 255;
      var b = integer & 255;
      return [
        r,
        g,
        b
      ];
    };
    convert.rgb.hcg = function(rgb) {
      var r = rgb[0] / 255;
      var g = rgb[1] / 255;
      var b = rgb[2] / 255;
      var max = Math.max(Math.max(r, g), b);
      var min = Math.min(Math.min(r, g), b);
      var chroma = max - min;
      var grayscale;
      var hue;
      if (chroma < 1) {
        grayscale = min / (1 - chroma);
      } else {
        grayscale = 0;
      }
      if (chroma <= 0) {
        hue = 0;
      } else if (max === r) {
        hue = (g - b) / chroma % 6;
      } else if (max === g) {
        hue = 2 + (b - r) / chroma;
      } else {
        hue = 4 + (r - g) / chroma + 4;
      }
      hue /= 6;
      hue %= 1;
      return [
        hue * 360,
        chroma * 100,
        grayscale * 100
      ];
    };
    convert.hsl.hcg = function(hsl) {
      var s = hsl[1] / 100;
      var l = hsl[2] / 100;
      var c = 1;
      var f = 0;
      if (l < 0.5) {
        c = 2 * s * l;
      } else {
        c = 2 * s * (1 - l);
      }
      if (c < 1) {
        f = (l - 0.5 * c) / (1 - c);
      }
      return [
        hsl[0],
        c * 100,
        f * 100
      ];
    };
    convert.hsv.hcg = function(hsv) {
      var s = hsv[1] / 100;
      var v = hsv[2] / 100;
      var c = s * v;
      var f = 0;
      if (c < 1) {
        f = (v - c) / (1 - c);
      }
      return [
        hsv[0],
        c * 100,
        f * 100
      ];
    };
    convert.hcg.rgb = function(hcg) {
      var h = hcg[0] / 360;
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      if (c === 0) {
        return [
          g * 255,
          g * 255,
          g * 255
        ];
      }
      var pure = [
        0,
        0,
        0
      ];
      var hi = h % 1 * 6;
      var v = hi % 1;
      var w = 1 - v;
      var mg = 0;
      switch (Math.floor(hi)) {
        case 0:
          pure[0] = 1;
          pure[1] = v;
          pure[2] = 0;
          break;
        case 1:
          pure[0] = w;
          pure[1] = 1;
          pure[2] = 0;
          break;
        case 2:
          pure[0] = 0;
          pure[1] = 1;
          pure[2] = v;
          break;
        case 3:
          pure[0] = 0;
          pure[1] = w;
          pure[2] = 1;
          break;
        case 4:
          pure[0] = v;
          pure[1] = 0;
          pure[2] = 1;
          break;
        default:
          pure[0] = 1;
          pure[1] = 0;
          pure[2] = w;
      }
      mg = (1 - c) * g;
      return [
        (c * pure[0] + mg) * 255,
        (c * pure[1] + mg) * 255,
        (c * pure[2] + mg) * 255
      ];
    };
    convert.hcg.hsv = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      var f = 0;
      if (v > 0) {
        f = c / v;
      }
      return [
        hcg[0],
        f * 100,
        v * 100
      ];
    };
    convert.hcg.hsl = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var l = g * (1 - c) + 0.5 * c;
      var s = 0;
      if (l > 0 && l < 0.5) {
        s = c / (2 * l);
      } else if (l >= 0.5 && l < 1) {
        s = c / (2 * (1 - l));
      }
      return [
        hcg[0],
        s * 100,
        l * 100
      ];
    };
    convert.hcg.hwb = function(hcg) {
      var c = hcg[1] / 100;
      var g = hcg[2] / 100;
      var v = c + g * (1 - c);
      return [
        hcg[0],
        (v - c) * 100,
        (1 - v) * 100
      ];
    };
    convert.hwb.hcg = function(hwb) {
      var w = hwb[1] / 100;
      var b = hwb[2] / 100;
      var v = 1 - b;
      var c = v - w;
      var g = 0;
      if (c < 1) {
        g = (v - c) / (1 - c);
      }
      return [
        hwb[0],
        c * 100,
        g * 100
      ];
    };
    convert.apple.rgb = function(apple) {
      return [
        apple[0] / 65535 * 255,
        apple[1] / 65535 * 255,
        apple[2] / 65535 * 255
      ];
    };
    convert.rgb.apple = function(rgb) {
      return [
        rgb[0] / 255 * 65535,
        rgb[1] / 255 * 65535,
        rgb[2] / 255 * 65535
      ];
    };
    convert.gray.rgb = function(args) {
      return [
        args[0] / 100 * 255,
        args[0] / 100 * 255,
        args[0] / 100 * 255
      ];
    };
    convert.gray.hsl = convert.gray.hsv = function(args) {
      return [
        0,
        0,
        args[0]
      ];
    };
    convert.gray.hwb = function(gray) {
      return [
        0,
        100,
        gray[0]
      ];
    };
    convert.gray.cmyk = function(gray) {
      return [
        0,
        0,
        0,
        gray[0]
      ];
    };
    convert.gray.lab = function(gray) {
      return [
        gray[0],
        0,
        0
      ];
    };
    convert.gray.hex = function(gray) {
      var val = Math.round(gray[0] / 100 * 255) & 255;
      var integer = (val << 16) + (val << 8) + val;
      var string = integer.toString(16).toUpperCase();
      return "000000".substring(string.length) + string;
    };
    convert.rgb.gray = function(rgb) {
      var val = (rgb[0] + rgb[1] + rgb[2]) / 3;
      return [
        val / 255 * 100
      ];
    };
  }
});

// node_modules/color-convert/route.js
var require_route = __commonJS({
  "node_modules/color-convert/route.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    function buildGraph() {
      var graph = {};
      var models = Object.keys(conversions);
      for (var len = models.length, i = 0; i < len; i++) {
        graph[models[i]] = {
          // http://jsperf.com/1-vs-infinity
          // micro-opt, but this is simple.
          distance: -1,
          parent: null
        };
      }
      return graph;
    }
    __name(buildGraph, "buildGraph");
    function deriveBFS(fromModel) {
      var graph = buildGraph();
      var queue = [
        fromModel
      ];
      graph[fromModel].distance = 0;
      while (queue.length) {
        var current = queue.pop();
        var adjacents = Object.keys(conversions[current]);
        for (var len = adjacents.length, i = 0; i < len; i++) {
          var adjacent = adjacents[i];
          var node = graph[adjacent];
          if (node.distance === -1) {
            node.distance = graph[current].distance + 1;
            node.parent = current;
            queue.unshift(adjacent);
          }
        }
      }
      return graph;
    }
    __name(deriveBFS, "deriveBFS");
    function link(from, to) {
      return function(args) {
        return to(from(args));
      };
    }
    __name(link, "link");
    function wrapConversion(toModel, graph) {
      var path = [
        graph[toModel].parent,
        toModel
      ];
      var fn = conversions[graph[toModel].parent][toModel];
      var cur = graph[toModel].parent;
      while (graph[cur].parent) {
        path.unshift(graph[cur].parent);
        fn = link(conversions[graph[cur].parent][cur], fn);
        cur = graph[cur].parent;
      }
      fn.conversion = path;
      return fn;
    }
    __name(wrapConversion, "wrapConversion");
    module2.exports = function(fromModel) {
      var graph = deriveBFS(fromModel);
      var conversion = {};
      var models = Object.keys(graph);
      for (var len = models.length, i = 0; i < len; i++) {
        var toModel = models[i];
        var node = graph[toModel];
        if (node.parent === null) {
          continue;
        }
        conversion[toModel] = wrapConversion(toModel, graph);
      }
      return conversion;
    };
  }
});

// node_modules/color-convert/index.js
var require_color_convert = __commonJS({
  "node_modules/color-convert/index.js"(exports2, module2) {
    "use strict";
    var conversions = require_conversions();
    var route = require_route();
    var convert = {};
    var models = Object.keys(conversions);
    function wrapRaw(fn) {
      var wrappedFn = /* @__PURE__ */ __name(function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        return fn(args);
      }, "wrappedFn");
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    __name(wrapRaw, "wrapRaw");
    function wrapRounded(fn) {
      var wrappedFn = /* @__PURE__ */ __name(function(args) {
        if (args === void 0 || args === null) {
          return args;
        }
        if (arguments.length > 1) {
          args = Array.prototype.slice.call(arguments);
        }
        var result2 = fn(args);
        if (typeof result2 === "object") {
          for (var len = result2.length, i = 0; i < len; i++) {
            result2[i] = Math.round(result2[i]);
          }
        }
        return result2;
      }, "wrappedFn");
      if ("conversion" in fn) {
        wrappedFn.conversion = fn.conversion;
      }
      return wrappedFn;
    }
    __name(wrapRounded, "wrapRounded");
    models.forEach(function(fromModel) {
      convert[fromModel] = {};
      Object.defineProperty(convert[fromModel], "channels", {
        value: conversions[fromModel].channels
      });
      Object.defineProperty(convert[fromModel], "labels", {
        value: conversions[fromModel].labels
      });
      var routes = route(fromModel);
      var routeModels = Object.keys(routes);
      routeModels.forEach(function(toModel) {
        var fn = routes[toModel];
        convert[fromModel][toModel] = wrapRounded(fn);
        convert[fromModel][toModel].raw = wrapRaw(fn);
      });
    });
    module2.exports = convert;
  }
});

// node_modules/color/index.js
var require_color = __commonJS({
  "node_modules/color/index.js"(exports2, module2) {
    "use strict";
    var colorString = require_color_string();
    var convert = require_color_convert();
    var _slice = [].slice;
    var skippedModels = [
      // to be honest, I don't really feel like keyword belongs in color convert, but eh.
      "keyword",
      // gray conflicts with some method names, and has its own method defined.
      "gray",
      // shouldn't really be in color-convert either...
      "hex"
    ];
    var hashedModelKeys = {};
    Object.keys(convert).forEach(function(model) {
      hashedModelKeys[_slice.call(convert[model].labels).sort().join("")] = model;
    });
    var limiters = {};
    function Color(obj, model) {
      if (!(this instanceof Color)) {
        return new Color(obj, model);
      }
      if (model && model in skippedModels) {
        model = null;
      }
      if (model && !(model in convert)) {
        throw new Error("Unknown model: " + model);
      }
      var i;
      var channels;
      if (obj == null) {
        this.model = "rgb";
        this.color = [
          0,
          0,
          0
        ];
        this.valpha = 1;
      } else if (obj instanceof Color) {
        this.model = obj.model;
        this.color = obj.color.slice();
        this.valpha = obj.valpha;
      } else if (typeof obj === "string") {
        var result2 = colorString.get(obj);
        if (result2 === null) {
          throw new Error("Unable to parse color from string: " + obj);
        }
        this.model = result2.model;
        channels = convert[this.model].channels;
        this.color = result2.value.slice(0, channels);
        this.valpha = typeof result2.value[channels] === "number" ? result2.value[channels] : 1;
      } else if (obj.length) {
        this.model = model || "rgb";
        channels = convert[this.model].channels;
        var newArr = _slice.call(obj, 0, channels);
        this.color = zeroArray(newArr, channels);
        this.valpha = typeof obj[channels] === "number" ? obj[channels] : 1;
      } else if (typeof obj === "number") {
        obj &= 16777215;
        this.model = "rgb";
        this.color = [
          obj >> 16 & 255,
          obj >> 8 & 255,
          obj & 255
        ];
        this.valpha = 1;
      } else {
        this.valpha = 1;
        var keys = Object.keys(obj);
        if ("alpha" in obj) {
          keys.splice(keys.indexOf("alpha"), 1);
          this.valpha = typeof obj.alpha === "number" ? obj.alpha : 0;
        }
        var hashedKeys = keys.sort().join("");
        if (!(hashedKeys in hashedModelKeys)) {
          throw new Error("Unable to parse color from object: " + JSON.stringify(obj));
        }
        this.model = hashedModelKeys[hashedKeys];
        var labels = convert[this.model].labels;
        var color = [];
        for (i = 0; i < labels.length; i++) {
          color.push(obj[labels[i]]);
        }
        this.color = zeroArray(color);
      }
      if (limiters[this.model]) {
        channels = convert[this.model].channels;
        for (i = 0; i < channels; i++) {
          var limit = limiters[this.model][i];
          if (limit) {
            this.color[i] = limit(this.color[i]);
          }
        }
      }
      this.valpha = Math.max(0, Math.min(1, this.valpha));
      if (Object.freeze) {
        Object.freeze(this);
      }
    }
    __name(Color, "Color");
    Color.prototype = {
      toString: /* @__PURE__ */ __name(function() {
        return this.string();
      }, "toString"),
      toJSON: /* @__PURE__ */ __name(function() {
        return this[this.model]();
      }, "toJSON"),
      string: /* @__PURE__ */ __name(function(places) {
        var self2 = this.model in colorString.to ? this : this.rgb();
        self2 = self2.round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to[self2.model](args);
      }, "string"),
      percentString: /* @__PURE__ */ __name(function(places) {
        var self2 = this.rgb().round(typeof places === "number" ? places : 1);
        var args = self2.valpha === 1 ? self2.color : self2.color.concat(this.valpha);
        return colorString.to.rgb.percent(args);
      }, "percentString"),
      array: /* @__PURE__ */ __name(function() {
        return this.valpha === 1 ? this.color.slice() : this.color.concat(this.valpha);
      }, "array"),
      object: /* @__PURE__ */ __name(function() {
        var result2 = {};
        var channels = convert[this.model].channels;
        var labels = convert[this.model].labels;
        for (var i = 0; i < channels; i++) {
          result2[labels[i]] = this.color[i];
        }
        if (this.valpha !== 1) {
          result2.alpha = this.valpha;
        }
        return result2;
      }, "object"),
      unitArray: /* @__PURE__ */ __name(function() {
        var rgb = this.rgb().color;
        rgb[0] /= 255;
        rgb[1] /= 255;
        rgb[2] /= 255;
        if (this.valpha !== 1) {
          rgb.push(this.valpha);
        }
        return rgb;
      }, "unitArray"),
      unitObject: /* @__PURE__ */ __name(function() {
        var rgb = this.rgb().object();
        rgb.r /= 255;
        rgb.g /= 255;
        rgb.b /= 255;
        if (this.valpha !== 1) {
          rgb.alpha = this.valpha;
        }
        return rgb;
      }, "unitObject"),
      round: /* @__PURE__ */ __name(function(places) {
        places = Math.max(places || 0, 0);
        return new Color(this.color.map(roundToPlace(places)).concat(this.valpha), this.model);
      }, "round"),
      alpha: /* @__PURE__ */ __name(function(val) {
        if (arguments.length) {
          return new Color(this.color.concat(Math.max(0, Math.min(1, val))), this.model);
        }
        return this.valpha;
      }, "alpha"),
      // rgb
      red: getset("rgb", 0, maxfn(255)),
      green: getset("rgb", 1, maxfn(255)),
      blue: getset("rgb", 2, maxfn(255)),
      hue: getset([
        "hsl",
        "hsv",
        "hsl",
        "hwb",
        "hcg"
      ], 0, function(val) {
        return (val % 360 + 360) % 360;
      }),
      saturationl: getset("hsl", 1, maxfn(100)),
      lightness: getset("hsl", 2, maxfn(100)),
      saturationv: getset("hsv", 1, maxfn(100)),
      value: getset("hsv", 2, maxfn(100)),
      chroma: getset("hcg", 1, maxfn(100)),
      gray: getset("hcg", 2, maxfn(100)),
      white: getset("hwb", 1, maxfn(100)),
      wblack: getset("hwb", 2, maxfn(100)),
      cyan: getset("cmyk", 0, maxfn(100)),
      magenta: getset("cmyk", 1, maxfn(100)),
      yellow: getset("cmyk", 2, maxfn(100)),
      black: getset("cmyk", 3, maxfn(100)),
      x: getset("xyz", 0, maxfn(100)),
      y: getset("xyz", 1, maxfn(100)),
      z: getset("xyz", 2, maxfn(100)),
      l: getset("lab", 0, maxfn(100)),
      a: getset("lab", 1),
      b: getset("lab", 2),
      keyword: /* @__PURE__ */ __name(function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return convert[this.model].keyword(this.color);
      }, "keyword"),
      hex: /* @__PURE__ */ __name(function(val) {
        if (arguments.length) {
          return new Color(val);
        }
        return colorString.to.hex(this.rgb().round().color);
      }, "hex"),
      rgbNumber: /* @__PURE__ */ __name(function() {
        var rgb = this.rgb().color;
        return (rgb[0] & 255) << 16 | (rgb[1] & 255) << 8 | rgb[2] & 255;
      }, "rgbNumber"),
      luminosity: /* @__PURE__ */ __name(function() {
        var rgb = this.rgb().color;
        var lum = [];
        for (var i = 0; i < rgb.length; i++) {
          var chan = rgb[i] / 255;
          lum[i] = chan <= 0.03928 ? chan / 12.92 : Math.pow((chan + 0.055) / 1.055, 2.4);
        }
        return 0.2126 * lum[0] + 0.7152 * lum[1] + 0.0722 * lum[2];
      }, "luminosity"),
      contrast: /* @__PURE__ */ __name(function(color2) {
        var lum1 = this.luminosity();
        var lum2 = color2.luminosity();
        if (lum1 > lum2) {
          return (lum1 + 0.05) / (lum2 + 0.05);
        }
        return (lum2 + 0.05) / (lum1 + 0.05);
      }, "contrast"),
      level: /* @__PURE__ */ __name(function(color2) {
        var contrastRatio = this.contrast(color2);
        if (contrastRatio >= 7.1) {
          return "AAA";
        }
        return contrastRatio >= 4.5 ? "AA" : "";
      }, "level"),
      isDark: /* @__PURE__ */ __name(function() {
        var rgb = this.rgb().color;
        var yiq = (rgb[0] * 299 + rgb[1] * 587 + rgb[2] * 114) / 1e3;
        return yiq < 128;
      }, "isDark"),
      isLight: /* @__PURE__ */ __name(function() {
        return !this.isDark();
      }, "isLight"),
      negate: /* @__PURE__ */ __name(function() {
        var rgb = this.rgb();
        for (var i = 0; i < 3; i++) {
          rgb.color[i] = 255 - rgb.color[i];
        }
        return rgb;
      }, "negate"),
      lighten: /* @__PURE__ */ __name(function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] += hsl.color[2] * ratio;
        return hsl;
      }, "lighten"),
      darken: /* @__PURE__ */ __name(function(ratio) {
        var hsl = this.hsl();
        hsl.color[2] -= hsl.color[2] * ratio;
        return hsl;
      }, "darken"),
      saturate: /* @__PURE__ */ __name(function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] += hsl.color[1] * ratio;
        return hsl;
      }, "saturate"),
      desaturate: /* @__PURE__ */ __name(function(ratio) {
        var hsl = this.hsl();
        hsl.color[1] -= hsl.color[1] * ratio;
        return hsl;
      }, "desaturate"),
      whiten: /* @__PURE__ */ __name(function(ratio) {
        var hwb = this.hwb();
        hwb.color[1] += hwb.color[1] * ratio;
        return hwb;
      }, "whiten"),
      blacken: /* @__PURE__ */ __name(function(ratio) {
        var hwb = this.hwb();
        hwb.color[2] += hwb.color[2] * ratio;
        return hwb;
      }, "blacken"),
      grayscale: /* @__PURE__ */ __name(function() {
        var rgb = this.rgb().color;
        var val = rgb[0] * 0.3 + rgb[1] * 0.59 + rgb[2] * 0.11;
        return Color.rgb(val, val, val);
      }, "grayscale"),
      fade: /* @__PURE__ */ __name(function(ratio) {
        return this.alpha(this.valpha - this.valpha * ratio);
      }, "fade"),
      opaquer: /* @__PURE__ */ __name(function(ratio) {
        return this.alpha(this.valpha + this.valpha * ratio);
      }, "opaquer"),
      rotate: /* @__PURE__ */ __name(function(degrees) {
        var hsl = this.hsl();
        var hue = hsl.color[0];
        hue = (hue + degrees) % 360;
        hue = hue < 0 ? 360 + hue : hue;
        hsl.color[0] = hue;
        return hsl;
      }, "rotate"),
      mix: /* @__PURE__ */ __name(function(mixinColor, weight) {
        if (!mixinColor || !mixinColor.rgb) {
          throw new Error('Argument to "mix" was not a Color instance, but rather an instance of ' + typeof mixinColor);
        }
        var color1 = mixinColor.rgb();
        var color2 = this.rgb();
        var p = weight === void 0 ? 0.5 : weight;
        var w = 2 * p - 1;
        var a = color1.alpha() - color2.alpha();
        var w1 = ((w * a === -1 ? w : (w + a) / (1 + w * a)) + 1) / 2;
        var w2 = 1 - w1;
        return Color.rgb(w1 * color1.red() + w2 * color2.red(), w1 * color1.green() + w2 * color2.green(), w1 * color1.blue() + w2 * color2.blue(), color1.alpha() * p + color2.alpha() * (1 - p));
      }, "mix")
    };
    Object.keys(convert).forEach(function(model) {
      if (skippedModels.indexOf(model) !== -1) {
        return;
      }
      var channels = convert[model].channels;
      Color.prototype[model] = function() {
        if (this.model === model) {
          return new Color(this);
        }
        if (arguments.length) {
          return new Color(arguments, model);
        }
        var newAlpha = typeof arguments[channels] === "number" ? channels : this.valpha;
        return new Color(assertArray(convert[this.model][model].raw(this.color)).concat(newAlpha), model);
      };
      Color[model] = function(color) {
        if (typeof color === "number") {
          color = zeroArray(_slice.call(arguments), channels);
        }
        return new Color(color, model);
      };
    });
    function roundTo(num, places) {
      return Number(num.toFixed(places));
    }
    __name(roundTo, "roundTo");
    function roundToPlace(places) {
      return function(num) {
        return roundTo(num, places);
      };
    }
    __name(roundToPlace, "roundToPlace");
    function getset(model, channel, modifier) {
      model = Array.isArray(model) ? model : [
        model
      ];
      model.forEach(function(m) {
        (limiters[m] || (limiters[m] = []))[channel] = modifier;
      });
      model = model[0];
      return function(val) {
        var result2;
        if (arguments.length) {
          if (modifier) {
            val = modifier(val);
          }
          result2 = this[model]();
          result2.color[channel] = val;
          return result2;
        }
        result2 = this[model]().color[channel];
        if (modifier) {
          result2 = modifier(result2);
        }
        return result2;
      };
    }
    __name(getset, "getset");
    function maxfn(max) {
      return function(v) {
        return Math.max(0, Math.min(max, v));
      };
    }
    __name(maxfn, "maxfn");
    function assertArray(val) {
      return Array.isArray(val) ? val : [
        val
      ];
    }
    __name(assertArray, "assertArray");
    function zeroArray(arr, length) {
      for (var i = 0; i < length; i++) {
        if (typeof arr[i] !== "number") {
          arr[i] = 0;
        }
      }
      return arr;
    }
    __name(zeroArray, "zeroArray");
    module2.exports = Color;
  }
});

// node_modules/text-hex/index.js
var require_text_hex = __commonJS({
  "node_modules/text-hex/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name(function hex(str) {
      for (var i = 0, hash = 0; i < str.length; hash = str.charCodeAt(i++) + ((hash << 5) - hash)) ;
      var color = Math.floor(Math.abs(Math.sin(hash) * 1e4 % 1 * 16777216)).toString(16);
      return "#" + Array(6 - color.length + 1).join("0") + color;
    }, "hex");
  }
});

// node_modules/colorspace/index.js
var require_colorspace = __commonJS({
  "node_modules/colorspace/index.js"(exports2, module2) {
    "use strict";
    var color = require_color();
    var hex = require_text_hex();
    module2.exports = /* @__PURE__ */ __name(function colorspace(namespace, delimiter) {
      var split = namespace.split(delimiter || ":");
      var base = hex(split[0]);
      if (!split.length) return base;
      for (var i = 0, l = split.length - 1; i < l; i++) {
        base = color(base).mix(color(hex(split[i + 1]))).saturate(1).hex();
      }
      return base;
    }, "colorspace");
  }
});

// node_modules/kuler/index.js
var require_kuler = __commonJS({
  "node_modules/kuler/index.js"(exports2, module2) {
    "use strict";
    function Kuler(text, color) {
      if (color) return new Kuler(text).style(color);
      if (!(this instanceof Kuler)) return new Kuler(text);
      this.text = text;
    }
    __name(Kuler, "Kuler");
    Kuler.prototype.prefix = "\x1B[";
    Kuler.prototype.suffix = "m";
    Kuler.prototype.hex = /* @__PURE__ */ __name(function hex(color) {
      color = color[0] === "#" ? color.substring(1) : color;
      if (color.length === 3) {
        color = color.split("");
        color[5] = color[2];
        color[4] = color[2];
        color[3] = color[1];
        color[2] = color[1];
        color[1] = color[0];
        color = color.join("");
      }
      var r = color.substring(0, 2), g = color.substring(2, 4), b = color.substring(4, 6);
      return [
        parseInt(r, 16),
        parseInt(g, 16),
        parseInt(b, 16)
      ];
    }, "hex");
    Kuler.prototype.rgb = /* @__PURE__ */ __name(function rgb(r, g, b) {
      var red = r / 255 * 5, green = g / 255 * 5, blue = b / 255 * 5;
      return this.ansi(red, green, blue);
    }, "rgb");
    Kuler.prototype.ansi = /* @__PURE__ */ __name(function ansi2(r, g, b) {
      var red = Math.round(r), green = Math.round(g), blue = Math.round(b);
      return 16 + red * 36 + green * 6 + blue;
    }, "ansi");
    Kuler.prototype.reset = /* @__PURE__ */ __name(function reset() {
      return this.prefix + "39;49" + this.suffix;
    }, "reset");
    Kuler.prototype.style = /* @__PURE__ */ __name(function style(color) {
      return this.prefix + "38;5;" + this.rgb.apply(this, this.hex(color)) + this.suffix + this.text + this.reset();
    }, "style");
    module2.exports = Kuler;
  }
});

// node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js
var require_namespace_ansi = __commonJS({
  "node_modules/@dabh/diagnostics/modifiers/namespace-ansi.js"(exports2, module2) {
    "use strict";
    var colorspace = require_colorspace();
    var kuler = require_kuler();
    module2.exports = /* @__PURE__ */ __name(function ansiModifier(args, options) {
      var namespace = options.namespace;
      var ansi2 = options.colors !== false ? kuler(namespace + ":", colorspace(namespace)) : namespace + ":";
      args[0] = ansi2 + " " + args[0];
      return args;
    }, "ansiModifier");
  }
});

// node_modules/enabled/index.js
var require_enabled = __commonJS({
  "node_modules/enabled/index.js"(exports2, module2) {
    "use strict";
    module2.exports = /* @__PURE__ */ __name(function enabled(name, variable) {
      if (!variable) return false;
      var variables = variable.split(/[\s,]+/), i = 0;
      for (; i < variables.length; i++) {
        variable = variables[i].replace("*", ".*?");
        if ("-" === variable.charAt(0)) {
          if (new RegExp("^" + variable.substr(1) + "$").test(name)) {
            return false;
          }
          continue;
        }
        if (new RegExp("^" + variable + "$").test(name)) {
          return true;
        }
      }
      return false;
    }, "enabled");
  }
});

// node_modules/@dabh/diagnostics/adapters/index.js
var require_adapters = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/index.js"(exports2, module2) {
    "use strict";
    var enabled = require_enabled();
    module2.exports = /* @__PURE__ */ __name(function create(fn) {
      return /* @__PURE__ */ __name(function adapter(namespace) {
        try {
          return enabled(namespace, fn());
        } catch (e) {
        }
        return false;
      }, "adapter");
    }, "create");
  }
});

// node_modules/@dabh/diagnostics/adapters/process.env.js
var require_process_env = __commonJS({
  "node_modules/@dabh/diagnostics/adapters/process.env.js"(exports2, module2) {
    "use strict";
    var adapter = require_adapters();
    module2.exports = adapter(/* @__PURE__ */ __name(function processenv() {
      return process.env.DEBUG || process.env.DIAGNOSTICS;
    }, "processenv"));
  }
});

// node_modules/@dabh/diagnostics/logger/console.js
var require_console2 = __commonJS({
  "node_modules/@dabh/diagnostics/logger/console.js"(exports2, module2) {
    "use strict";
    module2.exports = function(meta, messages) {
      try {
        Function.prototype.apply.call(console.log, console, messages);
      } catch (e) {
      }
    };
  }
});

// node_modules/@dabh/diagnostics/node/development.js
var require_development = __commonJS({
  "node_modules/@dabh/diagnostics/node/development.js"(exports2, module2) {
    "use strict";
    var create = require_diagnostics();
    var tty = require("tty").isatty(1);
    var diagnostics = create(/* @__PURE__ */ __name(function dev(namespace, options) {
      options = options || {};
      options.colors = "colors" in options ? options.colors : tty;
      options.namespace = namespace;
      options.prod = false;
      options.dev = true;
      if (!dev.enabled(namespace) && !(options.force || dev.force)) {
        return dev.nope(options);
      }
      return dev.yep(options);
    }, "dev"));
    diagnostics.modify(require_namespace_ansi());
    diagnostics.use(require_process_env());
    diagnostics.set(require_console2());
    module2.exports = diagnostics;
  }
});

// node_modules/@dabh/diagnostics/node/index.js
var require_node2 = __commonJS({
  "node_modules/@dabh/diagnostics/node/index.js"(exports2, module2) {
    "use strict";
    if (process.env.NODE_ENV === "production") {
      module2.exports = require_production();
    } else {
      module2.exports = require_development();
    }
  }
});

// node_modules/winston/lib/winston/tail-file.js
var require_tail_file = __commonJS({
  "node_modules/winston/lib/winston/tail-file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var { StringDecoder } = require("string_decoder");
    var { Stream } = require_readable();
    function noop() {
    }
    __name(noop, "noop");
    module2.exports = (options, iter) => {
      const buffer = Buffer.alloc(64 * 1024);
      const decode2 = new StringDecoder("utf8");
      const stream = new Stream();
      let buff = "";
      let pos = 0;
      let row = 0;
      if (options.start === -1) {
        delete options.start;
      }
      stream.readable = true;
      stream.destroy = () => {
        stream.destroyed = true;
        stream.emit("end");
        stream.emit("close");
      };
      fs.open(options.file, "a+", "0644", (err, fd) => {
        if (err) {
          if (!iter) {
            stream.emit("error", err);
          } else {
            iter(err);
          }
          stream.destroy();
          return;
        }
        (/* @__PURE__ */ __name(function read() {
          if (stream.destroyed) {
            fs.close(fd, noop);
            return;
          }
          return fs.read(fd, buffer, 0, buffer.length, pos, (error, bytes) => {
            if (error) {
              if (!iter) {
                stream.emit("error", error);
              } else {
                iter(error);
              }
              stream.destroy();
              return;
            }
            if (!bytes) {
              if (buff) {
                if (options.start == null || row > options.start) {
                  if (!iter) {
                    stream.emit("line", buff);
                  } else {
                    iter(null, buff);
                  }
                }
                row++;
                buff = "";
              }
              return setTimeout(read, 1e3);
            }
            let data = decode2.write(buffer.slice(0, bytes));
            if (!iter) {
              stream.emit("data", data);
            }
            data = (buff + data).split(/\n+/);
            const l = data.length - 1;
            let i = 0;
            for (; i < l; i++) {
              if (options.start == null || row > options.start) {
                if (!iter) {
                  stream.emit("line", data[i]);
                } else {
                  iter(null, data[i]);
                }
              }
              row++;
            }
            buff = data[l];
            pos += bytes;
            return read();
          });
        }, "read"))();
      });
      if (!iter) {
        return stream;
      }
      return stream.destroy;
    };
  }
});

// node_modules/winston/lib/winston/transports/file.js
var require_file = __commonJS({
  "node_modules/winston/lib/winston/transports/file.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var asyncSeries = require_series();
    var zlib = require("zlib");
    var { MESSAGE } = require_triple_beam();
    var { Stream, PassThrough } = require_readable();
    var TransportStream = require_winston_transport();
    var debug12 = require_node2()("winston:file");
    var os = require("os");
    var tailFile = require_tail_file();
    module2.exports = class File extends TransportStream {
      static {
        __name(this, "File");
      }
      /**
      * Constructor function for the File transport object responsible for
      * persisting log messages and metadata to one or more files.
      * @param {Object} options - Options for this instance.
      */
      constructor(options = {}) {
        super(options);
        this.name = options.name || "file";
        function throwIf(target, ...args) {
          args.slice(1).forEach((name) => {
            if (options[name]) {
              throw new Error(`Cannot set ${name} and ${target} together`);
            }
          });
        }
        __name(throwIf, "throwIf");
        this._stream = new PassThrough();
        this._stream.setMaxListeners(30);
        this._onError = this._onError.bind(this);
        if (options.filename || options.dirname) {
          throwIf("filename or dirname", "stream");
          this._basename = this.filename = options.filename ? path.basename(options.filename) : "winston.log";
          this.dirname = options.dirname || path.dirname(options.filename);
          this.options = options.options || {
            flags: "a"
          };
        } else if (options.stream) {
          console.warn("options.stream will be removed in winston@4. Use winston.transports.Stream");
          throwIf("stream", "filename", "maxsize");
          this._dest = this._stream.pipe(this._setupStream(options.stream));
          this.dirname = path.dirname(this._dest.path);
        } else {
          throw new Error("Cannot log to file without filename or stream.");
        }
        this.maxsize = options.maxsize || null;
        this.rotationFormat = options.rotationFormat || false;
        this.zippedArchive = options.zippedArchive || false;
        this.maxFiles = options.maxFiles || null;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
        this.tailable = options.tailable || false;
        this.lazy = options.lazy || false;
        this._size = 0;
        this._pendingSize = 0;
        this._created = 0;
        this._drain = false;
        this._opening = false;
        this._ending = false;
        this._fileExist = false;
        if (this.dirname) this._createLogDirIfNotExist(this.dirname);
        if (!this.lazy) this.open();
      }
      finishIfEnding() {
        if (this._ending) {
          if (this._opening) {
            this.once("open", () => {
              this._stream.once("finish", () => this.emit("finish"));
              setImmediate(() => this._stream.end());
            });
          } else {
            this._stream.once("finish", () => this.emit("finish"));
            setImmediate(() => this._stream.end());
          }
        }
      }
      /**
      * Core logging method exposed to Winston. Metadata is optional.
      * @param {Object} info - TODO: add param description.
      * @param {Function} callback - TODO: add param description.
      * @returns {undefined}
      */
      log(info, callback = () => {
      }) {
        if (this.silent) {
          callback();
          return true;
        }
        if (this._drain) {
          this._stream.once("drain", () => {
            this._drain = false;
            this.log(info, callback);
          });
          return;
        }
        if (this._rotate) {
          this._stream.once("rotate", () => {
            this._rotate = false;
            this.log(info, callback);
          });
          return;
        }
        if (this.lazy) {
          if (!this._fileExist) {
            if (!this._opening) {
              this.open();
            }
            this.once("open", () => {
              this._fileExist = true;
              this.log(info, callback);
              return;
            });
            return;
          }
          if (this._needsNewFile(this._pendingSize)) {
            this._dest.once("close", () => {
              if (!this._opening) {
                this.open();
              }
              this.once("open", () => {
                this.log(info, callback);
                return;
              });
              return;
            });
            return;
          }
        }
        const output = `${info[MESSAGE]}${this.eol}`;
        const bytes = Buffer.byteLength(output);
        function logged() {
          this._size += bytes;
          this._pendingSize -= bytes;
          debug12("logged %s %s", this._size, output);
          this.emit("logged", info);
          if (this._rotate) {
            return;
          }
          if (this._opening) {
            return;
          }
          if (!this._needsNewFile()) {
            return;
          }
          if (this.lazy) {
            this._endStream(() => {
              this.emit("fileclosed");
            });
            return;
          }
          this._rotate = true;
          this._endStream(() => this._rotateFile());
        }
        __name(logged, "logged");
        this._pendingSize += bytes;
        if (this._opening && !this.rotatedWhileOpening && this._needsNewFile(this._size + this._pendingSize)) {
          this.rotatedWhileOpening = true;
        }
        const written = this._stream.write(output, logged.bind(this));
        if (!written) {
          this._drain = true;
          this._stream.once("drain", () => {
            this._drain = false;
            callback();
          });
        } else {
          callback();
        }
        debug12("written", written, this._drain);
        this.finishIfEnding();
        return written;
      }
      /**
      * Query the transport. Options object is optional.
      * @param {Object} options - Loggly-like query options for this instance.
      * @param {function} callback - Continuation to respond to when complete.
      * TODO: Refactor me.
      */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = normalizeQuery(options);
        const file = path.join(this.dirname, this.filename);
        let buff = "";
        let results = [];
        let row = 0;
        const stream = fs.createReadStream(file, {
          encoding: "utf8"
        });
        stream.on("error", (err) => {
          if (stream.readable) {
            stream.destroy();
          }
          if (!callback) {
            return;
          }
          return err.code !== "ENOENT" ? callback(err) : callback(null, results);
        });
        stream.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            if (!options.start || row >= options.start) {
              add(data[i]);
            }
            row++;
          }
          buff = data[l];
        });
        stream.on("close", () => {
          if (buff) {
            add(buff, true);
          }
          if (options.order === "desc") {
            results = results.reverse();
          }
          if (callback) callback(null, results);
        });
        function add(buff2, attempt) {
          try {
            const log = JSON.parse(buff2);
            if (check(log)) {
              push(log);
            }
          } catch (e) {
            if (!attempt) {
              stream.emit("error", e);
            }
          }
        }
        __name(add, "add");
        function push(log) {
          if (options.rows && results.length >= options.rows && options.order !== "desc") {
            if (stream.readable) {
              stream.destroy();
            }
            return;
          }
          if (options.fields) {
            log = options.fields.reduce((obj, key) => {
              obj[key] = log[key];
              return obj;
            }, {});
          }
          if (options.order === "desc") {
            if (results.length >= options.rows) {
              results.shift();
            }
          }
          results.push(log);
        }
        __name(push, "push");
        function check(log) {
          if (!log) {
            return;
          }
          if (typeof log !== "object") {
            return;
          }
          const time = new Date(log.timestamp);
          if (options.from && time < options.from || options.until && time > options.until || options.level && options.level !== log.level) {
            return;
          }
          return true;
        }
        __name(check, "check");
        function normalizeQuery(options2) {
          options2 = options2 || {};
          options2.rows = options2.rows || options2.limit || 10;
          options2.start = options2.start || 0;
          options2.until = options2.until || /* @__PURE__ */ new Date();
          if (typeof options2.until !== "object") {
            options2.until = new Date(options2.until);
          }
          options2.from = options2.from || options2.until - 24 * 60 * 60 * 1e3;
          if (typeof options2.from !== "object") {
            options2.from = new Date(options2.from);
          }
          options2.order = options2.order || "desc";
          return options2;
        }
        __name(normalizeQuery, "normalizeQuery");
      }
      /**
      * Returns a log stream for this transport. Options object is optional.
      * @param {Object} options - Stream options for this instance.
      * @returns {Stream} - TODO: add return description.
      * TODO: Refactor me.
      */
      stream(options = {}) {
        const file = path.join(this.dirname, this.filename);
        const stream = new Stream();
        const tail = {
          file,
          start: options.start
        };
        stream.destroy = tailFile(tail, (err, line) => {
          if (err) {
            return stream.emit("error", err);
          }
          try {
            stream.emit("data", line);
            line = JSON.parse(line);
            stream.emit("log", line);
          } catch (e) {
            stream.emit("error", e);
          }
        });
        return stream;
      }
      /**
      * Checks to see the filesize of.
      * @returns {undefined}
      */
      open() {
        if (!this.filename) return;
        if (this._opening) return;
        this._opening = true;
        this.stat((err, size) => {
          if (err) {
            return this.emit("error", err);
          }
          debug12("stat done: %s { size: %s }", this.filename, size);
          this._size = size;
          this._dest = this._createStream(this._stream);
          this._opening = false;
          this.once("open", () => {
            if (!this._stream.emit("rotate")) {
              this._rotate = false;
            }
          });
        });
      }
      /**
      * Stat the file and assess information in order to create the proper stream.
      * @param {function} callback - TODO: add param description.
      * @returns {undefined}
      */
      stat(callback) {
        const target = this._getFile();
        const fullpath = path.join(this.dirname, target);
        fs.stat(fullpath, (err, stat) => {
          if (err && err.code === "ENOENT") {
            debug12("ENOENT\xA0ok", fullpath);
            this.filename = target;
            return callback(null, 0);
          }
          if (err) {
            debug12(`err ${err.code} ${fullpath}`);
            return callback(err);
          }
          if (!stat || this._needsNewFile(stat.size)) {
            return this._incFile(() => this.stat(callback));
          }
          this.filename = target;
          callback(null, stat.size);
        });
      }
      /**
      * Closes the stream associated with this instance.
      * @param {function} cb - TODO: add param description.
      * @returns {undefined}
      */
      close(cb) {
        if (!this._stream) {
          return;
        }
        this._stream.end(() => {
          if (cb) {
            cb();
          }
          this.emit("flush");
          this.emit("closed");
        });
      }
      /**
      * TODO: add method description.
      * @param {number} size - TODO: add param description.
      * @returns {undefined}
      */
      _needsNewFile(size) {
        size = size || this._size;
        return this.maxsize && size >= this.maxsize;
      }
      /**
      * TODO: add method description.
      * @param {Error} err - TODO: add param description.
      * @returns {undefined}
      */
      _onError(err) {
        this.emit("error", err);
      }
      /**
      * TODO: add method description.
      * @param {Stream} stream - TODO: add param description.
      * @returns {mixed} - TODO: add return description.
      */
      _setupStream(stream) {
        stream.on("error", this._onError);
        return stream;
      }
      /**
      * TODO: add method description.
      * @param {Stream} stream - TODO: add param description.
      * @returns {mixed} - TODO: add return description.
      */
      _cleanupStream(stream) {
        stream.removeListener("error", this._onError);
        stream.destroy();
        return stream;
      }
      /**
      * TODO: add method description.
      */
      _rotateFile() {
        this._incFile(() => this.open());
      }
      /**
      * Unpipe from the stream that has been marked as full and end it so it
      * flushes to disk.
      *
      * @param {function} callback - Callback for when the current file has closed.
      * @private
      */
      _endStream(callback = () => {
      }) {
        if (this._dest) {
          this._stream.unpipe(this._dest);
          this._dest.end(() => {
            this._cleanupStream(this._dest);
            callback();
          });
        } else {
          callback();
        }
      }
      /**
      * Returns the WritableStream for the active file on this instance. If we
      * should gzip the file then a zlib stream is returned.
      *
      * @param {ReadableStream} source –PassThrough to pipe to the file when open.
      * @returns {WritableStream} Stream that writes to disk for the active file.
      */
      _createStream(source) {
        const fullpath = path.join(this.dirname, this.filename);
        debug12("create stream start", fullpath, this.options);
        const dest = fs.createWriteStream(fullpath, this.options).on("error", (err) => debug12(err)).on("close", () => debug12("close", dest.path, dest.bytesWritten)).on("open", () => {
          debug12("file open ok", fullpath);
          this.emit("open", fullpath);
          source.pipe(dest);
          if (this.rotatedWhileOpening) {
            this._stream = new PassThrough();
            this._stream.setMaxListeners(30);
            this._rotateFile();
            this.rotatedWhileOpening = false;
            this._cleanupStream(dest);
            source.end();
          }
        });
        debug12("create stream ok", fullpath);
        return dest;
      }
      /**
      * TODO: add method description.
      * @param {function} callback - TODO: add param description.
      * @returns {undefined}
      */
      _incFile(callback) {
        debug12("_incFile", this.filename);
        const ext = path.extname(this._basename);
        const basename2 = path.basename(this._basename, ext);
        const tasks = [];
        if (this.zippedArchive) {
          tasks.push(function(cb) {
            const num = this._created > 0 && !this.tailable ? this._created : "";
            this._compressFile(path.join(this.dirname, `${basename2}${num}${ext}`), path.join(this.dirname, `${basename2}${num}${ext}.gz`), cb);
          }.bind(this));
        }
        tasks.push(function(cb) {
          if (!this.tailable) {
            this._created += 1;
            this._checkMaxFilesIncrementing(ext, basename2, cb);
          } else {
            this._checkMaxFilesTailable(ext, basename2, cb);
          }
        }.bind(this));
        asyncSeries(tasks, callback);
      }
      /**
      * Gets the next filename to use for this instance in the case that log
      * filesizes are being capped.
      * @returns {string} - TODO: add return description.
      * @private
      */
      _getFile() {
        const ext = path.extname(this._basename);
        const basename2 = path.basename(this._basename, ext);
        const isRotation = this.rotationFormat ? this.rotationFormat() : this._created;
        return !this.tailable && this._created ? `${basename2}${isRotation}${ext}` : `${basename2}${ext}`;
      }
      /**
      * Increment the number of files created or checked by this instance.
      * @param {mixed} ext - TODO: add param description.
      * @param {mixed} basename - TODO: add param description.
      * @param {mixed} callback - TODO: add param description.
      * @returns {undefined}
      * @private
      */
      _checkMaxFilesIncrementing(ext, basename2, callback) {
        if (!this.maxFiles || this._created < this.maxFiles) {
          return setImmediate(callback);
        }
        const oldest = this._created - this.maxFiles;
        const isOldest = oldest !== 0 ? oldest : "";
        const isZipped = this.zippedArchive ? ".gz" : "";
        const filePath = `${basename2}${isOldest}${ext}${isZipped}`;
        const target = path.join(this.dirname, filePath);
        fs.unlink(target, callback);
      }
      /**
      * Roll files forward based on integer, up to maxFiles. e.g. if base if
      * file.log and it becomes oversized, roll to file1.log, and allow file.log
      * to be re-used. If file is oversized again, roll file1.log to file2.log,
      * roll file.log to file1.log, and so on.
      * @param {mixed} ext - TODO: add param description.
      * @param {mixed} basename - TODO: add param description.
      * @param {mixed} callback - TODO: add param description.
      * @returns {undefined}
      * @private
      */
      _checkMaxFilesTailable(ext, basename2, callback) {
        const tasks = [];
        if (!this.maxFiles) {
          return;
        }
        const isZipped = this.zippedArchive ? ".gz" : "";
        for (let x = this.maxFiles - 1; x > 1; x--) {
          tasks.push(function(i, cb) {
            let fileName = `${basename2}${i - 1}${ext}${isZipped}`;
            const tmppath = path.join(this.dirname, fileName);
            fs.exists(tmppath, (exists) => {
              if (!exists) {
                return cb(null);
              }
              fileName = `${basename2}${i}${ext}${isZipped}`;
              fs.rename(tmppath, path.join(this.dirname, fileName), cb);
            });
          }.bind(this, x));
        }
        asyncSeries(tasks, () => {
          fs.rename(path.join(this.dirname, `${basename2}${ext}${isZipped}`), path.join(this.dirname, `${basename2}1${ext}${isZipped}`), callback);
        });
      }
      /**
      * Compresses src to dest with gzip and unlinks src
      * @param {string} src - path to source file.
      * @param {string} dest - path to zipped destination file.
      * @param {Function} callback - callback called after file has been compressed.
      * @returns {undefined}
      * @private
      */
      _compressFile(src, dest, callback) {
        fs.access(src, fs.F_OK, (err) => {
          if (err) {
            return callback();
          }
          var gzip = zlib.createGzip();
          var inp = fs.createReadStream(src);
          var out = fs.createWriteStream(dest);
          out.on("finish", () => {
            fs.unlink(src, callback);
          });
          inp.pipe(gzip).pipe(out);
        });
      }
      _createLogDirIfNotExist(dirPath) {
        if (!fs.existsSync(dirPath)) {
          fs.mkdirSync(dirPath, {
            recursive: true
          });
        }
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/http.js
var require_http = __commonJS({
  "node_modules/winston/lib/winston/transports/http.js"(exports2, module2) {
    "use strict";
    var http = require("http");
    var https = require("https");
    var { Stream } = require_readable();
    var TransportStream = require_winston_transport();
    var { configure } = require_safe_stable_stringify();
    module2.exports = class Http extends TransportStream {
      static {
        __name(this, "Http");
      }
      /**
      * Constructor function for the Http transport object responsible for
      * persisting log messages and metadata to a terminal or TTY.
      * @param {!Object} [options={}] - Options for this instance.
      */
      // eslint-disable-next-line max-statements
      constructor(options = {}) {
        super(options);
        this.options = options;
        this.name = options.name || "http";
        this.ssl = !!options.ssl;
        this.host = options.host || "localhost";
        this.port = options.port;
        this.auth = options.auth;
        this.path = options.path || "";
        this.maximumDepth = options.maximumDepth;
        this.agent = options.agent;
        this.headers = options.headers || {};
        this.headers["content-type"] = "application/json";
        this.batch = options.batch || false;
        this.batchInterval = options.batchInterval || 5e3;
        this.batchCount = options.batchCount || 10;
        this.batchOptions = [];
        this.batchTimeoutID = -1;
        this.batchCallback = {};
        if (!this.port) {
          this.port = this.ssl ? 443 : 80;
        }
      }
      /**
      * Core logging method exposed to Winston.
      * @param {Object} info - TODO: add param description.
      * @param {function} callback - TODO: add param description.
      * @returns {undefined}
      */
      log(info, callback) {
        this._request(info, null, null, (err, res) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            this.emit("warn", err);
          } else {
            this.emit("logged", info);
          }
        });
        if (callback) {
          setImmediate(callback);
        }
      }
      /**
      * Query the transport. Options object is optional.
      * @param {Object} options -  Loggly-like query options for this instance.
      * @param {function} callback - Continuation to respond to when complete.
      * @returns {undefined}
      */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = {
          method: "query",
          params: this.normalizeQuery(options)
        };
        const auth = options.params.auth || null;
        delete options.params.auth;
        const path = options.params.path || null;
        delete options.params.path;
        this._request(options, auth, path, (err, res, body) => {
          if (res && res.statusCode !== 200) {
            err = new Error(`Invalid HTTP Status Code: ${res.statusCode}`);
          }
          if (err) {
            return callback(err);
          }
          if (typeof body === "string") {
            try {
              body = JSON.parse(body);
            } catch (e) {
              return callback(e);
            }
          }
          callback(null, body);
        });
      }
      /**
      * Returns a log stream for this transport. Options object is optional.
      * @param {Object} options - Stream options for this instance.
      * @returns {Stream} - TODO: add return description
      */
      stream(options = {}) {
        const stream = new Stream();
        options = {
          method: "stream",
          params: options
        };
        const path = options.params.path || null;
        delete options.params.path;
        const auth = options.params.auth || null;
        delete options.params.auth;
        let buff = "";
        const req = this._request(options, auth, path);
        stream.destroy = () => req.destroy();
        req.on("data", (data) => {
          data = (buff + data).split(/\n+/);
          const l = data.length - 1;
          let i = 0;
          for (; i < l; i++) {
            try {
              stream.emit("log", JSON.parse(data[i]));
            } catch (e) {
              stream.emit("error", e);
            }
          }
          buff = data[l];
        });
        req.on("error", (err) => stream.emit("error", err));
        return stream;
      }
      /**
      * Make a request to a winstond server or any http server which can
      * handle json-rpc.
      * @param {function} options - Options to sent the request.
      * @param {Object?} auth - authentication options
      * @param {string} path - request path
      * @param {function} callback - Continuation to respond to when complete.
      */
      _request(options, auth, path, callback) {
        options = options || {};
        auth = auth || this.auth;
        path = path || this.path || "";
        if (this.batch) {
          this._doBatch(options, callback, auth, path);
        } else {
          this._doRequest(options, callback, auth, path);
        }
      }
      /**
      * Send or memorize the options according to batch configuration
      * @param {function} options - Options to sent the request.
      * @param {function} callback - Continuation to respond to when complete.
      * @param {Object?} auth - authentication options
      * @param {string} path - request path
      */
      _doBatch(options, callback, auth, path) {
        this.batchOptions.push(options);
        if (this.batchOptions.length === 1) {
          const me = this;
          this.batchCallback = callback;
          this.batchTimeoutID = setTimeout(function() {
            me.batchTimeoutID = -1;
            me._doBatchRequest(me.batchCallback, auth, path);
          }, this.batchInterval);
        }
        if (this.batchOptions.length === this.batchCount) {
          this._doBatchRequest(this.batchCallback, auth, path);
        }
      }
      /**
      * Initiate a request with the memorized batch options, stop the batch timeout
      * @param {function} callback - Continuation to respond to when complete.
      * @param {Object?} auth - authentication options
      * @param {string} path - request path
      */
      _doBatchRequest(callback, auth, path) {
        if (this.batchTimeoutID > 0) {
          clearTimeout(this.batchTimeoutID);
          this.batchTimeoutID = -1;
        }
        const batchOptionsCopy = this.batchOptions.slice();
        this.batchOptions = [];
        this._doRequest(batchOptionsCopy, callback, auth, path);
      }
      /**
      * Make a request to a winstond server or any http server which can
      * handle json-rpc.
      * @param {function} options - Options to sent the request.
      * @param {function} callback - Continuation to respond to when complete.
      * @param {Object?} auth - authentication options
      * @param {string} path - request path
      */
      _doRequest(options, callback, auth, path) {
        const headers = Object.assign({}, this.headers);
        if (auth && auth.bearer) {
          headers.Authorization = `Bearer ${auth.bearer}`;
        }
        const req = (this.ssl ? https : http).request({
          ...this.options,
          method: "POST",
          host: this.host,
          port: this.port,
          path: `/${path.replace(/^\//, "")}`,
          headers,
          auth: auth && auth.username && auth.password ? `${auth.username}:${auth.password}` : "",
          agent: this.agent
        });
        req.on("error", callback);
        req.on("response", (res) => res.on("end", () => callback(null, res)).resume());
        const jsonStringify = configure({
          ...this.maximumDepth && {
            maximumDepth: this.maximumDepth
          }
        });
        req.end(Buffer.from(jsonStringify(options, this.options.replacer), "utf8"));
      }
    };
  }
});

// node_modules/is-stream/index.js
var require_is_stream = __commonJS({
  "node_modules/is-stream/index.js"(exports2, module2) {
    "use strict";
    var isStream = /* @__PURE__ */ __name((stream) => stream !== null && typeof stream === "object" && typeof stream.pipe === "function", "isStream");
    isStream.writable = (stream) => isStream(stream) && stream.writable !== false && typeof stream._write === "function" && typeof stream._writableState === "object";
    isStream.readable = (stream) => isStream(stream) && stream.readable !== false && typeof stream._read === "function" && typeof stream._readableState === "object";
    isStream.duplex = (stream) => isStream.writable(stream) && isStream.readable(stream);
    isStream.transform = (stream) => isStream.duplex(stream) && typeof stream._transform === "function";
    module2.exports = isStream;
  }
});

// node_modules/winston/lib/winston/transports/stream.js
var require_stream2 = __commonJS({
  "node_modules/winston/lib/winston/transports/stream.js"(exports2, module2) {
    "use strict";
    var isStream = require_is_stream();
    var { MESSAGE } = require_triple_beam();
    var os = require("os");
    var TransportStream = require_winston_transport();
    module2.exports = class Stream extends TransportStream {
      static {
        __name(this, "Stream");
      }
      /**
      * Constructor function for the Console transport object responsible for
      * persisting log messages and metadata to a terminal or TTY.
      * @param {!Object} [options={}] - Options for this instance.
      */
      constructor(options = {}) {
        super(options);
        if (!options.stream || !isStream(options.stream)) {
          throw new Error("options.stream is required.");
        }
        this._stream = options.stream;
        this._stream.setMaxListeners(Infinity);
        this.isObjectMode = options.stream._writableState.objectMode;
        this.eol = typeof options.eol === "string" ? options.eol : os.EOL;
      }
      /**
      * Core logging method exposed to Winston.
      * @param {Object} info - TODO: add param description.
      * @param {Function} callback - TODO: add param description.
      * @returns {undefined}
      */
      log(info, callback) {
        setImmediate(() => this.emit("logged", info));
        if (this.isObjectMode) {
          this._stream.write(info);
          if (callback) {
            callback();
          }
          return;
        }
        this._stream.write(`${info[MESSAGE]}${this.eol}`);
        if (callback) {
          callback();
        }
        return;
      }
    };
  }
});

// node_modules/winston/lib/winston/transports/index.js
var require_transports = __commonJS({
  "node_modules/winston/lib/winston/transports/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "Console", {
      configurable: true,
      enumerable: true,
      get() {
        return require_console();
      }
    });
    Object.defineProperty(exports2, "File", {
      configurable: true,
      enumerable: true,
      get() {
        return require_file();
      }
    });
    Object.defineProperty(exports2, "Http", {
      configurable: true,
      enumerable: true,
      get() {
        return require_http();
      }
    });
    Object.defineProperty(exports2, "Stream", {
      configurable: true,
      enumerable: true,
      get() {
        return require_stream2();
      }
    });
  }
});

// node_modules/winston/lib/winston/config/index.js
var require_config2 = __commonJS({
  "node_modules/winston/lib/winston/config/index.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { configs } = require_triple_beam();
    exports2.cli = logform.levels(configs.cli);
    exports2.npm = logform.levels(configs.npm);
    exports2.syslog = logform.levels(configs.syslog);
    exports2.addColors = logform.levels;
  }
});

// node_modules/async/eachOf.js
var require_eachOf = __commonJS({
  "node_modules/async/eachOf.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _isArrayLike = require_isArrayLike();
    var _isArrayLike2 = _interopRequireDefault(_isArrayLike);
    var _breakLoop = require_breakLoop();
    var _breakLoop2 = _interopRequireDefault(_breakLoop);
    var _eachOfLimit = require_eachOfLimit2();
    var _eachOfLimit2 = _interopRequireDefault(_eachOfLimit);
    var _once = require_once();
    var _once2 = _interopRequireDefault(_once);
    var _onlyOnce = require_onlyOnce();
    var _onlyOnce2 = _interopRequireDefault(_onlyOnce);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function eachOfArrayLike(coll, iteratee, callback) {
      callback = (0, _once2.default)(callback);
      var index = 0, completed = 0, { length } = coll, canceled = false;
      if (length === 0) {
        callback(null);
      }
      function iteratorCallback(err, value2) {
        if (err === false) {
          canceled = true;
        }
        if (canceled === true) return;
        if (err) {
          callback(err);
        } else if (++completed === length || value2 === _breakLoop2.default) {
          callback(null);
        }
      }
      __name(iteratorCallback, "iteratorCallback");
      for (; index < length; index++) {
        iteratee(coll[index], index, (0, _onlyOnce2.default)(iteratorCallback));
      }
    }
    __name(eachOfArrayLike, "eachOfArrayLike");
    function eachOfGeneric(coll, iteratee, callback) {
      return (0, _eachOfLimit2.default)(coll, Infinity, iteratee, callback);
    }
    __name(eachOfGeneric, "eachOfGeneric");
    function eachOf(coll, iteratee, callback) {
      var eachOfImplementation = (0, _isArrayLike2.default)(coll) ? eachOfArrayLike : eachOfGeneric;
      return eachOfImplementation(coll, (0, _wrapAsync2.default)(iteratee), callback);
    }
    __name(eachOf, "eachOf");
    exports2.default = (0, _awaitify2.default)(eachOf, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/async/internal/withoutIndex.js
var require_withoutIndex = __commonJS({
  "node_modules/async/internal/withoutIndex.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.default = _withoutIndex;
    function _withoutIndex(iteratee) {
      return (value2, index, callback) => iteratee(value2, callback);
    }
    __name(_withoutIndex, "_withoutIndex");
    module2.exports = exports2.default;
  }
});

// node_modules/async/forEach.js
var require_forEach = __commonJS({
  "node_modules/async/forEach.js"(exports2, module2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    var _eachOf = require_eachOf();
    var _eachOf2 = _interopRequireDefault(_eachOf);
    var _withoutIndex = require_withoutIndex();
    var _withoutIndex2 = _interopRequireDefault(_withoutIndex);
    var _wrapAsync = require_wrapAsync();
    var _wrapAsync2 = _interopRequireDefault(_wrapAsync);
    var _awaitify = require_awaitify();
    var _awaitify2 = _interopRequireDefault(_awaitify);
    function _interopRequireDefault(obj) {
      return obj && obj.__esModule ? obj : {
        default: obj
      };
    }
    __name(_interopRequireDefault, "_interopRequireDefault");
    function eachLimit(coll, iteratee, callback) {
      return (0, _eachOf2.default)(coll, (0, _withoutIndex2.default)((0, _wrapAsync2.default)(iteratee)), callback);
    }
    __name(eachLimit, "eachLimit");
    exports2.default = (0, _awaitify2.default)(eachLimit, 3);
    module2.exports = exports2.default;
  }
});

// node_modules/fn.name/index.js
var require_fn = __commonJS({
  "node_modules/fn.name/index.js"(exports2, module2) {
    "use strict";
    var toString2 = Object.prototype.toString;
    module2.exports = /* @__PURE__ */ __name(function name(fn) {
      if ("string" === typeof fn.displayName && fn.constructor.name) {
        return fn.displayName;
      } else if ("string" === typeof fn.name && fn.name) {
        return fn.name;
      }
      if ("object" === typeof fn && fn.constructor && "string" === typeof fn.constructor.name) return fn.constructor.name;
      var named = fn.toString(), type = toString2.call(fn).slice(8, -1);
      if ("Function" === type) {
        named = named.substring(named.indexOf("(") + 1, named.indexOf(")"));
      } else {
        named = type;
      }
      return named || "anonymous";
    }, "name");
  }
});

// node_modules/one-time/index.js
var require_one_time = __commonJS({
  "node_modules/one-time/index.js"(exports2, module2) {
    "use strict";
    var name = require_fn();
    module2.exports = /* @__PURE__ */ __name(function one(fn) {
      var called = 0, value2;
      function onetime() {
        if (called) return value2;
        called = 1;
        value2 = fn.apply(this, arguments);
        fn = null;
        return value2;
      }
      __name(onetime, "onetime");
      onetime.displayName = name(fn);
      return onetime;
    }, "one");
  }
});

// node_modules/stack-trace/lib/stack-trace.js
var require_stack_trace = __commonJS({
  "node_modules/stack-trace/lib/stack-trace.js"(exports2) {
    "use strict";
    exports2.get = function(belowFn) {
      var oldLimit = Error.stackTraceLimit;
      Error.stackTraceLimit = Infinity;
      var dummyObject = {};
      var v8Handler = Error.prepareStackTrace;
      Error.prepareStackTrace = function(dummyObject2, v8StackTrace2) {
        return v8StackTrace2;
      };
      Error.captureStackTrace(dummyObject, belowFn || exports2.get);
      var v8StackTrace = dummyObject.stack;
      Error.prepareStackTrace = v8Handler;
      Error.stackTraceLimit = oldLimit;
      return v8StackTrace;
    };
    exports2.parse = function(err) {
      if (!err.stack) {
        return [];
      }
      var self2 = this;
      var lines = err.stack.split("\n").slice(1);
      return lines.map(function(line) {
        if (line.match(/^\s*[-]{4,}$/)) {
          return self2._createParsedCallSite({
            fileName: line,
            lineNumber: null,
            functionName: null,
            typeName: null,
            methodName: null,
            columnNumber: null,
            "native": null
          });
        }
        var lineMatch = line.match(/at (?:(.+)\s+\()?(?:(.+?):(\d+)(?::(\d+))?|([^)]+))\)?/);
        if (!lineMatch) {
          return;
        }
        var object = null;
        var method = null;
        var functionName = null;
        var typeName = null;
        var methodName = null;
        var isNative = lineMatch[5] === "native";
        if (lineMatch[1]) {
          functionName = lineMatch[1];
          var methodStart = functionName.lastIndexOf(".");
          if (functionName[methodStart - 1] == ".") methodStart--;
          if (methodStart > 0) {
            object = functionName.substr(0, methodStart);
            method = functionName.substr(methodStart + 1);
            var objectEnd = object.indexOf(".Module");
            if (objectEnd > 0) {
              functionName = functionName.substr(objectEnd + 1);
              object = object.substr(0, objectEnd);
            }
          }
          typeName = null;
        }
        if (method) {
          typeName = object;
          methodName = method;
        }
        if (method === "<anonymous>") {
          methodName = null;
          functionName = null;
        }
        var properties = {
          fileName: lineMatch[2] || null,
          lineNumber: parseInt(lineMatch[3], 10) || null,
          functionName,
          typeName,
          methodName,
          columnNumber: parseInt(lineMatch[4], 10) || null,
          "native": isNative
        };
        return self2._createParsedCallSite(properties);
      }).filter(function(callSite) {
        return !!callSite;
      });
    };
    function CallSite(properties) {
      for (var property in properties) {
        this[property] = properties[property];
      }
    }
    __name(CallSite, "CallSite");
    var strProperties = [
      "this",
      "typeName",
      "functionName",
      "methodName",
      "fileName",
      "lineNumber",
      "columnNumber",
      "function",
      "evalOrigin"
    ];
    var boolProperties = [
      "topLevel",
      "eval",
      "native",
      "constructor"
    ];
    strProperties.forEach(function(property) {
      CallSite.prototype[property] = null;
      CallSite.prototype["get" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    boolProperties.forEach(function(property) {
      CallSite.prototype[property] = false;
      CallSite.prototype["is" + property[0].toUpperCase() + property.substr(1)] = function() {
        return this[property];
      };
    });
    exports2._createParsedCallSite = function(properties) {
      return new CallSite(properties);
    };
  }
});

// node_modules/winston/lib/winston/exception-stream.js
var require_exception_stream = __commonJS({
  "node_modules/winston/lib/winston/exception-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class ExceptionStream extends Writable {
      static {
        __name(this, "ExceptionStream");
      }
      /**
      * Constructor function for the ExceptionStream responsible for wrapping a
      * TransportStream; only allowing writes of `info` objects with
      * `info.exception` set to true.
      * @param {!TransportStream} transport - Stream to filter to exceptions
      */
      constructor(transport) {
        super({
          objectMode: true
        });
        if (!transport) {
          throw new Error("ExceptionStream requires a TransportStream instance.");
        }
        this.handleExceptions = true;
        this.transport = transport;
      }
      /**
      * Writes the info object to our transport instance if (and only if) the
      * `exception` property is set on the info.
      * @param {mixed} info - TODO: add param description.
      * @param {mixed} enc - TODO: add param description.
      * @param {mixed} callback - TODO: add param description.
      * @returns {mixed} - TODO: add return description.
      * @private
      */
      _write(info, enc, callback) {
        if (info.exception) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/exception-handler.js
var require_exception_handler = __commonJS({
  "node_modules/winston/lib/winston/exception-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug12 = require_node2()("winston:exception");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var ExceptionStream = require_exception_stream();
    module2.exports = class ExceptionHandler {
      static {
        __name(this, "ExceptionHandler");
      }
      /**
      * TODO: add contructor description
      * @param {!Logger} logger - TODO: add param description
      */
      constructor(logger2) {
        if (!logger2) {
          throw new Error("Logger is required to handle exceptions");
        }
        this.logger = logger2;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
      * Handles `uncaughtException` events for the current process by adding any
      * handlers passed in.
      * @returns {undefined}
      */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._uncaughtException.bind(this);
          process.on("uncaughtException", this.catcher);
        }
      }
      /**
      * Removes any handlers to `uncaughtException` events for the current
      * process. This does not modify the state of the `this.handlers` set.
      * @returns {undefined}
      */
      unhandle() {
        if (this.catcher) {
          process.removeListener("uncaughtException", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
      * TODO: add method description
      * @param {Error} err - Error to get information about.
      * @returns {mixed} - TODO: add return description.
      */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `uncaughtException: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          exception: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
      * Gets all relevant process information for the currently running process.
      * @returns {mixed} - TODO: add return description.
      */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
      * Gets all relevant OS information for the currently running process.
      * @returns {mixed} - TODO: add return description.
      */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
      * Gets a stack trace for the specified error.
      * @param {mixed} err - TODO: add param description.
      * @returns {mixed} - TODO: add return description.
      */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
      * Helper method to add a transport as an exception handler.
      * @param {Transport} handler - The transport to add as an exception handler.
      * @returns {void}
      */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleExceptions = true;
          const wrapper = new ExceptionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
      * Logs all relevant information around the `err` and exits the current
      * process.
      * @param {Error} err - Error to handle
      * @returns {mixed} - TODO: add return description.
      * @private
      */
      _uncaughtException(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getExceptionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no exception handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug12("doExit", doExit);
          debug12("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        __name(gracefulExit, "gracefulExit");
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug12(event);
              done();
            };
          }
          __name(onDone, "onDone");
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
      * Returns the list of transports and exceptionHandlers for this instance.
      * @returns {Array} - List of transports and exceptionHandlers for this
      * instance.
      * @private
      */
      _getExceptionHandlers() {
        return this.logger.transports.filter((wrap2) => {
          const transport = wrap2.transport || wrap2;
          return transport.handleExceptions;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-stream.js
var require_rejection_stream = __commonJS({
  "node_modules/winston/lib/winston/rejection-stream.js"(exports2, module2) {
    "use strict";
    var { Writable } = require_readable();
    module2.exports = class RejectionStream extends Writable {
      static {
        __name(this, "RejectionStream");
      }
      /**
      * Constructor function for the RejectionStream responsible for wrapping a
      * TransportStream; only allowing writes of `info` objects with
      * `info.rejection` set to true.
      * @param {!TransportStream} transport - Stream to filter to rejections
      */
      constructor(transport) {
        super({
          objectMode: true
        });
        if (!transport) {
          throw new Error("RejectionStream requires a TransportStream instance.");
        }
        this.handleRejections = true;
        this.transport = transport;
      }
      /**
      * Writes the info object to our transport instance if (and only if) the
      * `rejection` property is set on the info.
      * @param {mixed} info - TODO: add param description.
      * @param {mixed} enc - TODO: add param description.
      * @param {mixed} callback - TODO: add param description.
      * @returns {mixed} - TODO: add return description.
      * @private
      */
      _write(info, enc, callback) {
        if (info.rejection) {
          return this.transport.log(info, callback);
        }
        callback();
        return true;
      }
    };
  }
});

// node_modules/winston/lib/winston/rejection-handler.js
var require_rejection_handler = __commonJS({
  "node_modules/winston/lib/winston/rejection-handler.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var asyncForEach = require_forEach();
    var debug12 = require_node2()("winston:rejection");
    var once = require_one_time();
    var stackTrace = require_stack_trace();
    var RejectionStream = require_rejection_stream();
    module2.exports = class RejectionHandler {
      static {
        __name(this, "RejectionHandler");
      }
      /**
      * TODO: add contructor description
      * @param {!Logger} logger - TODO: add param description
      */
      constructor(logger2) {
        if (!logger2) {
          throw new Error("Logger is required to handle rejections");
        }
        this.logger = logger2;
        this.handlers = /* @__PURE__ */ new Map();
      }
      /**
      * Handles `unhandledRejection` events for the current process by adding any
      * handlers passed in.
      * @returns {undefined}
      */
      handle(...args) {
        args.forEach((arg) => {
          if (Array.isArray(arg)) {
            return arg.forEach((handler) => this._addHandler(handler));
          }
          this._addHandler(arg);
        });
        if (!this.catcher) {
          this.catcher = this._unhandledRejection.bind(this);
          process.on("unhandledRejection", this.catcher);
        }
      }
      /**
      * Removes any handlers to `unhandledRejection` events for the current
      * process. This does not modify the state of the `this.handlers` set.
      * @returns {undefined}
      */
      unhandle() {
        if (this.catcher) {
          process.removeListener("unhandledRejection", this.catcher);
          this.catcher = false;
          Array.from(this.handlers.values()).forEach((wrapper) => this.logger.unpipe(wrapper));
        }
      }
      /**
      * TODO: add method description
      * @param {Error} err - Error to get information about.
      * @returns {mixed} - TODO: add return description.
      */
      getAllInfo(err) {
        let message = null;
        if (err) {
          message = typeof err === "string" ? err : err.message;
        }
        return {
          error: err,
          // TODO (indexzero): how do we configure this?
          level: "error",
          message: [
            `unhandledRejection: ${message || "(no error message)"}`,
            err && err.stack || "  No stack trace"
          ].join("\n"),
          stack: err && err.stack,
          rejection: true,
          date: (/* @__PURE__ */ new Date()).toString(),
          process: this.getProcessInfo(),
          os: this.getOsInfo(),
          trace: this.getTrace(err)
        };
      }
      /**
      * Gets all relevant process information for the currently running process.
      * @returns {mixed} - TODO: add return description.
      */
      getProcessInfo() {
        return {
          pid: process.pid,
          uid: process.getuid ? process.getuid() : null,
          gid: process.getgid ? process.getgid() : null,
          cwd: process.cwd(),
          execPath: process.execPath,
          version: process.version,
          argv: process.argv,
          memoryUsage: process.memoryUsage()
        };
      }
      /**
      * Gets all relevant OS information for the currently running process.
      * @returns {mixed} - TODO: add return description.
      */
      getOsInfo() {
        return {
          loadavg: os.loadavg(),
          uptime: os.uptime()
        };
      }
      /**
      * Gets a stack trace for the specified error.
      * @param {mixed} err - TODO: add param description.
      * @returns {mixed} - TODO: add return description.
      */
      getTrace(err) {
        const trace = err ? stackTrace.parse(err) : stackTrace.get();
        return trace.map((site) => {
          return {
            column: site.getColumnNumber(),
            file: site.getFileName(),
            function: site.getFunctionName(),
            line: site.getLineNumber(),
            method: site.getMethodName(),
            native: site.isNative()
          };
        });
      }
      /**
      * Helper method to add a transport as an exception handler.
      * @param {Transport} handler - The transport to add as an exception handler.
      * @returns {void}
      */
      _addHandler(handler) {
        if (!this.handlers.has(handler)) {
          handler.handleRejections = true;
          const wrapper = new RejectionStream(handler);
          this.handlers.set(handler, wrapper);
          this.logger.pipe(wrapper);
        }
      }
      /**
      * Logs all relevant information around the `err` and exits the current
      * process.
      * @param {Error} err - Error to handle
      * @returns {mixed} - TODO: add return description.
      * @private
      */
      _unhandledRejection(err) {
        const info = this.getAllInfo(err);
        const handlers = this._getRejectionHandlers();
        let doExit = typeof this.logger.exitOnError === "function" ? this.logger.exitOnError(err) : this.logger.exitOnError;
        let timeout;
        if (!handlers.length && doExit) {
          console.warn("winston: exitOnError cannot be true with no rejection handlers.");
          console.warn("winston: not exiting process.");
          doExit = false;
        }
        function gracefulExit() {
          debug12("doExit", doExit);
          debug12("process._exiting", process._exiting);
          if (doExit && !process._exiting) {
            if (timeout) {
              clearTimeout(timeout);
            }
            process.exit(1);
          }
        }
        __name(gracefulExit, "gracefulExit");
        if (!handlers || handlers.length === 0) {
          return process.nextTick(gracefulExit);
        }
        asyncForEach(handlers, (handler, next) => {
          const done = once(next);
          const transport = handler.transport || handler;
          function onDone(event) {
            return () => {
              debug12(event);
              done();
            };
          }
          __name(onDone, "onDone");
          transport._ending = true;
          transport.once("finish", onDone("finished"));
          transport.once("error", onDone("error"));
        }, () => doExit && gracefulExit());
        this.logger.log(info);
        if (doExit) {
          timeout = setTimeout(gracefulExit, 3e3);
        }
      }
      /**
      * Returns the list of transports and exceptionHandlers for this instance.
      * @returns {Array} - List of transports and exceptionHandlers for this
      * instance.
      * @private
      */
      _getRejectionHandlers() {
        return this.logger.transports.filter((wrap2) => {
          const transport = wrap2.transport || wrap2;
          return transport.handleRejections;
        });
      }
    };
  }
});

// node_modules/winston/lib/winston/profiler.js
var require_profiler = __commonJS({
  "node_modules/winston/lib/winston/profiler.js"(exports2, module2) {
    "use strict";
    var Profiler = class Profiler {
      static {
        __name(this, "Profiler");
      }
      /**
      * Constructor function for the Profiler instance used by
      * `Logger.prototype.startTimer`. When done is called the timer will finish
      * and log the duration.
      * @param {!Logger} logger - TODO: add param description.
      * @private
      */
      constructor(logger2) {
        const Logger = require_logger();
        if (typeof logger2 !== "object" || Array.isArray(logger2) || !(logger2 instanceof Logger)) {
          throw new Error("Logger is required for profiling");
        } else {
          this.logger = logger2;
          this.start = Date.now();
        }
      }
      /**
      * Ends the current timer (i.e. Profiler) instance and logs the `msg` along
      * with the duration since creation.
      * @returns {mixed} - TODO: add return description.
      * @private
      */
      done(...args) {
        if (typeof args[args.length - 1] === "function") {
          console.warn("Callback function no longer supported as of winston@3.0.0");
          args.pop();
        }
        const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
        info.level = info.level || "info";
        info.durationMs = Date.now() - this.start;
        return this.logger.write(info);
      }
    };
    module2.exports = Profiler;
  }
});

// node_modules/winston/lib/winston/logger.js
var require_logger = __commonJS({
  "node_modules/winston/lib/winston/logger.js"(exports2, module2) {
    "use strict";
    var { Stream, Transform } = require_readable();
    var asyncForEach = require_forEach();
    var { LEVEL, SPLAT } = require_triple_beam();
    var isStream = require_is_stream();
    var ExceptionHandler = require_exception_handler();
    var RejectionHandler = require_rejection_handler();
    var LegacyTransportStream = require_legacy();
    var Profiler = require_profiler();
    var { warn } = require_common();
    var config = require_config2();
    var formatRegExp = /%[scdjifoO%]/g;
    var Logger = class Logger extends Transform {
      static {
        __name(this, "Logger");
      }
      /**
      * Constructor function for the Logger object responsible for persisting log
      * messages and metadata to one or more transports.
      * @param {!Object} options - foo
      */
      constructor(options) {
        super({
          objectMode: true
        });
        this.configure(options);
      }
      child(defaultRequestMetadata) {
        const logger2 = this;
        return Object.create(logger2, {
          write: {
            value: /* @__PURE__ */ __name(function(info) {
              const infoClone = Object.assign({}, defaultRequestMetadata, info);
              if (info instanceof Error) {
                infoClone.stack = info.stack;
                infoClone.message = info.message;
              }
              logger2.write(infoClone);
            }, "value")
          }
        });
      }
      /**
      * This will wholesale reconfigure this instance by:
      * 1. Resetting all transports. Older transports will be removed implicitly.
      * 2. Set all other options including levels, colors, rewriters, filters,
      *    exceptionHandlers, etc.
      * @param {!Object} options - TODO: add param description.
      * @returns {undefined}
      */
      configure({ silent, format: format5, defaultMeta, levels, level = "info", exitOnError = true, transports: transports3, colors, emitErrs, formatters, padLevels, rewriters, stripColors, exceptionHandlers, rejectionHandlers } = {}) {
        if (this.transports.length) {
          this.clear();
        }
        this.silent = silent;
        this.format = format5 || this.format || require_json()();
        this.defaultMeta = defaultMeta || null;
        this.levels = levels || this.levels || config.npm.levels;
        this.level = level;
        if (this.exceptions) {
          this.exceptions.unhandle();
        }
        if (this.rejections) {
          this.rejections.unhandle();
        }
        this.exceptions = new ExceptionHandler(this);
        this.rejections = new RejectionHandler(this);
        this.profilers = {};
        this.exitOnError = exitOnError;
        if (transports3) {
          transports3 = Array.isArray(transports3) ? transports3 : [
            transports3
          ];
          transports3.forEach((transport) => this.add(transport));
        }
        if (colors || emitErrs || formatters || padLevels || rewriters || stripColors) {
          throw new Error([
            "{ colors, emitErrs, formatters, padLevels, rewriters, stripColors } were removed in winston@3.0.0.",
            "Use a custom winston.format(function) instead.",
            "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
          ].join("\n"));
        }
        if (exceptionHandlers) {
          this.exceptions.handle(exceptionHandlers);
        }
        if (rejectionHandlers) {
          this.rejections.handle(rejectionHandlers);
        }
      }
      isLevelEnabled(level) {
        const givenLevelValue = getLevelValue(this.levels, level);
        if (givenLevelValue === null) {
          return false;
        }
        const configuredLevelValue = getLevelValue(this.levels, this.level);
        if (configuredLevelValue === null) {
          return false;
        }
        if (!this.transports || this.transports.length === 0) {
          return configuredLevelValue >= givenLevelValue;
        }
        const index = this.transports.findIndex((transport) => {
          let transportLevelValue = getLevelValue(this.levels, transport.level);
          if (transportLevelValue === null) {
            transportLevelValue = configuredLevelValue;
          }
          return transportLevelValue >= givenLevelValue;
        });
        return index !== -1;
      }
      /* eslint-disable valid-jsdoc */
      /**
      * Ensure backwards compatibility with a `log` method
      * @param {mixed} level - Level the log message is written at.
      * @param {mixed} msg - TODO: add param description.
      * @param {mixed} meta - TODO: add param description.
      * @returns {Logger} - TODO: add return description.
      *
      * @example
      *    // Supports the existing API:
      *    logger.log('info', 'Hello world', { custom: true });
      *    logger.log('info', new Error('Yo, it\'s on fire'));
      *
      *    // Requires winston.format.splat()
      *    logger.log('info', '%s %d%%', 'A string', 50, { thisIsMeta: true });
      *
      *    // And the new API with a single JSON literal:
      *    logger.log({ level: 'info', message: 'Hello world', custom: true });
      *    logger.log({ level: 'info', message: new Error('Yo, it\'s on fire') });
      *
      *    // Also requires winston.format.splat()
      *    logger.log({
      *      level: 'info',
      *      message: '%s %d%%',
      *      [SPLAT]: ['A string', 50],
      *      meta: { thisIsMeta: true }
      *    });
      *
      */
      /* eslint-enable valid-jsdoc */
      log(level, msg, ...splat) {
        if (arguments.length === 1) {
          level[LEVEL] = level.level;
          this._addDefaultMeta(level);
          this.write(level);
          return this;
        }
        if (arguments.length === 2) {
          if (msg && typeof msg === "object") {
            msg[LEVEL] = msg.level = level;
            this._addDefaultMeta(msg);
            this.write(msg);
            return this;
          }
          msg = {
            [LEVEL]: level,
            level,
            message: msg
          };
          this._addDefaultMeta(msg);
          this.write(msg);
          return this;
        }
        const [meta] = splat;
        if (typeof meta === "object" && meta !== null) {
          const tokens = msg && msg.match && msg.match(formatRegExp);
          if (!tokens) {
            const info = Object.assign({}, this.defaultMeta, meta, {
              [LEVEL]: level,
              [SPLAT]: splat,
              level,
              message: msg
            });
            if (meta.message) info.message = `${info.message} ${meta.message}`;
            if (meta.stack) info.stack = meta.stack;
            if (meta.cause) info.cause = meta.cause;
            this.write(info);
            return this;
          }
        }
        this.write(Object.assign({}, this.defaultMeta, {
          [LEVEL]: level,
          [SPLAT]: splat,
          level,
          message: msg
        }));
        return this;
      }
      /**
      * Pushes data so that it can be picked up by all of our pipe targets.
      * @param {mixed} info - TODO: add param description.
      * @param {mixed} enc - TODO: add param description.
      * @param {mixed} callback - Continues stream processing.
      * @returns {undefined}
      * @private
      */
      _transform(info, enc, callback) {
        if (this.silent) {
          return callback();
        }
        if (!info[LEVEL]) {
          info[LEVEL] = info.level;
        }
        if (!this.levels[info[LEVEL]] && this.levels[info[LEVEL]] !== 0) {
          console.error("[winston] Unknown logger level: %s", info[LEVEL]);
        }
        if (!this._readableState.pipes) {
          console.error("[winston] Attempt to write logs with no transports, which can increase memory usage: %j", info);
        }
        try {
          this.push(this.format.transform(info, this.format.options));
        } finally {
          this._writableState.sync = false;
          callback();
        }
      }
      /**
      * Delays the 'finish' event until all transport pipe targets have
      * also emitted 'finish' or are already finished.
      * @param {mixed} callback - Continues stream processing.
      */
      _final(callback) {
        const transports3 = this.transports.slice();
        asyncForEach(transports3, (transport, next) => {
          if (!transport || transport.finished) return setImmediate(next);
          transport.once("finish", next);
          transport.end();
        }, callback);
      }
      /**
      * Adds the transport to this logger instance by piping to it.
      * @param {mixed} transport - TODO: add param description.
      * @returns {Logger} - TODO: add return description.
      */
      add(transport) {
        const target = !isStream(transport) || transport.log.length > 2 ? new LegacyTransportStream({
          transport
        }) : transport;
        if (!target._writableState || !target._writableState.objectMode) {
          throw new Error("Transports must WritableStreams in objectMode. Set { objectMode: true }.");
        }
        this._onEvent("error", target);
        this._onEvent("warn", target);
        this.pipe(target);
        if (transport.handleExceptions) {
          this.exceptions.handle();
        }
        if (transport.handleRejections) {
          this.rejections.handle();
        }
        return this;
      }
      /**
      * Removes the transport from this logger instance by unpiping from it.
      * @param {mixed} transport - TODO: add param description.
      * @returns {Logger} - TODO: add return description.
      */
      remove(transport) {
        if (!transport) return this;
        let target = transport;
        if (!isStream(transport) || transport.log.length > 2) {
          target = this.transports.filter((match) => match.transport === transport)[0];
        }
        if (target) {
          this.unpipe(target);
        }
        return this;
      }
      /**
      * Removes all transports from this logger instance.
      * @returns {Logger} - TODO: add return description.
      */
      clear() {
        this.unpipe();
        return this;
      }
      /**
      * Cleans up resources (streams, event listeners) for all transports
      * associated with this instance (if necessary).
      * @returns {Logger} - TODO: add return description.
      */
      close() {
        this.exceptions.unhandle();
        this.rejections.unhandle();
        this.clear();
        this.emit("close");
        return this;
      }
      /**
      * Sets the `target` levels specified on this instance.
      * @param {Object} Target levels to use on this instance.
      */
      setLevels() {
        warn.deprecated("setLevels");
      }
      /**
      * Queries the all transports for this instance with the specified `options`.
      * This will aggregate each transport's results into one object containing
      * a property per transport.
      * @param {Object} options - Query options for this instance.
      * @param {function} callback - Continuation to respond to when complete.
      */
      query(options, callback) {
        if (typeof options === "function") {
          callback = options;
          options = {};
        }
        options = options || {};
        const results = {};
        const queryObject = Object.assign({}, options.query || {});
        function queryTransport(transport, next) {
          if (options.query && typeof transport.formatQuery === "function") {
            options.query = transport.formatQuery(queryObject);
          }
          transport.query(options, (err, res) => {
            if (err) {
              return next(err);
            }
            if (typeof transport.formatResults === "function") {
              res = transport.formatResults(res, options.format);
            }
            next(null, res);
          });
        }
        __name(queryTransport, "queryTransport");
        function addResults(transport, next) {
          queryTransport(transport, (err, result2) => {
            if (next) {
              result2 = err || result2;
              if (result2) {
                results[transport.name] = result2;
              }
              next();
            }
            next = null;
          });
        }
        __name(addResults, "addResults");
        asyncForEach(this.transports.filter((transport) => !!transport.query), addResults, () => callback(null, results));
      }
      /**
      * Returns a log stream for all transports. Options object is optional.
      * @param{Object} options={} - Stream options for this instance.
      * @returns {Stream} - TODO: add return description.
      */
      stream(options = {}) {
        const out = new Stream();
        const streams = [];
        out._streams = streams;
        out.destroy = () => {
          let i = streams.length;
          while (i--) {
            streams[i].destroy();
          }
        };
        this.transports.filter((transport) => !!transport.stream).forEach((transport) => {
          const str = transport.stream(options);
          if (!str) {
            return;
          }
          streams.push(str);
          str.on("log", (log) => {
            log.transport = log.transport || [];
            log.transport.push(transport.name);
            out.emit("log", log);
          });
          str.on("error", (err) => {
            err.transport = err.transport || [];
            err.transport.push(transport.name);
            out.emit("error", err);
          });
        });
        return out;
      }
      /**
      * Returns an object corresponding to a specific timing. When done is called
      * the timer will finish and log the duration. e.g.:
      * @returns {Profile} - TODO: add return description.
      * @example
      *    const timer = winston.startTimer()
      *    setTimeout(() => {
      *      timer.done({
      *        message: 'Logging message'
      *      });
      *    }, 1000);
      */
      startTimer() {
        return new Profiler(this);
      }
      /**
      * Tracks the time inbetween subsequent calls to this method with the same
      * `id` parameter. The second call to this method will log the difference in
      * milliseconds along with the message.
      * @param {string} id Unique id of the profiler
      * @returns {Logger} - TODO: add return description.
      */
      profile(id, ...args) {
        const time = Date.now();
        if (this.profilers[id]) {
          const timeEnd = this.profilers[id];
          delete this.profilers[id];
          if (typeof args[args.length - 2] === "function") {
            console.warn("Callback function no longer supported as of winston@3.0.0");
            args.pop();
          }
          const info = typeof args[args.length - 1] === "object" ? args.pop() : {};
          info.level = info.level || "info";
          info.durationMs = time - timeEnd;
          info.message = info.message || id;
          return this.write(info);
        }
        this.profilers[id] = time;
        return this;
      }
      /**
      * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
      * @returns {undefined}
      * @deprecated
      */
      handleExceptions(...args) {
        console.warn("Deprecated: .handleExceptions() will be removed in winston@4. Use .exceptions.handle()");
        this.exceptions.handle(...args);
      }
      /**
      * Backwards compatibility to `exceptions.handle` in winston < 3.0.0.
      * @returns {undefined}
      * @deprecated
      */
      unhandleExceptions(...args) {
        console.warn("Deprecated: .unhandleExceptions() will be removed in winston@4. Use .exceptions.unhandle()");
        this.exceptions.unhandle(...args);
      }
      /**
      * Throw a more meaningful deprecation notice
      * @throws {Error} - TODO: add throws description.
      */
      cli() {
        throw new Error([
          "Logger.cli() was removed in winston@3.0.0",
          "Use a custom winston.formats.cli() instead.",
          "See: https://github.com/winstonjs/winston/tree/master/UPGRADE-3.0.md"
        ].join("\n"));
      }
      /**
      * Bubbles the `event` that occured on the specified `transport` up
      * from this instance.
      * @param {string} event - The event that occured
      * @param {Object} transport - Transport on which the event occured
      * @private
      */
      _onEvent(event, transport) {
        function transportEvent(err) {
          if (event === "error" && !this.transports.includes(transport)) {
            this.add(transport);
          }
          this.emit(event, err, transport);
        }
        __name(transportEvent, "transportEvent");
        if (!transport["__winston" + event]) {
          transport["__winston" + event] = transportEvent.bind(this);
          transport.on(event, transport["__winston" + event]);
        }
      }
      _addDefaultMeta(msg) {
        if (this.defaultMeta) {
          Object.assign(msg, this.defaultMeta);
        }
      }
    };
    function getLevelValue(levels, level) {
      const value2 = levels[level];
      if (!value2 && value2 !== 0) {
        return null;
      }
      return value2;
    }
    __name(getLevelValue, "getLevelValue");
    Object.defineProperty(Logger.prototype, "transports", {
      configurable: false,
      enumerable: true,
      get() {
        const { pipes } = this._readableState;
        return !Array.isArray(pipes) ? [
          pipes
        ].filter(Boolean) : pipes;
      }
    });
    module2.exports = Logger;
  }
});

// node_modules/winston/lib/winston/create-logger.js
var require_create_logger = __commonJS({
  "node_modules/winston/lib/winston/create-logger.js"(exports2, module2) {
    "use strict";
    var { LEVEL } = require_triple_beam();
    var config = require_config2();
    var Logger = require_logger();
    var debug12 = require_node2()("winston:create-logger");
    function isLevelEnabledFunctionName(level) {
      return "is" + level.charAt(0).toUpperCase() + level.slice(1) + "Enabled";
    }
    __name(isLevelEnabledFunctionName, "isLevelEnabledFunctionName");
    module2.exports = function(opts = {}) {
      opts.levels = opts.levels || config.npm.levels;
      let DerivedLogger = class DerivedLogger extends Logger {
        static {
          __name(this, "DerivedLogger");
        }
        /**
        * Create a new class derived logger for which the levels can be attached to
        * the prototype of. This is a V8 optimization that is well know to increase
        * performance of prototype functions.
        * @param {!Object} options - Options for the created logger.
        */
        constructor(options) {
          super(options);
        }
      };
      const logger2 = new DerivedLogger(opts);
      Object.keys(opts.levels).forEach(function(level) {
        debug12('Define prototype method for "%s"', level);
        if (level === "log") {
          console.warn('Level "log" not defined: conflicts with the method "log". Use a different level name.');
          return;
        }
        DerivedLogger.prototype[level] = function(...args) {
          const self2 = this || logger2;
          if (args.length === 1) {
            const [msg] = args;
            const info = msg && msg.message && msg || {
              message: msg
            };
            info.level = info[LEVEL] = level;
            self2._addDefaultMeta(info);
            self2.write(info);
            return this || logger2;
          }
          if (args.length === 0) {
            self2.log(level, "");
            return self2;
          }
          return self2.log(level, ...args);
        };
        DerivedLogger.prototype[isLevelEnabledFunctionName(level)] = function() {
          return (this || logger2).isLevelEnabled(level);
        };
      });
      return logger2;
    };
  }
});

// node_modules/winston/lib/winston/container.js
var require_container = __commonJS({
  "node_modules/winston/lib/winston/container.js"(exports2, module2) {
    "use strict";
    var createLogger2 = require_create_logger();
    module2.exports = class Container {
      static {
        __name(this, "Container");
      }
      /**
      * Constructor function for the Container object responsible for managing a
      * set of `winston.Logger` instances based on string ids.
      * @param {!Object} [options={}] - Default pass-thru options for Loggers.
      */
      constructor(options = {}) {
        this.loggers = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
      * Retrieves a `winston.Logger` instance for the specified `id`. If an
      * instance does not exist, one is created.
      * @param {!string} id - The id of the Logger to get.
      * @param {?Object} [options] - Options for the Logger instance.
      * @returns {Logger} - A configured Logger instance with a specified id.
      */
      add(id, options) {
        if (!this.loggers.has(id)) {
          options = Object.assign({}, options || this.options);
          const existing = options.transports || this.options.transports;
          if (existing) {
            options.transports = Array.isArray(existing) ? existing.slice() : [
              existing
            ];
          } else {
            options.transports = [];
          }
          const logger2 = createLogger2(options);
          logger2.on("close", () => this._delete(id));
          this.loggers.set(id, logger2);
        }
        return this.loggers.get(id);
      }
      /**
      * Retreives a `winston.Logger` instance for the specified `id`. If
      * an instance does not exist, one is created.
      * @param {!string} id - The id of the Logger to get.
      * @param {?Object} [options] - Options for the Logger instance.
      * @returns {Logger} - A configured Logger instance with a specified id.
      */
      get(id, options) {
        return this.add(id, options);
      }
      /**
      * Check if the container has a logger with the id.
      * @param {?string} id - The id of the Logger instance to find.
      * @returns {boolean} - Boolean value indicating if this instance has a
      * logger with the specified `id`.
      */
      has(id) {
        return !!this.loggers.has(id);
      }
      /**
      * Closes a `Logger` instance with the specified `id` if it exists.
      * If no `id` is supplied then all Loggers are closed.
      * @param {?string} id - The id of the Logger instance to close.
      * @returns {undefined}
      */
      close(id) {
        if (id) {
          return this._removeLogger(id);
        }
        this.loggers.forEach((val, key) => this._removeLogger(key));
      }
      /**
      * Remove a logger based on the id.
      * @param {!string} id - The id of the logger to remove.
      * @returns {undefined}
      * @private
      */
      _removeLogger(id) {
        if (!this.loggers.has(id)) {
          return;
        }
        const logger2 = this.loggers.get(id);
        logger2.close();
        this._delete(id);
      }
      /**
      * Deletes a `Logger` instance with the specified `id`.
      * @param {!string} id - The id of the Logger instance to delete from
      * container.
      * @returns {undefined}
      * @private
      */
      _delete(id) {
        this.loggers.delete(id);
      }
    };
  }
});

// node_modules/winston/lib/winston.js
var require_winston = __commonJS({
  "node_modules/winston/lib/winston.js"(exports2) {
    "use strict";
    var logform = require_logform();
    var { warn } = require_common();
    exports2.version = require_package().version;
    exports2.transports = require_transports();
    exports2.config = require_config2();
    exports2.addColors = logform.levels;
    exports2.format = logform.format;
    exports2.createLogger = require_create_logger();
    exports2.Logger = require_logger();
    exports2.ExceptionHandler = require_exception_handler();
    exports2.RejectionHandler = require_rejection_handler();
    exports2.Container = require_container();
    exports2.Transport = require_winston_transport();
    exports2.loggers = new exports2.Container();
    var defaultLogger = exports2.createLogger();
    Object.keys(exports2.config.npm.levels).concat([
      "log",
      "query",
      "stream",
      "add",
      "remove",
      "clear",
      "profile",
      "startTimer",
      "handleExceptions",
      "unhandleExceptions",
      "handleRejections",
      "unhandleRejections",
      "configure",
      "child"
    ]).forEach((method) => exports2[method] = (...args) => defaultLogger[method](...args));
    Object.defineProperty(exports2, "level", {
      get() {
        return defaultLogger.level;
      },
      set(val) {
        defaultLogger.level = val;
      }
    });
    Object.defineProperty(exports2, "exceptions", {
      get() {
        return defaultLogger.exceptions;
      }
    });
    Object.defineProperty(exports2, "rejections", {
      get() {
        return defaultLogger.rejections;
      }
    });
    [
      "exitOnError"
    ].forEach((prop) => {
      Object.defineProperty(exports2, prop, {
        get() {
          return defaultLogger[prop];
        },
        set(val) {
          defaultLogger[prop] = val;
        }
      });
    });
    Object.defineProperty(exports2, "default", {
      get() {
        return {
          exceptionHandlers: defaultLogger.exceptionHandlers,
          rejectionHandlers: defaultLogger.rejectionHandlers,
          transports: defaultLogger.transports
        };
      }
    });
    warn.deprecated(exports2, "setLevels");
    warn.forFunctions(exports2, "useFormat", [
      "cli"
    ]);
    warn.forProperties(exports2, "useFormat", [
      "padLevels",
      "stripColors"
    ]);
    warn.forFunctions(exports2, "deprecated", [
      "addRewriter",
      "addFilter",
      "clone",
      "extend"
    ]);
    warn.forProperties(exports2, "deprecated", [
      "emitErrs",
      "levelLength"
    ]);
  }
});

// src/shared/utils/logger.ts
var import_winston, customFormat, logger;
var init_logger = __esm({
  "src/shared/utils/logger.ts"() {
    "use strict";
    import_winston = __toESM(require_winston());
    customFormat = import_winston.format.printf(({ timestamp, level, message }) => {
      return `[${timestamp}] [${level}] ${message}`;
    });
    logger = (0, import_winston.createLogger)({
      level: "info",
      format: import_winston.format.combine(import_winston.format.colorize(), import_winston.format.timestamp(), import_winston.format.errors({
        stack: true
      }), customFormat),
      transports: [
        new import_winston.transports.Console()
      ],
      silent: false
    });
  }
});

// node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js
var require_XMLHttpRequest = __commonJS({
  "node_modules/xmlhttprequest-ssl/lib/XMLHttpRequest.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var Url = require("url");
    var spawn = require("child_process").spawn;
    module2.exports = XMLHttpRequest3;
    XMLHttpRequest3.XMLHttpRequest = XMLHttpRequest3;
    function XMLHttpRequest3(opts) {
      "use strict";
      opts = opts || {};
      var self2 = this;
      var http = require("http");
      var https = require("https");
      var request;
      var response;
      var settings = {};
      var disableHeaderCheck = false;
      var defaultHeaders = {
        "User-Agent": "node-XMLHttpRequest",
        "Accept": "*/*"
      };
      var headers = Object.assign({}, defaultHeaders);
      var forbiddenRequestHeaders = [
        "accept-charset",
        "accept-encoding",
        "access-control-request-headers",
        "access-control-request-method",
        "connection",
        "content-length",
        "content-transfer-encoding",
        "cookie",
        "cookie2",
        "date",
        "expect",
        "host",
        "keep-alive",
        "origin",
        "referer",
        "te",
        "trailer",
        "transfer-encoding",
        "upgrade",
        "via"
      ];
      var forbiddenRequestMethods = [
        "TRACE",
        "TRACK",
        "CONNECT"
      ];
      var sendFlag = false;
      var errorFlag = false;
      var abortedFlag = false;
      var listeners = {};
      this.UNSENT = 0;
      this.OPENED = 1;
      this.HEADERS_RECEIVED = 2;
      this.LOADING = 3;
      this.DONE = 4;
      this.readyState = this.UNSENT;
      this.onreadystatechange = null;
      this.responseText = "";
      this.responseXML = "";
      this.response = Buffer.alloc(0);
      this.status = null;
      this.statusText = null;
      var isAllowedHttpHeader = /* @__PURE__ */ __name(function(header) {
        return disableHeaderCheck || header && forbiddenRequestHeaders.indexOf(header.toLowerCase()) === -1;
      }, "isAllowedHttpHeader");
      var isAllowedHttpMethod = /* @__PURE__ */ __name(function(method) {
        return method && forbiddenRequestMethods.indexOf(method) === -1;
      }, "isAllowedHttpMethod");
      this.open = function(method, url2, async, user, password) {
        this.abort();
        errorFlag = false;
        abortedFlag = false;
        if (!isAllowedHttpMethod(method)) {
          throw new Error("SecurityError: Request method not allowed");
        }
        settings = {
          "method": method,
          "url": url2.toString(),
          "async": typeof async !== "boolean" ? true : async,
          "user": user || null,
          "password": password || null
        };
        setState(this.OPENED);
      };
      this.setDisableHeaderCheck = function(state) {
        disableHeaderCheck = state;
      };
      this.setRequestHeader = function(header, value2) {
        if (this.readyState != this.OPENED) {
          throw new Error("INVALID_STATE_ERR: setRequestHeader can only be called when state is OPEN");
        }
        if (!isAllowedHttpHeader(header)) {
          console.warn('Refused to set unsafe header "' + header + '"');
          return false;
        }
        if (sendFlag) {
          throw new Error("INVALID_STATE_ERR: send flag is true");
        }
        headers[header] = value2;
        return true;
      };
      this.getResponseHeader = function(header) {
        if (typeof header === "string" && this.readyState > this.OPENED && response.headers[header.toLowerCase()] && !errorFlag) {
          return response.headers[header.toLowerCase()];
        }
        return null;
      };
      this.getAllResponseHeaders = function() {
        if (this.readyState < this.HEADERS_RECEIVED || errorFlag) {
          return "";
        }
        var result2 = "";
        for (var i in response.headers) {
          if (i !== "set-cookie" && i !== "set-cookie2") {
            result2 += i + ": " + response.headers[i] + "\r\n";
          }
        }
        return result2.substr(0, result2.length - 2);
      };
      this.getRequestHeader = function(name) {
        if (typeof name === "string" && headers[name]) {
          return headers[name];
        }
        return "";
      };
      this.send = function(data) {
        if (this.readyState != this.OPENED) {
          throw new Error("INVALID_STATE_ERR: connection must be opened before send() is called");
        }
        if (sendFlag) {
          throw new Error("INVALID_STATE_ERR: send has already been called");
        }
        var ssl = false, local = false;
        var url2 = Url.parse(settings.url);
        var host;
        switch (url2.protocol) {
          case "https:":
            ssl = true;
          // SSL & non-SSL both need host, no break here.
          case "http:":
            host = url2.hostname;
            break;
          case "file:":
            local = true;
            break;
          case void 0:
          case "":
            host = "localhost";
            break;
          default:
            throw new Error("Protocol not supported.");
        }
        if (local) {
          if (settings.method !== "GET") {
            throw new Error("XMLHttpRequest: Only GET method is supported");
          }
          if (settings.async) {
            fs.readFile(unescape(url2.pathname), function(error, data2) {
              if (error) {
                self2.handleError(error, error.errno || -1);
              } else {
                self2.status = 200;
                self2.responseText = data2.toString("utf8");
                self2.response = data2;
                setState(self2.DONE);
              }
            });
          } else {
            try {
              this.response = fs.readFileSync(unescape(url2.pathname));
              this.responseText = this.response.toString("utf8");
              this.status = 200;
              setState(self2.DONE);
            } catch (e) {
              this.handleError(e, e.errno || -1);
            }
          }
          return;
        }
        var port = url2.port || (ssl ? 443 : 80);
        var uri = url2.pathname + (url2.search ? url2.search : "");
        headers["Host"] = host;
        if (!(ssl && port === 443 || port === 80)) {
          headers["Host"] += ":" + url2.port;
        }
        if (settings.user) {
          if (typeof settings.password == "undefined") {
            settings.password = "";
          }
          var authBuf = new Buffer(settings.user + ":" + settings.password);
          headers["Authorization"] = "Basic " + authBuf.toString("base64");
        }
        if (settings.method === "GET" || settings.method === "HEAD") {
          data = null;
        } else if (data) {
          headers["Content-Length"] = Buffer.isBuffer(data) ? data.length : Buffer.byteLength(data);
          var headersKeys = Object.keys(headers);
          if (!headersKeys.some(function(h) {
            return h.toLowerCase() === "content-type";
          })) {
            headers["Content-Type"] = "text/plain;charset=UTF-8";
          }
        } else if (settings.method === "POST") {
          headers["Content-Length"] = 0;
        }
        var agent = opts.agent || false;
        var options = {
          host,
          port,
          path: uri,
          method: settings.method,
          headers,
          agent
        };
        if (ssl) {
          options.pfx = opts.pfx;
          options.key = opts.key;
          options.passphrase = opts.passphrase;
          options.cert = opts.cert;
          options.ca = opts.ca;
          options.ciphers = opts.ciphers;
          options.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;
        }
        errorFlag = false;
        if (settings.async) {
          var doRequest = ssl ? https.request : http.request;
          sendFlag = true;
          self2.dispatchEvent("readystatechange");
          var responseHandler = /* @__PURE__ */ __name(function(resp2) {
            response = resp2;
            if (response.statusCode === 302 || response.statusCode === 303 || response.statusCode === 307) {
              settings.url = response.headers.location;
              var url3 = Url.parse(settings.url);
              host = url3.hostname;
              var newOptions = {
                hostname: url3.hostname,
                port: url3.port,
                path: url3.path,
                method: response.statusCode === 303 ? "GET" : settings.method,
                headers
              };
              if (ssl) {
                newOptions.pfx = opts.pfx;
                newOptions.key = opts.key;
                newOptions.passphrase = opts.passphrase;
                newOptions.cert = opts.cert;
                newOptions.ca = opts.ca;
                newOptions.ciphers = opts.ciphers;
                newOptions.rejectUnauthorized = opts.rejectUnauthorized === false ? false : true;
              }
              request = doRequest(newOptions, responseHandler).on("error", errorHandler);
              request.end();
              return;
            }
            setState(self2.HEADERS_RECEIVED);
            self2.status = response.statusCode;
            response.on("data", function(chunk) {
              if (chunk) {
                var data2 = Buffer.from(chunk);
                self2.response = Buffer.concat([
                  self2.response,
                  data2
                ]);
              }
              if (sendFlag) {
                setState(self2.LOADING);
              }
            });
            response.on("end", function() {
              if (sendFlag) {
                sendFlag = false;
                setState(self2.DONE);
                self2.responseText = self2.response.toString("utf8");
              }
            });
            response.on("error", function(error) {
              self2.handleError(error);
            });
          }, "responseHandler");
          var errorHandler = /* @__PURE__ */ __name(function(error) {
            if (request.reusedSocket && error.code === "ECONNRESET") return doRequest(options, responseHandler).on("error", errorHandler);
            self2.handleError(error);
          }, "errorHandler");
          request = doRequest(options, responseHandler).on("error", errorHandler);
          if (opts.autoUnref) {
            request.on("socket", (socket) => {
              socket.unref();
            });
          }
          if (data) {
            request.write(data);
          }
          request.end();
          self2.dispatchEvent("loadstart");
        } else {
          var contentFile = ".node-xmlhttprequest-content-" + process.pid;
          var syncFile = ".node-xmlhttprequest-sync-" + process.pid;
          fs.writeFileSync(syncFile, "", "utf8");
          var execString = "var http = require('http'), https = require('https'), fs = require('fs');var doRequest = http" + (ssl ? "s" : "") + ".request;var options = " + JSON.stringify(options) + ";var responseText = '';var responseData = Buffer.alloc(0);var req = doRequest(options, function(response) {response.on('data', function(chunk) {  var data = Buffer.from(chunk);  responseText += data.toString('utf8');  responseData = Buffer.concat([responseData, data]);});response.on('end', function() {fs.writeFileSync('" + contentFile + "', JSON.stringify({err: null, data: {statusCode: response.statusCode, headers: response.headers, text: responseText, data: responseData.toString('base64')}}), 'utf8');fs.unlinkSync('" + syncFile + "');});response.on('error', function(error) {fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');fs.unlinkSync('" + syncFile + "');});}).on('error', function(error) {fs.writeFileSync('" + contentFile + "', 'NODE-XMLHTTPREQUEST-ERROR:' + JSON.stringify(error), 'utf8');fs.unlinkSync('" + syncFile + "');});" + (data ? "req.write('" + JSON.stringify(data).slice(1, -1).replace(/'/g, "\\'") + "');" : "") + "req.end();";
          var syncProc = spawn(process.argv[0], [
            "-e",
            execString
          ]);
          var statusText;
          while (fs.existsSync(syncFile)) {
          }
          self2.responseText = fs.readFileSync(contentFile, "utf8");
          syncProc.stdin.end();
          fs.unlinkSync(contentFile);
          if (self2.responseText.match(/^NODE-XMLHTTPREQUEST-ERROR:/)) {
            var errorObj = JSON.parse(self2.responseText.replace(/^NODE-XMLHTTPREQUEST-ERROR:/, ""));
            self2.handleError(errorObj, 503);
          } else {
            self2.status = self2.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:([0-9]*),.*/, "$1");
            var resp = JSON.parse(self2.responseText.replace(/^NODE-XMLHTTPREQUEST-STATUS:[0-9]*,(.*)/, "$1"));
            response = {
              statusCode: self2.status,
              headers: resp.data.headers
            };
            self2.responseText = resp.data.text;
            self2.response = Buffer.from(resp.data.data, "base64");
            setState(self2.DONE, true);
          }
        }
      };
      this.handleError = function(error, status) {
        this.status = status || 0;
        this.statusText = error;
        this.responseText = error.stack;
        errorFlag = true;
        setState(this.DONE);
      };
      this.abort = function() {
        if (request) {
          request.abort();
          request = null;
        }
        headers = Object.assign({}, defaultHeaders);
        this.responseText = "";
        this.responseXML = "";
        this.response = Buffer.alloc(0);
        errorFlag = abortedFlag = true;
        if (this.readyState !== this.UNSENT && (this.readyState !== this.OPENED || sendFlag) && this.readyState !== this.DONE) {
          sendFlag = false;
          setState(this.DONE);
        }
        this.readyState = this.UNSENT;
      };
      this.addEventListener = function(event, callback) {
        if (!(event in listeners)) {
          listeners[event] = [];
        }
        listeners[event].push(callback);
      };
      this.removeEventListener = function(event, callback) {
        if (event in listeners) {
          listeners[event] = listeners[event].filter(function(ev) {
            return ev !== callback;
          });
        }
      };
      this.dispatchEvent = function(event) {
        if (typeof self2["on" + event] === "function") {
          if (this.readyState === this.DONE && settings.async) setTimeout(function() {
            self2["on" + event]();
          }, 0);
          else self2["on" + event]();
        }
        if (event in listeners) {
          for (let i = 0, len = listeners[event].length; i < len; i++) {
            if (this.readyState === this.DONE) setTimeout(function() {
              listeners[event][i].call(self2);
            }, 0);
            else listeners[event][i].call(self2);
          }
        }
      };
      var setState = /* @__PURE__ */ __name(function(state) {
        if (self2.readyState === state || self2.readyState === self2.UNSENT && abortedFlag) return;
        self2.readyState = state;
        if (settings.async || self2.readyState < self2.OPENED || self2.readyState === self2.DONE) {
          self2.dispatchEvent("readystatechange");
        }
        if (self2.readyState === self2.DONE) {
          let fire;
          if (abortedFlag) fire = "abort";
          else if (errorFlag) fire = "error";
          else fire = "load";
          self2.dispatchEvent(fire);
          self2.dispatchEvent("loadend");
        }
      }, "setState");
    }
    __name(XMLHttpRequest3, "XMLHttpRequest");
  }
});

// node_modules/engine.io-parser/build/esm/commons.js
var PACKET_TYPES, PACKET_TYPES_REVERSE, ERROR_PACKET;
var init_commons = __esm({
  "node_modules/engine.io-parser/build/esm/commons.js"() {
    "use strict";
    PACKET_TYPES = /* @__PURE__ */ Object.create(null);
    PACKET_TYPES["open"] = "0";
    PACKET_TYPES["close"] = "1";
    PACKET_TYPES["ping"] = "2";
    PACKET_TYPES["pong"] = "3";
    PACKET_TYPES["message"] = "4";
    PACKET_TYPES["upgrade"] = "5";
    PACKET_TYPES["noop"] = "6";
    PACKET_TYPES_REVERSE = /* @__PURE__ */ Object.create(null);
    Object.keys(PACKET_TYPES).forEach((key) => {
      PACKET_TYPES_REVERSE[PACKET_TYPES[key]] = key;
    });
    ERROR_PACKET = {
      type: "error",
      data: "parser error"
    };
  }
});

// node_modules/engine.io-parser/build/esm/encodePacket.js
function encodePacketToBinary(packet, callback) {
  if (packet.data instanceof ArrayBuffer || ArrayBuffer.isView(packet.data)) {
    return callback(toBuffer(packet.data, false));
  }
  encodePacket(packet, true, (encoded) => {
    if (!TEXT_ENCODER) {
      TEXT_ENCODER = new TextEncoder();
    }
    callback(TEXT_ENCODER.encode(encoded));
  });
}
var encodePacket, toBuffer, TEXT_ENCODER;
var init_encodePacket = __esm({
  "node_modules/engine.io-parser/build/esm/encodePacket.js"() {
    "use strict";
    init_commons();
    encodePacket = /* @__PURE__ */ __name(({ type, data }, supportsBinary, callback) => {
      if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {
        return callback(supportsBinary ? data : "b" + toBuffer(data, true).toString("base64"));
      }
      return callback(PACKET_TYPES[type] + (data || ""));
    }, "encodePacket");
    toBuffer = /* @__PURE__ */ __name((data, forceBufferConversion) => {
      if (Buffer.isBuffer(data) || data instanceof Uint8Array && !forceBufferConversion) {
        return data;
      } else if (data instanceof ArrayBuffer) {
        return Buffer.from(data);
      } else {
        return Buffer.from(data.buffer, data.byteOffset, data.byteLength);
      }
    }, "toBuffer");
    __name(encodePacketToBinary, "encodePacketToBinary");
  }
});

// node_modules/engine.io-parser/build/esm/decodePacket.js
var decodePacket, mapBinary;
var init_decodePacket = __esm({
  "node_modules/engine.io-parser/build/esm/decodePacket.js"() {
    "use strict";
    init_commons();
    decodePacket = /* @__PURE__ */ __name((encodedPacket, binaryType) => {
      if (typeof encodedPacket !== "string") {
        return {
          type: "message",
          data: mapBinary(encodedPacket, binaryType)
        };
      }
      const type = encodedPacket.charAt(0);
      if (type === "b") {
        const buffer = Buffer.from(encodedPacket.substring(1), "base64");
        return {
          type: "message",
          data: mapBinary(buffer, binaryType)
        };
      }
      if (!PACKET_TYPES_REVERSE[type]) {
        return ERROR_PACKET;
      }
      return encodedPacket.length > 1 ? {
        type: PACKET_TYPES_REVERSE[type],
        data: encodedPacket.substring(1)
      } : {
        type: PACKET_TYPES_REVERSE[type]
      };
    }, "decodePacket");
    mapBinary = /* @__PURE__ */ __name((data, binaryType) => {
      switch (binaryType) {
        case "arraybuffer":
          if (data instanceof ArrayBuffer) {
            return data;
          } else if (Buffer.isBuffer(data)) {
            return data.buffer.slice(data.byteOffset, data.byteOffset + data.byteLength);
          } else {
            return data.buffer;
          }
        case "nodebuffer":
        default:
          if (Buffer.isBuffer(data)) {
            return data;
          } else {
            return Buffer.from(data);
          }
      }
    }, "mapBinary");
  }
});

// node_modules/engine.io-parser/build/esm/index.js
function createPacketEncoderStream() {
  return new TransformStream({
    transform(packet, controller) {
      encodePacketToBinary(packet, (encodedPacket) => {
        const payloadLength = encodedPacket.length;
        let header;
        if (payloadLength < 126) {
          header = new Uint8Array(1);
          new DataView(header.buffer).setUint8(0, payloadLength);
        } else if (payloadLength < 65536) {
          header = new Uint8Array(3);
          const view = new DataView(header.buffer);
          view.setUint8(0, 126);
          view.setUint16(1, payloadLength);
        } else {
          header = new Uint8Array(9);
          const view = new DataView(header.buffer);
          view.setUint8(0, 127);
          view.setBigUint64(1, BigInt(payloadLength));
        }
        if (packet.data && typeof packet.data !== "string") {
          header[0] |= 128;
        }
        controller.enqueue(header);
        controller.enqueue(encodedPacket);
      });
    }
  });
}
function totalLength(chunks) {
  return chunks.reduce((acc, chunk) => acc + chunk.length, 0);
}
function concatChunks(chunks, size) {
  if (chunks[0].length === size) {
    return chunks.shift();
  }
  const buffer = new Uint8Array(size);
  let j = 0;
  for (let i = 0; i < size; i++) {
    buffer[i] = chunks[0][j++];
    if (j === chunks[0].length) {
      chunks.shift();
      j = 0;
    }
  }
  if (chunks.length && j < chunks[0].length) {
    chunks[0] = chunks[0].slice(j);
  }
  return buffer;
}
function createPacketDecoderStream(maxPayload, binaryType) {
  if (!TEXT_DECODER) {
    TEXT_DECODER = new TextDecoder();
  }
  const chunks = [];
  let state = 0;
  let expectedLength = -1;
  let isBinary2 = false;
  return new TransformStream({
    transform(chunk, controller) {
      chunks.push(chunk);
      while (true) {
        if (state === 0) {
          if (totalLength(chunks) < 1) {
            break;
          }
          const header = concatChunks(chunks, 1);
          isBinary2 = (header[0] & 128) === 128;
          expectedLength = header[0] & 127;
          if (expectedLength < 126) {
            state = 3;
          } else if (expectedLength === 126) {
            state = 1;
          } else {
            state = 2;
          }
        } else if (state === 1) {
          if (totalLength(chunks) < 2) {
            break;
          }
          const headerArray = concatChunks(chunks, 2);
          expectedLength = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length).getUint16(0);
          state = 3;
        } else if (state === 2) {
          if (totalLength(chunks) < 8) {
            break;
          }
          const headerArray = concatChunks(chunks, 8);
          const view = new DataView(headerArray.buffer, headerArray.byteOffset, headerArray.length);
          const n = view.getUint32(0);
          if (n > Math.pow(2, 53 - 32) - 1) {
            controller.enqueue(ERROR_PACKET);
            break;
          }
          expectedLength = n * Math.pow(2, 32) + view.getUint32(4);
          state = 3;
        } else {
          if (totalLength(chunks) < expectedLength) {
            break;
          }
          const data = concatChunks(chunks, expectedLength);
          controller.enqueue(decodePacket(isBinary2 ? data : TEXT_DECODER.decode(data), binaryType));
          state = 0;
        }
        if (expectedLength === 0 || expectedLength > maxPayload) {
          controller.enqueue(ERROR_PACKET);
          break;
        }
      }
    }
  });
}
var SEPARATOR, encodePayload, decodePayload, TEXT_DECODER, protocol;
var init_esm2 = __esm({
  "node_modules/engine.io-parser/build/esm/index.js"() {
    "use strict";
    init_encodePacket();
    init_decodePacket();
    init_commons();
    SEPARATOR = String.fromCharCode(30);
    encodePayload = /* @__PURE__ */ __name((packets, callback) => {
      const length = packets.length;
      const encodedPackets = new Array(length);
      let count = 0;
      packets.forEach((packet, i) => {
        encodePacket(packet, false, (encodedPacket) => {
          encodedPackets[i] = encodedPacket;
          if (++count === length) {
            callback(encodedPackets.join(SEPARATOR));
          }
        });
      });
    }, "encodePayload");
    decodePayload = /* @__PURE__ */ __name((encodedPayload, binaryType) => {
      const encodedPackets = encodedPayload.split(SEPARATOR);
      const packets = [];
      for (let i = 0; i < encodedPackets.length; i++) {
        const decodedPacket = decodePacket(encodedPackets[i], binaryType);
        packets.push(decodedPacket);
        if (decodedPacket.type === "error") {
          break;
        }
      }
      return packets;
    }, "decodePayload");
    __name(createPacketEncoderStream, "createPacketEncoderStream");
    __name(totalLength, "totalLength");
    __name(concatChunks, "concatChunks");
    __name(createPacketDecoderStream, "createPacketDecoderStream");
    protocol = 4;
  }
});

// node_modules/@socket.io/component-emitter/lib/esm/index.js
function Emitter(obj) {
  if (obj) return mixin3(obj);
}
function mixin3(obj) {
  for (var key in Emitter.prototype) {
    obj[key] = Emitter.prototype[key];
  }
  return obj;
}
var init_esm3 = __esm({
  "node_modules/@socket.io/component-emitter/lib/esm/index.js"() {
    "use strict";
    __name(Emitter, "Emitter");
    __name(mixin3, "mixin");
    Emitter.prototype.on = Emitter.prototype.addEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      (this._callbacks["$" + event] = this._callbacks["$" + event] || []).push(fn);
      return this;
    };
    Emitter.prototype.once = function(event, fn) {
      function on2() {
        this.off(event, on2);
        fn.apply(this, arguments);
      }
      __name(on2, "on");
      on2.fn = fn;
      this.on(event, on2);
      return this;
    };
    Emitter.prototype.off = Emitter.prototype.removeListener = Emitter.prototype.removeAllListeners = Emitter.prototype.removeEventListener = function(event, fn) {
      this._callbacks = this._callbacks || {};
      if (0 == arguments.length) {
        this._callbacks = {};
        return this;
      }
      var callbacks = this._callbacks["$" + event];
      if (!callbacks) return this;
      if (1 == arguments.length) {
        delete this._callbacks["$" + event];
        return this;
      }
      var cb;
      for (var i = 0; i < callbacks.length; i++) {
        cb = callbacks[i];
        if (cb === fn || cb.fn === fn) {
          callbacks.splice(i, 1);
          break;
        }
      }
      if (callbacks.length === 0) {
        delete this._callbacks["$" + event];
      }
      return this;
    };
    Emitter.prototype.emit = function(event) {
      this._callbacks = this._callbacks || {};
      var args = new Array(arguments.length - 1), callbacks = this._callbacks["$" + event];
      for (var i = 1; i < arguments.length; i++) {
        args[i - 1] = arguments[i];
      }
      if (callbacks) {
        callbacks = callbacks.slice(0);
        for (var i = 0, len = callbacks.length; i < len; ++i) {
          callbacks[i].apply(this, args);
        }
      }
      return this;
    };
    Emitter.prototype.emitReserved = Emitter.prototype.emit;
    Emitter.prototype.listeners = function(event) {
      this._callbacks = this._callbacks || {};
      return this._callbacks["$" + event] || [];
    };
    Emitter.prototype.hasListeners = function(event) {
      return !!this.listeners(event).length;
    };
  }
});

// node_modules/engine.io-client/build/esm-debug/globals.node.js
function createCookieJar() {
  return new CookieJar();
}
function parse2(setCookieString) {
  const parts2 = setCookieString.split("; ");
  const i = parts2[0].indexOf("=");
  if (i === -1) {
    return;
  }
  const name = parts2[0].substring(0, i).trim();
  if (!name.length) {
    return;
  }
  let value2 = parts2[0].substring(i + 1).trim();
  if (value2.charCodeAt(0) === 34) {
    value2 = value2.slice(1, -1);
  }
  const cookie = {
    name,
    value: value2
  };
  for (let j = 1; j < parts2.length; j++) {
    const subParts = parts2[j].split("=");
    if (subParts.length !== 2) {
      continue;
    }
    const key = subParts[0].trim();
    const value3 = subParts[1].trim();
    switch (key) {
      case "Expires":
        cookie.expires = new Date(value3);
        break;
      case "Max-Age":
        const expiration = /* @__PURE__ */ new Date();
        expiration.setUTCSeconds(expiration.getUTCSeconds() + parseInt(value3, 10));
        cookie.expires = expiration;
        break;
      default:
    }
  }
  return cookie;
}
var nextTick, globalThisShim, defaultBinaryType, CookieJar;
var init_globals_node = __esm({
  "node_modules/engine.io-client/build/esm-debug/globals.node.js"() {
    "use strict";
    nextTick = process.nextTick;
    globalThisShim = global;
    defaultBinaryType = "nodebuffer";
    __name(createCookieJar, "createCookieJar");
    __name(parse2, "parse");
    CookieJar = class {
      static {
        __name(this, "CookieJar");
      }
      constructor() {
        this._cookies = /* @__PURE__ */ new Map();
      }
      parseCookies(values) {
        if (!values) {
          return;
        }
        values.forEach((value2) => {
          const parsed = parse2(value2);
          if (parsed) {
            this._cookies.set(parsed.name, parsed);
          }
        });
      }
      get cookies() {
        const now = Date.now();
        this._cookies.forEach((cookie, name) => {
          var _a2;
          if (((_a2 = cookie.expires) === null || _a2 === void 0 ? void 0 : _a2.getTime()) < now) {
            this._cookies.delete(name);
          }
        });
        return this._cookies.entries();
      }
      addCookies(xhr) {
        const cookies = [];
        for (const [name, cookie] of this.cookies) {
          cookies.push(`${name}=${cookie.value}`);
        }
        if (cookies.length) {
          xhr.setDisableHeaderCheck(true);
          xhr.setRequestHeader("cookie", cookies.join("; "));
        }
      }
      appendCookies(headers) {
        for (const [name, cookie] of this.cookies) {
          headers.append("cookie", `${name}=${cookie.value}`);
        }
      }
    };
  }
});

// node_modules/engine.io-client/build/esm-debug/util.js
function pick(obj, ...attr) {
  return attr.reduce((acc, k) => {
    if (obj.hasOwnProperty(k)) {
      acc[k] = obj[k];
    }
    return acc;
  }, {});
}
function installTimerFunctions(obj, opts) {
  if (opts.useNativeTimers) {
    obj.setTimeoutFn = NATIVE_SET_TIMEOUT.bind(globalThisShim);
    obj.clearTimeoutFn = NATIVE_CLEAR_TIMEOUT.bind(globalThisShim);
  } else {
    obj.setTimeoutFn = globalThisShim.setTimeout.bind(globalThisShim);
    obj.clearTimeoutFn = globalThisShim.clearTimeout.bind(globalThisShim);
  }
}
function byteLength(obj) {
  if (typeof obj === "string") {
    return utf8Length(obj);
  }
  return Math.ceil((obj.byteLength || obj.size) * BASE64_OVERHEAD);
}
function utf8Length(str) {
  let c = 0, length = 0;
  for (let i = 0, l = str.length; i < l; i++) {
    c = str.charCodeAt(i);
    if (c < 128) {
      length += 1;
    } else if (c < 2048) {
      length += 2;
    } else if (c < 55296 || c >= 57344) {
      length += 3;
    } else {
      i++;
      length += 4;
    }
  }
  return length;
}
function randomString() {
  return Date.now().toString(36).substring(3) + Math.random().toString(36).substring(2, 5);
}
var NATIVE_SET_TIMEOUT, NATIVE_CLEAR_TIMEOUT, BASE64_OVERHEAD;
var init_util = __esm({
  "node_modules/engine.io-client/build/esm-debug/util.js"() {
    "use strict";
    init_globals_node();
    __name(pick, "pick");
    NATIVE_SET_TIMEOUT = globalThisShim.setTimeout;
    NATIVE_CLEAR_TIMEOUT = globalThisShim.clearTimeout;
    __name(installTimerFunctions, "installTimerFunctions");
    BASE64_OVERHEAD = 1.33;
    __name(byteLength, "byteLength");
    __name(utf8Length, "utf8Length");
    __name(randomString, "randomString");
  }
});

// node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js
function encode(obj) {
  let str = "";
  for (let i in obj) {
    if (obj.hasOwnProperty(i)) {
      if (str.length) str += "&";
      str += encodeURIComponent(i) + "=" + encodeURIComponent(obj[i]);
    }
  }
  return str;
}
function decode(qs) {
  let qry = {};
  let pairs = qs.split("&");
  for (let i = 0, l = pairs.length; i < l; i++) {
    let pair = pairs[i].split("=");
    qry[decodeURIComponent(pair[0])] = decodeURIComponent(pair[1]);
  }
  return qry;
}
var init_parseqs = __esm({
  "node_modules/engine.io-client/build/esm-debug/contrib/parseqs.js"() {
    "use strict";
    __name(encode, "encode");
    __name(decode, "decode");
  }
});

// node_modules/engine.io-client/node_modules/debug/src/common.js
var require_common2 = __commonJS({
  "node_modules/engine.io-client/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug12(...args) {
          if (!debug12.enabled) {
            return;
          }
          const self2 = debug12;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format5) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format5];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        __name(debug12, "debug");
        debug12.namespace = namespace;
        debug12.useColors = createDebug.useColors();
        debug12.color = createDebug.selectColor(namespace);
        debug12.extend = extend;
        debug12.destroy = createDebug.destroy;
        Object.defineProperty(debug12, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug12);
        }
        return debug12;
      }
      __name(createDebug, "createDebug");
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      __name(enable, "enable");
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      __name(toNamespace, "toNamespace");
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce2, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module2.exports = setup;
  }
});

// node_modules/engine.io-client/node_modules/debug/src/browser.js
var require_browser = __commonJS({
  "node_modules/engine.io-client/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage, "localstorage");
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/has-flag/index.js
var require_has_flag2 = __commonJS({
  "node_modules/has-flag/index.js"(exports2, module2) {
    "use strict";
    module2.exports = (flag, argv2 = process.argv) => {
      const prefix = flag.startsWith("-") ? "" : flag.length === 1 ? "-" : "--";
      const position = argv2.indexOf(prefix + flag);
      const terminatorPosition = argv2.indexOf("--");
      return position !== -1 && (terminatorPosition === -1 || position < terminatorPosition);
    };
  }
});

// node_modules/supports-color/index.js
var require_supports_color = __commonJS({
  "node_modules/supports-color/index.js"(exports2, module2) {
    "use strict";
    var os = require("os");
    var tty = require("tty");
    var hasFlag = require_has_flag2();
    var { env: env2 } = process;
    var forceColor;
    if (hasFlag("no-color") || hasFlag("no-colors") || hasFlag("color=false") || hasFlag("color=never")) {
      forceColor = 0;
    } else if (hasFlag("color") || hasFlag("colors") || hasFlag("color=true") || hasFlag("color=always")) {
      forceColor = 1;
    }
    if ("FORCE_COLOR" in env2) {
      if (env2.FORCE_COLOR === "true") {
        forceColor = 1;
      } else if (env2.FORCE_COLOR === "false") {
        forceColor = 0;
      } else {
        forceColor = env2.FORCE_COLOR.length === 0 ? 1 : Math.min(parseInt(env2.FORCE_COLOR, 10), 3);
      }
    }
    function translateLevel(level) {
      if (level === 0) {
        return false;
      }
      return {
        level,
        hasBasic: true,
        has256: level >= 2,
        has16m: level >= 3
      };
    }
    __name(translateLevel, "translateLevel");
    function supportsColor(haveStream, streamIsTTY) {
      if (forceColor === 0) {
        return 0;
      }
      if (hasFlag("color=16m") || hasFlag("color=full") || hasFlag("color=truecolor")) {
        return 3;
      }
      if (hasFlag("color=256")) {
        return 2;
      }
      if (haveStream && !streamIsTTY && forceColor === void 0) {
        return 0;
      }
      const min = forceColor || 0;
      if (env2.TERM === "dumb") {
        return min;
      }
      if (process.platform === "win32") {
        const osRelease = os.release().split(".");
        if (Number(osRelease[0]) >= 10 && Number(osRelease[2]) >= 10586) {
          return Number(osRelease[2]) >= 14931 ? 3 : 2;
        }
        return 1;
      }
      if ("CI" in env2) {
        if ([
          "TRAVIS",
          "CIRCLECI",
          "APPVEYOR",
          "GITLAB_CI",
          "GITHUB_ACTIONS",
          "BUILDKITE"
        ].some((sign) => sign in env2) || env2.CI_NAME === "codeship") {
          return 1;
        }
        return min;
      }
      if ("TEAMCITY_VERSION" in env2) {
        return /^(9\.(0*[1-9]\d*)\.|\d{2,}\.)/.test(env2.TEAMCITY_VERSION) ? 1 : 0;
      }
      if (env2.COLORTERM === "truecolor") {
        return 3;
      }
      if ("TERM_PROGRAM" in env2) {
        const version2 = parseInt((env2.TERM_PROGRAM_VERSION || "").split(".")[0], 10);
        switch (env2.TERM_PROGRAM) {
          case "iTerm.app":
            return version2 >= 3 ? 3 : 2;
          case "Apple_Terminal":
            return 2;
        }
      }
      if (/-256(color)?$/i.test(env2.TERM)) {
        return 2;
      }
      if (/^screen|^xterm|^vt100|^vt220|^rxvt|color|ansi|cygwin|linux/i.test(env2.TERM)) {
        return 1;
      }
      if ("COLORTERM" in env2) {
        return 1;
      }
      return min;
    }
    __name(supportsColor, "supportsColor");
    function getSupportLevel(stream) {
      const level = supportsColor(stream, stream && stream.isTTY);
      return translateLevel(level);
    }
    __name(getSupportLevel, "getSupportLevel");
    module2.exports = {
      supportsColor: getSupportLevel,
      stdout: translateLevel(supportsColor(true, tty.isatty(1))),
      stderr: translateLevel(supportsColor(true, tty.isatty(2)))
    };
  }
});

// node_modules/engine.io-client/node_modules/debug/src/node.js
var require_node3 = __commonJS({
  "node_modules/engine.io-client/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [
      6,
      2,
      3,
      4,
      5,
      1
    ];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    __name(log, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init(debug12) {
      debug12.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug12.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    __name(init, "init");
    module2.exports = require_common2()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/engine.io-client/node_modules/debug/src/index.js
var require_src = __commonJS({
  "node_modules/engine.io-client/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser();
    } else {
      module2.exports = require_node3();
    }
  }
});

// node_modules/engine.io-client/build/esm-debug/transport.js
var import_debug, debug, TransportError, Transport;
var init_transport = __esm({
  "node_modules/engine.io-client/build/esm-debug/transport.js"() {
    "use strict";
    init_esm2();
    init_esm3();
    init_util();
    init_parseqs();
    import_debug = __toESM(require_src(), 1);
    debug = (0, import_debug.default)("engine.io-client:transport");
    TransportError = class extends Error {
      static {
        __name(this, "TransportError");
      }
      constructor(reason, description, context) {
        super(reason);
        this.description = description;
        this.context = context;
        this.type = "TransportError";
      }
    };
    Transport = class extends Emitter {
      static {
        __name(this, "Transport");
      }
      /**
       * Transport abstract constructor.
       *
       * @param {Object} opts - options
       * @protected
       */
      constructor(opts) {
        super();
        this.writable = false;
        installTimerFunctions(this, opts);
        this.opts = opts;
        this.query = opts.query;
        this.socket = opts.socket;
        this.supportsBinary = !opts.forceBase64;
      }
      /**
       * Emits an error.
       *
       * @param {String} reason
       * @param description
       * @param context - the error context
       * @return {Transport} for chaining
       * @protected
       */
      onError(reason, description, context) {
        super.emitReserved("error", new TransportError(reason, description, context));
        return this;
      }
      /**
       * Opens the transport.
       */
      open() {
        this.readyState = "opening";
        this.doOpen();
        return this;
      }
      /**
       * Closes the transport.
       */
      close() {
        if (this.readyState === "opening" || this.readyState === "open") {
          this.doClose();
          this.onClose();
        }
        return this;
      }
      /**
       * Sends multiple packets.
       *
       * @param {Array} packets
       */
      send(packets) {
        if (this.readyState === "open") {
          this.write(packets);
        } else {
          debug("transport is not open, discarding packets");
        }
      }
      /**
       * Called upon open
       *
       * @protected
       */
      onOpen() {
        this.readyState = "open";
        this.writable = true;
        super.emitReserved("open");
      }
      /**
       * Called with data.
       *
       * @param {String} data
       * @protected
       */
      onData(data) {
        const packet = decodePacket(data, this.socket.binaryType);
        this.onPacket(packet);
      }
      /**
       * Called with a decoded packet.
       *
       * @protected
       */
      onPacket(packet) {
        super.emitReserved("packet", packet);
      }
      /**
       * Called upon close.
       *
       * @protected
       */
      onClose(details) {
        this.readyState = "closed";
        super.emitReserved("close", details);
      }
      /**
       * Pauses the transport, in order not to lose packets during an upgrade.
       *
       * @param onPause
       */
      pause(onPause) {
      }
      createUri(schema, query = {}) {
        return schema + "://" + this._hostname() + this._port() + this.opts.path + this._query(query);
      }
      _hostname() {
        const hostname = this.opts.hostname;
        return hostname.indexOf(":") === -1 ? hostname : "[" + hostname + "]";
      }
      _port() {
        if (this.opts.port && (this.opts.secure && Number(this.opts.port !== 443) || !this.opts.secure && Number(this.opts.port) !== 80)) {
          return ":" + this.opts.port;
        } else {
          return "";
        }
      }
      _query(query) {
        const encodedQuery = encode(query);
        return encodedQuery.length ? "?" + encodedQuery : "";
      }
    };
  }
});

// node_modules/engine.io-client/build/esm-debug/transports/polling.js
var import_debug2, debug2, Polling;
var init_polling = __esm({
  "node_modules/engine.io-client/build/esm-debug/transports/polling.js"() {
    "use strict";
    init_transport();
    init_util();
    init_esm2();
    import_debug2 = __toESM(require_src(), 1);
    debug2 = (0, import_debug2.default)("engine.io-client:polling");
    Polling = class extends Transport {
      static {
        __name(this, "Polling");
      }
      constructor() {
        super(...arguments);
        this._polling = false;
      }
      get name() {
        return "polling";
      }
      /**
       * Opens the socket (triggers polling). We write a PING message to determine
       * when the transport is open.
       *
       * @protected
       */
      doOpen() {
        this._poll();
      }
      /**
       * Pauses polling.
       *
       * @param {Function} onPause - callback upon buffers are flushed and transport is paused
       * @package
       */
      pause(onPause) {
        this.readyState = "pausing";
        const pause = /* @__PURE__ */ __name(() => {
          debug2("paused");
          this.readyState = "paused";
          onPause();
        }, "pause");
        if (this._polling || !this.writable) {
          let total = 0;
          if (this._polling) {
            debug2("we are currently polling - waiting to pause");
            total++;
            this.once("pollComplete", function() {
              debug2("pre-pause polling complete");
              --total || pause();
            });
          }
          if (!this.writable) {
            debug2("we are currently writing - waiting to pause");
            total++;
            this.once("drain", function() {
              debug2("pre-pause writing complete");
              --total || pause();
            });
          }
        } else {
          pause();
        }
      }
      /**
       * Starts polling cycle.
       *
       * @private
       */
      _poll() {
        debug2("polling");
        this._polling = true;
        this.doPoll();
        this.emitReserved("poll");
      }
      /**
       * Overloads onData to detect payloads.
       *
       * @protected
       */
      onData(data) {
        debug2("polling got data %s", data);
        const callback = /* @__PURE__ */ __name((packet) => {
          if ("opening" === this.readyState && packet.type === "open") {
            this.onOpen();
          }
          if ("close" === packet.type) {
            this.onClose({
              description: "transport closed by the server"
            });
            return false;
          }
          this.onPacket(packet);
        }, "callback");
        decodePayload(data, this.socket.binaryType).forEach(callback);
        if ("closed" !== this.readyState) {
          this._polling = false;
          this.emitReserved("pollComplete");
          if ("open" === this.readyState) {
            this._poll();
          } else {
            debug2('ignoring poll - transport state "%s"', this.readyState);
          }
        }
      }
      /**
       * For polling, send a close packet.
       *
       * @protected
       */
      doClose() {
        const close = /* @__PURE__ */ __name(() => {
          debug2("writing close packet");
          this.write([
            {
              type: "close"
            }
          ]);
        }, "close");
        if ("open" === this.readyState) {
          debug2("transport open - closing");
          close();
        } else {
          debug2("transport not open - deferring close");
          this.once("open", close);
        }
      }
      /**
       * Writes a packets payload.
       *
       * @param {Array} packets - data packets
       * @protected
       */
      write(packets) {
        this.writable = false;
        encodePayload(packets, (data) => {
          this.doWrite(data, () => {
            this.writable = true;
            this.emitReserved("drain");
          });
        });
      }
      /**
       * Generates uri for connection.
       *
       * @private
       */
      uri() {
        const schema = this.opts.secure ? "https" : "http";
        const query = this.query || {};
        if (false !== this.opts.timestampRequests) {
          query[this.opts.timestampParam] = randomString();
        }
        if (!this.supportsBinary && !query.sid) {
          query.b64 = 1;
        }
        return this.createUri(schema, query);
      }
    };
  }
});

// node_modules/engine.io-client/build/esm-debug/contrib/has-cors.js
var value, hasCORS;
var init_has_cors = __esm({
  "node_modules/engine.io-client/build/esm-debug/contrib/has-cors.js"() {
    "use strict";
    value = false;
    try {
      value = typeof XMLHttpRequest !== "undefined" && "withCredentials" in new XMLHttpRequest();
    } catch (err) {
    }
    hasCORS = value;
  }
});

// node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js
function empty() {
}
function unloadHandler() {
  for (let i in Request.requests) {
    if (Request.requests.hasOwnProperty(i)) {
      Request.requests[i].abort();
    }
  }
}
function newRequest(opts) {
  const xdomain = opts.xdomain;
  try {
    if ("undefined" !== typeof XMLHttpRequest && (!xdomain || hasCORS)) {
      return new XMLHttpRequest();
    }
  } catch (e) {
  }
  if (!xdomain) {
    try {
      return new globalThisShim[[
        "Active"
      ].concat("Object").join("X")]("Microsoft.XMLHTTP");
    } catch (e) {
    }
  }
}
var import_debug3, debug3, BaseXHR, Request, hasXHR2;
var init_polling_xhr = __esm({
  "node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.js"() {
    "use strict";
    init_polling();
    init_esm3();
    init_util();
    init_globals_node();
    init_has_cors();
    import_debug3 = __toESM(require_src(), 1);
    debug3 = (0, import_debug3.default)("engine.io-client:polling");
    __name(empty, "empty");
    BaseXHR = class extends Polling {
      static {
        __name(this, "BaseXHR");
      }
      /**
       * XHR Polling constructor.
       *
       * @param {Object} opts
       * @package
       */
      constructor(opts) {
        super(opts);
        if (typeof location !== "undefined") {
          const isSSL = "https:" === location.protocol;
          let port = location.port;
          if (!port) {
            port = isSSL ? "443" : "80";
          }
          this.xd = typeof location !== "undefined" && opts.hostname !== location.hostname || port !== opts.port;
        }
      }
      /**
       * Sends data.
       *
       * @param {String} data to send.
       * @param {Function} called upon flush.
       * @private
       */
      doWrite(data, fn) {
        const req = this.request({
          method: "POST",
          data
        });
        req.on("success", fn);
        req.on("error", (xhrStatus, context) => {
          this.onError("xhr post error", xhrStatus, context);
        });
      }
      /**
       * Starts a poll cycle.
       *
       * @private
       */
      doPoll() {
        debug3("xhr poll");
        const req = this.request();
        req.on("data", this.onData.bind(this));
        req.on("error", (xhrStatus, context) => {
          this.onError("xhr poll error", xhrStatus, context);
        });
        this.pollXhr = req;
      }
    };
    Request = class _Request extends Emitter {
      static {
        __name(this, "Request");
      }
      /**
       * Request constructor
       *
       * @param {Object} options
       * @package
       */
      constructor(createRequest, uri, opts) {
        super();
        this.createRequest = createRequest;
        installTimerFunctions(this, opts);
        this._opts = opts;
        this._method = opts.method || "GET";
        this._uri = uri;
        this._data = void 0 !== opts.data ? opts.data : null;
        this._create();
      }
      /**
       * Creates the XHR object and sends the request.
       *
       * @private
       */
      _create() {
        var _a2;
        const opts = pick(this._opts, "agent", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "autoUnref");
        opts.xdomain = !!this._opts.xd;
        const xhr = this._xhr = this.createRequest(opts);
        try {
          debug3("xhr open %s: %s", this._method, this._uri);
          xhr.open(this._method, this._uri, true);
          try {
            if (this._opts.extraHeaders) {
              xhr.setDisableHeaderCheck && xhr.setDisableHeaderCheck(true);
              for (let i in this._opts.extraHeaders) {
                if (this._opts.extraHeaders.hasOwnProperty(i)) {
                  xhr.setRequestHeader(i, this._opts.extraHeaders[i]);
                }
              }
            }
          } catch (e) {
          }
          if ("POST" === this._method) {
            try {
              xhr.setRequestHeader("Content-type", "text/plain;charset=UTF-8");
            } catch (e) {
            }
          }
          try {
            xhr.setRequestHeader("Accept", "*/*");
          } catch (e) {
          }
          (_a2 = this._opts.cookieJar) === null || _a2 === void 0 ? void 0 : _a2.addCookies(xhr);
          if ("withCredentials" in xhr) {
            xhr.withCredentials = this._opts.withCredentials;
          }
          if (this._opts.requestTimeout) {
            xhr.timeout = this._opts.requestTimeout;
          }
          xhr.onreadystatechange = () => {
            var _a3;
            if (xhr.readyState === 3) {
              (_a3 = this._opts.cookieJar) === null || _a3 === void 0 ? void 0 : _a3.parseCookies(
                // @ts-ignore
                xhr.getResponseHeader("set-cookie")
              );
            }
            if (4 !== xhr.readyState) return;
            if (200 === xhr.status || 1223 === xhr.status) {
              this._onLoad();
            } else {
              this.setTimeoutFn(() => {
                this._onError(typeof xhr.status === "number" ? xhr.status : 0);
              }, 0);
            }
          };
          debug3("xhr data %s", this._data);
          xhr.send(this._data);
        } catch (e) {
          this.setTimeoutFn(() => {
            this._onError(e);
          }, 0);
          return;
        }
        if (typeof document !== "undefined") {
          this._index = _Request.requestsCount++;
          _Request.requests[this._index] = this;
        }
      }
      /**
       * Called upon error.
       *
       * @private
       */
      _onError(err) {
        this.emitReserved("error", err, this._xhr);
        this._cleanup(true);
      }
      /**
       * Cleans up house.
       *
       * @private
       */
      _cleanup(fromError) {
        if ("undefined" === typeof this._xhr || null === this._xhr) {
          return;
        }
        this._xhr.onreadystatechange = empty;
        if (fromError) {
          try {
            this._xhr.abort();
          } catch (e) {
          }
        }
        if (typeof document !== "undefined") {
          delete _Request.requests[this._index];
        }
        this._xhr = null;
      }
      /**
       * Called upon load.
       *
       * @private
       */
      _onLoad() {
        const data = this._xhr.responseText;
        if (data !== null) {
          this.emitReserved("data", data);
          this.emitReserved("success");
          this._cleanup();
        }
      }
      /**
       * Aborts the request.
       *
       * @package
       */
      abort() {
        this._cleanup();
      }
    };
    Request.requestsCount = 0;
    Request.requests = {};
    if (typeof document !== "undefined") {
      if (typeof attachEvent === "function") {
        attachEvent("onunload", unloadHandler);
      } else if (typeof addEventListener === "function") {
        const terminationEvent = "onpagehide" in globalThisShim ? "pagehide" : "unload";
        addEventListener(terminationEvent, unloadHandler, false);
      }
    }
    __name(unloadHandler, "unloadHandler");
    hasXHR2 = function() {
      const xhr = newRequest({
        xdomain: false
      });
      return xhr && xhr.responseType !== null;
    }();
    __name(newRequest, "newRequest");
  }
});

// node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js
var XMLHttpRequestModule, XMLHttpRequest2, XHR;
var init_polling_xhr_node = __esm({
  "node_modules/engine.io-client/build/esm-debug/transports/polling-xhr.node.js"() {
    "use strict";
    XMLHttpRequestModule = __toESM(require_XMLHttpRequest(), 1);
    init_polling_xhr();
    XMLHttpRequest2 = XMLHttpRequestModule.default || XMLHttpRequestModule;
    XHR = class extends BaseXHR {
      static {
        __name(this, "XHR");
      }
      request(opts = {}) {
        var _a2;
        Object.assign(opts, {
          xd: this.xd,
          cookieJar: (_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2._cookieJar
        }, this.opts);
        return new Request((opts2) => new XMLHttpRequest2(opts2), this.uri(), opts);
      }
    };
  }
});

// node_modules/ws/lib/stream.js
var require_stream3 = __commonJS({
  "node_modules/ws/lib/stream.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    function emitClose(stream) {
      stream.emit("close");
    }
    __name(emitClose, "emitClose");
    function duplexOnEnd() {
      if (!this.destroyed && this._writableState.finished) {
        this.destroy();
      }
    }
    __name(duplexOnEnd, "duplexOnEnd");
    function duplexOnError(err) {
      this.removeListener("error", duplexOnError);
      this.destroy();
      if (this.listenerCount("error") === 0) {
        this.emit("error", err);
      }
    }
    __name(duplexOnError, "duplexOnError");
    function createWebSocketStream2(ws, options) {
      let terminateOnDestroy = true;
      const duplex = new Duplex({
        ...options,
        autoDestroy: false,
        emitClose: false,
        objectMode: false,
        writableObjectMode: false
      });
      ws.on("message", /* @__PURE__ */ __name(function message(msg, isBinary2) {
        const data = !isBinary2 && duplex._readableState.objectMode ? msg.toString() : msg;
        if (!duplex.push(data)) ws.pause();
      }, "message"));
      ws.once("error", /* @__PURE__ */ __name(function error(err) {
        if (duplex.destroyed) return;
        terminateOnDestroy = false;
        duplex.destroy(err);
      }, "error"));
      ws.once("close", /* @__PURE__ */ __name(function close() {
        if (duplex.destroyed) return;
        duplex.push(null);
      }, "close"));
      duplex._destroy = function(err, callback) {
        if (ws.readyState === ws.CLOSED) {
          callback(err);
          process.nextTick(emitClose, duplex);
          return;
        }
        let called = false;
        ws.once("error", /* @__PURE__ */ __name(function error(err2) {
          called = true;
          callback(err2);
        }, "error"));
        ws.once("close", /* @__PURE__ */ __name(function close() {
          if (!called) callback(err);
          process.nextTick(emitClose, duplex);
        }, "close"));
        if (terminateOnDestroy) ws.terminate();
      };
      duplex._final = function(callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", /* @__PURE__ */ __name(function open() {
            duplex._final(callback);
          }, "open"));
          return;
        }
        if (ws._socket === null) return;
        if (ws._socket._writableState.finished) {
          callback();
          if (duplex._readableState.endEmitted) duplex.destroy();
        } else {
          ws._socket.once("finish", /* @__PURE__ */ __name(function finish() {
            callback();
          }, "finish"));
          ws.close();
        }
      };
      duplex._read = function() {
        if (ws.isPaused) ws.resume();
      };
      duplex._write = function(chunk, encoding, callback) {
        if (ws.readyState === ws.CONNECTING) {
          ws.once("open", /* @__PURE__ */ __name(function open() {
            duplex._write(chunk, encoding, callback);
          }, "open"));
          return;
        }
        ws.send(chunk, callback);
      };
      duplex.on("end", duplexOnEnd);
      duplex.on("error", duplexOnError);
      return duplex;
    }
    __name(createWebSocketStream2, "createWebSocketStream");
    module2.exports = createWebSocketStream2;
  }
});

// node_modules/ws/lib/constants.js
var require_constants = __commonJS({
  "node_modules/ws/lib/constants.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      BINARY_TYPES: [
        "nodebuffer",
        "arraybuffer",
        "fragments"
      ],
      EMPTY_BUFFER: Buffer.alloc(0),
      GUID: "258EAFA5-E914-47DA-95CA-C5AB0DC85B11",
      kForOnEventAttribute: Symbol("kIsForOnEventAttribute"),
      kListener: Symbol("kListener"),
      kStatusCode: Symbol("status-code"),
      kWebSocket: Symbol("websocket"),
      NOOP: /* @__PURE__ */ __name(() => {
      }, "NOOP")
    };
  }
});

// node_modules/ws/lib/buffer-util.js
var require_buffer_util = __commonJS({
  "node_modules/ws/lib/buffer-util.js"(exports2, module2) {
    "use strict";
    var { EMPTY_BUFFER } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    function concat(list, totalLength2) {
      if (list.length === 0) return EMPTY_BUFFER;
      if (list.length === 1) return list[0];
      const target = Buffer.allocUnsafe(totalLength2);
      let offset = 0;
      for (let i = 0; i < list.length; i++) {
        const buf = list[i];
        target.set(buf, offset);
        offset += buf.length;
      }
      if (offset < totalLength2) {
        return new FastBuffer(target.buffer, target.byteOffset, offset);
      }
      return target;
    }
    __name(concat, "concat");
    function _mask(source, mask, output, offset, length) {
      for (let i = 0; i < length; i++) {
        output[offset + i] = source[i] ^ mask[i & 3];
      }
    }
    __name(_mask, "_mask");
    function _unmask(buffer, mask) {
      for (let i = 0; i < buffer.length; i++) {
        buffer[i] ^= mask[i & 3];
      }
    }
    __name(_unmask, "_unmask");
    function toArrayBuffer(buf) {
      if (buf.length === buf.buffer.byteLength) {
        return buf.buffer;
      }
      return buf.buffer.slice(buf.byteOffset, buf.byteOffset + buf.length);
    }
    __name(toArrayBuffer, "toArrayBuffer");
    function toBuffer2(data) {
      toBuffer2.readOnly = true;
      if (Buffer.isBuffer(data)) return data;
      let buf;
      if (data instanceof ArrayBuffer) {
        buf = new FastBuffer(data);
      } else if (ArrayBuffer.isView(data)) {
        buf = new FastBuffer(data.buffer, data.byteOffset, data.byteLength);
      } else {
        buf = Buffer.from(data);
        toBuffer2.readOnly = false;
      }
      return buf;
    }
    __name(toBuffer2, "toBuffer");
    module2.exports = {
      concat,
      mask: _mask,
      toArrayBuffer,
      toBuffer: toBuffer2,
      unmask: _unmask
    };
    if (!process.env.WS_NO_BUFFER_UTIL) {
      try {
        const bufferUtil = require("bufferutil");
        module2.exports.mask = function(source, mask, output, offset, length) {
          if (length < 48) _mask(source, mask, output, offset, length);
          else bufferUtil.mask(source, mask, output, offset, length);
        };
        module2.exports.unmask = function(buffer, mask) {
          if (buffer.length < 32) _unmask(buffer, mask);
          else bufferUtil.unmask(buffer, mask);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/limiter.js
var require_limiter = __commonJS({
  "node_modules/ws/lib/limiter.js"(exports2, module2) {
    "use strict";
    var kDone = Symbol("kDone");
    var kRun = Symbol("kRun");
    var Limiter = class Limiter {
      static {
        __name(this, "Limiter");
      }
      /**
      * Creates a new `Limiter`.
      *
      * @param {Number} [concurrency=Infinity] The maximum number of jobs allowed
      *     to run concurrently
      */
      constructor(concurrency) {
        this[kDone] = () => {
          this.pending--;
          this[kRun]();
        };
        this.concurrency = concurrency || Infinity;
        this.jobs = [];
        this.pending = 0;
      }
      /**
      * Adds a job to the queue.
      *
      * @param {Function} job The job to run
      * @public
      */
      add(job) {
        this.jobs.push(job);
        this[kRun]();
      }
      /**
      * Removes a job from the queue and runs it if possible.
      *
      * @private
      */
      [kRun]() {
        if (this.pending === this.concurrency) return;
        if (this.jobs.length) {
          const job = this.jobs.shift();
          this.pending++;
          job(this[kDone]);
        }
      }
    };
    module2.exports = Limiter;
  }
});

// node_modules/ws/lib/permessage-deflate.js
var require_permessage_deflate = __commonJS({
  "node_modules/ws/lib/permessage-deflate.js"(exports2, module2) {
    "use strict";
    var zlib = require("zlib");
    var bufferUtil = require_buffer_util();
    var Limiter = require_limiter();
    var { kStatusCode } = require_constants();
    var FastBuffer = Buffer[Symbol.species];
    var TRAILER = Buffer.from([
      0,
      0,
      255,
      255
    ]);
    var kPerMessageDeflate = Symbol("permessage-deflate");
    var kTotalLength = Symbol("total-length");
    var kCallback = Symbol("callback");
    var kBuffers = Symbol("buffers");
    var kError = Symbol("error");
    var zlibLimiter;
    var PerMessageDeflate = class PerMessageDeflate {
      static {
        __name(this, "PerMessageDeflate");
      }
      /**
      * Creates a PerMessageDeflate instance.
      *
      * @param {Object} [options] Configuration options
      * @param {(Boolean|Number)} [options.clientMaxWindowBits] Advertise support
      *     for, or request, a custom client window size
      * @param {Boolean} [options.clientNoContextTakeover=false] Advertise/
      *     acknowledge disabling of client context takeover
      * @param {Number} [options.concurrencyLimit=10] The number of concurrent
      *     calls to zlib
      * @param {(Boolean|Number)} [options.serverMaxWindowBits] Request/confirm the
      *     use of a custom server window size
      * @param {Boolean} [options.serverNoContextTakeover=false] Request/accept
      *     disabling of server context takeover
      * @param {Number} [options.threshold=1024] Size (in bytes) below which
      *     messages should not be compressed if context takeover is disabled
      * @param {Object} [options.zlibDeflateOptions] Options to pass to zlib on
      *     deflate
      * @param {Object} [options.zlibInflateOptions] Options to pass to zlib on
      *     inflate
      * @param {Boolean} [isServer=false] Create the instance in either server or
      *     client mode
      * @param {Number} [maxPayload=0] The maximum allowed message length
      */
      constructor(options, isServer, maxPayload) {
        this._maxPayload = maxPayload | 0;
        this._options = options || {};
        this._threshold = this._options.threshold !== void 0 ? this._options.threshold : 1024;
        this._isServer = !!isServer;
        this._deflate = null;
        this._inflate = null;
        this.params = null;
        if (!zlibLimiter) {
          const concurrency = this._options.concurrencyLimit !== void 0 ? this._options.concurrencyLimit : 10;
          zlibLimiter = new Limiter(concurrency);
        }
      }
      /**
      * @type {String}
      */
      static get extensionName() {
        return "permessage-deflate";
      }
      /**
      * Create an extension negotiation offer.
      *
      * @return {Object} Extension parameters
      * @public
      */
      offer() {
        const params2 = {};
        if (this._options.serverNoContextTakeover) {
          params2.server_no_context_takeover = true;
        }
        if (this._options.clientNoContextTakeover) {
          params2.client_no_context_takeover = true;
        }
        if (this._options.serverMaxWindowBits) {
          params2.server_max_window_bits = this._options.serverMaxWindowBits;
        }
        if (this._options.clientMaxWindowBits) {
          params2.client_max_window_bits = this._options.clientMaxWindowBits;
        } else if (this._options.clientMaxWindowBits == null) {
          params2.client_max_window_bits = true;
        }
        return params2;
      }
      /**
      * Accept an extension negotiation offer/response.
      *
      * @param {Array} configurations The extension negotiation offers/reponse
      * @return {Object} Accepted configuration
      * @public
      */
      accept(configurations) {
        configurations = this.normalizeParams(configurations);
        this.params = this._isServer ? this.acceptAsServer(configurations) : this.acceptAsClient(configurations);
        return this.params;
      }
      /**
      * Releases all resources used by the extension.
      *
      * @public
      */
      cleanup() {
        if (this._inflate) {
          this._inflate.close();
          this._inflate = null;
        }
        if (this._deflate) {
          const callback = this._deflate[kCallback];
          this._deflate.close();
          this._deflate = null;
          if (callback) {
            callback(new Error("The deflate stream was closed while data was being processed"));
          }
        }
      }
      /**
      *  Accept an extension negotiation offer.
      *
      * @param {Array} offers The extension negotiation offers
      * @return {Object} Accepted configuration
      * @private
      */
      acceptAsServer(offers) {
        const opts = this._options;
        const accepted = offers.find((params2) => {
          if (opts.serverNoContextTakeover === false && params2.server_no_context_takeover || params2.server_max_window_bits && (opts.serverMaxWindowBits === false || typeof opts.serverMaxWindowBits === "number" && opts.serverMaxWindowBits > params2.server_max_window_bits) || typeof opts.clientMaxWindowBits === "number" && !params2.client_max_window_bits) {
            return false;
          }
          return true;
        });
        if (!accepted) {
          throw new Error("None of the extension offers can be accepted");
        }
        if (opts.serverNoContextTakeover) {
          accepted.server_no_context_takeover = true;
        }
        if (opts.clientNoContextTakeover) {
          accepted.client_no_context_takeover = true;
        }
        if (typeof opts.serverMaxWindowBits === "number") {
          accepted.server_max_window_bits = opts.serverMaxWindowBits;
        }
        if (typeof opts.clientMaxWindowBits === "number") {
          accepted.client_max_window_bits = opts.clientMaxWindowBits;
        } else if (accepted.client_max_window_bits === true || opts.clientMaxWindowBits === false) {
          delete accepted.client_max_window_bits;
        }
        return accepted;
      }
      /**
      * Accept the extension negotiation response.
      *
      * @param {Array} response The extension negotiation response
      * @return {Object} Accepted configuration
      * @private
      */
      acceptAsClient(response) {
        const params2 = response[0];
        if (this._options.clientNoContextTakeover === false && params2.client_no_context_takeover) {
          throw new Error('Unexpected parameter "client_no_context_takeover"');
        }
        if (!params2.client_max_window_bits) {
          if (typeof this._options.clientMaxWindowBits === "number") {
            params2.client_max_window_bits = this._options.clientMaxWindowBits;
          }
        } else if (this._options.clientMaxWindowBits === false || typeof this._options.clientMaxWindowBits === "number" && params2.client_max_window_bits > this._options.clientMaxWindowBits) {
          throw new Error('Unexpected or invalid parameter "client_max_window_bits"');
        }
        return params2;
      }
      /**
      * Normalize parameters.
      *
      * @param {Array} configurations The extension negotiation offers/reponse
      * @return {Array} The offers/response with normalized parameters
      * @private
      */
      normalizeParams(configurations) {
        configurations.forEach((params2) => {
          Object.keys(params2).forEach((key) => {
            let value2 = params2[key];
            if (value2.length > 1) {
              throw new Error(`Parameter "${key}" must have only a single value`);
            }
            value2 = value2[0];
            if (key === "client_max_window_bits") {
              if (value2 !== true) {
                const num = +value2;
                if (!Number.isInteger(num) || num < 8 || num > 15) {
                  throw new TypeError(`Invalid value for parameter "${key}": ${value2}`);
                }
                value2 = num;
              } else if (!this._isServer) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value2}`);
              }
            } else if (key === "server_max_window_bits") {
              const num = +value2;
              if (!Number.isInteger(num) || num < 8 || num > 15) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value2}`);
              }
              value2 = num;
            } else if (key === "client_no_context_takeover" || key === "server_no_context_takeover") {
              if (value2 !== true) {
                throw new TypeError(`Invalid value for parameter "${key}": ${value2}`);
              }
            } else {
              throw new Error(`Unknown parameter "${key}"`);
            }
            params2[key] = value2;
          });
        });
        return configurations;
      }
      /**
      * Decompress data. Concurrency limited.
      *
      * @param {Buffer} data Compressed data
      * @param {Boolean} fin Specifies whether or not this is the last fragment
      * @param {Function} callback Callback
      * @public
      */
      decompress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._decompress(data, fin, (err, result2) => {
            done();
            callback(err, result2);
          });
        });
      }
      /**
      * Compress data. Concurrency limited.
      *
      * @param {(Buffer|String)} data Data to compress
      * @param {Boolean} fin Specifies whether or not this is the last fragment
      * @param {Function} callback Callback
      * @public
      */
      compress(data, fin, callback) {
        zlibLimiter.add((done) => {
          this._compress(data, fin, (err, result2) => {
            done();
            callback(err, result2);
          });
        });
      }
      /**
      * Decompress data.
      *
      * @param {Buffer} data Compressed data
      * @param {Boolean} fin Specifies whether or not this is the last fragment
      * @param {Function} callback Callback
      * @private
      */
      _decompress(data, fin, callback) {
        const endpoint = this._isServer ? "client" : "server";
        if (!this._inflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._inflate = zlib.createInflateRaw({
            ...this._options.zlibInflateOptions,
            windowBits
          });
          this._inflate[kPerMessageDeflate] = this;
          this._inflate[kTotalLength] = 0;
          this._inflate[kBuffers] = [];
          this._inflate.on("error", inflateOnError);
          this._inflate.on("data", inflateOnData);
        }
        this._inflate[kCallback] = callback;
        this._inflate.write(data);
        if (fin) this._inflate.write(TRAILER);
        this._inflate.flush(() => {
          const err = this._inflate[kError];
          if (err) {
            this._inflate.close();
            this._inflate = null;
            callback(err);
            return;
          }
          const data2 = bufferUtil.concat(this._inflate[kBuffers], this._inflate[kTotalLength]);
          if (this._inflate._readableState.endEmitted) {
            this._inflate.close();
            this._inflate = null;
          } else {
            this._inflate[kTotalLength] = 0;
            this._inflate[kBuffers] = [];
            if (fin && this.params[`${endpoint}_no_context_takeover`]) {
              this._inflate.reset();
            }
          }
          callback(null, data2);
        });
      }
      /**
      * Compress data.
      *
      * @param {(Buffer|String)} data Data to compress
      * @param {Boolean} fin Specifies whether or not this is the last fragment
      * @param {Function} callback Callback
      * @private
      */
      _compress(data, fin, callback) {
        const endpoint = this._isServer ? "server" : "client";
        if (!this._deflate) {
          const key = `${endpoint}_max_window_bits`;
          const windowBits = typeof this.params[key] !== "number" ? zlib.Z_DEFAULT_WINDOWBITS : this.params[key];
          this._deflate = zlib.createDeflateRaw({
            ...this._options.zlibDeflateOptions,
            windowBits
          });
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          this._deflate.on("data", deflateOnData);
        }
        this._deflate[kCallback] = callback;
        this._deflate.write(data);
        this._deflate.flush(zlib.Z_SYNC_FLUSH, () => {
          if (!this._deflate) {
            return;
          }
          let data2 = bufferUtil.concat(this._deflate[kBuffers], this._deflate[kTotalLength]);
          if (fin) {
            data2 = new FastBuffer(data2.buffer, data2.byteOffset, data2.length - 4);
          }
          this._deflate[kCallback] = null;
          this._deflate[kTotalLength] = 0;
          this._deflate[kBuffers] = [];
          if (fin && this.params[`${endpoint}_no_context_takeover`]) {
            this._deflate.reset();
          }
          callback(null, data2);
        });
      }
    };
    module2.exports = PerMessageDeflate;
    function deflateOnData(chunk) {
      this[kBuffers].push(chunk);
      this[kTotalLength] += chunk.length;
    }
    __name(deflateOnData, "deflateOnData");
    function inflateOnData(chunk) {
      this[kTotalLength] += chunk.length;
      if (this[kPerMessageDeflate]._maxPayload < 1 || this[kTotalLength] <= this[kPerMessageDeflate]._maxPayload) {
        this[kBuffers].push(chunk);
        return;
      }
      this[kError] = new RangeError("Max payload size exceeded");
      this[kError].code = "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH";
      this[kError][kStatusCode] = 1009;
      this.removeListener("data", inflateOnData);
      this.reset();
    }
    __name(inflateOnData, "inflateOnData");
    function inflateOnError(err) {
      this[kPerMessageDeflate]._inflate = null;
      err[kStatusCode] = 1007;
      this[kCallback](err);
    }
    __name(inflateOnError, "inflateOnError");
  }
});

// node_modules/ws/lib/validation.js
var require_validation = __commonJS({
  "node_modules/ws/lib/validation.js"(exports2, module2) {
    "use strict";
    var { isUtf8 } = require("buffer");
    var tokenChars = [
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      1,
      1,
      0,
      1,
      1,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      0,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      0,
      0,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      1,
      0,
      1,
      0,
      1,
      0
      // 112 - 127
    ];
    function isValidStatusCode(code) {
      return code >= 1e3 && code <= 1014 && code !== 1004 && code !== 1005 && code !== 1006 || code >= 3e3 && code <= 4999;
    }
    __name(isValidStatusCode, "isValidStatusCode");
    function _isValidUTF8(buf) {
      const len = buf.length;
      let i = 0;
      while (i < len) {
        if ((buf[i] & 128) === 0) {
          i++;
        } else if ((buf[i] & 224) === 192) {
          if (i + 1 === len || (buf[i + 1] & 192) !== 128 || (buf[i] & 254) === 192) {
            return false;
          }
          i += 2;
        } else if ((buf[i] & 240) === 224) {
          if (i + 2 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || buf[i] === 224 && (buf[i + 1] & 224) === 128 || // Overlong
          buf[i] === 237 && (buf[i + 1] & 224) === 160) {
            return false;
          }
          i += 3;
        } else if ((buf[i] & 248) === 240) {
          if (i + 3 >= len || (buf[i + 1] & 192) !== 128 || (buf[i + 2] & 192) !== 128 || (buf[i + 3] & 192) !== 128 || buf[i] === 240 && (buf[i + 1] & 240) === 128 || // Overlong
          buf[i] === 244 && buf[i + 1] > 143 || buf[i] > 244) {
            return false;
          }
          i += 4;
        } else {
          return false;
        }
      }
      return true;
    }
    __name(_isValidUTF8, "_isValidUTF8");
    module2.exports = {
      isValidStatusCode,
      isValidUTF8: _isValidUTF8,
      tokenChars
    };
    if (isUtf8) {
      module2.exports.isValidUTF8 = function(buf) {
        return buf.length < 24 ? _isValidUTF8(buf) : isUtf8(buf);
      };
    } else if (!process.env.WS_NO_UTF_8_VALIDATE) {
      try {
        const isValidUTF8 = require("utf-8-validate");
        module2.exports.isValidUTF8 = function(buf) {
          return buf.length < 32 ? _isValidUTF8(buf) : isValidUTF8(buf);
        };
      } catch (e) {
      }
    }
  }
});

// node_modules/ws/lib/receiver.js
var require_receiver = __commonJS({
  "node_modules/ws/lib/receiver.js"(exports2, module2) {
    "use strict";
    var { Writable } = require("stream");
    var PerMessageDeflate = require_permessage_deflate();
    var { BINARY_TYPES, EMPTY_BUFFER, kStatusCode, kWebSocket } = require_constants();
    var { concat, toArrayBuffer, unmask } = require_buffer_util();
    var { isValidStatusCode, isValidUTF8 } = require_validation();
    var FastBuffer = Buffer[Symbol.species];
    var GET_INFO = 0;
    var GET_PAYLOAD_LENGTH_16 = 1;
    var GET_PAYLOAD_LENGTH_64 = 2;
    var GET_MASK = 3;
    var GET_DATA = 4;
    var INFLATING = 5;
    var DEFER_EVENT = 6;
    var Receiver2 = class Receiver extends Writable {
      static {
        __name(this, "Receiver");
      }
      /**
      * Creates a Receiver instance.
      *
      * @param {Object} [options] Options object
      * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
      *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
      *     multiple times in the same tick
      * @param {String} [options.binaryType=nodebuffer] The type for binary data
      * @param {Object} [options.extensions] An object containing the negotiated
      *     extensions
      * @param {Boolean} [options.isServer=false] Specifies whether to operate in
      *     client or server mode
      * @param {Number} [options.maxPayload=0] The maximum allowed message length
      * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
      *     not to skip UTF-8 validation for text and close messages
      */
      constructor(options = {}) {
        super();
        this._allowSynchronousEvents = options.allowSynchronousEvents !== void 0 ? options.allowSynchronousEvents : true;
        this._binaryType = options.binaryType || BINARY_TYPES[0];
        this._extensions = options.extensions || {};
        this._isServer = !!options.isServer;
        this._maxPayload = options.maxPayload | 0;
        this._skipUTF8Validation = !!options.skipUTF8Validation;
        this[kWebSocket] = void 0;
        this._bufferedBytes = 0;
        this._buffers = [];
        this._compressed = false;
        this._payloadLength = 0;
        this._mask = void 0;
        this._fragmented = 0;
        this._masked = false;
        this._fin = false;
        this._opcode = 0;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragments = [];
        this._errored = false;
        this._loop = false;
        this._state = GET_INFO;
      }
      /**
      * Implements `Writable.prototype._write()`.
      *
      * @param {Buffer} chunk The chunk of data to write
      * @param {String} encoding The character encoding of `chunk`
      * @param {Function} cb Callback
      * @private
      */
      _write(chunk, encoding, cb) {
        if (this._opcode === 8 && this._state == GET_INFO) return cb();
        this._bufferedBytes += chunk.length;
        this._buffers.push(chunk);
        this.startLoop(cb);
      }
      /**
      * Consumes `n` bytes from the buffered data.
      *
      * @param {Number} n The number of bytes to consume
      * @return {Buffer} The consumed bytes
      * @private
      */
      consume(n) {
        this._bufferedBytes -= n;
        if (n === this._buffers[0].length) return this._buffers.shift();
        if (n < this._buffers[0].length) {
          const buf = this._buffers[0];
          this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
          return new FastBuffer(buf.buffer, buf.byteOffset, n);
        }
        const dst = Buffer.allocUnsafe(n);
        do {
          const buf = this._buffers[0];
          const offset = dst.length - n;
          if (n >= buf.length) {
            dst.set(this._buffers.shift(), offset);
          } else {
            dst.set(new Uint8Array(buf.buffer, buf.byteOffset, n), offset);
            this._buffers[0] = new FastBuffer(buf.buffer, buf.byteOffset + n, buf.length - n);
          }
          n -= buf.length;
        } while (n > 0);
        return dst;
      }
      /**
      * Starts the parsing loop.
      *
      * @param {Function} cb Callback
      * @private
      */
      startLoop(cb) {
        this._loop = true;
        do {
          switch (this._state) {
            case GET_INFO:
              this.getInfo(cb);
              break;
            case GET_PAYLOAD_LENGTH_16:
              this.getPayloadLength16(cb);
              break;
            case GET_PAYLOAD_LENGTH_64:
              this.getPayloadLength64(cb);
              break;
            case GET_MASK:
              this.getMask();
              break;
            case GET_DATA:
              this.getData(cb);
              break;
            case INFLATING:
            case DEFER_EVENT:
              this._loop = false;
              return;
          }
        } while (this._loop);
        if (!this._errored) cb();
      }
      /**
      * Reads the first two bytes of a frame.
      *
      * @param {Function} cb Callback
      * @private
      */
      getInfo(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        const buf = this.consume(2);
        if ((buf[0] & 48) !== 0) {
          const error = this.createError(RangeError, "RSV2 and RSV3 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_2_3");
          cb(error);
          return;
        }
        const compressed = (buf[0] & 64) === 64;
        if (compressed && !this._extensions[PerMessageDeflate.extensionName]) {
          const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
          cb(error);
          return;
        }
        this._fin = (buf[0] & 128) === 128;
        this._opcode = buf[0] & 15;
        this._payloadLength = buf[1] & 127;
        if (this._opcode === 0) {
          if (compressed) {
            const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
            cb(error);
            return;
          }
          if (!this._fragmented) {
            const error = this.createError(RangeError, "invalid opcode 0", true, 1002, "WS_ERR_INVALID_OPCODE");
            cb(error);
            return;
          }
          this._opcode = this._fragmented;
        } else if (this._opcode === 1 || this._opcode === 2) {
          if (this._fragmented) {
            const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
            cb(error);
            return;
          }
          this._compressed = compressed;
        } else if (this._opcode > 7 && this._opcode < 11) {
          if (!this._fin) {
            const error = this.createError(RangeError, "FIN must be set", true, 1002, "WS_ERR_EXPECTED_FIN");
            cb(error);
            return;
          }
          if (compressed) {
            const error = this.createError(RangeError, "RSV1 must be clear", true, 1002, "WS_ERR_UNEXPECTED_RSV_1");
            cb(error);
            return;
          }
          if (this._payloadLength > 125 || this._opcode === 8 && this._payloadLength === 1) {
            const error = this.createError(RangeError, `invalid payload length ${this._payloadLength}`, true, 1002, "WS_ERR_INVALID_CONTROL_PAYLOAD_LENGTH");
            cb(error);
            return;
          }
        } else {
          const error = this.createError(RangeError, `invalid opcode ${this._opcode}`, true, 1002, "WS_ERR_INVALID_OPCODE");
          cb(error);
          return;
        }
        if (!this._fin && !this._fragmented) this._fragmented = this._opcode;
        this._masked = (buf[1] & 128) === 128;
        if (this._isServer) {
          if (!this._masked) {
            const error = this.createError(RangeError, "MASK must be set", true, 1002, "WS_ERR_EXPECTED_MASK");
            cb(error);
            return;
          }
        } else if (this._masked) {
          const error = this.createError(RangeError, "MASK must be clear", true, 1002, "WS_ERR_UNEXPECTED_MASK");
          cb(error);
          return;
        }
        if (this._payloadLength === 126) this._state = GET_PAYLOAD_LENGTH_16;
        else if (this._payloadLength === 127) this._state = GET_PAYLOAD_LENGTH_64;
        else this.haveLength(cb);
      }
      /**
      * Gets extended payload length (7+16).
      *
      * @param {Function} cb Callback
      * @private
      */
      getPayloadLength16(cb) {
        if (this._bufferedBytes < 2) {
          this._loop = false;
          return;
        }
        this._payloadLength = this.consume(2).readUInt16BE(0);
        this.haveLength(cb);
      }
      /**
      * Gets extended payload length (7+64).
      *
      * @param {Function} cb Callback
      * @private
      */
      getPayloadLength64(cb) {
        if (this._bufferedBytes < 8) {
          this._loop = false;
          return;
        }
        const buf = this.consume(8);
        const num = buf.readUInt32BE(0);
        if (num > Math.pow(2, 53 - 32) - 1) {
          const error = this.createError(RangeError, "Unsupported WebSocket frame: payload length > 2^53 - 1", false, 1009, "WS_ERR_UNSUPPORTED_DATA_PAYLOAD_LENGTH");
          cb(error);
          return;
        }
        this._payloadLength = num * Math.pow(2, 32) + buf.readUInt32BE(4);
        this.haveLength(cb);
      }
      /**
      * Payload length has been read.
      *
      * @param {Function} cb Callback
      * @private
      */
      haveLength(cb) {
        if (this._payloadLength && this._opcode < 8) {
          this._totalPayloadLength += this._payloadLength;
          if (this._totalPayloadLength > this._maxPayload && this._maxPayload > 0) {
            const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
            cb(error);
            return;
          }
        }
        if (this._masked) this._state = GET_MASK;
        else this._state = GET_DATA;
      }
      /**
      * Reads mask bytes.
      *
      * @private
      */
      getMask() {
        if (this._bufferedBytes < 4) {
          this._loop = false;
          return;
        }
        this._mask = this.consume(4);
        this._state = GET_DATA;
      }
      /**
      * Reads data bytes.
      *
      * @param {Function} cb Callback
      * @private
      */
      getData(cb) {
        let data = EMPTY_BUFFER;
        if (this._payloadLength) {
          if (this._bufferedBytes < this._payloadLength) {
            this._loop = false;
            return;
          }
          data = this.consume(this._payloadLength);
          if (this._masked && (this._mask[0] | this._mask[1] | this._mask[2] | this._mask[3]) !== 0) {
            unmask(data, this._mask);
          }
        }
        if (this._opcode > 7) {
          this.controlMessage(data, cb);
          return;
        }
        if (this._compressed) {
          this._state = INFLATING;
          this.decompress(data, cb);
          return;
        }
        if (data.length) {
          this._messageLength = this._totalPayloadLength;
          this._fragments.push(data);
        }
        this.dataMessage(cb);
      }
      /**
      * Decompresses data.
      *
      * @param {Buffer} data Compressed data
      * @param {Function} cb Callback
      * @private
      */
      decompress(data, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        perMessageDeflate.decompress(data, this._fin, (err, buf) => {
          if (err) return cb(err);
          if (buf.length) {
            this._messageLength += buf.length;
            if (this._messageLength > this._maxPayload && this._maxPayload > 0) {
              const error = this.createError(RangeError, "Max payload size exceeded", false, 1009, "WS_ERR_UNSUPPORTED_MESSAGE_LENGTH");
              cb(error);
              return;
            }
            this._fragments.push(buf);
          }
          this.dataMessage(cb);
          if (this._state === GET_INFO) this.startLoop(cb);
        });
      }
      /**
      * Handles a data message.
      *
      * @param {Function} cb Callback
      * @private
      */
      dataMessage(cb) {
        if (!this._fin) {
          this._state = GET_INFO;
          return;
        }
        const messageLength = this._messageLength;
        const fragments = this._fragments;
        this._totalPayloadLength = 0;
        this._messageLength = 0;
        this._fragmented = 0;
        this._fragments = [];
        if (this._opcode === 2) {
          let data;
          if (this._binaryType === "nodebuffer") {
            data = concat(fragments, messageLength);
          } else if (this._binaryType === "arraybuffer") {
            data = toArrayBuffer(concat(fragments, messageLength));
          } else {
            data = fragments;
          }
          if (this._allowSynchronousEvents) {
            this.emit("message", data, true);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", data, true);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        } else {
          const buf = concat(fragments, messageLength);
          if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
            const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
            cb(error);
            return;
          }
          if (this._state === INFLATING || this._allowSynchronousEvents) {
            this.emit("message", buf, false);
            this._state = GET_INFO;
          } else {
            this._state = DEFER_EVENT;
            setImmediate(() => {
              this.emit("message", buf, false);
              this._state = GET_INFO;
              this.startLoop(cb);
            });
          }
        }
      }
      /**
      * Handles a control message.
      *
      * @param {Buffer} data Data to handle
      * @return {(Error|RangeError|undefined)} A possible error
      * @private
      */
      controlMessage(data, cb) {
        if (this._opcode === 8) {
          if (data.length === 0) {
            this._loop = false;
            this.emit("conclude", 1005, EMPTY_BUFFER);
            this.end();
          } else {
            const code = data.readUInt16BE(0);
            if (!isValidStatusCode(code)) {
              const error = this.createError(RangeError, `invalid status code ${code}`, true, 1002, "WS_ERR_INVALID_CLOSE_CODE");
              cb(error);
              return;
            }
            const buf = new FastBuffer(data.buffer, data.byteOffset + 2, data.length - 2);
            if (!this._skipUTF8Validation && !isValidUTF8(buf)) {
              const error = this.createError(Error, "invalid UTF-8 sequence", true, 1007, "WS_ERR_INVALID_UTF8");
              cb(error);
              return;
            }
            this._loop = false;
            this.emit("conclude", code, buf);
            this.end();
          }
          this._state = GET_INFO;
          return;
        }
        if (this._allowSynchronousEvents) {
          this.emit(this._opcode === 9 ? "ping" : "pong", data);
          this._state = GET_INFO;
        } else {
          this._state = DEFER_EVENT;
          setImmediate(() => {
            this.emit(this._opcode === 9 ? "ping" : "pong", data);
            this._state = GET_INFO;
            this.startLoop(cb);
          });
        }
      }
      /**
      * Builds an error object.
      *
      * @param {function(new:Error|RangeError)} ErrorCtor The error constructor
      * @param {String} message The error message
      * @param {Boolean} prefix Specifies whether or not to add a default prefix to
      *     `message`
      * @param {Number} statusCode The status code
      * @param {String} errorCode The exposed error code
      * @return {(Error|RangeError)} The error
      * @private
      */
      createError(ErrorCtor, message, prefix, statusCode, errorCode) {
        this._loop = false;
        this._errored = true;
        const err = new ErrorCtor(prefix ? `Invalid WebSocket frame: ${message}` : message);
        Error.captureStackTrace(err, this.createError);
        err.code = errorCode;
        err[kStatusCode] = statusCode;
        return err;
      }
    };
    module2.exports = Receiver2;
  }
});

// node_modules/ws/lib/sender.js
var require_sender = __commonJS({
  "node_modules/ws/lib/sender.js"(exports2, module2) {
    "use strict";
    var { Duplex } = require("stream");
    var { randomFillSync } = require("crypto");
    var PerMessageDeflate = require_permessage_deflate();
    var { EMPTY_BUFFER } = require_constants();
    var { isValidStatusCode } = require_validation();
    var { mask: applyMask, toBuffer: toBuffer2 } = require_buffer_util();
    var kByteLength = Symbol("kByteLength");
    var maskBuffer = Buffer.alloc(4);
    var RANDOM_POOL_SIZE = 8 * 1024;
    var randomPool;
    var randomPoolPointer = RANDOM_POOL_SIZE;
    var Sender2 = class Sender3 {
      static {
        __name(this, "Sender");
      }
      /**
      * Creates a Sender instance.
      *
      * @param {Duplex} socket The connection socket
      * @param {Object} [extensions] An object containing the negotiated extensions
      * @param {Function} [generateMask] The function used to generate the masking
      *     key
      */
      constructor(socket, extensions, generateMask) {
        this._extensions = extensions || {};
        if (generateMask) {
          this._generateMask = generateMask;
          this._maskBuffer = Buffer.alloc(4);
        }
        this._socket = socket;
        this._firstFragment = true;
        this._compress = false;
        this._bufferedBytes = 0;
        this._deflating = false;
        this._queue = [];
      }
      /**
      * Frames a piece of data according to the HyBi WebSocket protocol.
      *
      * @param {(Buffer|String)} data The data to frame
      * @param {Object} options Options object
      * @param {Boolean} [options.fin=false] Specifies whether or not to set the
      *     FIN bit
      * @param {Function} [options.generateMask] The function used to generate the
      *     masking key
      * @param {Boolean} [options.mask=false] Specifies whether or not to mask
      *     `data`
      * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
      *     key
      * @param {Number} options.opcode The opcode
      * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
      *     modified
      * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
      *     RSV1 bit
      * @return {(Buffer|String)[]} The framed data
      * @public
      */
      static frame(data, options) {
        let mask;
        let merge = false;
        let offset = 2;
        let skipMasking = false;
        if (options.mask) {
          mask = options.maskBuffer || maskBuffer;
          if (options.generateMask) {
            options.generateMask(mask);
          } else {
            if (randomPoolPointer === RANDOM_POOL_SIZE) {
              if (randomPool === void 0) {
                randomPool = Buffer.alloc(RANDOM_POOL_SIZE);
              }
              randomFillSync(randomPool, 0, RANDOM_POOL_SIZE);
              randomPoolPointer = 0;
            }
            mask[0] = randomPool[randomPoolPointer++];
            mask[1] = randomPool[randomPoolPointer++];
            mask[2] = randomPool[randomPoolPointer++];
            mask[3] = randomPool[randomPoolPointer++];
          }
          skipMasking = (mask[0] | mask[1] | mask[2] | mask[3]) === 0;
          offset = 6;
        }
        let dataLength;
        if (typeof data === "string") {
          if ((!options.mask || skipMasking) && options[kByteLength] !== void 0) {
            dataLength = options[kByteLength];
          } else {
            data = Buffer.from(data);
            dataLength = data.length;
          }
        } else {
          dataLength = data.length;
          merge = options.mask && options.readOnly && !skipMasking;
        }
        let payloadLength = dataLength;
        if (dataLength >= 65536) {
          offset += 8;
          payloadLength = 127;
        } else if (dataLength > 125) {
          offset += 2;
          payloadLength = 126;
        }
        const target = Buffer.allocUnsafe(merge ? dataLength + offset : offset);
        target[0] = options.fin ? options.opcode | 128 : options.opcode;
        if (options.rsv1) target[0] |= 64;
        target[1] = payloadLength;
        if (payloadLength === 126) {
          target.writeUInt16BE(dataLength, 2);
        } else if (payloadLength === 127) {
          target[2] = target[3] = 0;
          target.writeUIntBE(dataLength, 4, 6);
        }
        if (!options.mask) return [
          target,
          data
        ];
        target[1] |= 128;
        target[offset - 4] = mask[0];
        target[offset - 3] = mask[1];
        target[offset - 2] = mask[2];
        target[offset - 1] = mask[3];
        if (skipMasking) return [
          target,
          data
        ];
        if (merge) {
          applyMask(data, mask, target, offset, dataLength);
          return [
            target
          ];
        }
        applyMask(data, mask, data, 0, dataLength);
        return [
          target,
          data
        ];
      }
      /**
      * Sends a close message to the other peer.
      *
      * @param {Number} [code] The status code component of the body
      * @param {(String|Buffer)} [data] The message component of the body
      * @param {Boolean} [mask=false] Specifies whether or not to mask the message
      * @param {Function} [cb] Callback
      * @public
      */
      close(code, data, mask, cb) {
        let buf;
        if (code === void 0) {
          buf = EMPTY_BUFFER;
        } else if (typeof code !== "number" || !isValidStatusCode(code)) {
          throw new TypeError("First argument must be a valid error code number");
        } else if (data === void 0 || !data.length) {
          buf = Buffer.allocUnsafe(2);
          buf.writeUInt16BE(code, 0);
        } else {
          const length = Buffer.byteLength(data);
          if (length > 123) {
            throw new RangeError("The message must not be greater than 123 bytes");
          }
          buf = Buffer.allocUnsafe(2 + length);
          buf.writeUInt16BE(code, 0);
          if (typeof data === "string") {
            buf.write(data, 2);
          } else {
            buf.set(data, 2);
          }
        }
        const options = {
          [kByteLength]: buf.length,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 8,
          readOnly: false,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([
            this.dispatch,
            buf,
            false,
            options,
            cb
          ]);
        } else {
          this.sendFrame(Sender3.frame(buf, options), cb);
        }
      }
      /**
      * Sends a ping message to the other peer.
      *
      * @param {*} data The message to send
      * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
      * @param {Function} [cb] Callback
      * @public
      */
      ping(data, mask, cb) {
        let byteLength2;
        let readOnly;
        if (typeof data === "string") {
          byteLength2 = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer2(data);
          byteLength2 = data.length;
          readOnly = toBuffer2.readOnly;
        }
        if (byteLength2 > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength2,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 9,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([
            this.dispatch,
            data,
            false,
            options,
            cb
          ]);
        } else {
          this.sendFrame(Sender3.frame(data, options), cb);
        }
      }
      /**
      * Sends a pong message to the other peer.
      *
      * @param {*} data The message to send
      * @param {Boolean} [mask=false] Specifies whether or not to mask `data`
      * @param {Function} [cb] Callback
      * @public
      */
      pong(data, mask, cb) {
        let byteLength2;
        let readOnly;
        if (typeof data === "string") {
          byteLength2 = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer2(data);
          byteLength2 = data.length;
          readOnly = toBuffer2.readOnly;
        }
        if (byteLength2 > 125) {
          throw new RangeError("The data size must not be greater than 125 bytes");
        }
        const options = {
          [kByteLength]: byteLength2,
          fin: true,
          generateMask: this._generateMask,
          mask,
          maskBuffer: this._maskBuffer,
          opcode: 10,
          readOnly,
          rsv1: false
        };
        if (this._deflating) {
          this.enqueue([
            this.dispatch,
            data,
            false,
            options,
            cb
          ]);
        } else {
          this.sendFrame(Sender3.frame(data, options), cb);
        }
      }
      /**
      * Sends a data message to the other peer.
      *
      * @param {*} data The message to send
      * @param {Object} options Options object
      * @param {Boolean} [options.binary=false] Specifies whether `data` is binary
      *     or text
      * @param {Boolean} [options.compress=false] Specifies whether or not to
      *     compress `data`
      * @param {Boolean} [options.fin=false] Specifies whether the fragment is the
      *     last one
      * @param {Boolean} [options.mask=false] Specifies whether or not to mask
      *     `data`
      * @param {Function} [cb] Callback
      * @public
      */
      send(data, options, cb) {
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        let opcode = options.binary ? 2 : 1;
        let rsv1 = options.compress;
        let byteLength2;
        let readOnly;
        if (typeof data === "string") {
          byteLength2 = Buffer.byteLength(data);
          readOnly = false;
        } else {
          data = toBuffer2(data);
          byteLength2 = data.length;
          readOnly = toBuffer2.readOnly;
        }
        if (this._firstFragment) {
          this._firstFragment = false;
          if (rsv1 && perMessageDeflate && perMessageDeflate.params[perMessageDeflate._isServer ? "server_no_context_takeover" : "client_no_context_takeover"]) {
            rsv1 = byteLength2 >= perMessageDeflate._threshold;
          }
          this._compress = rsv1;
        } else {
          rsv1 = false;
          opcode = 0;
        }
        if (options.fin) this._firstFragment = true;
        if (perMessageDeflate) {
          const opts = {
            [kByteLength]: byteLength2,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1
          };
          if (this._deflating) {
            this.enqueue([
              this.dispatch,
              data,
              this._compress,
              opts,
              cb
            ]);
          } else {
            this.dispatch(data, this._compress, opts, cb);
          }
        } else {
          this.sendFrame(Sender3.frame(data, {
            [kByteLength]: byteLength2,
            fin: options.fin,
            generateMask: this._generateMask,
            mask: options.mask,
            maskBuffer: this._maskBuffer,
            opcode,
            readOnly,
            rsv1: false
          }), cb);
        }
      }
      /**
      * Dispatches a message.
      *
      * @param {(Buffer|String)} data The message to send
      * @param {Boolean} [compress=false] Specifies whether or not to compress
      *     `data`
      * @param {Object} options Options object
      * @param {Boolean} [options.fin=false] Specifies whether or not to set the
      *     FIN bit
      * @param {Function} [options.generateMask] The function used to generate the
      *     masking key
      * @param {Boolean} [options.mask=false] Specifies whether or not to mask
      *     `data`
      * @param {Buffer} [options.maskBuffer] The buffer used to store the masking
      *     key
      * @param {Number} options.opcode The opcode
      * @param {Boolean} [options.readOnly=false] Specifies whether `data` can be
      *     modified
      * @param {Boolean} [options.rsv1=false] Specifies whether or not to set the
      *     RSV1 bit
      * @param {Function} [cb] Callback
      * @private
      */
      dispatch(data, compress, options, cb) {
        if (!compress) {
          this.sendFrame(Sender3.frame(data, options), cb);
          return;
        }
        const perMessageDeflate = this._extensions[PerMessageDeflate.extensionName];
        this._bufferedBytes += options[kByteLength];
        this._deflating = true;
        perMessageDeflate.compress(data, options.fin, (_, buf) => {
          if (this._socket.destroyed) {
            const err = new Error("The socket was closed while data was being compressed");
            if (typeof cb === "function") cb(err);
            for (let i = 0; i < this._queue.length; i++) {
              const params2 = this._queue[i];
              const callback = params2[params2.length - 1];
              if (typeof callback === "function") callback(err);
            }
            return;
          }
          this._bufferedBytes -= options[kByteLength];
          this._deflating = false;
          options.readOnly = false;
          this.sendFrame(Sender3.frame(buf, options), cb);
          this.dequeue();
        });
      }
      /**
      * Executes queued send operations.
      *
      * @private
      */
      dequeue() {
        while (!this._deflating && this._queue.length) {
          const params2 = this._queue.shift();
          this._bufferedBytes -= params2[3][kByteLength];
          Reflect.apply(params2[0], this, params2.slice(1));
        }
      }
      /**
      * Enqueues a send operation.
      *
      * @param {Array} params Send operation parameters.
      * @private
      */
      enqueue(params2) {
        this._bufferedBytes += params2[3][kByteLength];
        this._queue.push(params2);
      }
      /**
      * Sends a frame.
      *
      * @param {Buffer[]} list The frame to send
      * @param {Function} [cb] Callback
      * @private
      */
      sendFrame(list, cb) {
        if (list.length === 2) {
          this._socket.cork();
          this._socket.write(list[0]);
          this._socket.write(list[1], cb);
          this._socket.uncork();
        } else {
          this._socket.write(list[0], cb);
        }
      }
    };
    module2.exports = Sender2;
  }
});

// node_modules/ws/lib/event-target.js
var require_event_target = __commonJS({
  "node_modules/ws/lib/event-target.js"(exports2, module2) {
    "use strict";
    var { kForOnEventAttribute, kListener } = require_constants();
    var kCode = Symbol("kCode");
    var kData = Symbol("kData");
    var kError = Symbol("kError");
    var kMessage = Symbol("kMessage");
    var kReason = Symbol("kReason");
    var kTarget = Symbol("kTarget");
    var kType = Symbol("kType");
    var kWasClean = Symbol("kWasClean");
    var Event = class Event {
      static {
        __name(this, "Event");
      }
      /**
      * Create a new `Event`.
      *
      * @param {String} type The name of the event
      * @throws {TypeError} If the `type` argument is not specified
      */
      constructor(type) {
        this[kTarget] = null;
        this[kType] = type;
      }
      /**
      * @type {*}
      */
      get target() {
        return this[kTarget];
      }
      /**
      * @type {String}
      */
      get type() {
        return this[kType];
      }
    };
    Object.defineProperty(Event.prototype, "target", {
      enumerable: true
    });
    Object.defineProperty(Event.prototype, "type", {
      enumerable: true
    });
    var CloseEvent = class CloseEvent extends Event {
      static {
        __name(this, "CloseEvent");
      }
      /**
      * Create a new `CloseEvent`.
      *
      * @param {String} type The name of the event
      * @param {Object} [options] A dictionary object that allows for setting
      *     attributes via object members of the same name
      * @param {Number} [options.code=0] The status code explaining why the
      *     connection was closed
      * @param {String} [options.reason=''] A human-readable string explaining why
      *     the connection was closed
      * @param {Boolean} [options.wasClean=false] Indicates whether or not the
      *     connection was cleanly closed
      */
      constructor(type, options = {}) {
        super(type);
        this[kCode] = options.code === void 0 ? 0 : options.code;
        this[kReason] = options.reason === void 0 ? "" : options.reason;
        this[kWasClean] = options.wasClean === void 0 ? false : options.wasClean;
      }
      /**
      * @type {Number}
      */
      get code() {
        return this[kCode];
      }
      /**
      * @type {String}
      */
      get reason() {
        return this[kReason];
      }
      /**
      * @type {Boolean}
      */
      get wasClean() {
        return this[kWasClean];
      }
    };
    Object.defineProperty(CloseEvent.prototype, "code", {
      enumerable: true
    });
    Object.defineProperty(CloseEvent.prototype, "reason", {
      enumerable: true
    });
    Object.defineProperty(CloseEvent.prototype, "wasClean", {
      enumerable: true
    });
    var ErrorEvent = class ErrorEvent extends Event {
      static {
        __name(this, "ErrorEvent");
      }
      /**
      * Create a new `ErrorEvent`.
      *
      * @param {String} type The name of the event
      * @param {Object} [options] A dictionary object that allows for setting
      *     attributes via object members of the same name
      * @param {*} [options.error=null] The error that generated this event
      * @param {String} [options.message=''] The error message
      */
      constructor(type, options = {}) {
        super(type);
        this[kError] = options.error === void 0 ? null : options.error;
        this[kMessage] = options.message === void 0 ? "" : options.message;
      }
      /**
      * @type {*}
      */
      get error() {
        return this[kError];
      }
      /**
      * @type {String}
      */
      get message() {
        return this[kMessage];
      }
    };
    Object.defineProperty(ErrorEvent.prototype, "error", {
      enumerable: true
    });
    Object.defineProperty(ErrorEvent.prototype, "message", {
      enumerable: true
    });
    var MessageEvent = class MessageEvent extends Event {
      static {
        __name(this, "MessageEvent");
      }
      /**
      * Create a new `MessageEvent`.
      *
      * @param {String} type The name of the event
      * @param {Object} [options] A dictionary object that allows for setting
      *     attributes via object members of the same name
      * @param {*} [options.data=null] The message content
      */
      constructor(type, options = {}) {
        super(type);
        this[kData] = options.data === void 0 ? null : options.data;
      }
      /**
      * @type {*}
      */
      get data() {
        return this[kData];
      }
    };
    Object.defineProperty(MessageEvent.prototype, "data", {
      enumerable: true
    });
    var EventTarget = {
      /**
      * Register an event listener.
      *
      * @param {String} type A string representing the event type to listen for
      * @param {(Function|Object)} handler The listener to add
      * @param {Object} [options] An options object specifies characteristics about
      *     the event listener
      * @param {Boolean} [options.once=false] A `Boolean` indicating that the
      *     listener should be invoked at most once after being added. If `true`,
      *     the listener would be automatically removed when invoked.
      * @public
      */
      addEventListener(type, handler, options = {}) {
        for (const listener of this.listeners(type)) {
          if (!options[kForOnEventAttribute] && listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            return;
          }
        }
        let wrapper;
        if (type === "message") {
          wrapper = /* @__PURE__ */ __name(function onMessage(data, isBinary2) {
            const event = new MessageEvent("message", {
              data: isBinary2 ? data : data.toString()
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          }, "onMessage");
        } else if (type === "close") {
          wrapper = /* @__PURE__ */ __name(function onClose(code, message) {
            const event = new CloseEvent("close", {
              code,
              reason: message.toString(),
              wasClean: this._closeFrameReceived && this._closeFrameSent
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          }, "onClose");
        } else if (type === "error") {
          wrapper = /* @__PURE__ */ __name(function onError(error) {
            const event = new ErrorEvent("error", {
              error,
              message: error.message
            });
            event[kTarget] = this;
            callListener(handler, this, event);
          }, "onError");
        } else if (type === "open") {
          wrapper = /* @__PURE__ */ __name(function onOpen() {
            const event = new Event("open");
            event[kTarget] = this;
            callListener(handler, this, event);
          }, "onOpen");
        } else {
          return;
        }
        wrapper[kForOnEventAttribute] = !!options[kForOnEventAttribute];
        wrapper[kListener] = handler;
        if (options.once) {
          this.once(type, wrapper);
        } else {
          this.on(type, wrapper);
        }
      },
      /**
      * Remove an event listener.
      *
      * @param {String} type A string representing the event type to remove
      * @param {(Function|Object)} handler The listener to remove
      * @public
      */
      removeEventListener(type, handler) {
        for (const listener of this.listeners(type)) {
          if (listener[kListener] === handler && !listener[kForOnEventAttribute]) {
            this.removeListener(type, listener);
            break;
          }
        }
      }
    };
    module2.exports = {
      CloseEvent,
      ErrorEvent,
      Event,
      EventTarget,
      MessageEvent
    };
    function callListener(listener, thisArg, event) {
      if (typeof listener === "object" && listener.handleEvent) {
        listener.handleEvent.call(listener, event);
      } else {
        listener.call(thisArg, event);
      }
    }
    __name(callListener, "callListener");
  }
});

// node_modules/ws/lib/extension.js
var require_extension = __commonJS({
  "node_modules/ws/lib/extension.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function push(dest, name, elem) {
      if (dest[name] === void 0) dest[name] = [
        elem
      ];
      else dest[name].push(elem);
    }
    __name(push, "push");
    function parse5(header) {
      const offers = /* @__PURE__ */ Object.create(null);
      let params2 = /* @__PURE__ */ Object.create(null);
      let mustUnescape = false;
      let isEscaping = false;
      let inQuotes = false;
      let extensionName;
      let paramName;
      let start = -1;
      let code = -1;
      let end = -1;
      let i = 0;
      for (; i < header.length; i++) {
        code = header.charCodeAt(i);
        if (extensionName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (i !== 0 && (code === 32 || code === 9)) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            const name = header.slice(start, end);
            if (code === 44) {
              push(offers, name, params2);
              params2 = /* @__PURE__ */ Object.create(null);
            } else {
              extensionName = name;
            }
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else if (paramName === void 0) {
          if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (code === 32 || code === 9) {
            if (end === -1 && start !== -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            push(params2, header.slice(start, end), true);
            if (code === 44) {
              push(offers, extensionName, params2);
              params2 = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            start = end = -1;
          } else if (code === 61 && start !== -1 && end === -1) {
            paramName = header.slice(start, i);
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        } else {
          if (isEscaping) {
            if (tokenChars[code] !== 1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (start === -1) start = i;
            else if (!mustUnescape) mustUnescape = true;
            isEscaping = false;
          } else if (inQuotes) {
            if (tokenChars[code] === 1) {
              if (start === -1) start = i;
            } else if (code === 34 && start !== -1) {
              inQuotes = false;
              end = i;
            } else if (code === 92) {
              isEscaping = true;
            } else {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
          } else if (code === 34 && header.charCodeAt(i - 1) === 61) {
            inQuotes = true;
          } else if (end === -1 && tokenChars[code] === 1) {
            if (start === -1) start = i;
          } else if (start !== -1 && (code === 32 || code === 9)) {
            if (end === -1) end = i;
          } else if (code === 59 || code === 44) {
            if (start === -1) {
              throw new SyntaxError(`Unexpected character at index ${i}`);
            }
            if (end === -1) end = i;
            let value2 = header.slice(start, end);
            if (mustUnescape) {
              value2 = value2.replace(/\\/g, "");
              mustUnescape = false;
            }
            push(params2, paramName, value2);
            if (code === 44) {
              push(offers, extensionName, params2);
              params2 = /* @__PURE__ */ Object.create(null);
              extensionName = void 0;
            }
            paramName = void 0;
            start = end = -1;
          } else {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
        }
      }
      if (start === -1 || inQuotes || code === 32 || code === 9) {
        throw new SyntaxError("Unexpected end of input");
      }
      if (end === -1) end = i;
      const token2 = header.slice(start, end);
      if (extensionName === void 0) {
        push(offers, token2, params2);
      } else {
        if (paramName === void 0) {
          push(params2, token2, true);
        } else if (mustUnescape) {
          push(params2, paramName, token2.replace(/\\/g, ""));
        } else {
          push(params2, paramName, token2);
        }
        push(offers, extensionName, params2);
      }
      return offers;
    }
    __name(parse5, "parse");
    function format5(extensions) {
      return Object.keys(extensions).map((extension) => {
        let configurations = extensions[extension];
        if (!Array.isArray(configurations)) configurations = [
          configurations
        ];
        return configurations.map((params2) => {
          return [
            extension
          ].concat(Object.keys(params2).map((k) => {
            let values = params2[k];
            if (!Array.isArray(values)) values = [
              values
            ];
            return values.map((v) => v === true ? k : `${k}=${v}`).join("; ");
          })).join("; ");
        }).join(", ");
      }).join(", ");
    }
    __name(format5, "format");
    module2.exports = {
      format: format5,
      parse: parse5
    };
  }
});

// node_modules/ws/lib/websocket.js
var require_websocket = __commonJS({
  "node_modules/ws/lib/websocket.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var https = require("https");
    var http = require("http");
    var net = require("net");
    var tls = require("tls");
    var { randomBytes, createHash } = require("crypto");
    var { Duplex, Readable } = require("stream");
    var { URL: URL3 } = require("url");
    var PerMessageDeflate = require_permessage_deflate();
    var Receiver2 = require_receiver();
    var Sender2 = require_sender();
    var { BINARY_TYPES, EMPTY_BUFFER, GUID, kForOnEventAttribute, kListener, kStatusCode, kWebSocket, NOOP } = require_constants();
    var { EventTarget: { addEventListener: addEventListener2, removeEventListener: removeEventListener2 } } = require_event_target();
    var { format: format5, parse: parse5 } = require_extension();
    var { toBuffer: toBuffer2 } = require_buffer_util();
    var closeTimeout = 30 * 1e3;
    var kAborted = Symbol("kAborted");
    var protocolVersions = [
      8,
      13
    ];
    var readyStates = [
      "CONNECTING",
      "OPEN",
      "CLOSING",
      "CLOSED"
    ];
    var subprotocolRegex = /^[!#$%&'*+\-.0-9A-Z^_`|a-z~]+$/;
    var WebSocket2 = class WebSocket3 extends EventEmitter {
      static {
        __name(this, "WebSocket");
      }
      /**
      * Create a new `WebSocket`.
      *
      * @param {(String|URL)} address The URL to which to connect
      * @param {(String|String[])} [protocols] The subprotocols
      * @param {Object} [options] Connection options
      */
      constructor(address, protocols, options) {
        super();
        this._binaryType = BINARY_TYPES[0];
        this._closeCode = 1006;
        this._closeFrameReceived = false;
        this._closeFrameSent = false;
        this._closeMessage = EMPTY_BUFFER;
        this._closeTimer = null;
        this._extensions = {};
        this._paused = false;
        this._protocol = "";
        this._readyState = WebSocket3.CONNECTING;
        this._receiver = null;
        this._sender = null;
        this._socket = null;
        if (address !== null) {
          this._bufferedAmount = 0;
          this._isServer = false;
          this._redirects = 0;
          if (protocols === void 0) {
            protocols = [];
          } else if (!Array.isArray(protocols)) {
            if (typeof protocols === "object" && protocols !== null) {
              options = protocols;
              protocols = [];
            } else {
              protocols = [
                protocols
              ];
            }
          }
          initAsClient(this, address, protocols, options);
        } else {
          this._autoPong = options.autoPong;
          this._isServer = true;
        }
      }
      /**
      * This deviates from the WHATWG interface since ws doesn't support the
      * required default "blob" type (instead we define a custom "nodebuffer"
      * type).
      *
      * @type {String}
      */
      get binaryType() {
        return this._binaryType;
      }
      set binaryType(type) {
        if (!BINARY_TYPES.includes(type)) return;
        this._binaryType = type;
        if (this._receiver) this._receiver._binaryType = type;
      }
      /**
      * @type {Number}
      */
      get bufferedAmount() {
        if (!this._socket) return this._bufferedAmount;
        return this._socket._writableState.length + this._sender._bufferedBytes;
      }
      /**
      * @type {String}
      */
      get extensions() {
        return Object.keys(this._extensions).join();
      }
      /**
      * @type {Boolean}
      */
      get isPaused() {
        return this._paused;
      }
      /**
      * @type {Function}
      */
      /* istanbul ignore next */
      get onclose() {
        return null;
      }
      /**
      * @type {Function}
      */
      /* istanbul ignore next */
      get onerror() {
        return null;
      }
      /**
      * @type {Function}
      */
      /* istanbul ignore next */
      get onopen() {
        return null;
      }
      /**
      * @type {Function}
      */
      /* istanbul ignore next */
      get onmessage() {
        return null;
      }
      /**
      * @type {String}
      */
      get protocol() {
        return this._protocol;
      }
      /**
      * @type {Number}
      */
      get readyState() {
        return this._readyState;
      }
      /**
      * @type {String}
      */
      get url() {
        return this._url;
      }
      /**
      * Set up the socket and the internal resources.
      *
      * @param {Duplex} socket The network socket between the server and client
      * @param {Buffer} head The first packet of the upgraded stream
      * @param {Object} options Options object
      * @param {Boolean} [options.allowSynchronousEvents=false] Specifies whether
      *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
      *     multiple times in the same tick
      * @param {Function} [options.generateMask] The function used to generate the
      *     masking key
      * @param {Number} [options.maxPayload=0] The maximum allowed message size
      * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
      *     not to skip UTF-8 validation for text and close messages
      * @private
      */
      setSocket(socket, head, options) {
        const receiver = new Receiver2({
          allowSynchronousEvents: options.allowSynchronousEvents,
          binaryType: this.binaryType,
          extensions: this._extensions,
          isServer: this._isServer,
          maxPayload: options.maxPayload,
          skipUTF8Validation: options.skipUTF8Validation
        });
        this._sender = new Sender2(socket, this._extensions, options.generateMask);
        this._receiver = receiver;
        this._socket = socket;
        receiver[kWebSocket] = this;
        socket[kWebSocket] = this;
        receiver.on("conclude", receiverOnConclude);
        receiver.on("drain", receiverOnDrain);
        receiver.on("error", receiverOnError);
        receiver.on("message", receiverOnMessage);
        receiver.on("ping", receiverOnPing);
        receiver.on("pong", receiverOnPong);
        if (socket.setTimeout) socket.setTimeout(0);
        if (socket.setNoDelay) socket.setNoDelay();
        if (head.length > 0) socket.unshift(head);
        socket.on("close", socketOnClose);
        socket.on("data", socketOnData);
        socket.on("end", socketOnEnd);
        socket.on("error", socketOnError);
        this._readyState = WebSocket3.OPEN;
        this.emit("open");
      }
      /**
      * Emit the `'close'` event.
      *
      * @private
      */
      emitClose() {
        if (!this._socket) {
          this._readyState = WebSocket3.CLOSED;
          this.emit("close", this._closeCode, this._closeMessage);
          return;
        }
        if (this._extensions[PerMessageDeflate.extensionName]) {
          this._extensions[PerMessageDeflate.extensionName].cleanup();
        }
        this._receiver.removeAllListeners();
        this._readyState = WebSocket3.CLOSED;
        this.emit("close", this._closeCode, this._closeMessage);
      }
      /**
      * Start a closing handshake.
      *
      *          +----------+   +-----------+   +----------+
      *     - - -|ws.close()|-->|close frame|-->|ws.close()|- - -
      *    |     +----------+   +-----------+   +----------+     |
      *          +----------+   +-----------+         |
      * CLOSING  |ws.close()|<--|close frame|<--+-----+       CLOSING
      *          +----------+   +-----------+   |
      *    |           |                        |   +---+        |
      *                +------------------------+-->|fin| - - - -
      *    |         +---+                      |   +---+
      *     - - - - -|fin|<---------------------+
      *              +---+
      *
      * @param {Number} [code] Status code explaining why the connection is closing
      * @param {(String|Buffer)} [data] The reason why the connection is
      *     closing
      * @public
      */
      close(code, data) {
        if (this.readyState === WebSocket3.CLOSED) return;
        if (this.readyState === WebSocket3.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this.readyState === WebSocket3.CLOSING) {
          if (this._closeFrameSent && (this._closeFrameReceived || this._receiver._writableState.errorEmitted)) {
            this._socket.end();
          }
          return;
        }
        this._readyState = WebSocket3.CLOSING;
        this._sender.close(code, data, !this._isServer, (err) => {
          if (err) return;
          this._closeFrameSent = true;
          if (this._closeFrameReceived || this._receiver._writableState.errorEmitted) {
            this._socket.end();
          }
        });
        this._closeTimer = setTimeout(this._socket.destroy.bind(this._socket), closeTimeout);
      }
      /**
      * Pause the socket.
      *
      * @public
      */
      pause() {
        if (this.readyState === WebSocket3.CONNECTING || this.readyState === WebSocket3.CLOSED) {
          return;
        }
        this._paused = true;
        this._socket.pause();
      }
      /**
      * Send a ping.
      *
      * @param {*} [data] The data to send
      * @param {Boolean} [mask] Indicates whether or not to mask `data`
      * @param {Function} [cb] Callback which is executed when the ping is sent
      * @public
      */
      ping(data, mask, cb) {
        if (this.readyState === WebSocket3.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket3.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.ping(data || EMPTY_BUFFER, mask, cb);
      }
      /**
      * Send a pong.
      *
      * @param {*} [data] The data to send
      * @param {Boolean} [mask] Indicates whether or not to mask `data`
      * @param {Function} [cb] Callback which is executed when the pong is sent
      * @public
      */
      pong(data, mask, cb) {
        if (this.readyState === WebSocket3.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof data === "function") {
          cb = data;
          data = mask = void 0;
        } else if (typeof mask === "function") {
          cb = mask;
          mask = void 0;
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket3.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        if (mask === void 0) mask = !this._isServer;
        this._sender.pong(data || EMPTY_BUFFER, mask, cb);
      }
      /**
      * Resume the socket.
      *
      * @public
      */
      resume() {
        if (this.readyState === WebSocket3.CONNECTING || this.readyState === WebSocket3.CLOSED) {
          return;
        }
        this._paused = false;
        if (!this._receiver._writableState.needDrain) this._socket.resume();
      }
      /**
      * Send a data message.
      *
      * @param {*} data The message to send
      * @param {Object} [options] Options object
      * @param {Boolean} [options.binary] Specifies whether `data` is binary or
      *     text
      * @param {Boolean} [options.compress] Specifies whether or not to compress
      *     `data`
      * @param {Boolean} [options.fin=true] Specifies whether the fragment is the
      *     last one
      * @param {Boolean} [options.mask] Specifies whether or not to mask `data`
      * @param {Function} [cb] Callback which is executed when data is written out
      * @public
      */
      send(data, options, cb) {
        if (this.readyState === WebSocket3.CONNECTING) {
          throw new Error("WebSocket is not open: readyState 0 (CONNECTING)");
        }
        if (typeof options === "function") {
          cb = options;
          options = {};
        }
        if (typeof data === "number") data = data.toString();
        if (this.readyState !== WebSocket3.OPEN) {
          sendAfterClose(this, data, cb);
          return;
        }
        const opts = {
          binary: typeof data !== "string",
          mask: !this._isServer,
          compress: true,
          fin: true,
          ...options
        };
        if (!this._extensions[PerMessageDeflate.extensionName]) {
          opts.compress = false;
        }
        this._sender.send(data || EMPTY_BUFFER, opts, cb);
      }
      /**
      * Forcibly close the connection.
      *
      * @public
      */
      terminate() {
        if (this.readyState === WebSocket3.CLOSED) return;
        if (this.readyState === WebSocket3.CONNECTING) {
          const msg = "WebSocket was closed before the connection was established";
          abortHandshake(this, this._req, msg);
          return;
        }
        if (this._socket) {
          this._readyState = WebSocket3.CLOSING;
          this._socket.destroy();
        }
      }
    };
    Object.defineProperty(WebSocket2, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2.prototype, "CONNECTING", {
      enumerable: true,
      value: readyStates.indexOf("CONNECTING")
    });
    Object.defineProperty(WebSocket2, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2.prototype, "OPEN", {
      enumerable: true,
      value: readyStates.indexOf("OPEN")
    });
    Object.defineProperty(WebSocket2, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSING", {
      enumerable: true,
      value: readyStates.indexOf("CLOSING")
    });
    Object.defineProperty(WebSocket2, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    Object.defineProperty(WebSocket2.prototype, "CLOSED", {
      enumerable: true,
      value: readyStates.indexOf("CLOSED")
    });
    [
      "binaryType",
      "bufferedAmount",
      "extensions",
      "isPaused",
      "protocol",
      "readyState",
      "url"
    ].forEach((property) => {
      Object.defineProperty(WebSocket2.prototype, property, {
        enumerable: true
      });
    });
    [
      "open",
      "error",
      "close",
      "message"
    ].forEach((method) => {
      Object.defineProperty(WebSocket2.prototype, `on${method}`, {
        enumerable: true,
        get() {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) return listener[kListener];
          }
          return null;
        },
        set(handler) {
          for (const listener of this.listeners(method)) {
            if (listener[kForOnEventAttribute]) {
              this.removeListener(method, listener);
              break;
            }
          }
          if (typeof handler !== "function") return;
          this.addEventListener(method, handler, {
            [kForOnEventAttribute]: true
          });
        }
      });
    });
    WebSocket2.prototype.addEventListener = addEventListener2;
    WebSocket2.prototype.removeEventListener = removeEventListener2;
    module2.exports = WebSocket2;
    function initAsClient(websocket, address, protocols, options) {
      const opts = {
        allowSynchronousEvents: true,
        autoPong: true,
        protocolVersion: protocolVersions[1],
        maxPayload: 100 * 1024 * 1024,
        skipUTF8Validation: false,
        perMessageDeflate: true,
        followRedirects: false,
        maxRedirects: 10,
        ...options,
        socketPath: void 0,
        hostname: void 0,
        protocol: void 0,
        timeout: void 0,
        method: "GET",
        host: void 0,
        path: void 0,
        port: void 0
      };
      websocket._autoPong = opts.autoPong;
      if (!protocolVersions.includes(opts.protocolVersion)) {
        throw new RangeError(`Unsupported protocol version: ${opts.protocolVersion} (supported versions: ${protocolVersions.join(", ")})`);
      }
      let parsedUrl;
      if (address instanceof URL3) {
        parsedUrl = address;
      } else {
        try {
          parsedUrl = new URL3(address);
        } catch (e) {
          throw new SyntaxError(`Invalid URL: ${address}`);
        }
      }
      if (parsedUrl.protocol === "http:") {
        parsedUrl.protocol = "ws:";
      } else if (parsedUrl.protocol === "https:") {
        parsedUrl.protocol = "wss:";
      }
      websocket._url = parsedUrl.href;
      const isSecure = parsedUrl.protocol === "wss:";
      const isIpcUrl = parsedUrl.protocol === "ws+unix:";
      let invalidUrlMessage;
      if (parsedUrl.protocol !== "ws:" && !isSecure && !isIpcUrl) {
        invalidUrlMessage = `The URL's protocol must be one of "ws:", "wss:", "http:", "https", or "ws+unix:"`;
      } else if (isIpcUrl && !parsedUrl.pathname) {
        invalidUrlMessage = "The URL's pathname is empty";
      } else if (parsedUrl.hash) {
        invalidUrlMessage = "The URL contains a fragment identifier";
      }
      if (invalidUrlMessage) {
        const err = new SyntaxError(invalidUrlMessage);
        if (websocket._redirects === 0) {
          throw err;
        } else {
          emitErrorAndClose(websocket, err);
          return;
        }
      }
      const defaultPort = isSecure ? 443 : 80;
      const key = randomBytes(16).toString("base64");
      const request = isSecure ? https.request : http.request;
      const protocolSet = /* @__PURE__ */ new Set();
      let perMessageDeflate;
      opts.createConnection = opts.createConnection || (isSecure ? tlsConnect : netConnect);
      opts.defaultPort = opts.defaultPort || defaultPort;
      opts.port = parsedUrl.port || defaultPort;
      opts.host = parsedUrl.hostname.startsWith("[") ? parsedUrl.hostname.slice(1, -1) : parsedUrl.hostname;
      opts.headers = {
        ...opts.headers,
        "Sec-WebSocket-Version": opts.protocolVersion,
        "Sec-WebSocket-Key": key,
        Connection: "Upgrade",
        Upgrade: "websocket"
      };
      opts.path = parsedUrl.pathname + parsedUrl.search;
      opts.timeout = opts.handshakeTimeout;
      if (opts.perMessageDeflate) {
        perMessageDeflate = new PerMessageDeflate(opts.perMessageDeflate !== true ? opts.perMessageDeflate : {}, false, opts.maxPayload);
        opts.headers["Sec-WebSocket-Extensions"] = format5({
          [PerMessageDeflate.extensionName]: perMessageDeflate.offer()
        });
      }
      if (protocols.length) {
        for (const protocol4 of protocols) {
          if (typeof protocol4 !== "string" || !subprotocolRegex.test(protocol4) || protocolSet.has(protocol4)) {
            throw new SyntaxError("An invalid or duplicated subprotocol was specified");
          }
          protocolSet.add(protocol4);
        }
        opts.headers["Sec-WebSocket-Protocol"] = protocols.join(",");
      }
      if (opts.origin) {
        if (opts.protocolVersion < 13) {
          opts.headers["Sec-WebSocket-Origin"] = opts.origin;
        } else {
          opts.headers.Origin = opts.origin;
        }
      }
      if (parsedUrl.username || parsedUrl.password) {
        opts.auth = `${parsedUrl.username}:${parsedUrl.password}`;
      }
      if (isIpcUrl) {
        const parts2 = opts.path.split(":");
        opts.socketPath = parts2[0];
        opts.path = parts2[1];
      }
      let req;
      if (opts.followRedirects) {
        if (websocket._redirects === 0) {
          websocket._originalIpc = isIpcUrl;
          websocket._originalSecure = isSecure;
          websocket._originalHostOrSocketPath = isIpcUrl ? opts.socketPath : parsedUrl.host;
          const headers = options && options.headers;
          options = {
            ...options,
            headers: {}
          };
          if (headers) {
            for (const [key2, value2] of Object.entries(headers)) {
              options.headers[key2.toLowerCase()] = value2;
            }
          }
        } else if (websocket.listenerCount("redirect") === 0) {
          const isSameHost = isIpcUrl ? websocket._originalIpc ? opts.socketPath === websocket._originalHostOrSocketPath : false : websocket._originalIpc ? false : parsedUrl.host === websocket._originalHostOrSocketPath;
          if (!isSameHost || websocket._originalSecure && !isSecure) {
            delete opts.headers.authorization;
            delete opts.headers.cookie;
            if (!isSameHost) delete opts.headers.host;
            opts.auth = void 0;
          }
        }
        if (opts.auth && !options.headers.authorization) {
          options.headers.authorization = "Basic " + Buffer.from(opts.auth).toString("base64");
        }
        req = websocket._req = request(opts);
        if (websocket._redirects) {
          websocket.emit("redirect", websocket.url, req);
        }
      } else {
        req = websocket._req = request(opts);
      }
      if (opts.timeout) {
        req.on("timeout", () => {
          abortHandshake(websocket, req, "Opening handshake has timed out");
        });
      }
      req.on("error", (err) => {
        if (req === null || req[kAborted]) return;
        req = websocket._req = null;
        emitErrorAndClose(websocket, err);
      });
      req.on("response", (res) => {
        const location2 = res.headers.location;
        const statusCode = res.statusCode;
        if (location2 && opts.followRedirects && statusCode >= 300 && statusCode < 400) {
          if (++websocket._redirects > opts.maxRedirects) {
            abortHandshake(websocket, req, "Maximum redirects exceeded");
            return;
          }
          req.abort();
          let addr;
          try {
            addr = new URL3(location2, address);
          } catch (e) {
            const err = new SyntaxError(`Invalid URL: ${location2}`);
            emitErrorAndClose(websocket, err);
            return;
          }
          initAsClient(websocket, addr, protocols, options);
        } else if (!websocket.emit("unexpected-response", req, res)) {
          abortHandshake(websocket, req, `Unexpected server response: ${res.statusCode}`);
        }
      });
      req.on("upgrade", (res, socket, head) => {
        websocket.emit("upgrade", res);
        if (websocket.readyState !== WebSocket2.CONNECTING) return;
        req = websocket._req = null;
        const upgrade = res.headers.upgrade;
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          abortHandshake(websocket, socket, "Invalid Upgrade header");
          return;
        }
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        if (res.headers["sec-websocket-accept"] !== digest) {
          abortHandshake(websocket, socket, "Invalid Sec-WebSocket-Accept header");
          return;
        }
        const serverProt = res.headers["sec-websocket-protocol"];
        let protError;
        if (serverProt !== void 0) {
          if (!protocolSet.size) {
            protError = "Server sent a subprotocol but none was requested";
          } else if (!protocolSet.has(serverProt)) {
            protError = "Server sent an invalid subprotocol";
          }
        } else if (protocolSet.size) {
          protError = "Server sent no subprotocol";
        }
        if (protError) {
          abortHandshake(websocket, socket, protError);
          return;
        }
        if (serverProt) websocket._protocol = serverProt;
        const secWebSocketExtensions = res.headers["sec-websocket-extensions"];
        if (secWebSocketExtensions !== void 0) {
          if (!perMessageDeflate) {
            const message = "Server sent a Sec-WebSocket-Extensions header but no extension was requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          let extensions;
          try {
            extensions = parse5(secWebSocketExtensions);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          const extensionNames = Object.keys(extensions);
          if (extensionNames.length !== 1 || extensionNames[0] !== PerMessageDeflate.extensionName) {
            const message = "Server indicated an extension that was not requested";
            abortHandshake(websocket, socket, message);
            return;
          }
          try {
            perMessageDeflate.accept(extensions[PerMessageDeflate.extensionName]);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Extensions header";
            abortHandshake(websocket, socket, message);
            return;
          }
          websocket._extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
        }
        websocket.setSocket(socket, head, {
          allowSynchronousEvents: opts.allowSynchronousEvents,
          generateMask: opts.generateMask,
          maxPayload: opts.maxPayload,
          skipUTF8Validation: opts.skipUTF8Validation
        });
      });
      if (opts.finishRequest) {
        opts.finishRequest(req, websocket);
      } else {
        req.end();
      }
    }
    __name(initAsClient, "initAsClient");
    function emitErrorAndClose(websocket, err) {
      websocket._readyState = WebSocket2.CLOSING;
      websocket.emit("error", err);
      websocket.emitClose();
    }
    __name(emitErrorAndClose, "emitErrorAndClose");
    function netConnect(options) {
      options.path = options.socketPath;
      return net.connect(options);
    }
    __name(netConnect, "netConnect");
    function tlsConnect(options) {
      options.path = void 0;
      if (!options.servername && options.servername !== "") {
        options.servername = net.isIP(options.host) ? "" : options.host;
      }
      return tls.connect(options);
    }
    __name(tlsConnect, "tlsConnect");
    function abortHandshake(websocket, stream, message) {
      websocket._readyState = WebSocket2.CLOSING;
      const err = new Error(message);
      Error.captureStackTrace(err, abortHandshake);
      if (stream.setHeader) {
        stream[kAborted] = true;
        stream.abort();
        if (stream.socket && !stream.socket.destroyed) {
          stream.socket.destroy();
        }
        process.nextTick(emitErrorAndClose, websocket, err);
      } else {
        stream.destroy(err);
        stream.once("error", websocket.emit.bind(websocket, "error"));
        stream.once("close", websocket.emitClose.bind(websocket));
      }
    }
    __name(abortHandshake, "abortHandshake");
    function sendAfterClose(websocket, data, cb) {
      if (data) {
        const length = toBuffer2(data).length;
        if (websocket._socket) websocket._sender._bufferedBytes += length;
        else websocket._bufferedAmount += length;
      }
      if (cb) {
        const err = new Error(`WebSocket is not open: readyState ${websocket.readyState} (${readyStates[websocket.readyState]})`);
        process.nextTick(cb, err);
      }
    }
    __name(sendAfterClose, "sendAfterClose");
    function receiverOnConclude(code, reason) {
      const websocket = this[kWebSocket];
      websocket._closeFrameReceived = true;
      websocket._closeMessage = reason;
      websocket._closeCode = code;
      if (websocket._socket[kWebSocket] === void 0) return;
      websocket._socket.removeListener("data", socketOnData);
      process.nextTick(resume, websocket._socket);
      if (code === 1005) websocket.close();
      else websocket.close(code, reason);
    }
    __name(receiverOnConclude, "receiverOnConclude");
    function receiverOnDrain() {
      const websocket = this[kWebSocket];
      if (!websocket.isPaused) websocket._socket.resume();
    }
    __name(receiverOnDrain, "receiverOnDrain");
    function receiverOnError(err) {
      const websocket = this[kWebSocket];
      if (websocket._socket[kWebSocket] !== void 0) {
        websocket._socket.removeListener("data", socketOnData);
        process.nextTick(resume, websocket._socket);
        websocket.close(err[kStatusCode]);
      }
      websocket.emit("error", err);
    }
    __name(receiverOnError, "receiverOnError");
    function receiverOnFinish() {
      this[kWebSocket].emitClose();
    }
    __name(receiverOnFinish, "receiverOnFinish");
    function receiverOnMessage(data, isBinary2) {
      this[kWebSocket].emit("message", data, isBinary2);
    }
    __name(receiverOnMessage, "receiverOnMessage");
    function receiverOnPing(data) {
      const websocket = this[kWebSocket];
      if (websocket._autoPong) websocket.pong(data, !this._isServer, NOOP);
      websocket.emit("ping", data);
    }
    __name(receiverOnPing, "receiverOnPing");
    function receiverOnPong(data) {
      this[kWebSocket].emit("pong", data);
    }
    __name(receiverOnPong, "receiverOnPong");
    function resume(stream) {
      stream.resume();
    }
    __name(resume, "resume");
    function socketOnClose() {
      const websocket = this[kWebSocket];
      this.removeListener("close", socketOnClose);
      this.removeListener("data", socketOnData);
      this.removeListener("end", socketOnEnd);
      websocket._readyState = WebSocket2.CLOSING;
      let chunk;
      if (!this._readableState.endEmitted && !websocket._closeFrameReceived && !websocket._receiver._writableState.errorEmitted && (chunk = websocket._socket.read()) !== null) {
        websocket._receiver.write(chunk);
      }
      websocket._receiver.end();
      this[kWebSocket] = void 0;
      clearTimeout(websocket._closeTimer);
      if (websocket._receiver._writableState.finished || websocket._receiver._writableState.errorEmitted) {
        websocket.emitClose();
      } else {
        websocket._receiver.on("error", receiverOnFinish);
        websocket._receiver.on("finish", receiverOnFinish);
      }
    }
    __name(socketOnClose, "socketOnClose");
    function socketOnData(chunk) {
      if (!this[kWebSocket]._receiver.write(chunk)) {
        this.pause();
      }
    }
    __name(socketOnData, "socketOnData");
    function socketOnEnd() {
      const websocket = this[kWebSocket];
      websocket._readyState = WebSocket2.CLOSING;
      websocket._receiver.end();
      this.end();
    }
    __name(socketOnEnd, "socketOnEnd");
    function socketOnError() {
      const websocket = this[kWebSocket];
      this.removeListener("error", socketOnError);
      this.on("error", NOOP);
      if (websocket) {
        websocket._readyState = WebSocket2.CLOSING;
        this.destroy();
      }
    }
    __name(socketOnError, "socketOnError");
  }
});

// node_modules/ws/lib/subprotocol.js
var require_subprotocol = __commonJS({
  "node_modules/ws/lib/subprotocol.js"(exports2, module2) {
    "use strict";
    var { tokenChars } = require_validation();
    function parse5(header) {
      const protocols = /* @__PURE__ */ new Set();
      let start = -1;
      let end = -1;
      let i = 0;
      for (i; i < header.length; i++) {
        const code = header.charCodeAt(i);
        if (end === -1 && tokenChars[code] === 1) {
          if (start === -1) start = i;
        } else if (i !== 0 && (code === 32 || code === 9)) {
          if (end === -1 && start !== -1) end = i;
        } else if (code === 44) {
          if (start === -1) {
            throw new SyntaxError(`Unexpected character at index ${i}`);
          }
          if (end === -1) end = i;
          const protocol5 = header.slice(start, end);
          if (protocols.has(protocol5)) {
            throw new SyntaxError(`The "${protocol5}" subprotocol is duplicated`);
          }
          protocols.add(protocol5);
          start = end = -1;
        } else {
          throw new SyntaxError(`Unexpected character at index ${i}`);
        }
      }
      if (start === -1 || end !== -1) {
        throw new SyntaxError("Unexpected end of input");
      }
      const protocol4 = header.slice(start, i);
      if (protocols.has(protocol4)) {
        throw new SyntaxError(`The "${protocol4}" subprotocol is duplicated`);
      }
      protocols.add(protocol4);
      return protocols;
    }
    __name(parse5, "parse");
    module2.exports = {
      parse: parse5
    };
  }
});

// node_modules/ws/lib/websocket-server.js
var require_websocket_server = __commonJS({
  "node_modules/ws/lib/websocket-server.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var http = require("http");
    var { Duplex } = require("stream");
    var { createHash } = require("crypto");
    var extension = require_extension();
    var PerMessageDeflate = require_permessage_deflate();
    var subprotocol = require_subprotocol();
    var WebSocket2 = require_websocket();
    var { GUID, kWebSocket } = require_constants();
    var keyRegex = /^[+/0-9A-Za-z]{22}==$/;
    var RUNNING = 0;
    var CLOSING = 1;
    var CLOSED = 2;
    var WebSocketServer2 = class WebSocketServer extends EventEmitter {
      static {
        __name(this, "WebSocketServer");
      }
      /**
      * Create a `WebSocketServer` instance.
      *
      * @param {Object} options Configuration options
      * @param {Boolean} [options.allowSynchronousEvents=true] Specifies whether
      *     any of the `'message'`, `'ping'`, and `'pong'` events can be emitted
      *     multiple times in the same tick
      * @param {Boolean} [options.autoPong=true] Specifies whether or not to
      *     automatically send a pong in response to a ping
      * @param {Number} [options.backlog=511] The maximum length of the queue of
      *     pending connections
      * @param {Boolean} [options.clientTracking=true] Specifies whether or not to
      *     track clients
      * @param {Function} [options.handleProtocols] A hook to handle protocols
      * @param {String} [options.host] The hostname where to bind the server
      * @param {Number} [options.maxPayload=104857600] The maximum allowed message
      *     size
      * @param {Boolean} [options.noServer=false] Enable no server mode
      * @param {String} [options.path] Accept only connections matching this path
      * @param {(Boolean|Object)} [options.perMessageDeflate=false] Enable/disable
      *     permessage-deflate
      * @param {Number} [options.port] The port where to bind the server
      * @param {(http.Server|https.Server)} [options.server] A pre-created HTTP/S
      *     server to use
      * @param {Boolean} [options.skipUTF8Validation=false] Specifies whether or
      *     not to skip UTF-8 validation for text and close messages
      * @param {Function} [options.verifyClient] A hook to reject connections
      * @param {Function} [options.WebSocket=WebSocket] Specifies the `WebSocket`
      *     class to use. It must be the `WebSocket` class or class that extends it
      * @param {Function} [callback] A listener for the `listening` event
      */
      constructor(options, callback) {
        super();
        options = {
          allowSynchronousEvents: true,
          autoPong: true,
          maxPayload: 100 * 1024 * 1024,
          skipUTF8Validation: false,
          perMessageDeflate: false,
          handleProtocols: null,
          clientTracking: true,
          verifyClient: null,
          noServer: false,
          backlog: null,
          server: null,
          host: null,
          path: null,
          port: null,
          WebSocket: WebSocket2,
          ...options
        };
        if (options.port == null && !options.server && !options.noServer || options.port != null && (options.server || options.noServer) || options.server && options.noServer) {
          throw new TypeError('One and only one of the "port", "server", or "noServer" options must be specified');
        }
        if (options.port != null) {
          this._server = http.createServer((req, res) => {
            const body = http.STATUS_CODES[426];
            res.writeHead(426, {
              "Content-Length": body.length,
              "Content-Type": "text/plain"
            });
            res.end(body);
          });
          this._server.listen(options.port, options.host, options.backlog, callback);
        } else if (options.server) {
          this._server = options.server;
        }
        if (this._server) {
          const emitConnection = this.emit.bind(this, "connection");
          this._removeListeners = addListeners(this._server, {
            listening: this.emit.bind(this, "listening"),
            error: this.emit.bind(this, "error"),
            upgrade: /* @__PURE__ */ __name((req, socket, head) => {
              this.handleUpgrade(req, socket, head, emitConnection);
            }, "upgrade")
          });
        }
        if (options.perMessageDeflate === true) options.perMessageDeflate = {};
        if (options.clientTracking) {
          this.clients = /* @__PURE__ */ new Set();
          this._shouldEmitClose = false;
        }
        this.options = options;
        this._state = RUNNING;
      }
      /**
      * Returns the bound address, the address family name, and port of the server
      * as reported by the operating system if listening on an IP socket.
      * If the server is listening on a pipe or UNIX domain socket, the name is
      * returned as a string.
      *
      * @return {(Object|String|null)} The address of the server
      * @public
      */
      address() {
        if (this.options.noServer) {
          throw new Error('The server is operating in "noServer" mode');
        }
        if (!this._server) return null;
        return this._server.address();
      }
      /**
      * Stop the server from accepting new connections and emit the `'close'` event
      * when all existing connections are closed.
      *
      * @param {Function} [cb] A one-time listener for the `'close'` event
      * @public
      */
      close(cb) {
        if (this._state === CLOSED) {
          if (cb) {
            this.once("close", () => {
              cb(new Error("The server is not running"));
            });
          }
          process.nextTick(emitClose, this);
          return;
        }
        if (cb) this.once("close", cb);
        if (this._state === CLOSING) return;
        this._state = CLOSING;
        if (this.options.noServer || this.options.server) {
          if (this._server) {
            this._removeListeners();
            this._removeListeners = this._server = null;
          }
          if (this.clients) {
            if (!this.clients.size) {
              process.nextTick(emitClose, this);
            } else {
              this._shouldEmitClose = true;
            }
          } else {
            process.nextTick(emitClose, this);
          }
        } else {
          const server = this._server;
          this._removeListeners();
          this._removeListeners = this._server = null;
          server.close(() => {
            emitClose(this);
          });
        }
      }
      /**
      * See if a given request should be handled by this server instance.
      *
      * @param {http.IncomingMessage} req Request object to inspect
      * @return {Boolean} `true` if the request is valid, else `false`
      * @public
      */
      shouldHandle(req) {
        if (this.options.path) {
          const index = req.url.indexOf("?");
          const pathname = index !== -1 ? req.url.slice(0, index) : req.url;
          if (pathname !== this.options.path) return false;
        }
        return true;
      }
      /**
      * Handle a HTTP Upgrade request.
      *
      * @param {http.IncomingMessage} req The request object
      * @param {Duplex} socket The network socket between the server and client
      * @param {Buffer} head The first packet of the upgraded stream
      * @param {Function} cb Callback
      * @public
      */
      handleUpgrade(req, socket, head, cb) {
        socket.on("error", socketOnError);
        const key = req.headers["sec-websocket-key"];
        const upgrade = req.headers.upgrade;
        const version2 = +req.headers["sec-websocket-version"];
        if (req.method !== "GET") {
          const message = "Invalid HTTP method";
          abortHandshakeOrEmitwsClientError(this, req, socket, 405, message);
          return;
        }
        if (upgrade === void 0 || upgrade.toLowerCase() !== "websocket") {
          const message = "Invalid Upgrade header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (key === void 0 || !keyRegex.test(key)) {
          const message = "Missing or invalid Sec-WebSocket-Key header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (version2 !== 8 && version2 !== 13) {
          const message = "Missing or invalid Sec-WebSocket-Version header";
          abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
          return;
        }
        if (!this.shouldHandle(req)) {
          abortHandshake(socket, 400);
          return;
        }
        const secWebSocketProtocol = req.headers["sec-websocket-protocol"];
        let protocols = /* @__PURE__ */ new Set();
        if (secWebSocketProtocol !== void 0) {
          try {
            protocols = subprotocol.parse(secWebSocketProtocol);
          } catch (err) {
            const message = "Invalid Sec-WebSocket-Protocol header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        const secWebSocketExtensions = req.headers["sec-websocket-extensions"];
        const extensions = {};
        if (this.options.perMessageDeflate && secWebSocketExtensions !== void 0) {
          const perMessageDeflate = new PerMessageDeflate(this.options.perMessageDeflate, true, this.options.maxPayload);
          try {
            const offers = extension.parse(secWebSocketExtensions);
            if (offers[PerMessageDeflate.extensionName]) {
              perMessageDeflate.accept(offers[PerMessageDeflate.extensionName]);
              extensions[PerMessageDeflate.extensionName] = perMessageDeflate;
            }
          } catch (err) {
            const message = "Invalid or unacceptable Sec-WebSocket-Extensions header";
            abortHandshakeOrEmitwsClientError(this, req, socket, 400, message);
            return;
          }
        }
        if (this.options.verifyClient) {
          const info = {
            origin: req.headers[`${version2 === 8 ? "sec-websocket-origin" : "origin"}`],
            secure: !!(req.socket.authorized || req.socket.encrypted),
            req
          };
          if (this.options.verifyClient.length === 2) {
            this.options.verifyClient(info, (verified, code, message, headers) => {
              if (!verified) {
                return abortHandshake(socket, code || 401, message, headers);
              }
              this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
            });
            return;
          }
          if (!this.options.verifyClient(info)) return abortHandshake(socket, 401);
        }
        this.completeUpgrade(extensions, key, protocols, req, socket, head, cb);
      }
      /**
      * Upgrade the connection to WebSocket.
      *
      * @param {Object} extensions The accepted extensions
      * @param {String} key The value of the `Sec-WebSocket-Key` header
      * @param {Set} protocols The subprotocols
      * @param {http.IncomingMessage} req The request object
      * @param {Duplex} socket The network socket between the server and client
      * @param {Buffer} head The first packet of the upgraded stream
      * @param {Function} cb Callback
      * @throws {Error} If called more than once with the same socket
      * @private
      */
      completeUpgrade(extensions, key, protocols, req, socket, head, cb) {
        if (!socket.readable || !socket.writable) return socket.destroy();
        if (socket[kWebSocket]) {
          throw new Error("server.handleUpgrade() was called more than once with the same socket, possibly due to a misconfiguration");
        }
        if (this._state > RUNNING) return abortHandshake(socket, 503);
        const digest = createHash("sha1").update(key + GUID).digest("base64");
        const headers = [
          "HTTP/1.1 101 Switching Protocols",
          "Upgrade: websocket",
          "Connection: Upgrade",
          `Sec-WebSocket-Accept: ${digest}`
        ];
        const ws = new this.options.WebSocket(null, void 0, this.options);
        if (protocols.size) {
          const protocol4 = this.options.handleProtocols ? this.options.handleProtocols(protocols, req) : protocols.values().next().value;
          if (protocol4) {
            headers.push(`Sec-WebSocket-Protocol: ${protocol4}`);
            ws._protocol = protocol4;
          }
        }
        if (extensions[PerMessageDeflate.extensionName]) {
          const params2 = extensions[PerMessageDeflate.extensionName].params;
          const value2 = extension.format({
            [PerMessageDeflate.extensionName]: [
              params2
            ]
          });
          headers.push(`Sec-WebSocket-Extensions: ${value2}`);
          ws._extensions = extensions;
        }
        this.emit("headers", headers, req);
        socket.write(headers.concat("\r\n").join("\r\n"));
        socket.removeListener("error", socketOnError);
        ws.setSocket(socket, head, {
          allowSynchronousEvents: this.options.allowSynchronousEvents,
          maxPayload: this.options.maxPayload,
          skipUTF8Validation: this.options.skipUTF8Validation
        });
        if (this.clients) {
          this.clients.add(ws);
          ws.on("close", () => {
            this.clients.delete(ws);
            if (this._shouldEmitClose && !this.clients.size) {
              process.nextTick(emitClose, this);
            }
          });
        }
        cb(ws, req);
      }
    };
    module2.exports = WebSocketServer2;
    function addListeners(server, map) {
      for (const event of Object.keys(map)) server.on(event, map[event]);
      return /* @__PURE__ */ __name(function removeListeners() {
        for (const event of Object.keys(map)) {
          server.removeListener(event, map[event]);
        }
      }, "removeListeners");
    }
    __name(addListeners, "addListeners");
    function emitClose(server) {
      server._state = CLOSED;
      server.emit("close");
    }
    __name(emitClose, "emitClose");
    function socketOnError() {
      this.destroy();
    }
    __name(socketOnError, "socketOnError");
    function abortHandshake(socket, code, message, headers) {
      message = message || http.STATUS_CODES[code];
      headers = {
        Connection: "close",
        "Content-Type": "text/html",
        "Content-Length": Buffer.byteLength(message),
        ...headers
      };
      socket.once("finish", socket.destroy);
      socket.end(`HTTP/1.1 ${code} ${http.STATUS_CODES[code]}\r
` + Object.keys(headers).map((h) => `${h}: ${headers[h]}`).join("\r\n") + "\r\n\r\n" + message);
    }
    __name(abortHandshake, "abortHandshake");
    function abortHandshakeOrEmitwsClientError(server, req, socket, code, message) {
      if (server.listenerCount("wsClientError")) {
        const err = new Error(message);
        Error.captureStackTrace(err, abortHandshakeOrEmitwsClientError);
        server.emit("wsClientError", err, socket, req);
      } else {
        abortHandshake(socket, code, message);
      }
    }
    __name(abortHandshakeOrEmitwsClientError, "abortHandshakeOrEmitwsClientError");
  }
});

// node_modules/ws/wrapper.mjs
var import_stream, import_receiver, import_sender, import_websocket, import_websocket_server;
var init_wrapper = __esm({
  "node_modules/ws/wrapper.mjs"() {
    "use strict";
    import_stream = __toESM(require_stream3(), 1);
    import_receiver = __toESM(require_receiver(), 1);
    import_sender = __toESM(require_sender(), 1);
    import_websocket = __toESM(require_websocket(), 1);
    import_websocket_server = __toESM(require_websocket_server(), 1);
  }
});

// node_modules/engine.io-client/build/esm-debug/transports/websocket.js
var import_debug4, debug4, isReactNative, BaseWS, WebSocketCtor;
var init_websocket = __esm({
  "node_modules/engine.io-client/build/esm-debug/transports/websocket.js"() {
    "use strict";
    init_transport();
    init_util();
    init_esm2();
    init_globals_node();
    import_debug4 = __toESM(require_src(), 1);
    debug4 = (0, import_debug4.default)("engine.io-client:websocket");
    isReactNative = typeof navigator !== "undefined" && typeof navigator.product === "string" && navigator.product.toLowerCase() === "reactnative";
    BaseWS = class extends Transport {
      static {
        __name(this, "BaseWS");
      }
      get name() {
        return "websocket";
      }
      doOpen() {
        const uri = this.uri();
        const protocols = this.opts.protocols;
        const opts = isReactNative ? {} : pick(this.opts, "agent", "perMessageDeflate", "pfx", "key", "passphrase", "cert", "ca", "ciphers", "rejectUnauthorized", "localAddress", "protocolVersion", "origin", "maxPayload", "family", "checkServerIdentity");
        if (this.opts.extraHeaders) {
          opts.headers = this.opts.extraHeaders;
        }
        try {
          this.ws = this.createSocket(uri, protocols, opts);
        } catch (err) {
          return this.emitReserved("error", err);
        }
        this.ws.binaryType = this.socket.binaryType;
        this.addEventListeners();
      }
      /**
       * Adds event listeners to the socket
       *
       * @private
       */
      addEventListeners() {
        this.ws.onopen = () => {
          if (this.opts.autoUnref) {
            this.ws._socket.unref();
          }
          this.onOpen();
        };
        this.ws.onclose = (closeEvent) => this.onClose({
          description: "websocket connection closed",
          context: closeEvent
        });
        this.ws.onmessage = (ev) => this.onData(ev.data);
        this.ws.onerror = (e) => this.onError("websocket error", e);
      }
      write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const lastPacket = i === packets.length - 1;
          encodePacket(packet, this.supportsBinary, (data) => {
            try {
              this.doWrite(packet, data);
            } catch (e) {
              debug4("websocket closed before onclose event");
            }
            if (lastPacket) {
              nextTick(() => {
                this.writable = true;
                this.emitReserved("drain");
              }, this.setTimeoutFn);
            }
          });
        }
      }
      doClose() {
        if (typeof this.ws !== "undefined") {
          this.ws.onerror = () => {
          };
          this.ws.close();
          this.ws = null;
        }
      }
      /**
       * Generates uri for connection.
       *
       * @private
       */
      uri() {
        const schema = this.opts.secure ? "wss" : "ws";
        const query = this.query || {};
        if (this.opts.timestampRequests) {
          query[this.opts.timestampParam] = randomString();
        }
        if (!this.supportsBinary) {
          query.b64 = 1;
        }
        return this.createUri(schema, query);
      }
    };
    WebSocketCtor = globalThisShim.WebSocket || globalThisShim.MozWebSocket;
  }
});

// node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js
var WS;
var init_websocket_node = __esm({
  "node_modules/engine.io-client/build/esm-debug/transports/websocket.node.js"() {
    "use strict";
    init_wrapper();
    init_websocket();
    WS = class extends BaseWS {
      static {
        __name(this, "WS");
      }
      createSocket(uri, protocols, opts) {
        var _a2;
        if ((_a2 = this.socket) === null || _a2 === void 0 ? void 0 : _a2._cookieJar) {
          opts.headers = opts.headers || {};
          opts.headers.cookie = typeof opts.headers.cookie === "string" ? [
            opts.headers.cookie
          ] : opts.headers.cookie || [];
          for (const [name, cookie] of this.socket._cookieJar.cookies) {
            opts.headers.cookie.push(`${name}=${cookie.value}`);
          }
        }
        return new import_websocket.default(uri, protocols, opts);
      }
      doWrite(packet, data) {
        const opts = {};
        if (packet.options) {
          opts.compress = packet.options.compress;
        }
        if (this.opts.perMessageDeflate) {
          const len = (
            // @ts-ignore
            "string" === typeof data ? Buffer.byteLength(data) : data.length
          );
          if (len < this.opts.perMessageDeflate.threshold) {
            opts.compress = false;
          }
        }
        this.ws.send(data, opts);
      }
    };
  }
});

// node_modules/engine.io-client/build/esm-debug/transports/webtransport.js
var import_debug5, debug5, WT;
var init_webtransport = __esm({
  "node_modules/engine.io-client/build/esm-debug/transports/webtransport.js"() {
    "use strict";
    init_transport();
    init_globals_node();
    init_esm2();
    import_debug5 = __toESM(require_src(), 1);
    debug5 = (0, import_debug5.default)("engine.io-client:webtransport");
    WT = class extends Transport {
      static {
        __name(this, "WT");
      }
      get name() {
        return "webtransport";
      }
      doOpen() {
        try {
          this._transport = new WebTransport(this.createUri("https"), this.opts.transportOptions[this.name]);
        } catch (err) {
          return this.emitReserved("error", err);
        }
        this._transport.closed.then(() => {
          debug5("transport closed gracefully");
          this.onClose();
        }).catch((err) => {
          debug5("transport closed due to %s", err);
          this.onError("webtransport error", err);
        });
        this._transport.ready.then(() => {
          this._transport.createBidirectionalStream().then((stream) => {
            const decoderStream = createPacketDecoderStream(Number.MAX_SAFE_INTEGER, this.socket.binaryType);
            const reader = stream.readable.pipeThrough(decoderStream).getReader();
            const encoderStream = createPacketEncoderStream();
            encoderStream.readable.pipeTo(stream.writable);
            this._writer = encoderStream.writable.getWriter();
            const read = /* @__PURE__ */ __name(() => {
              reader.read().then(({ done, value: value2 }) => {
                if (done) {
                  debug5("session is closed");
                  return;
                }
                debug5("received chunk: %o", value2);
                this.onPacket(value2);
                read();
              }).catch((err) => {
                debug5("an error occurred while reading: %s", err);
              });
            }, "read");
            read();
            const packet = {
              type: "open"
            };
            if (this.query.sid) {
              packet.data = `{"sid":"${this.query.sid}"}`;
            }
            this._writer.write(packet).then(() => this.onOpen());
          });
        });
      }
      write(packets) {
        this.writable = false;
        for (let i = 0; i < packets.length; i++) {
          const packet = packets[i];
          const lastPacket = i === packets.length - 1;
          this._writer.write(packet).then(() => {
            if (lastPacket) {
              nextTick(() => {
                this.writable = true;
                this.emitReserved("drain");
              }, this.setTimeoutFn);
            }
          });
        }
      }
      doClose() {
        var _a2;
        (_a2 = this._transport) === null || _a2 === void 0 ? void 0 : _a2.close();
      }
    };
  }
});

// node_modules/engine.io-client/build/esm-debug/transports/index.js
var transports2;
var init_transports = __esm({
  "node_modules/engine.io-client/build/esm-debug/transports/index.js"() {
    "use strict";
    init_polling_xhr_node();
    init_websocket_node();
    init_webtransport();
    transports2 = {
      websocket: WS,
      webtransport: WT,
      polling: XHR
    };
  }
});

// node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js
function parse3(str) {
  if (str.length > 8e3) {
    throw "URI too long";
  }
  const src = str, b = str.indexOf("["), e = str.indexOf("]");
  if (b != -1 && e != -1) {
    str = str.substring(0, b) + str.substring(b, e).replace(/:/g, ";") + str.substring(e, str.length);
  }
  let m = re.exec(str || ""), uri = {}, i = 14;
  while (i--) {
    uri[parts[i]] = m[i] || "";
  }
  if (b != -1 && e != -1) {
    uri.source = src;
    uri.host = uri.host.substring(1, uri.host.length - 1).replace(/;/g, ":");
    uri.authority = uri.authority.replace("[", "").replace("]", "").replace(/;/g, ":");
    uri.ipv6uri = true;
  }
  uri.pathNames = pathNames(uri, uri["path"]);
  uri.queryKey = queryKey(uri, uri["query"]);
  return uri;
}
function pathNames(obj, path) {
  const regx = /\/{2,9}/g, names = path.replace(regx, "/").split("/");
  if (path.slice(0, 1) == "/" || path.length === 0) {
    names.splice(0, 1);
  }
  if (path.slice(-1) == "/") {
    names.splice(names.length - 1, 1);
  }
  return names;
}
function queryKey(uri, query) {
  const data = {};
  query.replace(/(?:^|&)([^&=]*)=?([^&]*)/g, function($0, $1, $2) {
    if ($1) {
      data[$1] = $2;
    }
  });
  return data;
}
var re, parts;
var init_parseuri = __esm({
  "node_modules/engine.io-client/build/esm-debug/contrib/parseuri.js"() {
    "use strict";
    re = /^(?:(?![^:@\/?#]+:[^:@\/]*@)(http|https|ws|wss):\/\/)?((?:(([^:@\/?#]*)(?::([^:@\/?#]*))?)?@)?((?:[a-f0-9]{0,4}:){2,7}[a-f0-9]{0,4}|[^:\/?#]*)(?::(\d*))?)(((\/(?:[^?#](?![^?#\/]*\.[^?#\/.]+(?:[?#]|$)))*\/?)?([^?#\/]*))(?:\?([^#]*))?(?:#(.*))?)/;
    parts = [
      "source",
      "protocol",
      "authority",
      "userInfo",
      "user",
      "password",
      "host",
      "port",
      "relative",
      "path",
      "directory",
      "file",
      "query",
      "anchor"
    ];
    __name(parse3, "parse");
    __name(pathNames, "pathNames");
    __name(queryKey, "queryKey");
  }
});

// node_modules/engine.io-client/build/esm-debug/socket.js
var import_debug6, debug6, withEventListeners, OFFLINE_EVENT_LISTENERS, SocketWithoutUpgrade, SocketWithUpgrade, Socket;
var init_socket = __esm({
  "node_modules/engine.io-client/build/esm-debug/socket.js"() {
    "use strict";
    init_transports();
    init_util();
    init_parseqs();
    init_parseuri();
    init_esm3();
    init_esm2();
    init_globals_node();
    import_debug6 = __toESM(require_src(), 1);
    debug6 = (0, import_debug6.default)("engine.io-client:socket");
    withEventListeners = typeof addEventListener === "function" && typeof removeEventListener === "function";
    OFFLINE_EVENT_LISTENERS = [];
    if (withEventListeners) {
      addEventListener("offline", () => {
        debug6("closing %d connection(s) because the network was lost", OFFLINE_EVENT_LISTENERS.length);
        OFFLINE_EVENT_LISTENERS.forEach((listener) => listener());
      }, false);
    }
    SocketWithoutUpgrade = class _SocketWithoutUpgrade extends Emitter {
      static {
        __name(this, "SocketWithoutUpgrade");
      }
      /**
       * Socket constructor.
       *
       * @param {String|Object} uri - uri or options
       * @param {Object} opts - options
       */
      constructor(uri, opts) {
        super();
        this.binaryType = defaultBinaryType;
        this.writeBuffer = [];
        this._prevBufferLen = 0;
        this._pingInterval = -1;
        this._pingTimeout = -1;
        this._maxPayload = -1;
        this._pingTimeoutTime = Infinity;
        if (uri && "object" === typeof uri) {
          opts = uri;
          uri = null;
        }
        if (uri) {
          const parsedUri = parse3(uri);
          opts.hostname = parsedUri.host;
          opts.secure = parsedUri.protocol === "https" || parsedUri.protocol === "wss";
          opts.port = parsedUri.port;
          if (parsedUri.query) opts.query = parsedUri.query;
        } else if (opts.host) {
          opts.hostname = parse3(opts.host).host;
        }
        installTimerFunctions(this, opts);
        this.secure = null != opts.secure ? opts.secure : typeof location !== "undefined" && "https:" === location.protocol;
        if (opts.hostname && !opts.port) {
          opts.port = this.secure ? "443" : "80";
        }
        this.hostname = opts.hostname || (typeof location !== "undefined" ? location.hostname : "localhost");
        this.port = opts.port || (typeof location !== "undefined" && location.port ? location.port : this.secure ? "443" : "80");
        this.transports = [];
        this._transportsByName = {};
        opts.transports.forEach((t) => {
          const transportName = t.prototype.name;
          this.transports.push(transportName);
          this._transportsByName[transportName] = t;
        });
        this.opts = Object.assign({
          path: "/engine.io",
          agent: false,
          withCredentials: false,
          upgrade: true,
          timestampParam: "t",
          rememberUpgrade: false,
          addTrailingSlash: true,
          rejectUnauthorized: true,
          perMessageDeflate: {
            threshold: 1024
          },
          transportOptions: {},
          closeOnBeforeunload: false
        }, opts);
        this.opts.path = this.opts.path.replace(/\/$/, "") + (this.opts.addTrailingSlash ? "/" : "");
        if (typeof this.opts.query === "string") {
          this.opts.query = decode(this.opts.query);
        }
        if (withEventListeners) {
          if (this.opts.closeOnBeforeunload) {
            this._beforeunloadEventListener = () => {
              if (this.transport) {
                this.transport.removeAllListeners();
                this.transport.close();
              }
            };
            addEventListener("beforeunload", this._beforeunloadEventListener, false);
          }
          if (this.hostname !== "localhost") {
            debug6("adding listener for the 'offline' event");
            this._offlineEventListener = () => {
              this._onClose("transport close", {
                description: "network connection lost"
              });
            };
            OFFLINE_EVENT_LISTENERS.push(this._offlineEventListener);
          }
        }
        if (this.opts.withCredentials) {
          this._cookieJar = createCookieJar();
        }
        this._open();
      }
      /**
       * Creates transport of the given type.
       *
       * @param {String} name - transport name
       * @return {Transport}
       * @private
       */
      createTransport(name) {
        debug6('creating transport "%s"', name);
        const query = Object.assign({}, this.opts.query);
        query.EIO = protocol;
        query.transport = name;
        if (this.id) query.sid = this.id;
        const opts = Object.assign({}, this.opts, {
          query,
          socket: this,
          hostname: this.hostname,
          secure: this.secure,
          port: this.port
        }, this.opts.transportOptions[name]);
        debug6("options: %j", opts);
        return new this._transportsByName[name](opts);
      }
      /**
       * Initializes transport to use and starts probe.
       *
       * @private
       */
      _open() {
        if (this.transports.length === 0) {
          this.setTimeoutFn(() => {
            this.emitReserved("error", "No transports available");
          }, 0);
          return;
        }
        const transportName = this.opts.rememberUpgrade && _SocketWithoutUpgrade.priorWebsocketSuccess && this.transports.indexOf("websocket") !== -1 ? "websocket" : this.transports[0];
        this.readyState = "opening";
        const transport = this.createTransport(transportName);
        transport.open();
        this.setTransport(transport);
      }
      /**
       * Sets the current transport. Disables the existing one (if any).
       *
       * @private
       */
      setTransport(transport) {
        debug6("setting transport %s", transport.name);
        if (this.transport) {
          debug6("clearing existing transport %s", this.transport.name);
          this.transport.removeAllListeners();
        }
        this.transport = transport;
        transport.on("drain", this._onDrain.bind(this)).on("packet", this._onPacket.bind(this)).on("error", this._onError.bind(this)).on("close", (reason) => this._onClose("transport close", reason));
      }
      /**
       * Called when connection is deemed open.
       *
       * @private
       */
      onOpen() {
        debug6("socket open");
        this.readyState = "open";
        _SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === this.transport.name;
        this.emitReserved("open");
        this.flush();
      }
      /**
       * Handles a packet.
       *
       * @private
       */
      _onPacket(packet) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          debug6('socket receive: type "%s", data "%s"', packet.type, packet.data);
          this.emitReserved("packet", packet);
          this.emitReserved("heartbeat");
          switch (packet.type) {
            case "open":
              this.onHandshake(JSON.parse(packet.data));
              break;
            case "ping":
              this._sendPacket("pong");
              this.emitReserved("ping");
              this.emitReserved("pong");
              this._resetPingTimeout();
              break;
            case "error":
              const err = new Error("server error");
              err.code = packet.data;
              this._onError(err);
              break;
            case "message":
              this.emitReserved("data", packet.data);
              this.emitReserved("message", packet.data);
              break;
          }
        } else {
          debug6('packet received with socket readyState "%s"', this.readyState);
        }
      }
      /**
       * Called upon handshake completion.
       *
       * @param {Object} data - handshake obj
       * @private
       */
      onHandshake(data) {
        this.emitReserved("handshake", data);
        this.id = data.sid;
        this.transport.query.sid = data.sid;
        this._pingInterval = data.pingInterval;
        this._pingTimeout = data.pingTimeout;
        this._maxPayload = data.maxPayload;
        this.onOpen();
        if ("closed" === this.readyState) return;
        this._resetPingTimeout();
      }
      /**
       * Sets and resets ping timeout timer based on server pings.
       *
       * @private
       */
      _resetPingTimeout() {
        this.clearTimeoutFn(this._pingTimeoutTimer);
        const delay = this._pingInterval + this._pingTimeout;
        this._pingTimeoutTime = Date.now() + delay;
        this._pingTimeoutTimer = this.setTimeoutFn(() => {
          this._onClose("ping timeout");
        }, delay);
        if (this.opts.autoUnref) {
          this._pingTimeoutTimer.unref();
        }
      }
      /**
       * Called on `drain` event
       *
       * @private
       */
      _onDrain() {
        this.writeBuffer.splice(0, this._prevBufferLen);
        this._prevBufferLen = 0;
        if (0 === this.writeBuffer.length) {
          this.emitReserved("drain");
        } else {
          this.flush();
        }
      }
      /**
       * Flush write buffers.
       *
       * @private
       */
      flush() {
        if ("closed" !== this.readyState && this.transport.writable && !this.upgrading && this.writeBuffer.length) {
          const packets = this._getWritablePackets();
          debug6("flushing %d packets in socket", packets.length);
          this.transport.send(packets);
          this._prevBufferLen = packets.length;
          this.emitReserved("flush");
        }
      }
      /**
       * Ensure the encoded size of the writeBuffer is below the maxPayload value sent by the server (only for HTTP
       * long-polling)
       *
       * @private
       */
      _getWritablePackets() {
        const shouldCheckPayloadSize = this._maxPayload && this.transport.name === "polling" && this.writeBuffer.length > 1;
        if (!shouldCheckPayloadSize) {
          return this.writeBuffer;
        }
        let payloadSize = 1;
        for (let i = 0; i < this.writeBuffer.length; i++) {
          const data = this.writeBuffer[i].data;
          if (data) {
            payloadSize += byteLength(data);
          }
          if (i > 0 && payloadSize > this._maxPayload) {
            debug6("only send %d out of %d packets", i, this.writeBuffer.length);
            return this.writeBuffer.slice(0, i);
          }
          payloadSize += 2;
        }
        debug6("payload size is %d (max: %d)", payloadSize, this._maxPayload);
        return this.writeBuffer;
      }
      /**
       * Checks whether the heartbeat timer has expired but the socket has not yet been notified.
       *
       * Note: this method is private for now because it does not really fit the WebSocket API, but if we put it in the
       * `write()` method then the message would not be buffered by the Socket.IO client.
       *
       * @return {boolean}
       * @private
       */
      /* private */
      _hasPingExpired() {
        if (!this._pingTimeoutTime) return true;
        const hasExpired = Date.now() > this._pingTimeoutTime;
        if (hasExpired) {
          debug6("throttled timer detected, scheduling connection close");
          this._pingTimeoutTime = 0;
          nextTick(() => {
            this._onClose("ping timeout");
          }, this.setTimeoutFn);
        }
        return hasExpired;
      }
      /**
       * Sends a message.
       *
       * @param {String} msg - message.
       * @param {Object} options.
       * @param {Function} fn - callback function.
       * @return {Socket} for chaining.
       */
      write(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
      }
      /**
       * Sends a message. Alias of {@link Socket#write}.
       *
       * @param {String} msg - message.
       * @param {Object} options.
       * @param {Function} fn - callback function.
       * @return {Socket} for chaining.
       */
      send(msg, options, fn) {
        this._sendPacket("message", msg, options, fn);
        return this;
      }
      /**
       * Sends a packet.
       *
       * @param {String} type: packet type.
       * @param {String} data.
       * @param {Object} options.
       * @param {Function} fn - callback function.
       * @private
       */
      _sendPacket(type, data, options, fn) {
        if ("function" === typeof data) {
          fn = data;
          data = void 0;
        }
        if ("function" === typeof options) {
          fn = options;
          options = null;
        }
        if ("closing" === this.readyState || "closed" === this.readyState) {
          return;
        }
        options = options || {};
        options.compress = false !== options.compress;
        const packet = {
          type,
          data,
          options
        };
        this.emitReserved("packetCreate", packet);
        this.writeBuffer.push(packet);
        if (fn) this.once("flush", fn);
        this.flush();
      }
      /**
       * Closes the connection.
       */
      close() {
        const close = /* @__PURE__ */ __name(() => {
          this._onClose("forced close");
          debug6("socket closing - telling transport to close");
          this.transport.close();
        }, "close");
        const cleanupAndClose = /* @__PURE__ */ __name(() => {
          this.off("upgrade", cleanupAndClose);
          this.off("upgradeError", cleanupAndClose);
          close();
        }, "cleanupAndClose");
        const waitForUpgrade = /* @__PURE__ */ __name(() => {
          this.once("upgrade", cleanupAndClose);
          this.once("upgradeError", cleanupAndClose);
        }, "waitForUpgrade");
        if ("opening" === this.readyState || "open" === this.readyState) {
          this.readyState = "closing";
          if (this.writeBuffer.length) {
            this.once("drain", () => {
              if (this.upgrading) {
                waitForUpgrade();
              } else {
                close();
              }
            });
          } else if (this.upgrading) {
            waitForUpgrade();
          } else {
            close();
          }
        }
        return this;
      }
      /**
       * Called upon transport error
       *
       * @private
       */
      _onError(err) {
        debug6("socket error %j", err);
        _SocketWithoutUpgrade.priorWebsocketSuccess = false;
        if (this.opts.tryAllTransports && this.transports.length > 1 && this.readyState === "opening") {
          debug6("trying next transport");
          this.transports.shift();
          return this._open();
        }
        this.emitReserved("error", err);
        this._onClose("transport error", err);
      }
      /**
       * Called upon transport close.
       *
       * @private
       */
      _onClose(reason, description) {
        if ("opening" === this.readyState || "open" === this.readyState || "closing" === this.readyState) {
          debug6('socket close with reason: "%s"', reason);
          this.clearTimeoutFn(this._pingTimeoutTimer);
          this.transport.removeAllListeners("close");
          this.transport.close();
          this.transport.removeAllListeners();
          if (withEventListeners) {
            if (this._beforeunloadEventListener) {
              removeEventListener("beforeunload", this._beforeunloadEventListener, false);
            }
            if (this._offlineEventListener) {
              const i = OFFLINE_EVENT_LISTENERS.indexOf(this._offlineEventListener);
              if (i !== -1) {
                debug6("removing listener for the 'offline' event");
                OFFLINE_EVENT_LISTENERS.splice(i, 1);
              }
            }
          }
          this.readyState = "closed";
          this.id = null;
          this.emitReserved("close", reason, description);
          this.writeBuffer = [];
          this._prevBufferLen = 0;
        }
      }
    };
    SocketWithoutUpgrade.protocol = protocol;
    SocketWithUpgrade = class extends SocketWithoutUpgrade {
      static {
        __name(this, "SocketWithUpgrade");
      }
      constructor() {
        super(...arguments);
        this._upgrades = [];
      }
      onOpen() {
        super.onOpen();
        if ("open" === this.readyState && this.opts.upgrade) {
          debug6("starting upgrade probes");
          for (let i = 0; i < this._upgrades.length; i++) {
            this._probe(this._upgrades[i]);
          }
        }
      }
      /**
       * Probes a transport.
       *
       * @param {String} name - transport name
       * @private
       */
      _probe(name) {
        debug6('probing transport "%s"', name);
        let transport = this.createTransport(name);
        let failed = false;
        SocketWithoutUpgrade.priorWebsocketSuccess = false;
        const onTransportOpen = /* @__PURE__ */ __name(() => {
          if (failed) return;
          debug6('probe transport "%s" opened', name);
          transport.send([
            {
              type: "ping",
              data: "probe"
            }
          ]);
          transport.once("packet", (msg) => {
            if (failed) return;
            if ("pong" === msg.type && "probe" === msg.data) {
              debug6('probe transport "%s" pong', name);
              this.upgrading = true;
              this.emitReserved("upgrading", transport);
              if (!transport) return;
              SocketWithoutUpgrade.priorWebsocketSuccess = "websocket" === transport.name;
              debug6('pausing current transport "%s"', this.transport.name);
              this.transport.pause(() => {
                if (failed) return;
                if ("closed" === this.readyState) return;
                debug6("changing transport and sending upgrade packet");
                cleanup();
                this.setTransport(transport);
                transport.send([
                  {
                    type: "upgrade"
                  }
                ]);
                this.emitReserved("upgrade", transport);
                transport = null;
                this.upgrading = false;
                this.flush();
              });
            } else {
              debug6('probe transport "%s" failed', name);
              const err = new Error("probe error");
              err.transport = transport.name;
              this.emitReserved("upgradeError", err);
            }
          });
        }, "onTransportOpen");
        function freezeTransport() {
          if (failed) return;
          failed = true;
          cleanup();
          transport.close();
          transport = null;
        }
        __name(freezeTransport, "freezeTransport");
        const onerror = /* @__PURE__ */ __name((err) => {
          const error = new Error("probe error: " + err);
          error.transport = transport.name;
          freezeTransport();
          debug6('probe transport "%s" failed because of error: %s', name, err);
          this.emitReserved("upgradeError", error);
        }, "onerror");
        function onTransportClose() {
          onerror("transport closed");
        }
        __name(onTransportClose, "onTransportClose");
        function onclose() {
          onerror("socket closed");
        }
        __name(onclose, "onclose");
        function onupgrade(to) {
          if (transport && to.name !== transport.name) {
            debug6('"%s" works - aborting "%s"', to.name, transport.name);
            freezeTransport();
          }
        }
        __name(onupgrade, "onupgrade");
        const cleanup = /* @__PURE__ */ __name(() => {
          transport.removeListener("open", onTransportOpen);
          transport.removeListener("error", onerror);
          transport.removeListener("close", onTransportClose);
          this.off("close", onclose);
          this.off("upgrading", onupgrade);
        }, "cleanup");
        transport.once("open", onTransportOpen);
        transport.once("error", onerror);
        transport.once("close", onTransportClose);
        this.once("close", onclose);
        this.once("upgrading", onupgrade);
        if (this._upgrades.indexOf("webtransport") !== -1 && name !== "webtransport") {
          this.setTimeoutFn(() => {
            if (!failed) {
              transport.open();
            }
          }, 200);
        } else {
          transport.open();
        }
      }
      onHandshake(data) {
        this._upgrades = this._filterUpgrades(data.upgrades);
        super.onHandshake(data);
      }
      /**
       * Filters upgrades, returning only those matching client transports.
       *
       * @param {Array} upgrades - server upgrades
       * @private
       */
      _filterUpgrades(upgrades) {
        const filteredUpgrades = [];
        for (let i = 0; i < upgrades.length; i++) {
          if (~this.transports.indexOf(upgrades[i])) filteredUpgrades.push(upgrades[i]);
        }
        return filteredUpgrades;
      }
    };
    Socket = class extends SocketWithUpgrade {
      static {
        __name(this, "Socket");
      }
      constructor(uri, opts = {}) {
        const o = typeof uri === "object" ? uri : opts;
        if (!o.transports || o.transports && typeof o.transports[0] === "string") {
          o.transports = (o.transports || [
            "polling",
            "websocket",
            "webtransport"
          ]).map((transportName) => transports2[transportName]).filter((t) => !!t);
        }
        super(uri, o);
      }
    };
  }
});

// node_modules/engine.io-client/build/esm-debug/transports/polling-fetch.js
var init_polling_fetch = __esm({
  "node_modules/engine.io-client/build/esm-debug/transports/polling-fetch.js"() {
    "use strict";
    init_polling();
  }
});

// node_modules/engine.io-client/build/esm-debug/index.js
var protocol2;
var init_esm_debug = __esm({
  "node_modules/engine.io-client/build/esm-debug/index.js"() {
    "use strict";
    init_socket();
    init_socket();
    init_transport();
    init_transports();
    init_util();
    init_parseuri();
    init_globals_node();
    init_polling_fetch();
    init_polling_xhr_node();
    init_polling_xhr();
    init_websocket_node();
    init_websocket();
    init_webtransport();
    protocol2 = Socket.protocol;
  }
});

// node_modules/socket.io-client/node_modules/debug/src/common.js
var require_common3 = __commonJS({
  "node_modules/socket.io-client/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug12(...args) {
          if (!debug12.enabled) {
            return;
          }
          const self2 = debug12;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format5) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format5];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        __name(debug12, "debug");
        debug12.namespace = namespace;
        debug12.useColors = createDebug.useColors();
        debug12.color = createDebug.selectColor(namespace);
        debug12.extend = extend;
        debug12.destroy = createDebug.destroy;
        Object.defineProperty(debug12, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug12);
        }
        return debug12;
      }
      __name(createDebug, "createDebug");
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      __name(enable, "enable");
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      __name(toNamespace, "toNamespace");
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce2, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module2.exports = setup;
  }
});

// node_modules/socket.io-client/node_modules/debug/src/browser.js
var require_browser2 = __commonJS({
  "node_modules/socket.io-client/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage, "localstorage");
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/socket.io-client/node_modules/debug/src/node.js
var require_node4 = __commonJS({
  "node_modules/socket.io-client/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [
      6,
      2,
      3,
      4,
      5,
      1
    ];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    __name(log, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init(debug12) {
      debug12.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug12.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    __name(init, "init");
    module2.exports = require_common3()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/socket.io-client/node_modules/debug/src/index.js
var require_src2 = __commonJS({
  "node_modules/socket.io-client/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser2();
    } else {
      module2.exports = require_node4();
    }
  }
});

// node_modules/socket.io-client/build/esm-debug/url.js
function url(uri, path = "", loc) {
  let obj = uri;
  loc = loc || typeof location !== "undefined" && location;
  if (null == uri) uri = loc.protocol + "//" + loc.host;
  if (typeof uri === "string") {
    if ("/" === uri.charAt(0)) {
      if ("/" === uri.charAt(1)) {
        uri = loc.protocol + uri;
      } else {
        uri = loc.host + uri;
      }
    }
    if (!/^(https?|wss?):\/\//.test(uri)) {
      debug7("protocol-less url %s", uri);
      if ("undefined" !== typeof loc) {
        uri = loc.protocol + "//" + uri;
      } else {
        uri = "https://" + uri;
      }
    }
    debug7("parse %s", uri);
    obj = parse3(uri);
  }
  if (!obj.port) {
    if (/^(http|ws)$/.test(obj.protocol)) {
      obj.port = "80";
    } else if (/^(http|ws)s$/.test(obj.protocol)) {
      obj.port = "443";
    }
  }
  obj.path = obj.path || "/";
  const ipv6 = obj.host.indexOf(":") !== -1;
  const host = ipv6 ? "[" + obj.host + "]" : obj.host;
  obj.id = obj.protocol + "://" + host + ":" + obj.port + path;
  obj.href = obj.protocol + "://" + host + (loc && loc.port === obj.port ? "" : ":" + obj.port);
  return obj;
}
var import_debug7, debug7;
var init_url = __esm({
  "node_modules/socket.io-client/build/esm-debug/url.js"() {
    "use strict";
    init_esm_debug();
    import_debug7 = __toESM(require_src2(), 1);
    debug7 = (0, import_debug7.default)("socket.io-client:url");
    __name(url, "url");
  }
});

// node_modules/socket.io-parser/build/esm-debug/is-binary.js
function isBinary(obj) {
  return withNativeArrayBuffer && (obj instanceof ArrayBuffer || isView(obj)) || withNativeBlob && obj instanceof Blob || withNativeFile && obj instanceof File;
}
function hasBinary(obj, toJSON) {
  if (!obj || typeof obj !== "object") {
    return false;
  }
  if (Array.isArray(obj)) {
    for (let i = 0, l = obj.length; i < l; i++) {
      if (hasBinary(obj[i])) {
        return true;
      }
    }
    return false;
  }
  if (isBinary(obj)) {
    return true;
  }
  if (obj.toJSON && typeof obj.toJSON === "function" && arguments.length === 1) {
    return hasBinary(obj.toJSON(), true);
  }
  for (const key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key) && hasBinary(obj[key])) {
      return true;
    }
  }
  return false;
}
var withNativeArrayBuffer, isView, toString, withNativeBlob, withNativeFile;
var init_is_binary = __esm({
  "node_modules/socket.io-parser/build/esm-debug/is-binary.js"() {
    "use strict";
    withNativeArrayBuffer = typeof ArrayBuffer === "function";
    isView = /* @__PURE__ */ __name((obj) => {
      return typeof ArrayBuffer.isView === "function" ? ArrayBuffer.isView(obj) : obj.buffer instanceof ArrayBuffer;
    }, "isView");
    toString = Object.prototype.toString;
    withNativeBlob = typeof Blob === "function" || typeof Blob !== "undefined" && toString.call(Blob) === "[object BlobConstructor]";
    withNativeFile = typeof File === "function" || typeof File !== "undefined" && toString.call(File) === "[object FileConstructor]";
    __name(isBinary, "isBinary");
    __name(hasBinary, "hasBinary");
  }
});

// node_modules/socket.io-parser/build/esm-debug/binary.js
function deconstructPacket(packet) {
  const buffers = [];
  const packetData = packet.data;
  const pack = packet;
  pack.data = _deconstructPacket(packetData, buffers);
  pack.attachments = buffers.length;
  return {
    packet: pack,
    buffers
  };
}
function _deconstructPacket(data, buffers) {
  if (!data) return data;
  if (isBinary(data)) {
    const placeholder = {
      _placeholder: true,
      num: buffers.length
    };
    buffers.push(data);
    return placeholder;
  } else if (Array.isArray(data)) {
    const newData = new Array(data.length);
    for (let i = 0; i < data.length; i++) {
      newData[i] = _deconstructPacket(data[i], buffers);
    }
    return newData;
  } else if (typeof data === "object" && !(data instanceof Date)) {
    const newData = {};
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        newData[key] = _deconstructPacket(data[key], buffers);
      }
    }
    return newData;
  }
  return data;
}
function reconstructPacket(packet, buffers) {
  packet.data = _reconstructPacket(packet.data, buffers);
  delete packet.attachments;
  return packet;
}
function _reconstructPacket(data, buffers) {
  if (!data) return data;
  if (data && data._placeholder === true) {
    const isIndexValid = typeof data.num === "number" && data.num >= 0 && data.num < buffers.length;
    if (isIndexValid) {
      return buffers[data.num];
    } else {
      throw new Error("illegal attachments");
    }
  } else if (Array.isArray(data)) {
    for (let i = 0; i < data.length; i++) {
      data[i] = _reconstructPacket(data[i], buffers);
    }
  } else if (typeof data === "object") {
    for (const key in data) {
      if (Object.prototype.hasOwnProperty.call(data, key)) {
        data[key] = _reconstructPacket(data[key], buffers);
      }
    }
  }
  return data;
}
var init_binary = __esm({
  "node_modules/socket.io-parser/build/esm-debug/binary.js"() {
    "use strict";
    init_is_binary();
    __name(deconstructPacket, "deconstructPacket");
    __name(_deconstructPacket, "_deconstructPacket");
    __name(reconstructPacket, "reconstructPacket");
    __name(_reconstructPacket, "_reconstructPacket");
  }
});

// node_modules/socket.io-parser/node_modules/debug/src/common.js
var require_common4 = __commonJS({
  "node_modules/socket.io-parser/node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug12(...args) {
          if (!debug12.enabled) {
            return;
          }
          const self2 = debug12;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format5) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format5];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        __name(debug12, "debug");
        debug12.namespace = namespace;
        debug12.useColors = createDebug.useColors();
        debug12.color = createDebug.selectColor(namespace);
        debug12.extend = extend;
        debug12.destroy = createDebug.destroy;
        Object.defineProperty(debug12, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug12);
        }
        return debug12;
      }
      __name(createDebug, "createDebug");
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        let i;
        const split = (typeof namespaces === "string" ? namespaces : "").split(/[\s,]+/);
        const len = split.length;
        for (i = 0; i < len; i++) {
          if (!split[i]) {
            continue;
          }
          namespaces = split[i].replace(/\*/g, ".*?");
          if (namespaces[0] === "-") {
            createDebug.skips.push(new RegExp("^" + namespaces.slice(1) + "$"));
          } else {
            createDebug.names.push(new RegExp("^" + namespaces + "$"));
          }
        }
      }
      __name(enable, "enable");
      function disable() {
        const namespaces = [
          ...createDebug.names.map(toNamespace),
          ...createDebug.skips.map(toNamespace).map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        if (name[name.length - 1] === "*") {
          return true;
        }
        let i;
        let len;
        for (i = 0, len = createDebug.skips.length; i < len; i++) {
          if (createDebug.skips[i].test(name)) {
            return false;
          }
        }
        for (i = 0, len = createDebug.names.length; i < len; i++) {
          if (createDebug.names[i].test(name)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function toNamespace(regexp) {
        return regexp.toString().substring(2, regexp.toString().length - 2).replace(/\.\*\?$/, "*");
      }
      __name(toNamespace, "toNamespace");
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce2, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module2.exports = setup;
  }
});

// node_modules/socket.io-parser/node_modules/debug/src/browser.js
var require_browser3 = __commonJS({
  "node_modules/socket.io-parser/node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage, "localstorage");
    module2.exports = require_common4()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/socket.io-parser/node_modules/debug/src/node.js
var require_node5 = __commonJS({
  "node_modules/socket.io-parser/node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [
      6,
      2,
      3,
      4,
      5,
      1
    ];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    __name(log, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init(debug12) {
      debug12.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug12.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    __name(init, "init");
    module2.exports = require_common4()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/socket.io-parser/node_modules/debug/src/index.js
var require_src3 = __commonJS({
  "node_modules/socket.io-parser/node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser3();
    } else {
      module2.exports = require_node5();
    }
  }
});

// node_modules/socket.io-parser/build/esm-debug/index.js
var esm_debug_exports = {};
__export(esm_debug_exports, {
  Decoder: () => Decoder,
  Encoder: () => Encoder,
  PacketType: () => PacketType,
  protocol: () => protocol3
});
function isObject(value2) {
  return Object.prototype.toString.call(value2) === "[object Object]";
}
var import_debug8, debug8, RESERVED_EVENTS, protocol3, PacketType, Encoder, Decoder, BinaryReconstructor;
var init_esm_debug2 = __esm({
  "node_modules/socket.io-parser/build/esm-debug/index.js"() {
    "use strict";
    init_esm3();
    init_binary();
    init_is_binary();
    import_debug8 = __toESM(require_src3(), 1);
    debug8 = (0, import_debug8.default)("socket.io-parser");
    RESERVED_EVENTS = [
      "connect",
      "connect_error",
      "disconnect",
      "disconnecting",
      "newListener",
      "removeListener"
    ];
    protocol3 = 5;
    (function(PacketType2) {
      PacketType2[PacketType2["CONNECT"] = 0] = "CONNECT";
      PacketType2[PacketType2["DISCONNECT"] = 1] = "DISCONNECT";
      PacketType2[PacketType2["EVENT"] = 2] = "EVENT";
      PacketType2[PacketType2["ACK"] = 3] = "ACK";
      PacketType2[PacketType2["CONNECT_ERROR"] = 4] = "CONNECT_ERROR";
      PacketType2[PacketType2["BINARY_EVENT"] = 5] = "BINARY_EVENT";
      PacketType2[PacketType2["BINARY_ACK"] = 6] = "BINARY_ACK";
    })(PacketType || (PacketType = {}));
    Encoder = class {
      static {
        __name(this, "Encoder");
      }
      /**
       * Encoder constructor
       *
       * @param {function} replacer - custom replacer to pass down to JSON.parse
       */
      constructor(replacer) {
        this.replacer = replacer;
      }
      /**
       * Encode a packet as a single string if non-binary, or as a
       * buffer sequence, depending on packet type.
       *
       * @param {Object} obj - packet object
       */
      encode(obj) {
        debug8("encoding packet %j", obj);
        if (obj.type === PacketType.EVENT || obj.type === PacketType.ACK) {
          if (hasBinary(obj)) {
            return this.encodeAsBinary({
              type: obj.type === PacketType.EVENT ? PacketType.BINARY_EVENT : PacketType.BINARY_ACK,
              nsp: obj.nsp,
              data: obj.data,
              id: obj.id
            });
          }
        }
        return [
          this.encodeAsString(obj)
        ];
      }
      /**
       * Encode packet as string.
       */
      encodeAsString(obj) {
        let str = "" + obj.type;
        if (obj.type === PacketType.BINARY_EVENT || obj.type === PacketType.BINARY_ACK) {
          str += obj.attachments + "-";
        }
        if (obj.nsp && "/" !== obj.nsp) {
          str += obj.nsp + ",";
        }
        if (null != obj.id) {
          str += obj.id;
        }
        if (null != obj.data) {
          str += JSON.stringify(obj.data, this.replacer);
        }
        debug8("encoded %j as %s", obj, str);
        return str;
      }
      /**
       * Encode packet as 'buffer sequence' by removing blobs, and
       * deconstructing packet into object with placeholders and
       * a list of buffers.
       */
      encodeAsBinary(obj) {
        const deconstruction = deconstructPacket(obj);
        const pack = this.encodeAsString(deconstruction.packet);
        const buffers = deconstruction.buffers;
        buffers.unshift(pack);
        return buffers;
      }
    };
    __name(isObject, "isObject");
    Decoder = class _Decoder extends Emitter {
      static {
        __name(this, "Decoder");
      }
      /**
       * Decoder constructor
       *
       * @param {function} reviver - custom reviver to pass down to JSON.stringify
       */
      constructor(reviver) {
        super();
        this.reviver = reviver;
      }
      /**
       * Decodes an encoded packet string into packet JSON.
       *
       * @param {String} obj - encoded packet
       */
      add(obj) {
        let packet;
        if (typeof obj === "string") {
          if (this.reconstructor) {
            throw new Error("got plaintext data when reconstructing a packet");
          }
          packet = this.decodeString(obj);
          const isBinaryEvent = packet.type === PacketType.BINARY_EVENT;
          if (isBinaryEvent || packet.type === PacketType.BINARY_ACK) {
            packet.type = isBinaryEvent ? PacketType.EVENT : PacketType.ACK;
            this.reconstructor = new BinaryReconstructor(packet);
            if (packet.attachments === 0) {
              super.emitReserved("decoded", packet);
            }
          } else {
            super.emitReserved("decoded", packet);
          }
        } else if (isBinary(obj) || obj.base64) {
          if (!this.reconstructor) {
            throw new Error("got binary data when not reconstructing a packet");
          } else {
            packet = this.reconstructor.takeBinaryData(obj);
            if (packet) {
              this.reconstructor = null;
              super.emitReserved("decoded", packet);
            }
          }
        } else {
          throw new Error("Unknown type: " + obj);
        }
      }
      /**
       * Decode a packet String (JSON data)
       *
       * @param {String} str
       * @return {Object} packet
       */
      decodeString(str) {
        let i = 0;
        const p = {
          type: Number(str.charAt(0))
        };
        if (PacketType[p.type] === void 0) {
          throw new Error("unknown packet type " + p.type);
        }
        if (p.type === PacketType.BINARY_EVENT || p.type === PacketType.BINARY_ACK) {
          const start = i + 1;
          while (str.charAt(++i) !== "-" && i != str.length) {
          }
          const buf = str.substring(start, i);
          if (buf != Number(buf) || str.charAt(i) !== "-") {
            throw new Error("Illegal attachments");
          }
          p.attachments = Number(buf);
        }
        if ("/" === str.charAt(i + 1)) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if ("," === c) break;
            if (i === str.length) break;
          }
          p.nsp = str.substring(start, i);
        } else {
          p.nsp = "/";
        }
        const next = str.charAt(i + 1);
        if ("" !== next && Number(next) == next) {
          const start = i + 1;
          while (++i) {
            const c = str.charAt(i);
            if (null == c || Number(c) != c) {
              --i;
              break;
            }
            if (i === str.length) break;
          }
          p.id = Number(str.substring(start, i + 1));
        }
        if (str.charAt(++i)) {
          const payload = this.tryParse(str.substr(i));
          if (_Decoder.isPayloadValid(p.type, payload)) {
            p.data = payload;
          } else {
            throw new Error("invalid payload");
          }
        }
        debug8("decoded %s as %j", str, p);
        return p;
      }
      tryParse(str) {
        try {
          return JSON.parse(str, this.reviver);
        } catch (e) {
          return false;
        }
      }
      static isPayloadValid(type, payload) {
        switch (type) {
          case PacketType.CONNECT:
            return isObject(payload);
          case PacketType.DISCONNECT:
            return payload === void 0;
          case PacketType.CONNECT_ERROR:
            return typeof payload === "string" || isObject(payload);
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            return Array.isArray(payload) && (typeof payload[0] === "number" || typeof payload[0] === "string" && RESERVED_EVENTS.indexOf(payload[0]) === -1);
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            return Array.isArray(payload);
        }
      }
      /**
       * Deallocates a parser's resources
       */
      destroy() {
        if (this.reconstructor) {
          this.reconstructor.finishedReconstruction();
          this.reconstructor = null;
        }
      }
    };
    BinaryReconstructor = class BinaryReconstructor2 {
      static {
        __name(this, "BinaryReconstructor");
      }
      constructor(packet) {
        this.packet = packet;
        this.buffers = [];
        this.reconPack = packet;
      }
      /**
       * Method to be called when binary data received from connection
       * after a BINARY_EVENT packet.
       *
       * @param {Buffer | ArrayBuffer} binData - the raw binary data received
       * @return {null | Object} returns null if more binary data is expected or
       *   a reconstructed packet object if all buffers have been received.
       */
      takeBinaryData(binData) {
        this.buffers.push(binData);
        if (this.buffers.length === this.reconPack.attachments) {
          const packet = reconstructPacket(this.reconPack, this.buffers);
          this.finishedReconstruction();
          return packet;
        }
        return null;
      }
      /**
       * Cleans up binary packet reconstruction variables.
       */
      finishedReconstruction() {
        this.reconPack = null;
        this.buffers = [];
      }
    };
  }
});

// node_modules/socket.io-client/build/esm-debug/on.js
function on(obj, ev, fn) {
  obj.on(ev, fn);
  return /* @__PURE__ */ __name(function subDestroy() {
    obj.off(ev, fn);
  }, "subDestroy");
}
var init_on = __esm({
  "node_modules/socket.io-client/build/esm-debug/on.js"() {
    "use strict";
    __name(on, "on");
  }
});

// node_modules/socket.io-client/build/esm-debug/socket.js
var import_debug9, debug9, RESERVED_EVENTS2, Socket2;
var init_socket2 = __esm({
  "node_modules/socket.io-client/build/esm-debug/socket.js"() {
    "use strict";
    init_esm_debug2();
    init_on();
    init_esm3();
    import_debug9 = __toESM(require_src2(), 1);
    debug9 = (0, import_debug9.default)("socket.io-client:socket");
    RESERVED_EVENTS2 = Object.freeze({
      connect: 1,
      connect_error: 1,
      disconnect: 1,
      disconnecting: 1,
      // EventEmitter reserved events: https://nodejs.org/api/events.html#events_event_newlistener
      newListener: 1,
      removeListener: 1
    });
    Socket2 = class extends Emitter {
      static {
        __name(this, "Socket");
      }
      /**
       * `Socket` constructor.
       */
      constructor(io, nsp, opts) {
        super();
        this.connected = false;
        this.recovered = false;
        this.receiveBuffer = [];
        this.sendBuffer = [];
        this._queue = [];
        this._queueSeq = 0;
        this.ids = 0;
        this.acks = {};
        this.flags = {};
        this.io = io;
        this.nsp = nsp;
        if (opts && opts.auth) {
          this.auth = opts.auth;
        }
        this._opts = Object.assign({}, opts);
        if (this.io._autoConnect) this.open();
      }
      /**
       * Whether the socket is currently disconnected
       *
       * @example
       * const socket = io();
       *
       * socket.on("connect", () => {
       *   console.log(socket.disconnected); // false
       * });
       *
       * socket.on("disconnect", () => {
       *   console.log(socket.disconnected); // true
       * });
       */
      get disconnected() {
        return !this.connected;
      }
      /**
       * Subscribe to open, close and packet events
       *
       * @private
       */
      subEvents() {
        if (this.subs) return;
        const io = this.io;
        this.subs = [
          on(io, "open", this.onopen.bind(this)),
          on(io, "packet", this.onpacket.bind(this)),
          on(io, "error", this.onerror.bind(this)),
          on(io, "close", this.onclose.bind(this))
        ];
      }
      /**
       * Whether the Socket will try to reconnect when its Manager connects or reconnects.
       *
       * @example
       * const socket = io();
       *
       * console.log(socket.active); // true
       *
       * socket.on("disconnect", (reason) => {
       *   if (reason === "io server disconnect") {
       *     // the disconnection was initiated by the server, you need to manually reconnect
       *     console.log(socket.active); // false
       *   }
       *   // else the socket will automatically try to reconnect
       *   console.log(socket.active); // true
       * });
       */
      get active() {
        return !!this.subs;
      }
      /**
       * "Opens" the socket.
       *
       * @example
       * const socket = io({
       *   autoConnect: false
       * });
       *
       * socket.connect();
       */
      connect() {
        if (this.connected) return this;
        this.subEvents();
        if (!this.io["_reconnecting"]) this.io.open();
        if ("open" === this.io._readyState) this.onopen();
        return this;
      }
      /**
       * Alias for {@link connect()}.
       */
      open() {
        return this.connect();
      }
      /**
       * Sends a `message` event.
       *
       * This method mimics the WebSocket.send() method.
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/WebSocket/send
       *
       * @example
       * socket.send("hello");
       *
       * // this is equivalent to
       * socket.emit("message", "hello");
       *
       * @return self
       */
      send(...args) {
        args.unshift("message");
        this.emit.apply(this, args);
        return this;
      }
      /**
       * Override `emit`.
       * If the event is in `events`, it's emitted normally.
       *
       * @example
       * socket.emit("hello", "world");
       *
       * // all serializable datastructures are supported (no need to call JSON.stringify)
       * socket.emit("hello", 1, "2", { 3: ["4"], 5: Uint8Array.from([6]) });
       *
       * // with an acknowledgement from the server
       * socket.emit("hello", "world", (val) => {
       *   // ...
       * });
       *
       * @return self
       */
      emit(ev, ...args) {
        var _a2, _b2, _c2;
        if (RESERVED_EVENTS2.hasOwnProperty(ev)) {
          throw new Error('"' + ev.toString() + '" is a reserved event name');
        }
        args.unshift(ev);
        if (this._opts.retries && !this.flags.fromQueue && !this.flags.volatile) {
          this._addToQueue(args);
          return this;
        }
        const packet = {
          type: PacketType.EVENT,
          data: args
        };
        packet.options = {};
        packet.options.compress = this.flags.compress !== false;
        if ("function" === typeof args[args.length - 1]) {
          const id = this.ids++;
          debug9("emitting packet with ack id %d", id);
          const ack = args.pop();
          this._registerAckCallback(id, ack);
          packet.id = id;
        }
        const isTransportWritable = (_b2 = (_a2 = this.io.engine) === null || _a2 === void 0 ? void 0 : _a2.transport) === null || _b2 === void 0 ? void 0 : _b2.writable;
        const isConnected = this.connected && !((_c2 = this.io.engine) === null || _c2 === void 0 ? void 0 : _c2._hasPingExpired());
        const discardPacket = this.flags.volatile && !isTransportWritable;
        if (discardPacket) {
          debug9("discard packet as the transport is not currently writable");
        } else if (isConnected) {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        } else {
          this.sendBuffer.push(packet);
        }
        this.flags = {};
        return this;
      }
      /**
       * @private
       */
      _registerAckCallback(id, ack) {
        var _a2;
        const timeout = (_a2 = this.flags.timeout) !== null && _a2 !== void 0 ? _a2 : this._opts.ackTimeout;
        if (timeout === void 0) {
          this.acks[id] = ack;
          return;
        }
        const timer = this.io.setTimeoutFn(() => {
          delete this.acks[id];
          for (let i = 0; i < this.sendBuffer.length; i++) {
            if (this.sendBuffer[i].id === id) {
              debug9("removing packet with ack id %d from the buffer", id);
              this.sendBuffer.splice(i, 1);
            }
          }
          debug9("event with ack id %d has timed out after %d ms", id, timeout);
          ack.call(this, new Error("operation has timed out"));
        }, timeout);
        const fn = /* @__PURE__ */ __name((...args) => {
          this.io.clearTimeoutFn(timer);
          ack.apply(this, args);
        }, "fn");
        fn.withError = true;
        this.acks[id] = fn;
      }
      /**
       * Emits an event and waits for an acknowledgement
       *
       * @example
       * // without timeout
       * const response = await socket.emitWithAck("hello", "world");
       *
       * // with a specific timeout
       * try {
       *   const response = await socket.timeout(1000).emitWithAck("hello", "world");
       * } catch (err) {
       *   // the server did not acknowledge the event in the given delay
       * }
       *
       * @return a Promise that will be fulfilled when the server acknowledges the event
       */
      emitWithAck(ev, ...args) {
        return new Promise((resolve5, reject) => {
          const fn = /* @__PURE__ */ __name((arg1, arg2) => {
            return arg1 ? reject(arg1) : resolve5(arg2);
          }, "fn");
          fn.withError = true;
          args.push(fn);
          this.emit(ev, ...args);
        });
      }
      /**
       * Add the packet to the queue.
       * @param args
       * @private
       */
      _addToQueue(args) {
        let ack;
        if (typeof args[args.length - 1] === "function") {
          ack = args.pop();
        }
        const packet = {
          id: this._queueSeq++,
          tryCount: 0,
          pending: false,
          args,
          flags: Object.assign({
            fromQueue: true
          }, this.flags)
        };
        args.push((err, ...responseArgs) => {
          if (packet !== this._queue[0]) {
            return;
          }
          const hasError = err !== null;
          if (hasError) {
            if (packet.tryCount > this._opts.retries) {
              debug9("packet [%d] is discarded after %d tries", packet.id, packet.tryCount);
              this._queue.shift();
              if (ack) {
                ack(err);
              }
            }
          } else {
            debug9("packet [%d] was successfully sent", packet.id);
            this._queue.shift();
            if (ack) {
              ack(null, ...responseArgs);
            }
          }
          packet.pending = false;
          return this._drainQueue();
        });
        this._queue.push(packet);
        this._drainQueue();
      }
      /**
       * Send the first packet of the queue, and wait for an acknowledgement from the server.
       * @param force - whether to resend a packet that has not been acknowledged yet
       *
       * @private
       */
      _drainQueue(force = false) {
        debug9("draining queue");
        if (!this.connected || this._queue.length === 0) {
          return;
        }
        const packet = this._queue[0];
        if (packet.pending && !force) {
          debug9("packet [%d] has already been sent and is waiting for an ack", packet.id);
          return;
        }
        packet.pending = true;
        packet.tryCount++;
        debug9("sending packet [%d] (try n\xB0%d)", packet.id, packet.tryCount);
        this.flags = packet.flags;
        this.emit.apply(this, packet.args);
      }
      /**
       * Sends a packet.
       *
       * @param packet
       * @private
       */
      packet(packet) {
        packet.nsp = this.nsp;
        this.io._packet(packet);
      }
      /**
       * Called upon engine `open`.
       *
       * @private
       */
      onopen() {
        debug9("transport is open - connecting");
        if (typeof this.auth == "function") {
          this.auth((data) => {
            this._sendConnectPacket(data);
          });
        } else {
          this._sendConnectPacket(this.auth);
        }
      }
      /**
       * Sends a CONNECT packet to initiate the Socket.IO session.
       *
       * @param data
       * @private
       */
      _sendConnectPacket(data) {
        this.packet({
          type: PacketType.CONNECT,
          data: this._pid ? Object.assign({
            pid: this._pid,
            offset: this._lastOffset
          }, data) : data
        });
      }
      /**
       * Called upon engine or manager `error`.
       *
       * @param err
       * @private
       */
      onerror(err) {
        if (!this.connected) {
          this.emitReserved("connect_error", err);
        }
      }
      /**
       * Called upon engine `close`.
       *
       * @param reason
       * @param description
       * @private
       */
      onclose(reason, description) {
        debug9("close (%s)", reason);
        this.connected = false;
        delete this.id;
        this.emitReserved("disconnect", reason, description);
        this._clearAcks();
      }
      /**
       * Clears the acknowledgement handlers upon disconnection, since the client will never receive an acknowledgement from
       * the server.
       *
       * @private
       */
      _clearAcks() {
        Object.keys(this.acks).forEach((id) => {
          const isBuffered = this.sendBuffer.some((packet) => String(packet.id) === id);
          if (!isBuffered) {
            const ack = this.acks[id];
            delete this.acks[id];
            if (ack.withError) {
              ack.call(this, new Error("socket has been disconnected"));
            }
          }
        });
      }
      /**
       * Called with socket packet.
       *
       * @param packet
       * @private
       */
      onpacket(packet) {
        const sameNamespace = packet.nsp === this.nsp;
        if (!sameNamespace) return;
        switch (packet.type) {
          case PacketType.CONNECT:
            if (packet.data && packet.data.sid) {
              this.onconnect(packet.data.sid, packet.data.pid);
            } else {
              this.emitReserved("connect_error", new Error("It seems you are trying to reach a Socket.IO server in v2.x with a v3.x client, but they are not compatible (more information here: https://socket.io/docs/v3/migrating-from-2-x-to-3-0/)"));
            }
            break;
          case PacketType.EVENT:
          case PacketType.BINARY_EVENT:
            this.onevent(packet);
            break;
          case PacketType.ACK:
          case PacketType.BINARY_ACK:
            this.onack(packet);
            break;
          case PacketType.DISCONNECT:
            this.ondisconnect();
            break;
          case PacketType.CONNECT_ERROR:
            this.destroy();
            const err = new Error(packet.data.message);
            err.data = packet.data.data;
            this.emitReserved("connect_error", err);
            break;
        }
      }
      /**
       * Called upon a server event.
       *
       * @param packet
       * @private
       */
      onevent(packet) {
        const args = packet.data || [];
        debug9("emitting event %j", args);
        if (null != packet.id) {
          debug9("attaching ack callback to event");
          args.push(this.ack(packet.id));
        }
        if (this.connected) {
          this.emitEvent(args);
        } else {
          this.receiveBuffer.push(Object.freeze(args));
        }
      }
      emitEvent(args) {
        if (this._anyListeners && this._anyListeners.length) {
          const listeners = this._anyListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, args);
          }
        }
        super.emit.apply(this, args);
        if (this._pid && args.length && typeof args[args.length - 1] === "string") {
          this._lastOffset = args[args.length - 1];
        }
      }
      /**
       * Produces an ack callback to emit with an event.
       *
       * @private
       */
      ack(id) {
        const self2 = this;
        let sent = false;
        return function(...args) {
          if (sent) return;
          sent = true;
          debug9("sending ack %j", args);
          self2.packet({
            type: PacketType.ACK,
            id,
            data: args
          });
        };
      }
      /**
       * Called upon a server acknowledgement.
       *
       * @param packet
       * @private
       */
      onack(packet) {
        const ack = this.acks[packet.id];
        if (typeof ack !== "function") {
          debug9("bad ack %s", packet.id);
          return;
        }
        delete this.acks[packet.id];
        debug9("calling ack %s with %j", packet.id, packet.data);
        if (ack.withError) {
          packet.data.unshift(null);
        }
        ack.apply(this, packet.data);
      }
      /**
       * Called upon server connect.
       *
       * @private
       */
      onconnect(id, pid) {
        debug9("socket connected with id %s", id);
        this.id = id;
        this.recovered = pid && this._pid === pid;
        this._pid = pid;
        this.connected = true;
        this.emitBuffered();
        this.emitReserved("connect");
        this._drainQueue(true);
      }
      /**
       * Emit buffered events (received and emitted).
       *
       * @private
       */
      emitBuffered() {
        this.receiveBuffer.forEach((args) => this.emitEvent(args));
        this.receiveBuffer = [];
        this.sendBuffer.forEach((packet) => {
          this.notifyOutgoingListeners(packet);
          this.packet(packet);
        });
        this.sendBuffer = [];
      }
      /**
       * Called upon server disconnect.
       *
       * @private
       */
      ondisconnect() {
        debug9("server disconnect (%s)", this.nsp);
        this.destroy();
        this.onclose("io server disconnect");
      }
      /**
       * Called upon forced client/server side disconnections,
       * this method ensures the manager stops tracking us and
       * that reconnections don't get triggered for this.
       *
       * @private
       */
      destroy() {
        if (this.subs) {
          this.subs.forEach((subDestroy) => subDestroy());
          this.subs = void 0;
        }
        this.io["_destroy"](this);
      }
      /**
       * Disconnects the socket manually. In that case, the socket will not try to reconnect.
       *
       * If this is the last active Socket instance of the {@link Manager}, the low-level connection will be closed.
       *
       * @example
       * const socket = io();
       *
       * socket.on("disconnect", (reason) => {
       *   // console.log(reason); prints "io client disconnect"
       * });
       *
       * socket.disconnect();
       *
       * @return self
       */
      disconnect() {
        if (this.connected) {
          debug9("performing disconnect (%s)", this.nsp);
          this.packet({
            type: PacketType.DISCONNECT
          });
        }
        this.destroy();
        if (this.connected) {
          this.onclose("io client disconnect");
        }
        return this;
      }
      /**
       * Alias for {@link disconnect()}.
       *
       * @return self
       */
      close() {
        return this.disconnect();
      }
      /**
       * Sets the compress flag.
       *
       * @example
       * socket.compress(false).emit("hello");
       *
       * @param compress - if `true`, compresses the sending data
       * @return self
       */
      compress(compress) {
        this.flags.compress = compress;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the event message will be dropped when this socket is not
       * ready to send messages.
       *
       * @example
       * socket.volatile.emit("hello"); // the server may or may not receive it
       *
       * @returns self
       */
      get volatile() {
        this.flags.volatile = true;
        return this;
      }
      /**
       * Sets a modifier for a subsequent event emission that the callback will be called with an error when the
       * given number of milliseconds have elapsed without an acknowledgement from the server:
       *
       * @example
       * socket.timeout(5000).emit("my-event", (err) => {
       *   if (err) {
       *     // the server did not acknowledge the event in the given delay
       *   }
       * });
       *
       * @returns self
       */
      timeout(timeout) {
        this.flags.timeout = timeout;
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * @example
       * socket.onAny((event, ...args) => {
       *   console.log(`got ${event}`);
       * });
       *
       * @param listener
       */
      onAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.push(listener);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * @example
       * socket.prependAny((event, ...args) => {
       *   console.log(`got event ${event}`);
       * });
       *
       * @param listener
       */
      prependAny(listener) {
        this._anyListeners = this._anyListeners || [];
        this._anyListeners.unshift(listener);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @example
       * const catchAllListener = (event, ...args) => {
       *   console.log(`got event ${event}`);
       * }
       *
       * socket.onAny(catchAllListener);
       *
       * // remove a specific listener
       * socket.offAny(catchAllListener);
       *
       * // or remove all listeners
       * socket.offAny();
       *
       * @param listener
       */
      offAny(listener) {
        if (!this._anyListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAny() {
        return this._anyListeners || [];
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback.
       *
       * Note: acknowledgements sent to the server are not included.
       *
       * @example
       * socket.onAnyOutgoing((event, ...args) => {
       *   console.log(`sent event ${event}`);
       * });
       *
       * @param listener
       */
      onAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.push(listener);
        return this;
      }
      /**
       * Adds a listener that will be fired when any event is emitted. The event name is passed as the first argument to the
       * callback. The listener is added to the beginning of the listeners array.
       *
       * Note: acknowledgements sent to the server are not included.
       *
       * @example
       * socket.prependAnyOutgoing((event, ...args) => {
       *   console.log(`sent event ${event}`);
       * });
       *
       * @param listener
       */
      prependAnyOutgoing(listener) {
        this._anyOutgoingListeners = this._anyOutgoingListeners || [];
        this._anyOutgoingListeners.unshift(listener);
        return this;
      }
      /**
       * Removes the listener that will be fired when any event is emitted.
       *
       * @example
       * const catchAllListener = (event, ...args) => {
       *   console.log(`sent event ${event}`);
       * }
       *
       * socket.onAnyOutgoing(catchAllListener);
       *
       * // remove a specific listener
       * socket.offAnyOutgoing(catchAllListener);
       *
       * // or remove all listeners
       * socket.offAnyOutgoing();
       *
       * @param [listener] - the catch-all listener (optional)
       */
      offAnyOutgoing(listener) {
        if (!this._anyOutgoingListeners) {
          return this;
        }
        if (listener) {
          const listeners = this._anyOutgoingListeners;
          for (let i = 0; i < listeners.length; i++) {
            if (listener === listeners[i]) {
              listeners.splice(i, 1);
              return this;
            }
          }
        } else {
          this._anyOutgoingListeners = [];
        }
        return this;
      }
      /**
       * Returns an array of listeners that are listening for any event that is specified. This array can be manipulated,
       * e.g. to remove listeners.
       */
      listenersAnyOutgoing() {
        return this._anyOutgoingListeners || [];
      }
      /**
       * Notify the listeners for each packet sent
       *
       * @param packet
       *
       * @private
       */
      notifyOutgoingListeners(packet) {
        if (this._anyOutgoingListeners && this._anyOutgoingListeners.length) {
          const listeners = this._anyOutgoingListeners.slice();
          for (const listener of listeners) {
            listener.apply(this, packet.data);
          }
        }
      }
    };
  }
});

// node_modules/socket.io-client/build/esm-debug/contrib/backo2.js
function Backoff(opts) {
  opts = opts || {};
  this.ms = opts.min || 100;
  this.max = opts.max || 1e4;
  this.factor = opts.factor || 2;
  this.jitter = opts.jitter > 0 && opts.jitter <= 1 ? opts.jitter : 0;
  this.attempts = 0;
}
var init_backo2 = __esm({
  "node_modules/socket.io-client/build/esm-debug/contrib/backo2.js"() {
    "use strict";
    __name(Backoff, "Backoff");
    Backoff.prototype.duration = function() {
      var ms = this.ms * Math.pow(this.factor, this.attempts++);
      if (this.jitter) {
        var rand = Math.random();
        var deviation = Math.floor(rand * this.jitter * ms);
        ms = (Math.floor(rand * 10) & 1) == 0 ? ms - deviation : ms + deviation;
      }
      return Math.min(ms, this.max) | 0;
    };
    Backoff.prototype.reset = function() {
      this.attempts = 0;
    };
    Backoff.prototype.setMin = function(min) {
      this.ms = min;
    };
    Backoff.prototype.setMax = function(max) {
      this.max = max;
    };
    Backoff.prototype.setJitter = function(jitter) {
      this.jitter = jitter;
    };
  }
});

// node_modules/socket.io-client/build/esm-debug/manager.js
var import_debug10, debug10, Manager;
var init_manager = __esm({
  "node_modules/socket.io-client/build/esm-debug/manager.js"() {
    "use strict";
    init_esm_debug();
    init_socket2();
    init_esm_debug2();
    init_on();
    init_backo2();
    init_esm3();
    import_debug10 = __toESM(require_src2(), 1);
    debug10 = (0, import_debug10.default)("socket.io-client:manager");
    Manager = class extends Emitter {
      static {
        __name(this, "Manager");
      }
      constructor(uri, opts) {
        var _a2;
        super();
        this.nsps = {};
        this.subs = [];
        if (uri && "object" === typeof uri) {
          opts = uri;
          uri = void 0;
        }
        opts = opts || {};
        opts.path = opts.path || "/socket.io";
        this.opts = opts;
        installTimerFunctions(this, opts);
        this.reconnection(opts.reconnection !== false);
        this.reconnectionAttempts(opts.reconnectionAttempts || Infinity);
        this.reconnectionDelay(opts.reconnectionDelay || 1e3);
        this.reconnectionDelayMax(opts.reconnectionDelayMax || 5e3);
        this.randomizationFactor((_a2 = opts.randomizationFactor) !== null && _a2 !== void 0 ? _a2 : 0.5);
        this.backoff = new Backoff({
          min: this.reconnectionDelay(),
          max: this.reconnectionDelayMax(),
          jitter: this.randomizationFactor()
        });
        this.timeout(null == opts.timeout ? 2e4 : opts.timeout);
        this._readyState = "closed";
        this.uri = uri;
        const _parser = opts.parser || esm_debug_exports;
        this.encoder = new _parser.Encoder();
        this.decoder = new _parser.Decoder();
        this._autoConnect = opts.autoConnect !== false;
        if (this._autoConnect) this.open();
      }
      reconnection(v) {
        if (!arguments.length) return this._reconnection;
        this._reconnection = !!v;
        if (!v) {
          this.skipReconnect = true;
        }
        return this;
      }
      reconnectionAttempts(v) {
        if (v === void 0) return this._reconnectionAttempts;
        this._reconnectionAttempts = v;
        return this;
      }
      reconnectionDelay(v) {
        var _a2;
        if (v === void 0) return this._reconnectionDelay;
        this._reconnectionDelay = v;
        (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMin(v);
        return this;
      }
      randomizationFactor(v) {
        var _a2;
        if (v === void 0) return this._randomizationFactor;
        this._randomizationFactor = v;
        (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setJitter(v);
        return this;
      }
      reconnectionDelayMax(v) {
        var _a2;
        if (v === void 0) return this._reconnectionDelayMax;
        this._reconnectionDelayMax = v;
        (_a2 = this.backoff) === null || _a2 === void 0 ? void 0 : _a2.setMax(v);
        return this;
      }
      timeout(v) {
        if (!arguments.length) return this._timeout;
        this._timeout = v;
        return this;
      }
      /**
       * Starts trying to reconnect if reconnection is enabled and we have not
       * started reconnecting yet
       *
       * @private
       */
      maybeReconnectOnOpen() {
        if (!this._reconnecting && this._reconnection && this.backoff.attempts === 0) {
          this.reconnect();
        }
      }
      /**
       * Sets the current transport `socket`.
       *
       * @param {Function} fn - optional, callback
       * @return self
       * @public
       */
      open(fn) {
        debug10("readyState %s", this._readyState);
        if (~this._readyState.indexOf("open")) return this;
        debug10("opening %s", this.uri);
        this.engine = new Socket(this.uri, this.opts);
        const socket = this.engine;
        const self2 = this;
        this._readyState = "opening";
        this.skipReconnect = false;
        const openSubDestroy = on(socket, "open", function() {
          self2.onopen();
          fn && fn();
        });
        const onError = /* @__PURE__ */ __name((err) => {
          debug10("error");
          this.cleanup();
          this._readyState = "closed";
          this.emitReserved("error", err);
          if (fn) {
            fn(err);
          } else {
            this.maybeReconnectOnOpen();
          }
        }, "onError");
        const errorSub = on(socket, "error", onError);
        if (false !== this._timeout) {
          const timeout = this._timeout;
          debug10("connect attempt will timeout after %d", timeout);
          const timer = this.setTimeoutFn(() => {
            debug10("connect attempt timed out after %d", timeout);
            openSubDestroy();
            onError(new Error("timeout"));
            socket.close();
          }, timeout);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(() => {
            this.clearTimeoutFn(timer);
          });
        }
        this.subs.push(openSubDestroy);
        this.subs.push(errorSub);
        return this;
      }
      /**
       * Alias for open()
       *
       * @return self
       * @public
       */
      connect(fn) {
        return this.open(fn);
      }
      /**
       * Called upon transport open.
       *
       * @private
       */
      onopen() {
        debug10("open");
        this.cleanup();
        this._readyState = "open";
        this.emitReserved("open");
        const socket = this.engine;
        this.subs.push(
          on(socket, "ping", this.onping.bind(this)),
          on(socket, "data", this.ondata.bind(this)),
          on(socket, "error", this.onerror.bind(this)),
          on(socket, "close", this.onclose.bind(this)),
          // @ts-ignore
          on(this.decoder, "decoded", this.ondecoded.bind(this))
        );
      }
      /**
       * Called upon a ping.
       *
       * @private
       */
      onping() {
        this.emitReserved("ping");
      }
      /**
       * Called with data.
       *
       * @private
       */
      ondata(data) {
        try {
          this.decoder.add(data);
        } catch (e) {
          this.onclose("parse error", e);
        }
      }
      /**
       * Called when parser fully decodes a packet.
       *
       * @private
       */
      ondecoded(packet) {
        nextTick(() => {
          this.emitReserved("packet", packet);
        }, this.setTimeoutFn);
      }
      /**
       * Called upon socket error.
       *
       * @private
       */
      onerror(err) {
        debug10("error", err);
        this.emitReserved("error", err);
      }
      /**
       * Creates a new socket for the given `nsp`.
       *
       * @return {Socket}
       * @public
       */
      socket(nsp, opts) {
        let socket = this.nsps[nsp];
        if (!socket) {
          socket = new Socket2(this, nsp, opts);
          this.nsps[nsp] = socket;
        } else if (this._autoConnect && !socket.active) {
          socket.connect();
        }
        return socket;
      }
      /**
       * Called upon a socket close.
       *
       * @param socket
       * @private
       */
      _destroy(socket) {
        const nsps = Object.keys(this.nsps);
        for (const nsp of nsps) {
          const socket2 = this.nsps[nsp];
          if (socket2.active) {
            debug10("socket %s is still active, skipping close", nsp);
            return;
          }
        }
        this._close();
      }
      /**
       * Writes a packet.
       *
       * @param packet
       * @private
       */
      _packet(packet) {
        debug10("writing packet %j", packet);
        const encodedPackets = this.encoder.encode(packet);
        for (let i = 0; i < encodedPackets.length; i++) {
          this.engine.write(encodedPackets[i], packet.options);
        }
      }
      /**
       * Clean up transport subscriptions and packet buffer.
       *
       * @private
       */
      cleanup() {
        debug10("cleanup");
        this.subs.forEach((subDestroy) => subDestroy());
        this.subs.length = 0;
        this.decoder.destroy();
      }
      /**
       * Close the current socket.
       *
       * @private
       */
      _close() {
        debug10("disconnect");
        this.skipReconnect = true;
        this._reconnecting = false;
        this.onclose("forced close");
      }
      /**
       * Alias for close()
       *
       * @private
       */
      disconnect() {
        return this._close();
      }
      /**
       * Called when:
       *
       * - the low-level engine is closed
       * - the parser encountered a badly formatted packet
       * - all sockets are disconnected
       *
       * @private
       */
      onclose(reason, description) {
        var _a2;
        debug10("closed due to %s", reason);
        this.cleanup();
        (_a2 = this.engine) === null || _a2 === void 0 ? void 0 : _a2.close();
        this.backoff.reset();
        this._readyState = "closed";
        this.emitReserved("close", reason, description);
        if (this._reconnection && !this.skipReconnect) {
          this.reconnect();
        }
      }
      /**
       * Attempt a reconnection.
       *
       * @private
       */
      reconnect() {
        if (this._reconnecting || this.skipReconnect) return this;
        const self2 = this;
        if (this.backoff.attempts >= this._reconnectionAttempts) {
          debug10("reconnect failed");
          this.backoff.reset();
          this.emitReserved("reconnect_failed");
          this._reconnecting = false;
        } else {
          const delay = this.backoff.duration();
          debug10("will wait %dms before reconnect attempt", delay);
          this._reconnecting = true;
          const timer = this.setTimeoutFn(() => {
            if (self2.skipReconnect) return;
            debug10("attempting reconnect");
            this.emitReserved("reconnect_attempt", self2.backoff.attempts);
            if (self2.skipReconnect) return;
            self2.open((err) => {
              if (err) {
                debug10("reconnect attempt error");
                self2._reconnecting = false;
                self2.reconnect();
                this.emitReserved("reconnect_error", err);
              } else {
                debug10("reconnect success");
                self2.onreconnect();
              }
            });
          }, delay);
          if (this.opts.autoUnref) {
            timer.unref();
          }
          this.subs.push(() => {
            this.clearTimeoutFn(timer);
          });
        }
      }
      /**
       * Called upon successful reconnect.
       *
       * @private
       */
      onreconnect() {
        const attempt = this.backoff.attempts;
        this._reconnecting = false;
        this.backoff.reset();
        this.emitReserved("reconnect", attempt);
      }
    };
  }
});

// node_modules/socket.io-client/build/esm-debug/index.js
function lookup(uri, opts) {
  if (typeof uri === "object") {
    opts = uri;
    uri = void 0;
  }
  opts = opts || {};
  const parsed = url(uri, opts.path || "/socket.io");
  const source = parsed.source;
  const id = parsed.id;
  const path = parsed.path;
  const sameNamespace = cache[id] && path in cache[id]["nsps"];
  const newConnection = opts.forceNew || opts["force new connection"] || false === opts.multiplex || sameNamespace;
  let io;
  if (newConnection) {
    debug11("ignoring socket cache for %s", source);
    io = new Manager(source, opts);
  } else {
    if (!cache[id]) {
      debug11("new io instance for %s", source);
      cache[id] = new Manager(source, opts);
    }
    io = cache[id];
  }
  if (parsed.query && !opts.query) {
    opts.query = parsed.queryKey;
  }
  return io.socket(parsed.path, opts);
}
var import_debug11, debug11, cache;
var init_esm_debug3 = __esm({
  "node_modules/socket.io-client/build/esm-debug/index.js"() {
    "use strict";
    init_url();
    init_manager();
    init_socket2();
    import_debug11 = __toESM(require_src2(), 1);
    init_esm_debug2();
    init_esm_debug();
    debug11 = (0, import_debug11.default)("socket.io-client");
    cache = {};
    __name(lookup, "lookup");
    Object.assign(lookup, {
      Manager,
      Socket: Socket2,
      io: lookup,
      connect: lookup
    });
  }
});

// src/shared/utils/sleep.util.ts
var sleep;
var init_sleep_util = __esm({
  "src/shared/utils/sleep.util.ts"() {
    "use strict";
    sleep = /* @__PURE__ */ __name((ms) => {
      return new Promise((resolve5) => {
        setTimeout(resolve5, ms);
      });
    }, "sleep");
  }
});

// src/shared/utils/executeAction.util.ts
var executeAction;
var init_executeAction_util = __esm({
  "src/shared/utils/executeAction.util.ts"() {
    "use strict";
    init_sleep_util();
    init_logger();
    executeAction = /* @__PURE__ */ __name(async (params2) => {
      const { actionName = "Action", action, attempt = 1, maxRetries = Infinity, logging } = params2;
      try {
        const result2 = await action({
          attempt
        });
        logger.info(attempt > 1 ? `\u{1F197} ${actionName} success with attempt ${attempt} \u274E. ` : `\u{1F197} ${actionName} success.`);
        return result2;
      } catch (err) {
        if (attempt > maxRetries) throw new Error(`\u274C ${actionName} failure after ${attempt - 1} retries. ${err?.message}`);
        if (logging) logger.error(`\u274C ${actionName} attempt ${attempt} failed. \u{1F504} Retrying... ${err.message} `);
        await sleep(params2.retryDelay || 5e3);
        return executeAction({
          ...params2,
          attempt: attempt + 1
        });
      }
    }, "executeAction");
  }
});

// src/shared/infrastructure/websocketClient/index.ts
var WebSocketClient;
var init_websocketClient = __esm({
  "src/shared/infrastructure/websocketClient/index.ts"() {
    "use strict";
    init_esm_debug3();
    init_logger();
    init_executeAction_util();
    init_index();
    WebSocketClient = class WebSocketClient2 {
      static {
        __name(this, "WebSocketClient");
      }
      socket;
      constructor() {
        const { token: token2, url: url2 } = params;
        this.socket = lookup(url2, {
          path: "/websocket",
          auth: /* @__PURE__ */ __name((getAuthToken) => {
            getAuthToken({
              token: `Bearer ${token2}`
            });
          }, "auth"),
          autoConnect: false,
          reconnection: true,
          reconnectionDelay: 3e4,
          reconnectionAttempts: Infinity
        });
        this.startCommonListeners();
      }
      async checkServerConnection() {
        const { url: url2 } = params;
        if (!url2) throw new Error("\u274C URL is not defined");
        return new Promise((resolve5) => {
          const checkConnection = /* @__PURE__ */ __name(async () => {
            try {
              const response = await fetch(url2);
              if (response.ok) {
                logger.info("\u{1F7E2} Server is online");
                if (!this.socket.connected) {
                  logger.info("Attempting to reconnect to server");
                  await this.init();
                }
                return true;
              }
              logger.warn(`\u{1F7E0} Server returned status ${response.status}`);
              return false;
            } catch (error) {
              logger.error(`\u{1F534} Server connection failed: ${error instanceof Error ? error.message : String(error)}`);
              return false;
            }
          }, "checkConnection");
          const intervalId = setInterval(async () => {
            if (await checkConnection()) {
              clearInterval(intervalId);
              resolve5();
            }
          }, 5e3);
        });
      }
      async init() {
        if (!this.socket.connected) await executeAction({
          action: /* @__PURE__ */ __name(() => this.connect(), "action"),
          actionName: "Websocket connection initialization",
          retryDelay: 15e3,
          maxRetries: Infinity,
          logging: true
        });
      }
      async handleConnectionError() {
        try {
          await this.checkServerConnection();
          logger.info("Server is available, trying to refresh authentication");
          await this.init();
        } catch (error) {
          logger.error(`\u274C Error while refreshing access token during websocket connection opening. Unable to continue ${error}`);
          process.exit(1);
        }
      }
      async connect() {
        return new Promise((resolve5, reject) => {
          const stopListeners = /* @__PURE__ */ __name(() => {
            this.socket.off("connect_error", onError);
            this.socket.off("connect", onSuccess);
          }, "stopListeners");
          const onSuccess = /* @__PURE__ */ __name(() => {
            stopListeners();
            resolve5();
          }, "onSuccess");
          const onError = /* @__PURE__ */ __name((error) => {
            stopListeners();
            this.disconnect();
            reject(error);
          }, "onError");
          try {
            this.socket.connect();
            this.socket.once("connect_error", onError);
            this.socket.once("connect", onSuccess);
          } catch (error) {
            stopListeners();
            this.disconnect();
            reject(error);
          }
        });
      }
      disconnect() {
        this.socket.disconnect();
      }
      startCommonListeners() {
        this.socket.on("connect", () => {
          logger.info("\u2705 Connected to server");
        });
        this.socket.on("disconnect", () => {
          logger.info("\u2B55 Disconnected from server");
        });
        this.socket.io.on("error", (error) => {
          logger.error(`\u274C Websocket error due ${error.message}`);
        });
        this.socket.on("connect_error", (err) => {
          logger.error(`\u274C Websocket connection error due ${err.message}`);
          if (!!err.message && err.message.toLowerCase().includes("unauthorized")) {
            logger.error("\u274C Unauthorized access. Trying to refresh.");
            this.handleConnectionError();
          }
        });
        this.socket.io.on("reconnect_attempt", () => {
          logger.info("\u{1F503} Trying to reconnect to server");
        });
        this.socket.io.on("reconnect_error", (error) => {
          logger.error(`\u274C Error while reconnecting ${error.message}`);
        });
        this.socket.io.on("reconnect_failed", () => {
          logger.error(`\u274C Fail to reconnect to server`);
        });
        this.socket.io.on("reconnect", () => {
          logger.info("\u{1F504} Reconnected to server");
        });
      }
      getIsConnected() {
        return this.socket.connected;
      }
    };
  }
});

// node_modules/systeminformation/package.json
var require_package2 = __commonJS({
  "node_modules/systeminformation/package.json"(exports2, module2) {
    module2.exports = {
      name: "systeminformation",
      version: "5.25.11",
      description: "Advanced, lightweight system and OS information library",
      license: "MIT",
      author: "Sebastian Hildebrandt <hildebrandt@plus-innovations.com> (https://plus-innovations.com)",
      homepage: "https://systeminformation.io",
      main: "./lib/index.js",
      type: "commonjs",
      bin: {
        systeminformation: "lib/cli.js"
      },
      types: "./lib/index.d.ts",
      scripts: {
        test: "node ./test/test.js",
        testDeno: "deno run -A ./test/test.js"
      },
      files: [
        "lib/"
      ],
      keywords: [
        "system information",
        "sysinfo",
        "monitor",
        "monitoring",
        "os",
        "linux",
        "osx",
        "windows",
        "freebsd",
        "openbsd",
        "netbsd",
        "cpu",
        "cpuload",
        "physical cores",
        "logical cores",
        "processor",
        "cores",
        "threads",
        "socket type",
        "memory",
        "file system",
        "fsstats",
        "diskio",
        "block devices",
        "netstats",
        "network",
        "network interfaces",
        "network connections",
        "network stats",
        "iface",
        "printer",
        "processes",
        "users",
        "internet",
        "battery",
        "docker",
        "docker stats",
        "docker processes",
        "graphics",
        "graphic card",
        "graphic controller",
        "gpu",
        "display",
        "smart",
        "disk layout",
        "usb",
        "audio",
        "bluetooth",
        "wifi",
        "wifinetworks",
        "virtual box",
        "virtualbox",
        "vm",
        "backend",
        "hardware",
        "BIOS",
        "chassis"
      ],
      repository: {
        type: "git",
        url: "https://github.com/sebhildebrandt/systeminformation.git"
      },
      funding: {
        type: "Buy me a coffee",
        url: "https://www.buymeacoffee.com/systeminfo"
      },
      os: [
        "darwin",
        "linux",
        "win32",
        "freebsd",
        "openbsd",
        "netbsd",
        "sunos",
        "android"
      ],
      engines: {
        node: ">=8.0.0"
      }
    };
  }
});

// node_modules/systeminformation/lib/util.js
var require_util = __commonJS({
  "node_modules/systeminformation/lib/util.js"(exports2) {
    "use strict";
    var os = require("os");
    var fs = require("fs");
    var path = require("path");
    var spawn = require("child_process").spawn;
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util2 = require("util");
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _cores = 0;
    var wmicPath = "";
    var codepage = "";
    var _smartMonToolsInstalled = null;
    var _rpi_cpuinfo = null;
    var WINDIR = process.env.WINDIR || "C:\\Windows";
    var _psChild;
    var _psResult = "";
    var _psCmds = [];
    var _psPersistent = false;
    var _powerShell = "";
    var _psToUTF8 = "$OutputEncoding = [System.Console]::OutputEncoding = [System.Console]::InputEncoding = [System.Text.Encoding]::UTF8 ; ";
    var _psCmdStart = "--###START###--";
    var _psError = "--ERROR--";
    var _psCmdSeperator = "--###ENDCMD###--";
    var _psIdSeperator = "--##ID##--";
    var execOptsWin = {
      windowsHide: true,
      maxBuffer: 1024 * 2e4,
      encoding: "UTF-8",
      env: Object.assign({}, process.env, {
        LANG: "en_US.UTF-8"
      })
    };
    var execOptsLinux = {
      maxBuffer: 1024 * 2e4,
      encoding: "UTF-8",
      stdio: [
        "pipe",
        "pipe",
        "ignore"
      ]
    };
    function toInt(value2) {
      let result2 = parseInt(value2, 10);
      if (isNaN(result2)) {
        result2 = 0;
      }
      return result2;
    }
    __name(toInt, "toInt");
    function splitByNumber(str) {
      let numberStarted = false;
      let num = "";
      let cpart = "";
      for (const c of str) {
        if (c >= "0" && c <= "9" || numberStarted) {
          numberStarted = true;
          num += c;
        } else {
          cpart += c;
        }
      }
      return [
        cpart,
        num
      ];
    }
    __name(splitByNumber, "splitByNumber");
    var stringObj = new String();
    var stringReplace = new String().replace;
    var stringToLower = new String().toLowerCase;
    var stringToString = new String().toString;
    var stringSubstr = new String().substr;
    var stringSubstring = new String().substring;
    var stringTrim = new String().trim;
    var stringStartWith = new String().startsWith;
    var mathMin = Math.min;
    function isFunction2(functionToCheck) {
      let getType = {};
      return functionToCheck && getType.toString.call(functionToCheck) === "[object Function]";
    }
    __name(isFunction2, "isFunction");
    function unique(obj) {
      let uniques = [];
      let stringify2 = {};
      for (let i = 0; i < obj.length; i++) {
        let keys = Object.keys(obj[i]);
        keys.sort(function(a, b) {
          return a - b;
        });
        let str = "";
        for (let j = 0; j < keys.length; j++) {
          str += JSON.stringify(keys[j]);
          str += JSON.stringify(obj[i][keys[j]]);
        }
        if (!{}.hasOwnProperty.call(stringify2, str)) {
          uniques.push(obj[i]);
          stringify2[str] = true;
        }
      }
      return uniques;
    }
    __name(unique, "unique");
    function sortByKey(array, keys) {
      return array.sort(function(a, b) {
        let x = "";
        let y = "";
        keys.forEach(function(key) {
          x = x + a[key];
          y = y + b[key];
        });
        return x < y ? -1 : x > y ? 1 : 0;
      });
    }
    __name(sortByKey, "sortByKey");
    function cores() {
      if (_cores === 0) {
        _cores = os.cpus().length;
      }
      return _cores;
    }
    __name(cores, "cores");
    function getValue(lines, property, separator, trimmed, lineMatch) {
      separator = separator || ":";
      property = property.toLowerCase();
      trimmed = trimmed || false;
      lineMatch = lineMatch || false;
      let result2 = "";
      lines.some((line) => {
        let lineLower = line.toLowerCase().replace(/\t/g, "");
        if (trimmed) {
          lineLower = lineLower.trim();
        }
        if (lineLower.startsWith(property) && (lineMatch ? lineLower.match(property + separator) || lineLower.match(property + " " + separator) : true)) {
          const parts2 = trimmed ? line.trim().split(separator) : line.split(separator);
          if (parts2.length >= 2) {
            parts2.shift();
            result2 = parts2.join(separator).trim();
            return true;
          }
        }
      });
      return result2;
    }
    __name(getValue, "getValue");
    function decodeEscapeSequence(str, base) {
      base = base || 16;
      return str.replace(/\\x([0-9A-Fa-f]{2})/g, function() {
        return String.fromCharCode(parseInt(arguments[1], base));
      });
    }
    __name(decodeEscapeSequence, "decodeEscapeSequence");
    function detectSplit(str) {
      let seperator = "";
      let part = 0;
      str.split("").forEach((element) => {
        if (element >= "0" && element <= "9") {
          if (part === 1) {
            part++;
          }
        } else {
          if (part === 0) {
            part++;
          }
          if (part === 1) {
            seperator += element;
          }
        }
      });
      return seperator;
    }
    __name(detectSplit, "detectSplit");
    function parseTime(t, pmDesignator) {
      pmDesignator = pmDesignator || "";
      t = t.toUpperCase();
      let hour = 0;
      let min = 0;
      let splitter = detectSplit(t);
      let parts2 = t.split(splitter);
      if (parts2.length >= 2) {
        if (parts2[2]) {
          parts2[1] += parts2[2];
        }
        let isPM = parts2[1] && parts2[1].toLowerCase().indexOf("pm") > -1 || parts2[1].toLowerCase().indexOf("p.m.") > -1 || parts2[1].toLowerCase().indexOf("p. m.") > -1 || parts2[1].toLowerCase().indexOf("n") > -1 || parts2[1].toLowerCase().indexOf("ch") > -1 || parts2[1].toLowerCase().indexOf("\xF6s") > -1 || pmDesignator && parts2[1].toLowerCase().indexOf(pmDesignator) > -1;
        hour = parseInt(parts2[0], 10);
        min = parseInt(parts2[1], 10);
        hour = isPM && hour < 12 ? hour + 12 : hour;
        return ("0" + hour).substr(-2) + ":" + ("0" + min).substr(-2);
      }
    }
    __name(parseTime, "parseTime");
    function parseDateTime(dt, culture) {
      const result2 = {
        date: "",
        time: ""
      };
      culture = culture || {};
      let dateFormat = (culture.dateFormat || "").toLowerCase();
      let pmDesignator = culture.pmDesignator || "";
      const parts2 = dt.split(" ");
      if (parts2[0]) {
        if (parts2[0].indexOf("/") >= 0) {
          const dtparts = parts2[0].split("/");
          if (dtparts.length === 3) {
            if (dtparts[0].length === 4) {
              result2.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
            } else if (dtparts[2].length === 2) {
              if (dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) {
                result2.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              } else {
                result2.date = "20" + dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              }
            } else {
              const isEN = dt.toLowerCase().indexOf("pm") > -1 || dt.toLowerCase().indexOf("p.m.") > -1 || dt.toLowerCase().indexOf("p. m.") > -1 || dt.toLowerCase().indexOf("am") > -1 || dt.toLowerCase().indexOf("a.m.") > -1 || dt.toLowerCase().indexOf("a. m.") > -1;
              if ((isEN || dateFormat.indexOf("/d/") > -1 || dateFormat.indexOf("/dd/") > -1) && dateFormat.indexOf("dd/") !== 0) {
                result2.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
              } else {
                result2.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
              }
            }
          }
        }
        if (parts2[0].indexOf(".") >= 0) {
          const dtparts = parts2[0].split(".");
          if (dtparts.length === 3) {
            if (dateFormat.indexOf(".d.") > -1 || dateFormat.indexOf(".dd.") > -1) {
              result2.date = dtparts[2] + "-" + ("0" + dtparts[0]).substr(-2) + "-" + ("0" + dtparts[1]).substr(-2);
            } else {
              result2.date = dtparts[2] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[0]).substr(-2);
            }
          }
        }
        if (parts2[0].indexOf("-") >= 0) {
          const dtparts = parts2[0].split("-");
          if (dtparts.length === 3) {
            result2.date = dtparts[0] + "-" + ("0" + dtparts[1]).substr(-2) + "-" + ("0" + dtparts[2]).substr(-2);
          }
        }
      }
      if (parts2[1]) {
        parts2.shift();
        let time = parts2.join(" ");
        result2.time = parseTime(time, pmDesignator);
      }
      return result2;
    }
    __name(parseDateTime, "parseDateTime");
    function parseHead(head, rights) {
      let space = rights > 0;
      let count = 1;
      let from = 0;
      let to = 0;
      let result2 = [];
      for (let i = 0; i < head.length; i++) {
        if (count <= rights) {
          if (/\s/.test(head[i]) && !space) {
            to = i - 1;
            result2.push({
              from,
              to: to + 1,
              cap: head.substring(from, to + 1)
            });
            from = to + 2;
            count++;
          }
          space = head[i] === " ";
        } else {
          if (!/\s/.test(head[i]) && space) {
            to = i - 1;
            if (from < to) {
              result2.push({
                from,
                to,
                cap: head.substring(from, to)
              });
            }
            from = to + 1;
            count++;
          }
          space = head[i] === " ";
        }
      }
      to = 5e3;
      result2.push({
        from,
        to,
        cap: head.substring(from, to)
      });
      let len = result2.length;
      for (let i = 0; i < len; i++) {
        if (result2[i].cap.replace(/\s/g, "").length === 0) {
          if (i + 1 < len) {
            result2[i].to = result2[i + 1].to;
            result2[i].cap = result2[i].cap + result2[i + 1].cap;
            result2.splice(i + 1, 1);
            len = len - 1;
          }
        }
      }
      return result2;
    }
    __name(parseHead, "parseHead");
    function findObjectByKey(array, key, value2) {
      for (let i = 0; i < array.length; i++) {
        if (array[i][key] === value2) {
          return i;
        }
      }
      return -1;
    }
    __name(findObjectByKey, "findObjectByKey");
    function getPowershell() {
      _powerShell = "powershell.exe";
      if (_windows) {
        const defaultPath = `${WINDIR}\\system32\\WindowsPowerShell\\v1.0\\powershell.exe`;
        if (fs.existsSync(defaultPath)) {
          _powerShell = defaultPath;
        }
      }
    }
    __name(getPowershell, "getPowershell");
    function getWmic() {
      if (os.type() === "Windows_NT" && !wmicPath) {
        wmicPath = WINDIR + "\\system32\\wbem\\wmic.exe";
        if (!fs.existsSync(wmicPath)) {
          try {
            const wmicPathArray = execSync("WHERE WMIC", execOptsWin).toString().split("\r\n");
            if (wmicPathArray && wmicPathArray.length) {
              wmicPath = wmicPathArray[0];
            } else {
              wmicPath = "wmic";
            }
          } catch (e) {
            wmicPath = "wmic";
          }
        }
      }
      return wmicPath;
    }
    __name(getWmic, "getWmic");
    function wmic(command2) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          try {
            powerShell(getWmic() + " " + command2).then((stdout) => {
              resolve5(stdout, "");
            });
          } catch (e) {
            resolve5("", e);
          }
        });
      });
    }
    __name(wmic, "wmic");
    function getVboxmanage() {
      return _windows ? `"${process.env.VBOX_INSTALL_PATH || process.env.VBOX_MSI_INSTALL_PATH}\\VBoxManage.exe"` : "vboxmanage";
    }
    __name(getVboxmanage, "getVboxmanage");
    function powerShellProceedResults(data) {
      let id = "";
      let parts2;
      let res = "";
      if (data.indexOf(_psCmdStart) >= 0) {
        parts2 = data.split(_psCmdStart);
        const parts22 = parts2[1].split(_psIdSeperator);
        id = parts22[0];
        if (parts22.length > 1) {
          data = parts22.slice(1).join(_psIdSeperator);
        }
      }
      if (data.indexOf(_psCmdSeperator) >= 0) {
        parts2 = data.split(_psCmdSeperator);
        res = parts2[0];
      }
      let remove = -1;
      for (let i = 0; i < _psCmds.length; i++) {
        if (_psCmds[i].id === id) {
          remove = i;
          _psCmds[i].callback(res);
        }
      }
      if (remove >= 0) {
        _psCmds.splice(remove, 1);
      }
    }
    __name(powerShellProceedResults, "powerShellProceedResults");
    function powerShellStart() {
      if (!_psChild) {
        _psChild = spawn(_powerShell, [
          "-NoProfile",
          "-NoLogo",
          "-InputFormat",
          "Text",
          "-NoExit",
          "-Command",
          "-"
        ], {
          stdio: "pipe",
          windowsHide: true,
          maxBuffer: 1024 * 2e4,
          encoding: "UTF-8",
          env: Object.assign({}, process.env, {
            LANG: "en_US.UTF-8"
          })
        });
        if (_psChild && _psChild.pid) {
          _psPersistent = true;
          _psChild.stdout.on("data", function(data) {
            _psResult = _psResult + data.toString("utf8");
            if (data.indexOf(_psCmdSeperator) >= 0) {
              powerShellProceedResults(_psResult);
              _psResult = "";
            }
          });
          _psChild.stderr.on("data", function() {
            powerShellProceedResults(_psResult + _psError);
          });
          _psChild.on("error", function() {
            powerShellProceedResults(_psResult + _psError);
          });
          _psChild.on("close", function() {
            if (_psChild) {
              _psChild.kill();
            }
          });
        }
      }
    }
    __name(powerShellStart, "powerShellStart");
    function powerShellRelease() {
      try {
        if (_psChild) {
          _psChild.stdin.write("exit" + os.EOL);
          _psChild.stdin.end();
          _psPersistent = false;
        }
      } catch (e) {
        if (_psChild) {
          _psChild.kill();
        }
      }
      _psChild = null;
    }
    __name(powerShellRelease, "powerShellRelease");
    function powerShell(cmd) {
      if (_psPersistent) {
        const id = Math.random().toString(36).substring(2, 12);
        return new Promise((resolve5) => {
          process.nextTick(() => {
            function callback(data) {
              resolve5(data);
            }
            __name(callback, "callback");
            _psCmds.push({
              id,
              cmd,
              callback,
              start: /* @__PURE__ */ new Date()
            });
            try {
              if (_psChild && _psChild.pid) {
                _psChild.stdin.write(_psToUTF8 + "echo " + _psCmdStart + id + _psIdSeperator + "; " + os.EOL + cmd + os.EOL + "echo " + _psCmdSeperator + os.EOL);
              }
            } catch (e) {
              resolve5("");
            }
          });
        });
      } else {
        let result2 = "";
        return new Promise((resolve5) => {
          process.nextTick(() => {
            try {
              const child = spawn(_powerShell, [
                "-NoProfile",
                "-NoLogo",
                "-InputFormat",
                "Text",
                "-NoExit",
                "-ExecutionPolicy",
                "Unrestricted",
                "-Command",
                "-"
              ], {
                stdio: "pipe",
                windowsHide: true,
                maxBuffer: 1024 * 2e4,
                encoding: "UTF-8",
                env: Object.assign({}, process.env, {
                  LANG: "en_US.UTF-8"
                })
              });
              if (child && !child.pid) {
                child.on("error", function() {
                  resolve5(result2);
                });
              }
              if (child && child.pid) {
                child.stdout.on("data", function(data) {
                  result2 = result2 + data.toString("utf8");
                });
                child.stderr.on("data", function() {
                  child.kill();
                  resolve5(result2);
                });
                child.on("close", function() {
                  child.kill();
                  resolve5(result2);
                });
                child.on("error", function() {
                  child.kill();
                  resolve5(result2);
                });
                try {
                  child.stdin.write(_psToUTF8 + cmd + os.EOL);
                  child.stdin.write("exit" + os.EOL);
                  child.stdin.end();
                } catch (e) {
                  child.kill();
                  resolve5(result2);
                }
              } else {
                resolve5(result2);
              }
            } catch (e) {
              resolve5(result2);
            }
          });
        });
      }
    }
    __name(powerShell, "powerShell");
    function execSafe(cmd, args, options) {
      let result2 = "";
      options = options || {};
      return new Promise((resolve5) => {
        process.nextTick(() => {
          try {
            const child = spawn(cmd, args, options);
            if (child && !child.pid) {
              child.on("error", function() {
                resolve5(result2);
              });
            }
            if (child && child.pid) {
              child.stdout.on("data", function(data) {
                result2 += data.toString();
              });
              child.on("close", function() {
                child.kill();
                resolve5(result2);
              });
              child.on("error", function() {
                child.kill();
                resolve5(result2);
              });
            } else {
              resolve5(result2);
            }
          } catch (e) {
            resolve5(result2);
          }
        });
      });
    }
    __name(execSafe, "execSafe");
    function getCodepage() {
      if (_windows) {
        if (!codepage) {
          try {
            const stdout = execSync("chcp", execOptsWin);
            const lines = stdout.toString().split("\r\n");
            const parts2 = lines[0].split(":");
            codepage = parts2.length > 1 ? parts2[1].replace(".", "").trim() : "";
          } catch (err) {
            codepage = "437";
          }
        }
        return codepage;
      }
      if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
        if (!codepage) {
          try {
            const stdout = execSync("echo $LANG", execOptsLinux);
            const lines = stdout.toString().split("\r\n");
            const parts2 = lines[0].split(".");
            codepage = parts2.length > 1 ? parts2[1].trim() : "";
            if (!codepage) {
              codepage = "UTF-8";
            }
          } catch (err) {
            codepage = "UTF-8";
          }
        }
        return codepage;
      }
    }
    __name(getCodepage, "getCodepage");
    function smartMonToolsInstalled() {
      if (_smartMonToolsInstalled !== null) {
        return _smartMonToolsInstalled;
      }
      _smartMonToolsInstalled = false;
      if (_windows) {
        try {
          const pathArray = execSync("WHERE smartctl 2>nul", execOptsWin).toString().split("\r\n");
          if (pathArray && pathArray.length) {
            _smartMonToolsInstalled = pathArray[0].indexOf(":\\") >= 0;
          } else {
            _smartMonToolsInstalled = false;
          }
        } catch (e) {
          _smartMonToolsInstalled = false;
        }
      }
      if (_linux || _darwin || _freebsd || _openbsd || _netbsd) {
        try {
          const pathArray = execSync("which smartctl 2>/dev/null", execOptsLinux).toString().split("\r\n");
          _smartMonToolsInstalled = pathArray.length > 0;
        } catch (e) {
          util2.noop();
        }
      }
      return _smartMonToolsInstalled;
    }
    __name(smartMonToolsInstalled, "smartMonToolsInstalled");
    function isRaspberry(cpuinfo) {
      const PI_MODEL_NO = [
        "BCM2708",
        "BCM2709",
        "BCM2710",
        "BCM2711",
        "BCM2712",
        "BCM2835",
        "BCM2836",
        "BCM2837",
        "BCM2837B0"
      ];
      if (_rpi_cpuinfo !== null) {
        cpuinfo = _rpi_cpuinfo;
      } else if (cpuinfo === void 0) {
        try {
          cpuinfo = fs.readFileSync("/proc/cpuinfo", {
            encoding: "utf8"
          }).toString().split("\n");
          _rpi_cpuinfo = cpuinfo;
        } catch (e) {
          return false;
        }
      }
      const hardware = getValue(cpuinfo, "hardware");
      const model = getValue(cpuinfo, "model");
      return hardware && PI_MODEL_NO.indexOf(hardware) > -1 || model && model.indexOf("Raspberry Pi") > -1;
    }
    __name(isRaspberry, "isRaspberry");
    function isRaspbian() {
      let osrelease = [];
      try {
        osrelease = fs.readFileSync("/etc/os-release", {
          encoding: "utf8"
        }).toString().split("\n");
      } catch (e) {
        return false;
      }
      const id = getValue(osrelease, "id", "=");
      return id && id.indexOf("raspbian") > -1;
    }
    __name(isRaspbian, "isRaspbian");
    function execWin(cmd, opts, callback) {
      if (!callback) {
        callback = opts;
        opts = execOptsWin;
      }
      let newCmd = "chcp 65001 > nul && cmd /C " + cmd + " && chcp " + codepage + " > nul";
      exec(newCmd, opts, function(error, stdout) {
        callback(error, stdout);
      });
    }
    __name(execWin, "execWin");
    function darwinXcodeExists() {
      const cmdLineToolsExists = fs.existsSync("/Library/Developer/CommandLineTools/usr/bin/");
      const xcodeAppExists = fs.existsSync("/Applications/Xcode.app/Contents/Developer/Tools");
      const xcodeExists = fs.existsSync("/Library/Developer/Xcode/");
      return cmdLineToolsExists || xcodeExists || xcodeAppExists;
    }
    __name(darwinXcodeExists, "darwinXcodeExists");
    function nanoSeconds() {
      const time = process.hrtime();
      if (!Array.isArray(time) || time.length !== 2) {
        return 0;
      }
      return +time[0] * 1e9 + +time[1];
    }
    __name(nanoSeconds, "nanoSeconds");
    function countUniqueLines(lines, startingWith) {
      startingWith = startingWith || "";
      const uniqueLines = [];
      lines.forEach((line) => {
        if (line.startsWith(startingWith)) {
          if (uniqueLines.indexOf(line) === -1) {
            uniqueLines.push(line);
          }
        }
      });
      return uniqueLines.length;
    }
    __name(countUniqueLines, "countUniqueLines");
    function countLines(lines, startingWith) {
      startingWith = startingWith || "";
      const uniqueLines = [];
      lines.forEach((line) => {
        if (line.startsWith(startingWith)) {
          uniqueLines.push(line);
        }
      });
      return uniqueLines.length;
    }
    __name(countLines, "countLines");
    function sanitizeShellString(str, strict) {
      if (typeof strict === "undefined") {
        strict = false;
      }
      const s = str || "";
      let result2 = "";
      const l = mathMin(s.length, 2e3);
      for (let i = 0; i <= l; i++) {
        if (!(s[i] === void 0 || s[i] === ">" || s[i] === "<" || s[i] === "*" || s[i] === "?" || s[i] === "[" || s[i] === "]" || s[i] === "|" || s[i] === "\u02DA" || s[i] === "$" || s[i] === ";" || s[i] === "&" || s[i] === "]" || s[i] === "#" || s[i] === "\\" || s[i] === "	" || s[i] === "\n" || s[i] === "\r" || s[i] === "'" || s[i] === "`" || s[i] === '"' || s[i].length > 1 || strict && s[i] === "(" || strict && s[i] === ")" || strict && s[i] === "@" || strict && s[i] === " " || strict && s[i] == "{" || strict && s[i] == ";" || strict && s[i] == "}")) {
          result2 = result2 + s[i];
        }
      }
      return result2;
    }
    __name(sanitizeShellString, "sanitizeShellString");
    function isPrototypePolluted() {
      const s = "1234567890abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ";
      let notPolluted = true;
      let st = "";
      try {
        st.__proto__.replace = stringReplace;
        st.__proto__.toLowerCase = stringToLower;
        st.__proto__.toString = stringToString;
        st.__proto__.substr = stringSubstr;
        st.__proto__.substring = stringSubstring;
        st.__proto__.trim = stringTrim;
        st.__proto__.startsWith = stringStartWith;
      } catch (e) {
        Object.setPrototypeOf(st, stringObj);
      }
      notPolluted = notPolluted || s.length !== 62;
      const ms = Date.now();
      if (typeof ms === "number" && ms > 16e11) {
        const l = ms % 100 + 15;
        for (let i = 0; i < l; i++) {
          const r = Math.random() * 61.99999999 + 1;
          const rs = parseInt(Math.floor(r).toString(), 10);
          const rs2 = parseInt(r.toString().split(".")[0], 10);
          const q = Math.random() * 61.99999999 + 1;
          const qs = parseInt(Math.floor(q).toString(), 10);
          const qs2 = parseInt(q.toString().split(".")[0], 10);
          notPolluted = notPolluted && r !== q;
          notPolluted = notPolluted && rs === rs2 && qs === qs2;
          st += s[rs - 1];
        }
        notPolluted = notPolluted && st.length === l;
        let p = Math.random() * l * 0.9999999999;
        let stm = st.substr(0, p) + " " + st.substr(p, 2e3);
        try {
          stm.__proto__.replace = stringReplace;
        } catch (e) {
          Object.setPrototypeOf(stm, stringObj);
        }
        let sto = stm.replace(/ /g, "");
        notPolluted = notPolluted && st === sto;
        p = Math.random() * l * 0.9999999999;
        stm = st.substr(0, p) + "{" + st.substr(p, 2e3);
        sto = stm.replace(/{/g, "");
        notPolluted = notPolluted && st === sto;
        p = Math.random() * l * 0.9999999999;
        stm = st.substr(0, p) + "*" + st.substr(p, 2e3);
        sto = stm.replace(/\*/g, "");
        notPolluted = notPolluted && st === sto;
        p = Math.random() * l * 0.9999999999;
        stm = st.substr(0, p) + "$" + st.substr(p, 2e3);
        sto = stm.replace(/\$/g, "");
        notPolluted = notPolluted && st === sto;
        const stl = st.toLowerCase();
        notPolluted = notPolluted && stl.length === l && stl[l - 1] && !stl[l];
        for (let i = 0; i < l; i++) {
          const s1 = st[i];
          try {
            s1.__proto__.toLowerCase = stringToLower;
          } catch (e) {
            Object.setPrototypeOf(st, stringObj);
          }
          const s2 = stl ? stl[i] : "";
          const s1l = s1.toLowerCase();
          notPolluted = notPolluted && s1l[0] === s2 && s1l[0] && !s1l[1];
        }
      }
      return !notPolluted;
    }
    __name(isPrototypePolluted, "isPrototypePolluted");
    function hex2bin(hex) {
      return ("00000000" + parseInt(hex, 16).toString(2)).substr(-8);
    }
    __name(hex2bin, "hex2bin");
    function getFilesInPath(source) {
      const lstatSync = fs.lstatSync;
      const readdirSync2 = fs.readdirSync;
      const join = path.join;
      function isDirectory(source2) {
        return lstatSync(source2).isDirectory();
      }
      __name(isDirectory, "isDirectory");
      function isFile(source2) {
        return lstatSync(source2).isFile();
      }
      __name(isFile, "isFile");
      function getDirectories(source2) {
        return readdirSync2(source2).map(function(name) {
          return join(source2, name);
        }).filter(isDirectory);
      }
      __name(getDirectories, "getDirectories");
      function getFiles(source2) {
        return readdirSync2(source2).map(function(name) {
          return join(source2, name);
        }).filter(isFile);
      }
      __name(getFiles, "getFiles");
      function getFilesRecursively(source2) {
        try {
          let dirs = getDirectories(source2);
          let files = dirs.map(function(dir) {
            return getFilesRecursively(dir);
          }).reduce(function(a, b) {
            return a.concat(b);
          }, []);
          return files.concat(getFiles(source2));
        } catch (e) {
          return [];
        }
      }
      __name(getFilesRecursively, "getFilesRecursively");
      if (fs.existsSync(source)) {
        return getFilesRecursively(source);
      } else {
        return [];
      }
    }
    __name(getFilesInPath, "getFilesInPath");
    function decodePiCpuinfo(lines) {
      if (_rpi_cpuinfo === null) {
        _rpi_cpuinfo = lines;
      } else if (lines === void 0) {
        lines = _rpi_cpuinfo;
      }
      const oldRevisionCodes = {
        "0002": {
          type: "B",
          revision: "1.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0003": {
          type: "B",
          revision: "1.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0004": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0005": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Qisda",
          processor: "BCM2835"
        },
        "0006": {
          type: "B",
          revision: "2.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0007": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0008": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0009": {
          type: "A",
          revision: "2.0",
          memory: 256,
          manufacturer: "Qisda",
          processor: "BCM2835"
        },
        "000d": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "000e": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "000f": {
          type: "B",
          revision: "2.0",
          memory: 512,
          manufacturer: "Egoman",
          processor: "BCM2835"
        },
        "0010": {
          type: "B+",
          revision: "1.2",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0011": {
          type: "CM1",
          revision: "1.0",
          memory: 512,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0012": {
          type: "A+",
          revision: "1.1",
          memory: 256,
          manufacturer: "Sony UK",
          processor: "BCM2835"
        },
        "0013": {
          type: "B+",
          revision: "1.2",
          memory: 512,
          manufacturer: "Embest",
          processor: "BCM2835"
        },
        "0014": {
          type: "CM1",
          revision: "1.0",
          memory: 512,
          manufacturer: "Embest",
          processor: "BCM2835"
        },
        "0015": {
          type: "A+",
          revision: "1.1",
          memory: 256,
          manufacturer: "512MB	Embest",
          processor: "BCM2835"
        }
      };
      const processorList = [
        "BCM2835",
        "BCM2836",
        "BCM2837",
        "BCM2711",
        "BCM2712"
      ];
      const manufacturerList = [
        "Sony UK",
        "Egoman",
        "Embest",
        "Sony Japan",
        "Embest",
        "Stadium"
      ];
      const typeList = {
        "00": "A",
        "01": "B",
        "02": "A+",
        "03": "B+",
        "04": "2B",
        "05": "Alpha (early prototype)",
        "06": "CM1",
        "08": "3B",
        "09": "Zero",
        "0a": "CM3",
        "0c": "Zero W",
        "0d": "3B+",
        "0e": "3A+",
        "0f": "Internal use only",
        "10": "CM3+",
        "11": "4B",
        "12": "Zero 2 W",
        "13": "400",
        "14": "CM4",
        "15": "CM4S",
        "16": "Internal use only",
        "17": "5",
        "18": "CM5",
        "19": "500",
        "1a": "CM5 Lite"
      };
      const revisionCode = getValue(lines, "revision", ":", true);
      const model = getValue(lines, "model:", ":", true);
      const serial = getValue(lines, "serial", ":", true);
      let result2 = {};
      if ({}.hasOwnProperty.call(oldRevisionCodes, revisionCode)) {
        result2 = {
          model,
          serial,
          revisionCode,
          memory: oldRevisionCodes[revisionCode].memory,
          manufacturer: oldRevisionCodes[revisionCode].manufacturer,
          processor: oldRevisionCodes[revisionCode].processor,
          type: oldRevisionCodes[revisionCode].type,
          revision: oldRevisionCodes[revisionCode].revision
        };
      } else {
        const revision = ("00000000" + getValue(lines, "revision", ":", true).toLowerCase()).substr(-8);
        const memSizeCode = parseInt(hex2bin(revision.substr(2, 1)).substr(5, 3), 2) || 0;
        const manufacturer = manufacturerList[parseInt(revision.substr(3, 1), 10)];
        const processor = processorList[parseInt(revision.substr(4, 1), 10)];
        const typeCode = revision.substr(5, 2);
        result2 = {
          model,
          serial,
          revisionCode,
          memory: 256 * Math.pow(2, memSizeCode),
          manufacturer,
          processor,
          type: {}.hasOwnProperty.call(typeList, typeCode) ? typeList[typeCode] : "",
          revision: "1." + revision.substr(7, 1)
        };
      }
      return result2;
    }
    __name(decodePiCpuinfo, "decodePiCpuinfo");
    function getRpiGpu(cpuinfo) {
      if (_rpi_cpuinfo === null && cpuinfo !== void 0) {
        _rpi_cpuinfo = cpuinfo;
      } else if (cpuinfo === void 0 && _rpi_cpuinfo !== null) {
        cpuinfo = _rpi_cpuinfo;
      } else {
        try {
          cpuinfo = fs.readFileSync("/proc/cpuinfo", {
            encoding: "utf8"
          }).toString().split("\n");
          _rpi_cpuinfo = cpuinfo;
        } catch (e) {
          return false;
        }
      }
      const rpi = decodePiCpuinfo(cpuinfo);
      if (rpi.type === "4B" || rpi.type === "CM4" || rpi.type === "CM4S" || rpi.type === "400") {
        return "VideoCore VI";
      }
      if (rpi.type === "5" || rpi.type === "500") {
        return "VideoCore VII";
      }
      return "VideoCore IV";
    }
    __name(getRpiGpu, "getRpiGpu");
    function promiseAll(promises) {
      const resolvingPromises = promises.map(function(promise) {
        return new Promise(function(resolve5) {
          let payload = new Array(2);
          promise.then(function(result2) {
            payload[0] = result2;
          }).catch(function(error) {
            payload[1] = error;
          }).then(function() {
            resolve5(payload);
          });
        });
      });
      const errors = [];
      const results = [];
      return Promise.all(resolvingPromises).then(function(items) {
        items.forEach(function(payload) {
          if (payload[1]) {
            errors.push(payload[1]);
            results.push(null);
          } else {
            errors.push(null);
            results.push(payload[0]);
          }
        });
        return {
          errors,
          results
        };
      });
    }
    __name(promiseAll, "promiseAll");
    function promisify(nodeStyleFunction) {
      return function() {
        const args = Array.prototype.slice.call(arguments);
        return new Promise(function(resolve5, reject) {
          args.push(function(err, data) {
            if (err) {
              reject(err);
            } else {
              resolve5(data);
            }
          });
          nodeStyleFunction.apply(null, args);
        });
      };
    }
    __name(promisify, "promisify");
    function promisifySave(nodeStyleFunction) {
      return function() {
        const args = Array.prototype.slice.call(arguments);
        return new Promise(function(resolve5) {
          args.push(function(err, data) {
            resolve5(data);
          });
          nodeStyleFunction.apply(null, args);
        });
      };
    }
    __name(promisifySave, "promisifySave");
    function linuxVersion() {
      let result2 = "";
      if (_linux) {
        try {
          result2 = execSync("uname -v", execOptsLinux).toString();
        } catch (e) {
          result2 = "";
        }
      }
      return result2;
    }
    __name(linuxVersion, "linuxVersion");
    function plistParser(xmlStr) {
      const tags = [
        "array",
        "dict",
        "key",
        "string",
        "integer",
        "date",
        "real",
        "data",
        "boolean",
        "arrayEmpty"
      ];
      const startStr = "<plist version";
      let pos = xmlStr.indexOf(startStr);
      let len = xmlStr.length;
      while (xmlStr[pos] !== ">" && pos < len) {
        pos++;
      }
      let depth = 0;
      let inTagStart = false;
      let inTagContent = false;
      let inTagEnd = false;
      let metaData = [
        {
          tagStart: "",
          tagEnd: "",
          tagContent: "",
          key: "",
          data: null
        }
      ];
      let c = "";
      let cn = xmlStr[pos];
      while (pos < len) {
        c = cn;
        if (pos + 1 < len) {
          cn = xmlStr[pos + 1];
        }
        if (c === "<") {
          inTagContent = false;
          if (cn === "/") {
            inTagEnd = true;
          } else if (metaData[depth].tagStart) {
            metaData[depth].tagContent = "";
            if (!metaData[depth].data) {
              metaData[depth].data = metaData[depth].tagStart === "array" ? [] : {};
            }
            depth++;
            metaData.push({
              tagStart: "",
              tagEnd: "",
              tagContent: "",
              key: null,
              data: null
            });
            inTagStart = true;
            inTagContent = false;
          } else if (!inTagStart) {
            inTagStart = true;
          }
        } else if (c === ">") {
          if (metaData[depth].tagStart === "true/") {
            inTagStart = false;
            inTagEnd = true;
            metaData[depth].tagStart = "";
            metaData[depth].tagEnd = "/boolean";
            metaData[depth].data = true;
          }
          if (metaData[depth].tagStart === "false/") {
            inTagStart = false;
            inTagEnd = true;
            metaData[depth].tagStart = "";
            metaData[depth].tagEnd = "/boolean";
            metaData[depth].data = false;
          }
          if (metaData[depth].tagStart === "array/") {
            inTagStart = false;
            inTagEnd = true;
            metaData[depth].tagStart = "";
            metaData[depth].tagEnd = "/arrayEmpty";
            metaData[depth].data = [];
          }
          if (inTagContent) {
            inTagContent = false;
          }
          if (inTagStart) {
            inTagStart = false;
            inTagContent = true;
            if (metaData[depth].tagStart === "array") {
              metaData[depth].data = [];
            }
            if (metaData[depth].tagStart === "dict") {
              metaData[depth].data = {};
            }
          }
          if (inTagEnd) {
            inTagEnd = false;
            if (metaData[depth].tagEnd && tags.indexOf(metaData[depth].tagEnd.substr(1)) >= 0) {
              if (metaData[depth].tagEnd === "/dict" || metaData[depth].tagEnd === "/array") {
                if (depth > 1 && metaData[depth - 2].tagStart === "array") {
                  metaData[depth - 2].data.push(metaData[depth - 1].data);
                }
                if (depth > 1 && metaData[depth - 2].tagStart === "dict") {
                  metaData[depth - 2].data[metaData[depth - 1].key] = metaData[depth - 1].data;
                }
                depth--;
                metaData.pop();
                metaData[depth].tagContent = "";
                metaData[depth].tagStart = "";
                metaData[depth].tagEnd = "";
              } else {
                if (metaData[depth].tagEnd === "/key" && metaData[depth].tagContent) {
                  metaData[depth].key = metaData[depth].tagContent;
                } else {
                  if (metaData[depth].tagEnd === "/real" && metaData[depth].tagContent) {
                    metaData[depth].data = parseFloat(metaData[depth].tagContent) || 0;
                  }
                  if (metaData[depth].tagEnd === "/integer" && metaData[depth].tagContent) {
                    metaData[depth].data = parseInt(metaData[depth].tagContent) || 0;
                  }
                  if (metaData[depth].tagEnd === "/string" && metaData[depth].tagContent) {
                    metaData[depth].data = metaData[depth].tagContent || "";
                  }
                  if (metaData[depth].tagEnd === "/boolean") {
                    metaData[depth].data = metaData[depth].tagContent || false;
                  }
                  if (metaData[depth].tagEnd === "/arrayEmpty") {
                    metaData[depth].data = metaData[depth].tagContent || [];
                  }
                  if (depth > 0 && metaData[depth - 1].tagStart === "array") {
                    metaData[depth - 1].data.push(metaData[depth].data);
                  }
                  if (depth > 0 && metaData[depth - 1].tagStart === "dict") {
                    metaData[depth - 1].data[metaData[depth].key] = metaData[depth].data;
                  }
                }
                metaData[depth].tagContent = "";
                metaData[depth].tagStart = "";
                metaData[depth].tagEnd = "";
              }
            }
            metaData[depth].tagEnd = "";
            inTagStart = false;
            inTagContent = false;
          }
        } else {
          if (inTagStart) {
            metaData[depth].tagStart += c;
          }
          if (inTagEnd) {
            metaData[depth].tagEnd += c;
          }
          if (inTagContent) {
            metaData[depth].tagContent += c;
          }
        }
        pos++;
      }
      return metaData[0].data;
    }
    __name(plistParser, "plistParser");
    function strIsNumeric(str) {
      return typeof str === "string" && !isNaN(str) && !isNaN(parseFloat(str));
    }
    __name(strIsNumeric, "strIsNumeric");
    function plistReader(output) {
      const lines = output.split("\n");
      for (let i = 0; i < lines.length; i++) {
        if (lines[i].indexOf(" = ") >= 0) {
          const lineParts = lines[i].split(" = ");
          lineParts[0] = lineParts[0].trim();
          if (!lineParts[0].startsWith('"')) {
            lineParts[0] = '"' + lineParts[0] + '"';
          }
          lineParts[1] = lineParts[1].trim();
          if (lineParts[1].indexOf('"') === -1 && lineParts[1].endsWith(";")) {
            const valueString = lineParts[1].substring(0, lineParts[1].length - 1);
            if (!strIsNumeric(valueString)) {
              lineParts[1] = `"${valueString}";`;
            }
          }
          if (lineParts[1].indexOf('"') >= 0 && lineParts[1].endsWith(";")) {
            const valueString = lineParts[1].substring(0, lineParts[1].length - 1).replace(/"/g, "");
            if (strIsNumeric(valueString)) {
              lineParts[1] = `${valueString};`;
            }
          }
          lines[i] = lineParts.join(" : ");
        }
        lines[i] = lines[i].replace(/\(/g, "[").replace(/\)/g, "]").replace(/;/g, ",").trim();
        if (lines[i].startsWith("}") && lines[i - 1] && lines[i - 1].endsWith(",")) {
          lines[i - 1] = lines[i - 1].substring(0, lines[i - 1].length - 1);
        }
      }
      output = lines.join("");
      let obj = {};
      try {
        obj = JSON.parse(output);
      } catch (e) {
        noop();
      }
      return obj;
    }
    __name(plistReader, "plistReader");
    function semverCompare(v12, v2) {
      let res = 0;
      const parts1 = v12.split(".");
      const parts2 = v2.split(".");
      if (parts1[0] < parts2[0]) {
        res = 1;
      } else if (parts1[0] > parts2[0]) {
        res = -1;
      } else if (parts1[0] === parts2[0] && parts1.length >= 2 && parts2.length >= 2) {
        if (parts1[1] < parts2[1]) {
          res = 1;
        } else if (parts1[1] > parts2[1]) {
          res = -1;
        } else if (parts1[1] === parts2[1]) {
          if (parts1.length >= 3 && parts2.length >= 3) {
            if (parts1[2] < parts2[2]) {
              res = 1;
            } else if (parts1[2] > parts2[2]) {
              res = -1;
            }
          } else if (parts2.length >= 3) {
            res = 1;
          }
        }
      }
      return res;
    }
    __name(semverCompare, "semverCompare");
    function getAppleModel(key) {
      const appleModelIds = [
        {
          key: "Mac15,12",
          name: "MacBook Air",
          size: "13-inch",
          processor: "M3",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac14,15",
          name: "MacBook Air",
          size: "15-inch",
          processor: "M2",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac14,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "M2",
          year: "2022",
          additional: ""
        },
        {
          key: "MacBookAir10,1",
          name: "MacBook Air",
          size: "13-inch",
          processor: "M1",
          year: "2020",
          additional: ""
        },
        {
          key: "MacBookAir9,1",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "2020",
          additional: ""
        },
        {
          key: "MacBookAir8,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "2019",
          additional: ""
        },
        {
          key: "MacBookAir8,1",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "2018",
          additional: ""
        },
        {
          key: "MacBookAir7,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "2017",
          additional: ""
        },
        {
          key: "MacBookAir7,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "Early 2015",
          additional: ""
        },
        {
          key: "MacBookAir7,1",
          name: "MacBook Air",
          size: "11-inch",
          processor: "",
          year: "Early 2015",
          additional: ""
        },
        {
          key: "MacBookAir6,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "Early 2014",
          additional: ""
        },
        {
          key: "MacBookAir6,1",
          name: "MacBook Air",
          size: "11-inch",
          processor: "",
          year: "Early 2014",
          additional: ""
        },
        {
          key: "MacBookAir6,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "Mid 2013",
          additional: ""
        },
        {
          key: "MacBookAir6,1",
          name: "MacBook Air",
          size: "11-inch",
          processor: "",
          year: "Mid 2013",
          additional: ""
        },
        {
          key: "MacBookAir5,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "Mid 2012",
          additional: ""
        },
        {
          key: "MacBookAir5,1",
          name: "MacBook Air",
          size: "11-inch",
          processor: "",
          year: "Mid 2012",
          additional: ""
        },
        {
          key: "MacBookAir4,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "Mid 2011",
          additional: ""
        },
        {
          key: "MacBookAir4,1",
          name: "MacBook Air",
          size: "11-inch",
          processor: "",
          year: "Mid 2011",
          additional: ""
        },
        {
          key: "MacBookAir3,2",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "Late 2010",
          additional: ""
        },
        {
          key: "MacBookAir3,1",
          name: "MacBook Air",
          size: "11-inch",
          processor: "",
          year: "Late 2010",
          additional: ""
        },
        {
          key: "MacBookAir2,1",
          name: "MacBook Air",
          size: "13-inch",
          processor: "",
          year: "Mid 2009",
          additional: ""
        },
        {
          key: "Mac16,1",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M4",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac16,6",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M4 Pro",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac16,8",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M4 Max",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac16,5",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M4 Pro",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac16,6",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M4 Max",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac15,3",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M3",
          year: "Nov 2023",
          additional: ""
        },
        {
          key: "Mac15,6",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M3 Pro",
          year: "Nov 2023",
          additional: ""
        },
        {
          key: "Mac15,8",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M3 Pro",
          year: "Nov 2023",
          additional: ""
        },
        {
          key: "Mac15,10",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M3 Max",
          year: "Nov 2023",
          additional: ""
        },
        {
          key: "Mac15,7",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M3 Pro",
          year: "Nov 2023",
          additional: ""
        },
        {
          key: "Mac15,9",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M3 Pro",
          year: "Nov 2023",
          additional: ""
        },
        {
          key: "Mac15,11",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M3 Max",
          year: "Nov 2023",
          additional: ""
        },
        {
          key: "Mac14,5",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M2 Max",
          year: "2023",
          additional: ""
        },
        {
          key: "Mac14,9",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M2 Max",
          year: "2023",
          additional: ""
        },
        {
          key: "Mac14,6",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M2 Max",
          year: "2023",
          additional: ""
        },
        {
          key: "Mac14,10",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M2 Max",
          year: "2023",
          additional: ""
        },
        {
          key: "Mac14,7",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "M2",
          year: "2022",
          additional: ""
        },
        {
          key: "MacBookPro18,3",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M1 Pro",
          year: "2021",
          additional: ""
        },
        {
          key: "MacBookPro18,4",
          name: "MacBook Pro",
          size: "14-inch",
          processor: "M1 Max",
          year: "2021",
          additional: ""
        },
        {
          key: "MacBookPro18,1",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M1 Pro",
          year: "2021",
          additional: ""
        },
        {
          key: "MacBookPro18,2",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "M1 Max",
          year: "2021",
          additional: ""
        },
        {
          key: "MacBookPro17,1",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "M1",
          year: "2020",
          additional: ""
        },
        {
          key: "MacBookPro16,3",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2020",
          additional: "Two Thunderbolt 3 ports"
        },
        {
          key: "MacBookPro16,2",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2020",
          additional: "Four Thunderbolt 3 ports"
        },
        {
          key: "MacBookPro16,1",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "",
          year: "2019",
          additional: ""
        },
        {
          key: "MacBookPro16,4",
          name: "MacBook Pro",
          size: "16-inch",
          processor: "",
          year: "2019",
          additional: ""
        },
        {
          key: "MacBookPro15,3",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "2019",
          additional: ""
        },
        {
          key: "MacBookPro15,2",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2019",
          additional: ""
        },
        {
          key: "MacBookPro15,1",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "2019",
          additional: ""
        },
        {
          key: "MacBookPro15,4",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2019",
          additional: "Two Thunderbolt 3 ports"
        },
        {
          key: "MacBookPro15,1",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "2018",
          additional: ""
        },
        {
          key: "MacBookPro15,2",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2018",
          additional: "Four Thunderbolt 3 ports"
        },
        {
          key: "MacBookPro14,1",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2017",
          additional: "Two Thunderbolt 3 ports"
        },
        {
          key: "MacBookPro14,2",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2017",
          additional: "Four Thunderbolt 3 ports"
        },
        {
          key: "MacBookPro14,3",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "2017",
          additional: ""
        },
        {
          key: "MacBookPro13,1",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2016",
          additional: "Two Thunderbolt 3 ports"
        },
        {
          key: "MacBookPro13,2",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "2016",
          additional: "Four Thunderbolt 3 ports"
        },
        {
          key: "MacBookPro13,3",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "2016",
          additional: ""
        },
        {
          key: "MacBookPro11,4",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Mid 2015",
          additional: ""
        },
        {
          key: "MacBookPro11,5",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Mid 2015",
          additional: ""
        },
        {
          key: "MacBookPro12,1",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "Early 2015",
          additional: ""
        },
        {
          key: "MacBookPro11,2",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Late 2013",
          additional: ""
        },
        {
          key: "MacBookPro11,3",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Late 2013",
          additional: ""
        },
        {
          key: "MacBookPro11,1",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "Late 2013",
          additional: ""
        },
        {
          key: "MacBookPro10,1",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Mid 2012",
          additional: ""
        },
        {
          key: "MacBookPro10,2",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "Late 2012",
          additional: ""
        },
        {
          key: "MacBookPro9,1",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Mid 2012",
          additional: ""
        },
        {
          key: "MacBookPro9,2",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "Mid 2012",
          additional: ""
        },
        {
          key: "MacBookPro8,3",
          name: "MacBook Pro",
          size: "17-inch",
          processor: "",
          year: "Early 2011",
          additional: ""
        },
        {
          key: "MacBookPro8,2",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Early 2011",
          additional: ""
        },
        {
          key: "MacBookPro8,1",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "Early 2011",
          additional: ""
        },
        {
          key: "MacBookPro6,1",
          name: "MacBook Pro",
          size: "17-inch",
          processor: "",
          year: "Mid 2010",
          additional: ""
        },
        {
          key: "MacBookPro6,2",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Mid 2010",
          additional: ""
        },
        {
          key: "MacBookPro7,1",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "Mid 2010",
          additional: ""
        },
        {
          key: "MacBookPro5,2",
          name: "MacBook Pro",
          size: "17-inch",
          processor: "",
          year: "Early 2009",
          additional: ""
        },
        {
          key: "MacBookPro5,3",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Mid 2009",
          additional: ""
        },
        {
          key: "MacBookPro5,5",
          name: "MacBook Pro",
          size: "13-inch",
          processor: "",
          year: "Mid 2009",
          additional: ""
        },
        {
          key: "MacBookPro5,1",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Late 2008",
          additional: ""
        },
        {
          key: "MacBookPro4,1",
          name: "MacBook Pro",
          size: "15-inch",
          processor: "",
          year: "Early 2008",
          additional: ""
        },
        {
          key: "MacBook10,1",
          name: "MacBook",
          size: "12-inch",
          processor: "",
          year: "2017",
          additional: ""
        },
        {
          key: "MacBook9,1",
          name: "MacBook",
          size: "12-inch",
          processor: "",
          year: "Early 2016",
          additional: ""
        },
        {
          key: "MacBook8,1",
          name: "MacBook",
          size: "12-inch",
          processor: "",
          year: "Early 2015",
          additional: ""
        },
        {
          key: "MacBook7,1",
          name: "MacBook",
          size: "13-inch",
          processor: "",
          year: "Mid 2010",
          additional: ""
        },
        {
          key: "MacBook6,1",
          name: "MacBook",
          size: "13-inch",
          processor: "",
          year: "Late 2009",
          additional: ""
        },
        {
          key: "MacBook5,2",
          name: "MacBook",
          size: "13-inch",
          processor: "",
          year: "Early 2009",
          additional: ""
        },
        {
          key: "Mac14,13",
          name: "Mac Studio",
          size: "",
          processor: "",
          year: "2023",
          additional: ""
        },
        {
          key: "Mac14,14",
          name: "Mac Studio",
          size: "",
          processor: "",
          year: "2023",
          additional: ""
        },
        {
          key: "Mac13,1",
          name: "Mac Studio",
          size: "",
          processor: "",
          year: "2022",
          additional: ""
        },
        {
          key: "Mac13,2",
          name: "Mac Studio",
          size: "",
          processor: "",
          year: "2022",
          additional: ""
        },
        {
          key: "Mac16,11",
          name: "Mac mini",
          size: "",
          processor: "M4 Pro",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac16,10",
          name: "Mac mini",
          size: "",
          processor: "M4",
          year: "2024",
          additional: ""
        },
        {
          key: "Mac14,3",
          name: "Mac mini",
          size: "",
          processor: "M2",
          year: "2023",
          additional: ""
        },
        {
          key: "Mac14,12",
          name: "Mac mini",
          size: "",
          processor: "M2 Pro",
          year: "2023",
          additional: ""
        },
        {
          key: "Macmini9,1",
          name: "Mac mini",
          size: "",
          processor: "M1",
          year: "2020",
          additional: ""
        },
        {
          key: "Macmini8,1",
          name: "Mac mini",
          size: "",
          processor: "",
          year: "Late 2018",
          additional: ""
        },
        {
          key: "Macmini7,1",
          name: "Mac mini",
          size: "",
          processor: "",
          year: "Late 2014",
          additional: ""
        },
        {
          key: "Macmini6,1",
          name: "Mac mini",
          size: "",
          processor: "",
          year: "Late 2012",
          additional: ""
        },
        {
          key: "Macmini6,2",
          name: "Mac mini",
          size: "",
          processor: "",
          year: "Late 2012",
          additional: ""
        },
        {
          key: "Macmini5,1",
          name: "Mac mini",
          size: "",
          processor: "",
          year: "Mid 2011",
          additional: ""
        },
        {
          key: "Macmini5,2",
          name: "Mac mini",
          size: "",
          processor: "",
          year: "Mid 2011",
          additional: ""
        },
        {
          key: "Macmini4,1",
          name: "Mac mini",
          size: "",
          processor: "",
          year: "Mid 2010",
          additional: ""
        },
        {
          key: "Macmini3,1",
          name: "Mac mini",
          size: "",
          processor: "",
          year: "Early 2009",
          additional: ""
        },
        {
          key: "Mac16,3",
          name: "iMac",
          size: "24-inch",
          processor: "M4",
          year: "2024",
          additional: "Four ports"
        },
        {
          key: "Mac16,2",
          name: "iMac",
          size: "24-inch",
          processor: "M4",
          year: "2024",
          additional: "Two ports"
        },
        {
          key: "Mac15,5",
          name: "iMac",
          size: "24-inch",
          processor: "M3",
          year: "2023",
          additional: "Four ports"
        },
        {
          key: "Mac15,4",
          name: "iMac",
          size: "24-inch",
          processor: "M3",
          year: "2023",
          additional: "Two ports"
        },
        {
          key: "iMac21,1",
          name: "iMac",
          size: "24-inch",
          processor: "M1",
          year: "2021",
          additional: ""
        },
        {
          key: "iMac21,2",
          name: "iMac",
          size: "24-inch",
          processor: "M1",
          year: "2021",
          additional: ""
        },
        {
          key: "iMac20,1",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "2020",
          additional: "Retina 5K"
        },
        {
          key: "iMac20,2",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "2020",
          additional: "Retina 5K"
        },
        {
          key: "iMac19,1",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "2019",
          additional: "Retina 5K"
        },
        {
          key: "iMac19,2",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "2019",
          additional: "Retina 4K"
        },
        {
          key: "iMacPro1,1",
          name: "iMac Pro",
          size: "",
          processor: "",
          year: "2017",
          additional: ""
        },
        {
          key: "iMac18,3",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "2017",
          additional: "Retina 5K"
        },
        {
          key: "iMac18,2",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "2017",
          additional: "Retina 4K"
        },
        {
          key: "iMac18,1",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "2017",
          additional: ""
        },
        {
          key: "iMac17,1",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "Late 2015",
          additional: "Retina 5K"
        },
        {
          key: "iMac16,2",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "Late 2015",
          additional: "Retina 4K"
        },
        {
          key: "iMac16,1",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "Late 2015",
          additional: ""
        },
        {
          key: "iMac15,1",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "Late 2014",
          additional: "Retina 5K"
        },
        {
          key: "iMac14,4",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "Mid 2014",
          additional: ""
        },
        {
          key: "iMac14,2",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "Late 2013",
          additional: ""
        },
        {
          key: "iMac14,1",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "Late 2013",
          additional: ""
        },
        {
          key: "iMac13,2",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "Late 2012",
          additional: ""
        },
        {
          key: "iMac13,1",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "Late 2012",
          additional: ""
        },
        {
          key: "iMac12,2",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "Mid 2011",
          additional: ""
        },
        {
          key: "iMac12,1",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "Mid 2011",
          additional: ""
        },
        {
          key: "iMac11,3",
          name: "iMac",
          size: "27-inch",
          processor: "",
          year: "Mid 2010",
          additional: ""
        },
        {
          key: "iMac11,2",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "Mid 2010",
          additional: ""
        },
        {
          key: "iMac10,1",
          name: "iMac",
          size: "21.5-inch",
          processor: "",
          year: "Late 2009",
          additional: ""
        },
        {
          key: "iMac9,1",
          name: "iMac",
          size: "20-inch",
          processor: "",
          year: "Early 2009",
          additional: ""
        },
        {
          key: "Mac14,8",
          name: "Mac Pro",
          size: "",
          processor: "",
          year: "2023",
          additional: ""
        },
        {
          key: "Mac14,8",
          name: "Mac Pro",
          size: "",
          processor: "",
          year: "2023",
          additional: "Rack"
        },
        {
          key: "MacPro7,1",
          name: "Mac Pro",
          size: "",
          processor: "",
          year: "2019",
          additional: ""
        },
        {
          key: "MacPro7,1",
          name: "Mac Pro",
          size: "",
          processor: "",
          year: "2019",
          additional: "Rack"
        },
        {
          key: "MacPro6,1",
          name: "Mac Pro",
          size: "",
          processor: "",
          year: "Late 2013",
          additional: ""
        },
        {
          key: "MacPro5,1",
          name: "Mac Pro",
          size: "",
          processor: "",
          year: "Mid 2012",
          additional: ""
        },
        {
          key: "MacPro5,1",
          name: "Mac Pro Server",
          size: "",
          processor: "",
          year: "Mid 2012",
          additional: "Server"
        },
        {
          key: "MacPro5,1",
          name: "Mac Pro",
          size: "",
          processor: "",
          year: "Mid 2010",
          additional: ""
        },
        {
          key: "MacPro5,1",
          name: "Mac Pro Server",
          size: "",
          processor: "",
          year: "Mid 2010",
          additional: "Server"
        },
        {
          key: "MacPro4,1",
          name: "Mac Pro",
          size: "",
          processor: "",
          year: "Early 2009",
          additional: ""
        }
      ];
      const list = appleModelIds.filter((model) => model.key === key);
      if (list.length === 0) {
        return {
          key,
          model: "Apple",
          version: "Unknown"
        };
      }
      const features = [];
      if (list[0].size) {
        features.push(list[0].size);
      }
      if (list[0].processor) {
        features.push(list[0].processor);
      }
      if (list[0].year) {
        features.push(list[0].year);
      }
      if (list[0].additional) {
        features.push(list[0].additional);
      }
      return {
        key,
        model: list[0].name,
        version: list[0].name + " (" + features.join(", ") + ")"
      };
    }
    __name(getAppleModel, "getAppleModel");
    function checkWebsite(url2, timeout = 5e3) {
      const http = url2.startsWith("https:") || url2.indexOf(":443/") > 0 || url2.indexOf(":8443/") > 0 ? require("https") : require("http");
      const t = Date.now();
      return new Promise((resolve5) => {
        const request = http.get(url2, function(res) {
          res.on("data", () => {
          });
          res.on("end", () => {
            resolve5({
              url: url2,
              statusCode: res.statusCode,
              message: res.statusMessage,
              time: Date.now() - t
            });
          });
        }).on("error", function(e) {
          resolve5({
            url: url2,
            statusCode: 404,
            message: e.message,
            time: Date.now() - t
          });
        }).setTimeout(timeout, () => {
          request.close();
          resolve5({
            url: url2,
            statusCode: 408,
            message: "Request Timeout",
            time: Date.now() - t
          });
        });
      });
    }
    __name(checkWebsite, "checkWebsite");
    function cleanString(str) {
      return str.replace(/To Be Filled By O.E.M./g, "");
    }
    __name(cleanString, "cleanString");
    function noop() {
    }
    __name(noop, "noop");
    exports2.toInt = toInt;
    exports2.splitByNumber = splitByNumber;
    exports2.execOptsWin = execOptsWin;
    exports2.execOptsLinux = execOptsLinux;
    exports2.getCodepage = getCodepage;
    exports2.execWin = execWin;
    exports2.isFunction = isFunction2;
    exports2.unique = unique;
    exports2.sortByKey = sortByKey;
    exports2.cores = cores;
    exports2.getValue = getValue;
    exports2.decodeEscapeSequence = decodeEscapeSequence;
    exports2.parseDateTime = parseDateTime;
    exports2.parseHead = parseHead;
    exports2.findObjectByKey = findObjectByKey;
    exports2.getWmic = getWmic;
    exports2.wmic = wmic;
    exports2.darwinXcodeExists = darwinXcodeExists;
    exports2.getVboxmanage = getVboxmanage;
    exports2.powerShell = powerShell;
    exports2.powerShellStart = powerShellStart;
    exports2.powerShellRelease = powerShellRelease;
    exports2.execSafe = execSafe;
    exports2.nanoSeconds = nanoSeconds;
    exports2.countUniqueLines = countUniqueLines;
    exports2.countLines = countLines;
    exports2.noop = noop;
    exports2.isRaspberry = isRaspberry;
    exports2.isRaspbian = isRaspbian;
    exports2.sanitizeShellString = sanitizeShellString;
    exports2.isPrototypePolluted = isPrototypePolluted;
    exports2.decodePiCpuinfo = decodePiCpuinfo;
    exports2.getRpiGpu = getRpiGpu;
    exports2.promiseAll = promiseAll;
    exports2.promisify = promisify;
    exports2.promisifySave = promisifySave;
    exports2.smartMonToolsInstalled = smartMonToolsInstalled;
    exports2.linuxVersion = linuxVersion;
    exports2.plistParser = plistParser;
    exports2.plistReader = plistReader;
    exports2.stringObj = stringObj;
    exports2.stringReplace = stringReplace;
    exports2.stringToLower = stringToLower;
    exports2.stringToString = stringToString;
    exports2.stringSubstr = stringSubstr;
    exports2.stringSubstring = stringSubstring;
    exports2.stringTrim = stringTrim;
    exports2.stringStartWith = stringStartWith;
    exports2.mathMin = mathMin;
    exports2.WINDIR = WINDIR;
    exports2.getFilesInPath = getFilesInPath;
    exports2.semverCompare = semverCompare;
    exports2.getAppleModel = getAppleModel;
    exports2.checkWebsite = checkWebsite;
    exports2.cleanString = cleanString;
    exports2.getPowershell = getPowershell;
  }
});

// node_modules/systeminformation/lib/system.js
var require_system = __commonJS({
  "node_modules/systeminformation/lib/system.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var os = require("os");
    var util2 = require_util();
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var execPromise = util2.promisify(require("child_process").exec);
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function system(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            manufacturer: "",
            model: "Computer",
            version: "",
            serial: "-",
            uuid: "-",
            sku: "-",
            virtual: false
          };
          if (_linux || _freebsd || _openbsd || _netbsd) {
            exec("export LC_ALL=C; dmidecode -t system 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result2.manufacturer = cleanDefaults(util2.getValue(lines, "manufacturer"));
              result2.model = cleanDefaults(util2.getValue(lines, "product name"));
              result2.version = cleanDefaults(util2.getValue(lines, "version"));
              result2.serial = cleanDefaults(util2.getValue(lines, "serial number"));
              result2.uuid = cleanDefaults(util2.getValue(lines, "uuid")).toLowerCase();
              result2.sku = cleanDefaults(util2.getValue(lines, "sku number"));
              const cmd = `echo -n "product_name: "; cat /sys/devices/virtual/dmi/id/product_name 2>/dev/null; echo;
            echo -n "product_serial: "; cat /sys/devices/virtual/dmi/id/product_serial 2>/dev/null; echo;
            echo -n "product_uuid: "; cat /sys/devices/virtual/dmi/id/product_uuid 2>/dev/null; echo;
            echo -n "product_version: "; cat /sys/devices/virtual/dmi/id/product_version 2>/dev/null; echo;
            echo -n "sys_vendor: "; cat /sys/devices/virtual/dmi/id/sys_vendor 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd, util2.execOptsLinux).toString().split("\n");
                result2.manufacturer = cleanDefaults(result2.manufacturer === "" ? util2.getValue(lines, "sys_vendor") : result2.manufacturer);
                result2.model = cleanDefaults(result2.model === "" ? util2.getValue(lines, "product_name") : result2.model);
                result2.version = cleanDefaults(result2.version === "" ? util2.getValue(lines, "product_version") : result2.version);
                result2.serial = cleanDefaults(result2.serial === "" ? util2.getValue(lines, "product_serial") : result2.serial);
                result2.uuid = cleanDefaults(result2.uuid === "" ? util2.getValue(lines, "product_uuid").toLowerCase() : result2.uuid);
              } catch (e) {
                util2.noop();
              }
              if (!result2.serial) {
                result2.serial = "-";
              }
              if (!result2.manufacturer) {
                result2.manufacturer = "";
              }
              if (!result2.model) {
                result2.model = "Computer";
              }
              if (!result2.version) {
                result2.version = "";
              }
              if (!result2.sku) {
                result2.sku = "-";
              }
              if (result2.model.toLowerCase() === "virtualbox" || result2.model.toLowerCase() === "kvm" || result2.model.toLowerCase() === "virtual machine" || result2.model.toLowerCase() === "bochs" || result2.model.toLowerCase().startsWith("vmware") || result2.model.toLowerCase().startsWith("droplet")) {
                result2.virtual = true;
                switch (result2.model.toLowerCase()) {
                  case "virtualbox":
                    result2.virtualHost = "VirtualBox";
                    break;
                  case "vmware":
                    result2.virtualHost = "VMware";
                    break;
                  case "kvm":
                    result2.virtualHost = "KVM";
                    break;
                  case "bochs":
                    result2.virtualHost = "bochs";
                    break;
                }
              }
              if (result2.manufacturer.toLowerCase().startsWith("vmware") || result2.manufacturer.toLowerCase() === "xen") {
                result2.virtual = true;
                switch (result2.manufacturer.toLowerCase()) {
                  case "vmware":
                    result2.virtualHost = "VMware";
                    break;
                  case "xen":
                    result2.virtualHost = "Xen";
                    break;
                }
              }
              if (!result2.virtual) {
                try {
                  const disksById = execSync("ls -1 /dev/disk/by-id/ 2>/dev/null", util2.execOptsLinux).toString();
                  if (disksById.indexOf("_QEMU_") >= 0) {
                    result2.virtual = true;
                    result2.virtualHost = "QEMU";
                  }
                  if (disksById.indexOf("_VBOX_") >= 0) {
                    result2.virtual = true;
                    result2.virtualHost = "VirtualBox";
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              if (!result2.virtual && (os.release().toLowerCase().indexOf("microsoft") >= 0 || os.release().toLowerCase().endsWith("wsl2"))) {
                const kernelVersion = parseFloat(os.release().toLowerCase());
                result2.virtual = true;
                result2.manufacturer = "Microsoft";
                result2.model = "WSL";
                result2.version = kernelVersion < 4.19 ? "1" : "2";
              }
              if ((_freebsd || _openbsd || _netbsd) && !result2.virtualHost) {
                try {
                  const procInfo = execSync("dmidecode -t 4", util2.execOptsLinux);
                  const procLines = procInfo.toString().split("\n");
                  const procManufacturer = util2.getValue(procLines, "manufacturer", ":", true);
                  switch (procManufacturer.toLowerCase()) {
                    case "virtualbox":
                      result2.virtualHost = "VirtualBox";
                      break;
                    case "vmware":
                      result2.virtualHost = "VMware";
                      break;
                    case "kvm":
                      result2.virtualHost = "KVM";
                      break;
                    case "bochs":
                      result2.virtualHost = "bochs";
                      break;
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              if (fs.existsSync("/.dockerenv") || fs.existsSync("/.dockerinit")) {
                result2.model = "Docker Container";
              }
              try {
                const stdout2 = execSync('dmesg 2>/dev/null | grep -iE "virtual|hypervisor" | grep -iE "vmware|qemu|kvm|xen" | grep -viE "Nested Virtualization|/virtual/"');
                let lines2 = stdout2.toString().split("\n");
                if (lines2.length > 0) {
                  if (result2.model === "Computer") {
                    result2.model = "Virtual machine";
                  }
                  result2.virtual = true;
                  if (stdout2.toString().toLowerCase().indexOf("vmware") >= 0 && !result2.virtualHost) {
                    result2.virtualHost = "VMware";
                  }
                  if (stdout2.toString().toLowerCase().indexOf("qemu") >= 0 && !result2.virtualHost) {
                    result2.virtualHost = "QEMU";
                  }
                  if (stdout2.toString().toLowerCase().indexOf("xen") >= 0 && !result2.virtualHost) {
                    result2.virtualHost = "Xen";
                  }
                  if (stdout2.toString().toLowerCase().indexOf("kvm") >= 0 && !result2.virtualHost) {
                    result2.virtualHost = "KVM";
                  }
                }
              } catch (e) {
                util2.noop();
              }
              if (result2.manufacturer === "" && result2.model === "Computer" && result2.version === "") {
                fs.readFile("/proc/cpuinfo", function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    result2.model = util2.getValue(lines2, "hardware", ":", true).toUpperCase();
                    result2.version = util2.getValue(lines2, "revision", ":", true).toLowerCase();
                    result2.serial = util2.getValue(lines2, "serial", ":", true);
                    const model = util2.getValue(lines2, "model:", ":", true);
                    if (util2.isRaspberry(lines2)) {
                      const rPIRevision = util2.decodePiCpuinfo(lines2);
                      result2.model = rPIRevision.model;
                      result2.version = rPIRevision.revisionCode;
                      result2.manufacturer = "Raspberry Pi Foundation";
                      result2.raspberry = {
                        manufacturer: rPIRevision.manufacturer,
                        processor: rPIRevision.processor,
                        type: rPIRevision.type,
                        revision: rPIRevision.revision
                      };
                    }
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            });
          }
          if (_darwin) {
            exec("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
                const model = util2.getAppleModel(util2.getValue(lines, "model", "=", true));
                result2.manufacturer = util2.getValue(lines, "manufacturer", "=", true);
                result2.model = model.key;
                result2.type = macOsChassisType(model.version);
                result2.version = model.version;
                result2.serial = util2.getValue(lines, "ioplatformserialnumber", "=", true);
                result2.uuid = util2.getValue(lines, "ioplatformuuid", "=", true).toLowerCase();
                result2.sku = util2.getValue(lines, "board-id", "=", true) || util2.getValue(lines, "target-sub-type", "=", true);
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_windows) {
            try {
              util2.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select Name,Vendor,Version,IdentifyingNumber,UUID | fl").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.split("\r\n");
                  result2.manufacturer = util2.getValue(lines, "vendor", ":");
                  result2.model = util2.getValue(lines, "name", ":");
                  result2.version = util2.getValue(lines, "version", ":");
                  result2.serial = util2.getValue(lines, "identifyingnumber", ":");
                  result2.uuid = util2.getValue(lines, "uuid", ":").toLowerCase();
                  const model = result2.model.toLowerCase();
                  if (model === "virtualbox" || model === "kvm" || model === "virtual machine" || model === "bochs" || model.startsWith("vmware") || model.startsWith("qemu") || model.startsWith("parallels")) {
                    result2.virtual = true;
                    if (model.startsWith("virtualbox")) {
                      result2.virtualHost = "VirtualBox";
                    }
                    if (model.startsWith("vmware")) {
                      result2.virtualHost = "VMware";
                    }
                    if (model.startsWith("kvm")) {
                      result2.virtualHost = "KVM";
                    }
                    if (model.startsWith("bochs")) {
                      result2.virtualHost = "bochs";
                    }
                    if (model.startsWith("qemu")) {
                      result2.virtualHost = "KVM";
                    }
                    if (model.startsWith("parallels")) {
                      result2.virtualHost = "Parallels";
                    }
                  }
                  const manufacturer = result2.manufacturer.toLowerCase();
                  if (manufacturer.startsWith("vmware") || manufacturer.startsWith("qemu") || manufacturer === "xen" || manufacturer.startsWith("parallels")) {
                    result2.virtual = true;
                    if (manufacturer.startsWith("vmware")) {
                      result2.virtualHost = "VMware";
                    }
                    if (manufacturer.startsWith("xen")) {
                      result2.virtualHost = "Xen";
                    }
                    if (manufacturer.startsWith("qemu")) {
                      result2.virtualHost = "KVM";
                    }
                    if (manufacturer.startsWith("parallels")) {
                      result2.virtualHost = "Parallels";
                    }
                  }
                  util2.powerShell('Get-CimInstance MS_Systeminformation -Namespace "root/wmi" | select systemsku | fl ').then((stdout2, error2) => {
                    if (!error2) {
                      let lines2 = stdout2.split("\r\n");
                      result2.sku = util2.getValue(lines2, "systemsku", ":");
                    }
                    if (!result2.virtual) {
                      util2.powerShell("Get-CimInstance Win32_bios | select Version, SerialNumber, SMBIOSBIOSVersion").then((stdout3, error3) => {
                        if (!error3) {
                          let lines2 = stdout3.toString();
                          if (lines2.indexOf("VRTUAL") >= 0 || lines2.indexOf("A M I ") >= 0 || lines2.indexOf("VirtualBox") >= 0 || lines2.indexOf("VMWare") >= 0 || lines2.indexOf("Xen") >= 0 || lines2.indexOf("Parallels") >= 0) {
                            result2.virtual = true;
                            if (lines2.indexOf("VirtualBox") >= 0 && !result2.virtualHost) {
                              result2.virtualHost = "VirtualBox";
                            }
                            if (lines2.indexOf("VMware") >= 0 && !result2.virtualHost) {
                              result2.virtualHost = "VMware";
                            }
                            if (lines2.indexOf("Xen") >= 0 && !result2.virtualHost) {
                              result2.virtualHost = "Xen";
                            }
                            if (lines2.indexOf("VRTUAL") >= 0 && !result2.virtualHost) {
                              result2.virtualHost = "Hyper-V";
                            }
                            if (lines2.indexOf("A M I") >= 0 && !result2.virtualHost) {
                              result2.virtualHost = "Virtual PC";
                            }
                            if (lines2.indexOf("Parallels") >= 0 && !result2.virtualHost) {
                              result2.virtualHost = "Parallels";
                            }
                          }
                          if (callback) {
                            callback(result2);
                          }
                          resolve5(result2);
                        } else {
                          if (callback) {
                            callback(result2);
                          }
                          resolve5(result2);
                        }
                      });
                    } else {
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    }
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(system, "system");
    exports2.system = system;
    function cleanDefaults(s) {
      const cmpStr = s.toLowerCase();
      if (cmpStr.indexOf("o.e.m.") === -1 && cmpStr.indexOf("default string") === -1 && cmpStr !== "default") {
        return s || "";
      }
      return "";
    }
    __name(cleanDefaults, "cleanDefaults");
    function bios(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            vendor: "",
            version: "",
            releaseDate: "",
            revision: ""
          };
          let cmd = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            if (process.arch === "arm") {
              cmd = "cat /proc/cpuinfo | grep Serial";
            } else {
              cmd = "export LC_ALL=C; dmidecode -t bios 2>/dev/null; unset LC_ALL";
            }
            exec(cmd, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result2.vendor = util2.getValue(lines, "Vendor");
              result2.version = util2.getValue(lines, "Version");
              let datetime = util2.getValue(lines, "Release Date");
              result2.releaseDate = util2.parseDateTime(datetime).date;
              result2.revision = util2.getValue(lines, "BIOS Revision");
              result2.serial = util2.getValue(lines, "SerialNumber");
              let language = util2.getValue(lines, "Currently Installed Language").split("|")[0];
              if (language) {
                result2.language = language;
              }
              if (lines.length && stdout.toString().indexOf("Characteristics:") >= 0) {
                const features = [];
                lines.forEach((line) => {
                  if (line.indexOf(" is supported") >= 0) {
                    const feature = line.split(" is supported")[0].trim();
                    features.push(feature);
                  }
                });
                result2.features = features;
              }
              const cmd2 = `echo -n "bios_date: "; cat /sys/devices/virtual/dmi/id/bios_date 2>/dev/null; echo;
            echo -n "bios_vendor: "; cat /sys/devices/virtual/dmi/id/bios_vendor 2>/dev/null; echo;
            echo -n "bios_version: "; cat /sys/devices/virtual/dmi/id/bios_version 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd2, util2.execOptsLinux).toString().split("\n");
                result2.vendor = !result2.vendor ? util2.getValue(lines, "bios_vendor") : result2.vendor;
                result2.version = !result2.version ? util2.getValue(lines, "bios_version") : result2.version;
                datetime = util2.getValue(lines, "bios_date");
                result2.releaseDate = !result2.releaseDate ? util2.parseDateTime(datetime).date : result2.releaseDate;
              } catch (e) {
                util2.noop();
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            result2.vendor = "Apple Inc.";
            exec("system_profiler SPHardwareDataType -json", function(error, stdout) {
              try {
                const hardwareData = JSON.parse(stdout.toString());
                if (hardwareData && hardwareData.SPHardwareDataType && hardwareData.SPHardwareDataType.length) {
                  let bootRomVersion = hardwareData.SPHardwareDataType[0].boot_rom_version;
                  bootRomVersion = bootRomVersion ? bootRomVersion.split("(")[0].trim() : null;
                  result2.version = bootRomVersion;
                }
              } catch (e) {
                util2.noop();
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            result2.vendor = "Sun Microsystems";
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_windows) {
            try {
              util2.powerShell('Get-CimInstance Win32_bios | select Description,Version,Manufacturer,@{n="ReleaseDate";e={$_.ReleaseDate.ToString("yyyy-MM-dd")}},BuildNumber,SerialNumber,SMBIOSBIOSVersion | fl').then((stdout, error) => {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  const description = util2.getValue(lines, "description", ":");
                  const version2 = util2.getValue(lines, "SMBIOSBIOSVersion", ":");
                  if (description.indexOf(" Version ") !== -1) {
                    result2.vendor = description.split(" Version ")[0].trim();
                    result2.version = description.split(" Version ")[1].trim();
                  } else if (description.indexOf(" Ver: ") !== -1) {
                    result2.vendor = util2.getValue(lines, "manufacturer", ":");
                    result2.version = description.split(" Ver: ")[1].trim();
                  } else {
                    result2.vendor = util2.getValue(lines, "manufacturer", ":");
                    result2.version = version2 || util2.getValue(lines, "version", ":");
                  }
                  result2.releaseDate = util2.getValue(lines, "releasedate", ":");
                  result2.revision = util2.getValue(lines, "buildnumber", ":");
                  result2.serial = cleanDefaults(util2.getValue(lines, "serialnumber", ":"));
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(bios, "bios");
    exports2.bios = bios;
    function baseboard(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            manufacturer: "",
            model: "",
            version: "",
            serial: "-",
            assetTag: "-",
            memMax: null,
            memSlots: null
          };
          let cmd = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            if (process.arch === "arm") {
              cmd = "cat /proc/cpuinfo | grep Serial";
            } else {
              cmd = "export LC_ALL=C; dmidecode -t 2 2>/dev/null; unset LC_ALL";
            }
            const workload = [];
            workload.push(execPromise(cmd));
            workload.push(execPromise("export LC_ALL=C; dmidecode -t memory 2>/dev/null"));
            util2.promiseAll(workload).then((data) => {
              let lines = data.results[0] ? data.results[0].toString().split("\n") : [
                ""
              ];
              result2.manufacturer = cleanDefaults(util2.getValue(lines, "Manufacturer"));
              result2.model = cleanDefaults(util2.getValue(lines, "Product Name"));
              result2.version = cleanDefaults(util2.getValue(lines, "Version"));
              result2.serial = cleanDefaults(util2.getValue(lines, "Serial Number"));
              result2.assetTag = cleanDefaults(util2.getValue(lines, "Asset Tag"));
              const cmd2 = `echo -n "board_asset_tag: "; cat /sys/devices/virtual/dmi/id/board_asset_tag 2>/dev/null; echo;
            echo -n "board_name: "; cat /sys/devices/virtual/dmi/id/board_name 2>/dev/null; echo;
            echo -n "board_serial: "; cat /sys/devices/virtual/dmi/id/board_serial 2>/dev/null; echo;
            echo -n "board_vendor: "; cat /sys/devices/virtual/dmi/id/board_vendor 2>/dev/null; echo;
            echo -n "board_version: "; cat /sys/devices/virtual/dmi/id/board_version 2>/dev/null; echo;`;
              try {
                lines = execSync(cmd2, util2.execOptsLinux).toString().split("\n");
                result2.manufacturer = cleanDefaults(!result2.manufacturer ? util2.getValue(lines, "board_vendor") : result2.manufacturer);
                result2.model = cleanDefaults(!result2.model ? util2.getValue(lines, "board_name") : result2.model);
                result2.version = cleanDefaults(!result2.version ? util2.getValue(lines, "board_version") : result2.version);
                result2.serial = cleanDefaults(!result2.serial ? util2.getValue(lines, "board_serial") : result2.serial);
                result2.assetTag = cleanDefaults(!result2.assetTag ? util2.getValue(lines, "board_asset_tag") : result2.assetTag);
              } catch (e) {
                util2.noop();
              }
              lines = data.results[1] ? data.results[1].toString().split("\n") : [
                ""
              ];
              result2.memMax = util2.toInt(util2.getValue(lines, "Maximum Capacity")) * 1024 * 1024 * 1024 || null;
              result2.memSlots = util2.toInt(util2.getValue(lines, "Number Of Devices")) || null;
              if (util2.isRaspberry()) {
                const rpi = util2.decodePiCpuinfo();
                result2.manufacturer = rpi.manufacturer;
                result2.model = "Raspberry Pi";
                result2.serial = rpi.serial;
                result2.version = rpi.type + " - " + rpi.revision;
                result2.memMax = os.totalmem();
                result2.memSlots = 0;
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            const workload = [];
            workload.push(execPromise("ioreg -c IOPlatformExpertDevice -d 2"));
            workload.push(execPromise("system_profiler SPMemoryDataType"));
            util2.promiseAll(workload).then((data) => {
              let lines = data.results[0] ? data.results[0].toString().replace(/[<>"]/g, "").split("\n") : [
                ""
              ];
              result2.manufacturer = util2.getValue(lines, "manufacturer", "=", true);
              result2.model = util2.getValue(lines, "model", "=", true);
              result2.version = util2.getValue(lines, "version", "=", true);
              result2.serial = util2.getValue(lines, "ioplatformserialnumber", "=", true);
              result2.assetTag = util2.getValue(lines, "board-id", "=", true);
              let devices = data.results[1] ? data.results[1].toString().split("        BANK ") : [
                ""
              ];
              if (devices.length === 1) {
                devices = data.results[1] ? data.results[1].toString().split("        DIMM") : [
                  ""
                ];
              }
              devices.shift();
              result2.memSlots = devices.length;
              if (os.arch() === "arm64") {
                result2.memSlots = 0;
                result2.memMax = os.totalmem();
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_windows) {
            try {
              const workload = [];
              const win10plus = parseInt(os.release()) >= 10;
              const maxCapacityAttribute = win10plus ? "MaxCapacityEx" : "MaxCapacity";
              workload.push(util2.powerShell("Get-CimInstance Win32_baseboard | select Model,Manufacturer,Product,Version,SerialNumber,PartNumber,SKU | fl"));
              workload.push(util2.powerShell(`Get-CimInstance Win32_physicalmemoryarray | select ${maxCapacityAttribute}, MemoryDevices | fl`));
              util2.promiseAll(workload).then((data) => {
                let lines = data.results[0] ? data.results[0].toString().split("\r\n") : [
                  ""
                ];
                result2.manufacturer = cleanDefaults(util2.getValue(lines, "manufacturer", ":"));
                result2.model = cleanDefaults(util2.getValue(lines, "model", ":"));
                if (!result2.model) {
                  result2.model = cleanDefaults(util2.getValue(lines, "product", ":"));
                }
                result2.version = cleanDefaults(util2.getValue(lines, "version", ":"));
                result2.serial = cleanDefaults(util2.getValue(lines, "serialnumber", ":"));
                result2.assetTag = cleanDefaults(util2.getValue(lines, "partnumber", ":"));
                if (!result2.assetTag) {
                  result2.assetTag = cleanDefaults(util2.getValue(lines, "sku", ":"));
                }
                lines = data.results[1] ? data.results[1].toString().split("\r\n") : [
                  ""
                ];
                result2.memMax = util2.toInt(util2.getValue(lines, maxCapacityAttribute, ":")) * (win10plus ? 1024 : 1) || null;
                result2.memSlots = util2.toInt(util2.getValue(lines, "MemoryDevices", ":")) || null;
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(baseboard, "baseboard");
    exports2.baseboard = baseboard;
    function macOsChassisType(model) {
      model = model.toLowerCase();
      if (model.indexOf("macbookair") >= 0 || model.indexOf("macbook air") >= 0) {
        return "Notebook";
      }
      if (model.indexOf("macbookpro") >= 0 || model.indexOf("macbook pro") >= 0) {
        return "Notebook";
      }
      if (model.indexOf("macbook") >= 0) {
        return "Notebook";
      }
      if (model.indexOf("macmini") >= 0 || model.indexOf("mac mini") >= 0) {
        return "Desktop";
      }
      if (model.indexOf("imac") >= 0) {
        return "Desktop";
      }
      if (model.indexOf("macstudio") >= 0 || model.indexOf("mac studio") >= 0) {
        return "Desktop";
      }
      if (model.indexOf("macpro") >= 0 || model.indexOf("mac pro") >= 0) {
        return "Tower";
      }
      return "Other";
    }
    __name(macOsChassisType, "macOsChassisType");
    function chassis(callback) {
      const chassisTypes = [
        "Other",
        "Unknown",
        "Desktop",
        "Low Profile Desktop",
        "Pizza Box",
        "Mini Tower",
        "Tower",
        "Portable",
        "Laptop",
        "Notebook",
        "Hand Held",
        "Docking Station",
        "All in One",
        "Sub Notebook",
        "Space-Saving",
        "Lunch Box",
        "Main System Chassis",
        "Expansion Chassis",
        "SubChassis",
        "Bus Expansion Chassis",
        "Peripheral Chassis",
        "Storage Chassis",
        "Rack Mount Chassis",
        "Sealed-Case PC",
        "Multi-System Chassis",
        "Compact PCI",
        "Advanced TCA",
        "Blade",
        "Blade Enclosure",
        "Tablet",
        "Convertible",
        "Detachable",
        "IoT Gateway ",
        "Embedded PC",
        "Mini PC",
        "Stick PC"
      ];
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            manufacturer: "",
            model: "",
            type: "",
            version: "",
            serial: "-",
            assetTag: "-",
            sku: ""
          };
          if (_linux || _freebsd || _openbsd || _netbsd) {
            const cmd = `echo -n "chassis_asset_tag: "; cat /sys/devices/virtual/dmi/id/chassis_asset_tag 2>/dev/null; echo;
            echo -n "chassis_serial: "; cat /sys/devices/virtual/dmi/id/chassis_serial 2>/dev/null; echo;
            echo -n "chassis_type: "; cat /sys/devices/virtual/dmi/id/chassis_type 2>/dev/null; echo;
            echo -n "chassis_vendor: "; cat /sys/devices/virtual/dmi/id/chassis_vendor 2>/dev/null; echo;
            echo -n "chassis_version: "; cat /sys/devices/virtual/dmi/id/chassis_version 2>/dev/null; echo;`;
            exec(cmd, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result2.manufacturer = cleanDefaults(util2.getValue(lines, "chassis_vendor"));
              const ctype = parseInt(util2.getValue(lines, "chassis_type").replace(/\D/g, ""));
              result2.type = cleanDefaults(ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "");
              result2.version = cleanDefaults(util2.getValue(lines, "chassis_version"));
              result2.serial = cleanDefaults(util2.getValue(lines, "chassis_serial"));
              result2.assetTag = cleanDefaults(util2.getValue(lines, "chassis_asset_tag"));
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            exec("ioreg -c IOPlatformExpertDevice -d 2", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().replace(/[<>"]/g, "").split("\n");
                const model = util2.getAppleModel(util2.getValue(lines, "model", "=", true));
                result2.manufacturer = util2.getValue(lines, "manufacturer", "=", true);
                result2.model = model.key;
                result2.type = macOsChassisType(model.model);
                result2.version = model.version;
                result2.serial = util2.getValue(lines, "ioplatformserialnumber", "=", true);
                result2.assetTag = util2.getValue(lines, "board-id", "=", true) || util2.getValue(lines, "target-type", "=", true);
                result2.sku = util2.getValue(lines, "target-sub-type", "=", true);
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_windows) {
            try {
              util2.powerShell("Get-CimInstance Win32_SystemEnclosure | select Model,Manufacturer,ChassisTypes,Version,SerialNumber,PartNumber,SKU,SMBIOSAssetTag | fl").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  result2.manufacturer = cleanDefaults(util2.getValue(lines, "manufacturer", ":"));
                  result2.model = cleanDefaults(util2.getValue(lines, "model", ":"));
                  const ctype = parseInt(util2.getValue(lines, "ChassisTypes", ":").replace(/\D/g, ""));
                  result2.type = ctype && !isNaN(ctype) && ctype < chassisTypes.length ? chassisTypes[ctype - 1] : "";
                  result2.version = cleanDefaults(util2.getValue(lines, "version", ":"));
                  result2.serial = cleanDefaults(util2.getValue(lines, "serialnumber", ":"));
                  result2.assetTag = cleanDefaults(util2.getValue(lines, "partnumber", ":"));
                  if (!result2.assetTag) {
                    result2.assetTag = cleanDefaults(util2.getValue(lines, "SMBIOSAssetTag", ":"));
                  }
                  result2.sku = cleanDefaults(util2.getValue(lines, "sku", ":"));
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(chassis, "chassis");
    exports2.chassis = chassis;
  }
});

// node_modules/systeminformation/lib/osinfo.js
var require_osinfo = __commonJS({
  "node_modules/systeminformation/lib/osinfo.js"(exports2) {
    "use strict";
    var os = require("os");
    var fs = require("fs");
    var util2 = require_util();
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function time() {
      let t = (/* @__PURE__ */ new Date()).toString().split(" ");
      const result1 = {
        current: Date.now(),
        uptime: os.uptime(),
        timezone: t.length >= 7 ? t[5] : "",
        timezoneName: Intl ? Intl.DateTimeFormat().resolvedOptions().timeZone : t.length >= 7 ? t.slice(6).join(" ").replace(/\(/g, "").replace(/\)/g, "") : ""
      };
      if (_darwin || _linux) {
        try {
          const stdout = execSync("date +%Z && date +%z && ls -l /etc/localtime 2>/dev/null", util2.execOptsLinux);
          const lines = stdout.toString().split(os.EOL);
          if (lines.length > 3 && !lines[0]) {
            lines.shift();
          }
          let timezone = lines[0] || "";
          if (timezone.startsWith("+") || timezone.startsWith("-")) {
            timezone = "GMT";
          }
          return {
            current: Date.now(),
            uptime: os.uptime(),
            timezone: lines[1] ? timezone + lines[1] : timezone,
            timezoneName: lines[2] && lines[2].indexOf("/zoneinfo/") > 0 ? lines[2].split("/zoneinfo/")[1] || "" : ""
          };
        } catch (e) {
          util2.noop();
        }
      }
      return result1;
    }
    __name(time, "time");
    exports2.time = time;
    function getLogoFile(distro) {
      distro = distro || "";
      distro = distro.toLowerCase();
      let result1 = _platform;
      if (_windows) {
        result1 = "windows";
      } else if (distro.indexOf("mac os") !== -1 || distro.indexOf("macos") !== -1) {
        result1 = "apple";
      } else if (distro.indexOf("arch") !== -1) {
        result1 = "arch";
      } else if (distro.indexOf("cachy") !== -1) {
        result1 = "cachy";
      } else if (distro.indexOf("centos") !== -1) {
        result1 = "centos";
      } else if (distro.indexOf("coreos") !== -1) {
        result1 = "coreos";
      } else if (distro.indexOf("debian") !== -1) {
        result1 = "debian";
      } else if (distro.indexOf("deepin") !== -1) {
        result1 = "deepin";
      } else if (distro.indexOf("elementary") !== -1) {
        result1 = "elementary";
      } else if (distro.indexOf("endeavour") !== -1) {
        result1 = "endeavour";
      } else if (distro.indexOf("fedora") !== -1) {
        result1 = "fedora";
      } else if (distro.indexOf("gentoo") !== -1) {
        result1 = "gentoo";
      } else if (distro.indexOf("mageia") !== -1) {
        result1 = "mageia";
      } else if (distro.indexOf("mandriva") !== -1) {
        result1 = "mandriva";
      } else if (distro.indexOf("manjaro") !== -1) {
        result1 = "manjaro";
      } else if (distro.indexOf("mint") !== -1) {
        result1 = "mint";
      } else if (distro.indexOf("mx") !== -1) {
        result1 = "mx";
      } else if (distro.indexOf("openbsd") !== -1) {
        result1 = "openbsd";
      } else if (distro.indexOf("freebsd") !== -1) {
        result1 = "freebsd";
      } else if (distro.indexOf("opensuse") !== -1) {
        result1 = "opensuse";
      } else if (distro.indexOf("pclinuxos") !== -1) {
        result1 = "pclinuxos";
      } else if (distro.indexOf("puppy") !== -1) {
        result1 = "puppy";
      } else if (distro.indexOf("popos") !== -1) {
        result1 = "popos";
      } else if (distro.indexOf("raspbian") !== -1) {
        result1 = "raspbian";
      } else if (distro.indexOf("reactos") !== -1) {
        result1 = "reactos";
      } else if (distro.indexOf("redhat") !== -1) {
        result1 = "redhat";
      } else if (distro.indexOf("slackware") !== -1) {
        result1 = "slackware";
      } else if (distro.indexOf("sugar") !== -1) {
        result1 = "sugar";
      } else if (distro.indexOf("steam") !== -1) {
        result1 = "steam";
      } else if (distro.indexOf("suse") !== -1) {
        result1 = "suse";
      } else if (distro.indexOf("mate") !== -1) {
        result1 = "ubuntu-mate";
      } else if (distro.indexOf("lubuntu") !== -1) {
        result1 = "lubuntu";
      } else if (distro.indexOf("xubuntu") !== -1) {
        result1 = "xubuntu";
      } else if (distro.indexOf("ubuntu") !== -1) {
        result1 = "ubuntu";
      } else if (distro.indexOf("solaris") !== -1) {
        result1 = "solaris";
      } else if (distro.indexOf("tails") !== -1) {
        result1 = "tails";
      } else if (distro.indexOf("feren") !== -1) {
        result1 = "ferenos";
      } else if (distro.indexOf("robolinux") !== -1) {
        result1 = "robolinux";
      } else if (_linux && distro) {
        result1 = distro.toLowerCase().trim().replace(/\s+/g, "-");
      }
      return result1;
    }
    __name(getLogoFile, "getLogoFile");
    function getFQDN() {
      let fqdn = os.hostname;
      if (_linux || _darwin) {
        try {
          const stdout = execSync("hostname -f 2>/dev/null", util2.execOptsLinux);
          fqdn = stdout.toString().split(os.EOL)[0];
        } catch (e) {
          util2.noop();
        }
      }
      if (_freebsd || _openbsd || _netbsd) {
        try {
          const stdout = execSync("hostname 2>/dev/null");
          fqdn = stdout.toString().split(os.EOL)[0];
        } catch (e) {
          util2.noop();
        }
      }
      if (_windows) {
        try {
          const stdout = execSync("echo %COMPUTERNAME%.%USERDNSDOMAIN%", util2.execOptsWin);
          fqdn = stdout.toString().replace(".%USERDNSDOMAIN%", "").split(os.EOL)[0];
        } catch (e) {
          util2.noop();
        }
      }
      return fqdn;
    }
    __name(getFQDN, "getFQDN");
    function osInfo(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result1 = {
            platform: _platform === "win32" ? "Windows" : _platform,
            distro: "unknown",
            release: "unknown",
            codename: "",
            kernel: os.release(),
            arch: os.arch(),
            hostname: os.hostname(),
            fqdn: getFQDN(),
            codepage: "",
            logofile: "",
            serial: "",
            build: "",
            servicepack: "",
            uefi: false
          };
          if (_linux) {
            exec("cat /etc/*-release; cat /usr/lib/os-release; cat /etc/openwrt_release", function(error, stdout) {
              let release = {};
              let lines = stdout.toString().split("\n");
              lines.forEach(function(line) {
                if (line.indexOf("=") !== -1) {
                  release[line.split("=")[0].trim().toUpperCase()] = line.split("=")[1].trim();
                }
              });
              result1.distro = (release.DISTRIB_ID || release.NAME || "unknown").replace(/"/g, "");
              result1.logofile = getLogoFile(result1.distro);
              let releaseVersion = (release.VERSION || "").replace(/"/g, "");
              let codename = (release.DISTRIB_CODENAME || release.VERSION_CODENAME || "").replace(/"/g, "");
              const prettyName = (release.PRETTY_NAME || "").replace(/"/g, "");
              if (prettyName.indexOf(result1.distro + " ") === 0) {
                releaseVersion = prettyName.replace(result1.distro + " ", "").trim();
              }
              if (releaseVersion.indexOf("(") >= 0) {
                codename = releaseVersion.split("(")[1].replace(/[()]/g, "").trim();
                releaseVersion = releaseVersion.split("(")[0].trim();
              }
              result1.release = (releaseVersion || release.DISTRIB_RELEASE || release.VERSION_ID || "unknown").replace(/"/g, "");
              result1.codename = codename;
              result1.codepage = util2.getCodepage();
              result1.build = (release.BUILD_ID || "").replace(/"/g, "").trim();
              isUefiLinux().then((uefi) => {
                result1.uefi = uefi;
                uuid().then((data) => {
                  result1.serial = data.os;
                  if (callback) {
                    callback(result1);
                  }
                  resolve5(result1);
                });
              });
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec("sysctl kern.ostype kern.osrelease kern.osrevision kern.hostuuid machdep.bootmethod kern.geom.confxml", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              const distro = util2.getValue(lines, "kern.ostype");
              const logofile = getLogoFile(distro);
              const release = util2.getValue(lines, "kern.osrelease").split("-")[0];
              const serial = util2.getValue(lines, "kern.uuid");
              const bootmethod = util2.getValue(lines, "machdep.bootmethod");
              const uefiConf = stdout.toString().indexOf("<type>efi</type>") >= 0;
              const uefi = bootmethod ? bootmethod.toLowerCase().indexOf("uefi") >= 0 : uefiConf ? uefiConf : null;
              result1.distro = distro || result1.distro;
              result1.logofile = logofile || result1.logofile;
              result1.release = release || result1.release;
              result1.serial = serial || result1.serial;
              result1.codename = "";
              result1.codepage = util2.getCodepage();
              result1.uefi = uefi || null;
              if (callback) {
                callback(result1);
              }
              resolve5(result1);
            });
          }
          if (_darwin) {
            exec("sw_vers; sysctl kern.ostype kern.osrelease kern.osrevision kern.uuid", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result1.serial = util2.getValue(lines, "kern.uuid");
              result1.distro = util2.getValue(lines, "ProductName");
              result1.release = (util2.getValue(lines, "ProductVersion", ":", true, true) + " " + util2.getValue(lines, "ProductVersionExtra", ":", true, true)).trim();
              result1.build = util2.getValue(lines, "BuildVersion");
              result1.logofile = getLogoFile(result1.distro);
              result1.codename = "macOS";
              result1.codename = result1.release.indexOf("10.4") > -1 ? "OS X Tiger" : result1.codename;
              result1.codename = result1.release.indexOf("10.5") > -1 ? "OS X Leopard" : result1.codename;
              result1.codename = result1.release.indexOf("10.6") > -1 ? "OS X Snow Leopard" : result1.codename;
              result1.codename = result1.release.indexOf("10.7") > -1 ? "OS X Lion" : result1.codename;
              result1.codename = result1.release.indexOf("10.8") > -1 ? "OS X Mountain Lion" : result1.codename;
              result1.codename = result1.release.indexOf("10.9") > -1 ? "OS X Mavericks" : result1.codename;
              result1.codename = result1.release.indexOf("10.10") > -1 ? "OS X Yosemite" : result1.codename;
              result1.codename = result1.release.indexOf("10.11") > -1 ? "OS X El Capitan" : result1.codename;
              result1.codename = result1.release.indexOf("10.12") > -1 ? "Sierra" : result1.codename;
              result1.codename = result1.release.indexOf("10.13") > -1 ? "High Sierra" : result1.codename;
              result1.codename = result1.release.indexOf("10.14") > -1 ? "Mojave" : result1.codename;
              result1.codename = result1.release.indexOf("10.15") > -1 ? "Catalina" : result1.codename;
              result1.codename = result1.release.startsWith("11.") ? "Big Sur" : result1.codename;
              result1.codename = result1.release.startsWith("12.") ? "Monterey" : result1.codename;
              result1.codename = result1.release.startsWith("13.") ? "Ventura" : result1.codename;
              result1.codename = result1.release.startsWith("14.") ? "Sonoma" : result1.codename;
              result1.codename = result1.release.startsWith("15.") ? "Sequoia" : result1.codename;
              result1.uefi = true;
              result1.codepage = util2.getCodepage();
              if (callback) {
                callback(result1);
              }
              resolve5(result1);
            });
          }
          if (_sunos) {
            result1.release = result1.kernel;
            exec("uname -o", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              result1.distro = lines[0];
              result1.logofile = getLogoFile(result1.distro);
              if (callback) {
                callback(result1);
              }
              resolve5(result1);
            });
          }
          if (_windows) {
            result1.logofile = getLogoFile();
            result1.release = result1.kernel;
            try {
              const workload = [];
              workload.push(util2.powerShell("Get-CimInstance Win32_OperatingSystem | select Caption,SerialNumber,BuildNumber,ServicePackMajorVersion,ServicePackMinorVersion | fl"));
              workload.push(util2.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
              workload.push(util2.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.SystemInformation]::TerminalServerSession"));
              util2.promiseAll(workload).then((data) => {
                let lines = data.results[0] ? data.results[0].toString().split("\r\n") : [
                  ""
                ];
                result1.distro = util2.getValue(lines, "Caption", ":").trim();
                result1.serial = util2.getValue(lines, "SerialNumber", ":").trim();
                result1.build = util2.getValue(lines, "BuildNumber", ":").trim();
                result1.servicepack = util2.getValue(lines, "ServicePackMajorVersion", ":").trim() + "." + util2.getValue(lines, "ServicePackMinorVersion", ":").trim();
                result1.codepage = util2.getCodepage();
                const hyperv = data.results[1] ? data.results[1].toString().toLowerCase() : "";
                result1.hypervisor = hyperv.indexOf("true") !== -1;
                const term = data.results[2] ? data.results[2].toString() : "";
                result1.remoteSession = term.toString().toLowerCase().indexOf("true") >= 0;
                isUefiWindows().then((uefi) => {
                  result1.uefi = uefi;
                  if (callback) {
                    callback(result1);
                  }
                  resolve5(result1);
                });
              });
            } catch (e) {
              if (callback) {
                callback(result1);
              }
              resolve5(result1);
            }
          }
        });
      });
    }
    __name(osInfo, "osInfo");
    exports2.osInfo = osInfo;
    function isUefiLinux() {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          fs.stat("/sys/firmware/efi", function(err) {
            if (!err) {
              return resolve5(true);
            } else {
              exec('dmesg | grep -E "EFI v"', function(error, stdout) {
                if (!error) {
                  const lines = stdout.toString().split("\n");
                  return resolve5(lines.length > 0);
                }
                return resolve5(false);
              });
            }
          });
        });
      });
    }
    __name(isUefiLinux, "isUefiLinux");
    function isUefiWindows() {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          try {
            exec('findstr /C:"Detected boot environment" "%windir%\\Panther\\setupact.log"', util2.execOptsWin, function(error, stdout) {
              if (!error) {
                const line = stdout.toString().split("\n\r")[0];
                return resolve5(line.toLowerCase().indexOf("efi") >= 0);
              } else {
                exec("echo %firmware_type%", util2.execOptsWin, function(error2, stdout2) {
                  if (!error2) {
                    const line = stdout2.toString() || "";
                    return resolve5(line.toLowerCase().indexOf("efi") >= 0);
                  } else {
                    return resolve5(false);
                  }
                });
              }
            });
          } catch (e) {
            return resolve5(false);
          }
        });
      });
    }
    __name(isUefiWindows, "isUefiWindows");
    function versions(apps, callback) {
      let versionObject = {
        kernel: os.release(),
        apache: "",
        bash: "",
        bun: "",
        deno: "",
        docker: "",
        dotnet: "",
        fish: "",
        gcc: "",
        git: "",
        grunt: "",
        gulp: "",
        homebrew: "",
        java: "",
        mongodb: "",
        mysql: "",
        nginx: "",
        node: "",
        npm: "",
        openssl: "",
        perl: "",
        php: "",
        pip3: "",
        pip: "",
        pm2: "",
        postfix: "",
        postgresql: "",
        powershell: "",
        python3: "",
        python: "",
        redis: "",
        systemOpenssl: "",
        systemOpensslLib: "",
        tsc: "",
        v8: process.versions.v8,
        virtualbox: "",
        yarn: "",
        zsh: ""
      };
      function checkVersionParam(apps2) {
        if (apps2 === "*") {
          return {
            versions: versionObject,
            counter: 34
          };
        }
        if (!Array.isArray(apps2)) {
          apps2 = apps2.trim().toLowerCase().replace(/,+/g, "|").replace(/ /g, "|");
          apps2 = apps2.split("|");
          const result1 = {
            versions: {},
            counter: 0
          };
          apps2.forEach((el) => {
            if (el) {
              for (let key in versionObject) {
                if ({}.hasOwnProperty.call(versionObject, key)) {
                  if (key.toLowerCase() === el.toLowerCase() && !{}.hasOwnProperty.call(result1.versions, key)) {
                    result1.versions[key] = versionObject[key];
                    if (key === "openssl") {
                      result1.versions.systemOpenssl = "";
                      result1.versions.systemOpensslLib = "";
                    }
                    if (!result1.versions[key]) {
                      result1.counter++;
                    }
                  }
                }
              }
            }
          });
          return result1;
        }
      }
      __name(checkVersionParam, "checkVersionParam");
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (util2.isFunction(apps) && !callback) {
            callback = apps;
            apps = "*";
          } else {
            apps = apps || "*";
            if (typeof apps !== "string") {
              if (callback) {
                callback({});
              }
              return resolve5({});
            }
          }
          const appsObj = checkVersionParam(apps);
          let totalFunctions = appsObj.counter;
          let functionProcessed = /* @__PURE__ */ function() {
            return function() {
              if (--totalFunctions === 0) {
                if (callback) {
                  callback(appsObj.versions);
                }
                resolve5(appsObj.versions);
              }
            };
          }();
          let cmd = "";
          try {
            if ({}.hasOwnProperty.call(appsObj.versions, "openssl")) {
              appsObj.versions.openssl = process.versions.openssl;
              exec("openssl version", function(error, stdout) {
                if (!error) {
                  let openssl_string = stdout.toString().split("\n")[0].trim();
                  let openssl = openssl_string.split(" ");
                  appsObj.versions.systemOpenssl = openssl.length > 0 ? openssl[1] : openssl[0];
                  appsObj.versions.systemOpensslLib = openssl.length > 0 ? openssl[0] : "openssl";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "npm")) {
              exec("npm -v", function(error, stdout) {
                if (!error) {
                  appsObj.versions.npm = stdout.toString().split("\n")[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pm2")) {
              cmd = "pm2";
              if (_windows) {
                cmd += ".cmd";
              }
              exec(`${cmd} -v`, function(error, stdout) {
                if (!error) {
                  let pm2 = stdout.toString().split("\n")[0].trim();
                  if (!pm2.startsWith("[PM2]")) {
                    appsObj.versions.pm2 = pm2;
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "yarn")) {
              exec("yarn --version", function(error, stdout) {
                if (!error) {
                  appsObj.versions.yarn = stdout.toString().split("\n")[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "gulp")) {
              cmd = "gulp";
              if (_windows) {
                cmd += ".cmd";
              }
              exec(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const gulp = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.gulp = (gulp.toLowerCase().split("version")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "homebrew")) {
              cmd = "brew";
              exec(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const brew = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.homebrew = (brew.toLowerCase().split(" ")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "tsc")) {
              cmd = "tsc";
              if (_windows) {
                cmd += ".cmd";
              }
              exec(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const tsc = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.tsc = (tsc.toLowerCase().split("version")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "grunt")) {
              cmd = "grunt";
              if (_windows) {
                cmd += ".cmd";
              }
              exec(`${cmd} --version`, function(error, stdout) {
                if (!error) {
                  const grunt = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.grunt = (grunt.toLowerCase().split("cli v")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "git")) {
              if (_darwin) {
                const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/git") || fs.existsSync("/opt/homebrew/bin/git");
                if (util2.darwinXcodeExists() || gitHomebrewExists) {
                  exec("git --version", function(error, stdout) {
                    if (!error) {
                      let git = stdout.toString().split("\n")[0] || "";
                      git = (git.toLowerCase().split("version")[1] || "").trim();
                      appsObj.versions.git = (git.split(" ")[0] || "").trim();
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec("git --version", function(error, stdout) {
                  if (!error) {
                    let git = stdout.toString().split("\n")[0] || "";
                    git = (git.toLowerCase().split("version")[1] || "").trim();
                    appsObj.versions.git = (git.split(" ")[0] || "").trim();
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "apache")) {
              exec("apachectl -v 2>&1", function(error, stdout) {
                if (!error) {
                  const apache = (stdout.toString().split("\n")[0] || "").split(":");
                  appsObj.versions.apache = apache.length > 1 ? apache[1].replace("Apache", "").replace("/", "").split("(")[0].trim() : "";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "nginx")) {
              exec("nginx -v 2>&1", function(error, stdout) {
                if (!error) {
                  const nginx = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.nginx = (nginx.toLowerCase().split("/")[1] || "").trim();
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "mysql")) {
              exec("mysql -V", function(error, stdout) {
                if (!error) {
                  let mysql = stdout.toString().split("\n")[0] || "";
                  mysql = mysql.toLowerCase();
                  if (mysql.indexOf(",") > -1) {
                    mysql = (mysql.split(",")[0] || "").trim();
                    const parts2 = mysql.split(" ");
                    appsObj.versions.mysql = (parts2[parts2.length - 1] || "").trim();
                  } else {
                    if (mysql.indexOf(" ver ") > -1) {
                      mysql = mysql.split(" ver ")[1];
                      appsObj.versions.mysql = mysql.split(" ")[0];
                    }
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "php")) {
              exec("php -v", function(error, stdout) {
                if (!error) {
                  const php = stdout.toString().split("\n")[0] || "";
                  let parts2 = php.split("(");
                  if (parts2[0].indexOf("-")) {
                    parts2 = parts2[0].split("-");
                  }
                  appsObj.versions.php = parts2[0].replace(/[^0-9.]/g, "");
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "redis")) {
              exec("redis-server --version", function(error, stdout) {
                if (!error) {
                  const redis = stdout.toString().split("\n")[0] || "";
                  const parts2 = redis.split(" ");
                  appsObj.versions.redis = util2.getValue(parts2, "v", "=", true);
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "docker")) {
              exec("docker --version", function(error, stdout) {
                if (!error) {
                  const docker = stdout.toString().split("\n")[0] || "";
                  const parts2 = docker.split(" ");
                  appsObj.versions.docker = parts2.length > 2 && parts2[2].endsWith(",") ? parts2[2].slice(0, -1) : "";
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "postfix")) {
              exec("postconf -d | grep mail_version", function(error, stdout) {
                if (!error) {
                  const postfix = stdout.toString().split("\n") || [];
                  appsObj.versions.postfix = util2.getValue(postfix, "mail_version", "=", true);
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "mongodb")) {
              exec("mongod --version", function(error, stdout) {
                if (!error) {
                  const mongodb = stdout.toString().split("\n")[0] || "";
                  appsObj.versions.mongodb = (mongodb.toLowerCase().split(",")[0] || "").replace(/[^0-9.]/g, "");
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "postgresql")) {
              if (_linux) {
                exec("locate bin/postgres", function(error, stdout) {
                  if (!error) {
                    const postgresqlBin = stdout.toString().split("\n").sort();
                    if (postgresqlBin.length) {
                      exec(postgresqlBin[postgresqlBin.length - 1] + " -V", function(error2, stdout2) {
                        if (!error2) {
                          const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                          appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                        }
                        functionProcessed();
                      });
                    } else {
                      functionProcessed();
                    }
                  } else {
                    exec("psql -V", function(error2, stdout2) {
                      if (!error2) {
                        const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                        appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                        appsObj.versions.postgresql = appsObj.versions.postgresql.split("-")[0];
                      }
                      functionProcessed();
                    });
                  }
                });
              } else {
                if (_windows) {
                  util2.powerShell("Get-CimInstance Win32_Service | select caption | fl").then((stdout) => {
                    let serviceSections = stdout.split(/\n\s*\n/);
                    serviceSections.forEach((item) => {
                      if (item.trim() !== "") {
                        let lines = item.trim().split("\r\n");
                        let srvCaption = util2.getValue(lines, "caption", ":", true).toLowerCase();
                        if (srvCaption.indexOf("postgresql") > -1) {
                          const parts2 = srvCaption.split(" server ");
                          if (parts2.length > 1) {
                            appsObj.versions.postgresql = parts2[1];
                          }
                        }
                      }
                    });
                    functionProcessed();
                  });
                } else {
                  exec("postgres -V", function(error, stdout) {
                    if (!error) {
                      const postgresql = stdout.toString().split("\n")[0].split(" ") || [];
                      appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                    } else {
                      exec("pg_config --version", function(error2, stdout2) {
                        if (!error2) {
                          const postgresql = stdout2.toString().split("\n")[0].split(" ") || [];
                          appsObj.versions.postgresql = postgresql.length ? postgresql[postgresql.length - 1] : "";
                        }
                      });
                    }
                    functionProcessed();
                  });
                }
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "perl")) {
              exec("perl -v", function(error, stdout) {
                if (!error) {
                  const perl = stdout.toString().split("\n") || "";
                  while (perl.length > 0 && perl[0].trim() === "") {
                    perl.shift();
                  }
                  if (perl.length > 0) {
                    appsObj.versions.perl = perl[0].split("(").pop().split(")")[0].replace("v", "");
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "python")) {
              if (_darwin) {
                try {
                  const stdout = execSync("sw_vers");
                  const lines = stdout.toString().split("\n");
                  const osVersion = util2.getValue(lines, "ProductVersion", ":");
                  const gitHomebrewExists1 = fs.existsSync("/usr/local/Cellar/python");
                  const gitHomebrewExists2 = fs.existsSync("/opt/homebrew/bin/python");
                  if (util2.darwinXcodeExists() && util2.semverCompare("12.0.1", osVersion) < 0 || gitHomebrewExists1 || gitHomebrewExists2) {
                    const cmd2 = gitHomebrewExists1 ? "/usr/local/Cellar/python -V 2>&1" : gitHomebrewExists2 ? "/opt/homebrew/bin/python -V 2>&1" : "python -V 2>&1";
                    exec(cmd2, function(error, stdout2) {
                      if (!error) {
                        const python = stdout2.toString().split("\n")[0] || "";
                        appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                      }
                      functionProcessed();
                    });
                  } else {
                    functionProcessed();
                  }
                } catch (e) {
                  functionProcessed();
                }
              } else {
                exec("python -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const python = stdout.toString().split("\n")[0] || "";
                    appsObj.versions.python = python.toLowerCase().replace("python", "").trim();
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "python3")) {
              if (_darwin) {
                const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/python3") || fs.existsSync("/opt/homebrew/bin/python3");
                if (util2.darwinXcodeExists() || gitHomebrewExists) {
                  exec("python3 -V 2>&1", function(error, stdout) {
                    if (!error) {
                      const python = stdout.toString().split("\n")[0] || "";
                      appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec("python3 -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const python = stdout.toString().split("\n")[0] || "";
                    appsObj.versions.python3 = python.toLowerCase().replace("python", "").trim();
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pip")) {
              if (_darwin) {
                const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/pip") || fs.existsSync("/opt/homebrew/bin/pip");
                if (util2.darwinXcodeExists() || gitHomebrewExists) {
                  exec("pip -V 2>&1", function(error, stdout) {
                    if (!error) {
                      const pip = stdout.toString().split("\n")[0] || "";
                      const parts2 = pip.split(" ");
                      appsObj.versions.pip = parts2.length >= 2 ? parts2[1] : "";
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec("pip -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const pip = stdout.toString().split("\n")[0] || "";
                    const parts2 = pip.split(" ");
                    appsObj.versions.pip = parts2.length >= 2 ? parts2[1] : "";
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "pip3")) {
              if (_darwin) {
                const gitHomebrewExists = fs.existsSync("/usr/local/Cellar/pip3") || fs.existsSync("/opt/homebrew/bin/pip3");
                if (util2.darwinXcodeExists() || gitHomebrewExists) {
                  exec("pip3 -V 2>&1", function(error, stdout) {
                    if (!error) {
                      const pip = stdout.toString().split("\n")[0] || "";
                      const parts2 = pip.split(" ");
                      appsObj.versions.pip3 = parts2.length >= 2 ? parts2[1] : "";
                    }
                    functionProcessed();
                  });
                } else {
                  functionProcessed();
                }
              } else {
                exec("pip3 -V 2>&1", function(error, stdout) {
                  if (!error) {
                    const pip = stdout.toString().split("\n")[0] || "";
                    const parts2 = pip.split(" ");
                    appsObj.versions.pip3 = parts2.length >= 2 ? parts2[1] : "";
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "java")) {
              if (_darwin) {
                exec("/usr/libexec/java_home -V 2>&1", function(error, stdout) {
                  if (!error && stdout.toString().toLowerCase().indexOf("no java runtime") === -1) {
                    exec("java -version 2>&1", function(error2, stdout2) {
                      if (!error2) {
                        const java = stdout2.toString().split("\n")[0] || "";
                        const parts2 = java.split('"');
                        appsObj.versions.java = parts2.length === 3 ? parts2[1].trim() : "";
                      }
                      functionProcessed();
                    });
                  } else {
                    functionProcessed();
                  }
                });
              } else {
                exec("java -version 2>&1", function(error, stdout) {
                  if (!error) {
                    const java = stdout.toString().split("\n")[0] || "";
                    const parts2 = java.split('"');
                    appsObj.versions.java = parts2.length === 3 ? parts2[1].trim() : "";
                  }
                  functionProcessed();
                });
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "gcc")) {
              if (_darwin && util2.darwinXcodeExists() || !_darwin) {
                exec("gcc -dumpversion", function(error, stdout) {
                  if (!error) {
                    appsObj.versions.gcc = stdout.toString().split("\n")[0].trim() || "";
                  }
                  if (appsObj.versions.gcc.indexOf(".") > -1) {
                    functionProcessed();
                  } else {
                    exec("gcc --version", function(error2, stdout2) {
                      if (!error2) {
                        const gcc = stdout2.toString().split("\n")[0].trim();
                        if (gcc.indexOf("gcc") > -1 && gcc.indexOf(")") > -1) {
                          const parts2 = gcc.split(")");
                          appsObj.versions.gcc = parts2[1].trim() || appsObj.versions.gcc;
                        }
                      }
                      functionProcessed();
                    });
                  }
                });
              } else {
                functionProcessed();
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "virtualbox")) {
              exec(util2.getVboxmanage() + " -v 2>&1", function(error, stdout) {
                if (!error) {
                  const vbox = stdout.toString().split("\n")[0] || "";
                  const parts2 = vbox.split("r");
                  appsObj.versions.virtualbox = parts2[0];
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "bash")) {
              exec("bash --version", function(error, stdout) {
                if (!error) {
                  const line = stdout.toString().split("\n")[0];
                  const parts2 = line.split(" version ");
                  if (parts2.length > 1) {
                    appsObj.versions.bash = parts2[1].split(" ")[0].split("(")[0];
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "zsh")) {
              exec("zsh --version", function(error, stdout) {
                if (!error) {
                  const line = stdout.toString().split("\n")[0];
                  const parts2 = line.split("zsh ");
                  if (parts2.length > 1) {
                    appsObj.versions.zsh = parts2[1].split(" ")[0];
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "fish")) {
              exec("fish --version", function(error, stdout) {
                if (!error) {
                  const line = stdout.toString().split("\n")[0];
                  const parts2 = line.split(" version ");
                  if (parts2.length > 1) {
                    appsObj.versions.fish = parts2[1].split(" ")[0];
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "bun")) {
              exec("bun -v", function(error, stdout) {
                if (!error) {
                  const line = stdout.toString().split("\n")[0].trim();
                  appsObj.versions.bun = line;
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "deno")) {
              exec("deno -v", function(error, stdout) {
                if (!error) {
                  const line = stdout.toString().split("\n")[0].trim();
                  const parts2 = line.split(" ");
                  if (parts2.length > 1) {
                    appsObj.versions.deno = parts2[1];
                  }
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "node")) {
              exec("node -v", function(error, stdout) {
                if (!error) {
                  let line = stdout.toString().split("\n")[0].trim();
                  if (line.startsWith("v")) {
                    line = line.slice(1);
                  }
                  appsObj.versions.node = line;
                }
                functionProcessed();
              });
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "powershell")) {
              if (_windows) {
                util2.powerShell("$PSVersionTable").then((stdout) => {
                  const lines = stdout.toString().toLowerCase().split("\n").map((line) => line.replace(/ +/g, " ").replace(/ +/g, ":"));
                  appsObj.versions.powershell = util2.getValue(lines, "psversion");
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            }
            if ({}.hasOwnProperty.call(appsObj.versions, "dotnet")) {
              if (_windows) {
                util2.powerShell('gci "HKLM:\\SOFTWARE\\Microsoft\\NET Framework Setup\\NDP" -recurse | gp -name Version,Release -EA 0 | where { $_.PSChildName -match "^(?!S)\\p{L}"} | select PSChildName, Version, Release').then((stdout) => {
                  const lines = stdout.toString().split("\r\n");
                  let dotnet = "";
                  lines.forEach((line) => {
                    line = line.replace(/ +/g, " ");
                    const parts2 = line.split(" ");
                    dotnet = dotnet || (parts2[0].toLowerCase().startsWith("client") && parts2.length > 2 ? parts2[1].trim() : parts2[0].toLowerCase().startsWith("full") && parts2.length > 2 ? parts2[1].trim() : "");
                  });
                  appsObj.versions.dotnet = dotnet.trim();
                  functionProcessed();
                });
              } else {
                functionProcessed();
              }
            }
          } catch (e) {
            if (callback) {
              callback(appsObj.versions);
            }
            resolve5(appsObj.versions);
          }
        });
      });
    }
    __name(versions, "versions");
    exports2.versions = versions;
    function shell(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (_windows) {
            try {
              const result1 = "CMD";
              util2.powerShell(`Get-CimInstance -className win32_process | where-object {$_.ProcessId -eq ${process.ppid} } | select Name`).then((stdout) => {
                let result12 = "CMD";
                if (stdout) {
                  if (stdout.toString().toLowerCase().indexOf("powershell") >= 0) {
                    result12 = "PowerShell";
                  }
                }
                if (callback) {
                  callback(result12);
                }
                resolve5(result12);
              });
            } catch {
              if (callback) {
                callback(result);
              }
              resolve5(result);
            }
          } else {
            let result1 = "";
            exec("echo $SHELL", function(error, stdout) {
              if (!error) {
                result1 = stdout.toString().split("\n")[0];
              }
              if (callback) {
                callback(result1);
              }
              resolve5(result1);
            });
          }
        });
      });
    }
    __name(shell, "shell");
    exports2.shell = shell;
    function getUniqueMacAdresses() {
      let macs = [];
      try {
        const ifaces = os.networkInterfaces();
        for (let dev in ifaces) {
          if ({}.hasOwnProperty.call(ifaces, dev)) {
            ifaces[dev].forEach(function(details) {
              if (details && details.mac && details.mac !== "00:00:00:00:00:00") {
                const mac = details.mac.toLowerCase();
                if (macs.indexOf(mac) === -1) {
                  macs.push(mac);
                }
              }
            });
          }
        }
        macs = macs.sort(function(a, b) {
          if (a < b) {
            return -1;
          }
          if (a > b) {
            return 1;
          }
          return 0;
        });
      } catch (e) {
        macs.push("00:00:00:00:00:00");
      }
      return macs;
    }
    __name(getUniqueMacAdresses, "getUniqueMacAdresses");
    function uuid(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result1 = {
            os: "",
            hardware: "",
            macs: getUniqueMacAdresses()
          };
          let parts2;
          if (_darwin) {
            exec("system_profiler SPHardwareDataType -json", function(error, stdout) {
              if (!error) {
                try {
                  const jsonObj = JSON.parse(stdout.toString());
                  if (jsonObj.SPHardwareDataType && jsonObj.SPHardwareDataType.length > 0) {
                    const spHardware = jsonObj.SPHardwareDataType[0];
                    result1.os = spHardware.platform_UUID.toLowerCase();
                    result1.hardware = spHardware.serial_number;
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              if (callback) {
                callback(result1);
              }
              resolve5(result1);
            });
          }
          if (_linux) {
            const cmd = `echo -n "os: "; cat /var/lib/dbus/machine-id 2> /dev/null ||
cat /etc/machine-id 2> /dev/null; echo;
echo -n "hardware: "; cat /sys/class/dmi/id/product_uuid 2> /dev/null; echo;`;
            exec(cmd, function(error, stdout) {
              const lines = stdout.toString().split("\n");
              result1.os = util2.getValue(lines, "os").toLowerCase();
              result1.hardware = util2.getValue(lines, "hardware").toLowerCase();
              if (!result1.hardware) {
                const lines2 = fs.readFileSync("/proc/cpuinfo", {
                  encoding: "utf8"
                }).toString().split("\n");
                const serial = util2.getValue(lines2, "serial");
                result1.hardware = serial || "";
              }
              if (callback) {
                callback(result1);
              }
              resolve5(result1);
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec("sysctl -i kern.hostid kern.hostuuid", function(error, stdout) {
              const lines = stdout.toString().split("\n");
              result1.os = util2.getValue(lines, "kern.hostid", ":").toLowerCase();
              result1.hardware = util2.getValue(lines, "kern.hostuuid", ":").toLowerCase();
              if (result1.os.indexOf("unknown") >= 0) {
                result1.os = "";
              }
              if (result1.hardware.indexOf("unknown") >= 0) {
                result1.hardware = "";
              }
              if (callback) {
                callback(result1);
              }
              resolve5(result1);
            });
          }
          if (_windows) {
            let sysdir = "%windir%\\System32";
            if (process.arch === "ia32" && Object.prototype.hasOwnProperty.call(process.env, "PROCESSOR_ARCHITEW6432")) {
              sysdir = "%windir%\\sysnative\\cmd.exe /c %windir%\\System32";
            }
            util2.powerShell("Get-CimInstance Win32_ComputerSystemProduct | select UUID | fl").then((stdout) => {
              let lines = stdout.split("\r\n");
              result1.hardware = util2.getValue(lines, "uuid", ":").toLowerCase();
              exec(`${sysdir}\\reg query "HKEY_LOCAL_MACHINE\\SOFTWARE\\Microsoft\\Cryptography" /v MachineGuid`, util2.execOptsWin, function(error, stdout2) {
                parts2 = stdout2.toString().split("\n\r")[0].split("REG_SZ");
                result1.os = parts2.length > 1 ? parts2[1].replace(/\r+|\n+|\s+/ig, "").toLowerCase() : "";
                if (callback) {
                  callback(result1);
                }
                resolve5(result1);
              });
            });
          }
        });
      });
    }
    __name(uuid, "uuid");
    exports2.uuid = uuid;
  }
});

// node_modules/systeminformation/lib/cpu.js
var require_cpu = __commonJS({
  "node_modules/systeminformation/lib/cpu.js"(exports2) {
    "use strict";
    var os = require("os");
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var fs = require("fs");
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _cpu_speed = 0;
    var _current_cpu = {
      user: 0,
      nice: 0,
      system: 0,
      idle: 0,
      irq: 0,
      steal: 0,
      guest: 0,
      load: 0,
      tick: 0,
      ms: 0,
      currentLoad: 0,
      currentLoadUser: 0,
      currentLoadSystem: 0,
      currentLoadNice: 0,
      currentLoadIdle: 0,
      currentLoadIrq: 0,
      currentLoadSteal: 0,
      currentLoadGuest: 0,
      rawCurrentLoad: 0,
      rawCurrentLoadUser: 0,
      rawCurrentLoadSystem: 0,
      rawCurrentLoadNice: 0,
      rawCurrentLoadIdle: 0,
      rawCurrentLoadIrq: 0,
      rawCurrentLoadSteal: 0,
      rawCurrentLoadGuest: 0
    };
    var _cpus = [];
    var _corecount = 0;
    var AMDBaseFrequencies = {
      "8346": "1.8",
      "8347": "1.9",
      "8350": "2.0",
      "8354": "2.2",
      "8356|SE": "2.4",
      "8356": "2.3",
      "8360": "2.5",
      "2372": "2.1",
      "2373": "2.1",
      "2374": "2.2",
      "2376": "2.3",
      "2377": "2.3",
      "2378": "2.4",
      "2379": "2.4",
      "2380": "2.5",
      "2381": "2.5",
      "2382": "2.6",
      "2384": "2.7",
      "2386": "2.8",
      "2387": "2.8",
      "2389": "2.9",
      "2393": "3.1",
      "8374": "2.2",
      "8376": "2.3",
      "8378": "2.4",
      "8379": "2.4",
      "8380": "2.5",
      "8381": "2.5",
      "8382": "2.6",
      "8384": "2.7",
      "8386": "2.8",
      "8387": "2.8",
      "8389": "2.9",
      "8393": "3.1",
      "2419EE": "1.8",
      "2423HE": "2.0",
      "2425HE": "2.1",
      "2427": "2.2",
      "2431": "2.4",
      "2435": "2.6",
      "2439SE": "2.8",
      "8425HE": "2.1",
      "8431": "2.4",
      "8435": "2.6",
      "8439SE": "2.8",
      "4122": "2.2",
      "4130": "2.6",
      "4162EE": "1.7",
      "4164EE": "1.8",
      "4170HE": "2.1",
      "4174HE": "2.3",
      "4176HE": "2.4",
      "4180": "2.6",
      "4184": "2.8",
      "6124HE": "1.8",
      "6128HE": "2.0",
      "6132HE": "2.2",
      "6128": "2.0",
      "6134": "2.3",
      "6136": "2.4",
      "6140": "2.6",
      "6164HE": "1.7",
      "6166HE": "1.8",
      "6168": "1.9",
      "6172": "2.1",
      "6174": "2.2",
      "6176": "2.3",
      "6176SE": "2.3",
      "6180SE": "2.5",
      "3250": "2.5",
      "3260": "2.7",
      "3280": "2.4",
      "4226": "2.7",
      "4228": "2.8",
      "4230": "2.9",
      "4234": "3.1",
      "4238": "3.3",
      "4240": "3.4",
      "4256": "1.6",
      "4274": "2.5",
      "4276": "2.6",
      "4280": "2.8",
      "4284": "3.0",
      "6204": "3.3",
      "6212": "2.6",
      "6220": "3.0",
      "6234": "2.4",
      "6238": "2.6",
      "6262HE": "1.6",
      "6272": "2.1",
      "6274": "2.2",
      "6276": "2.3",
      "6278": "2.4",
      "6282SE": "2.6",
      "6284SE": "2.7",
      "6308": "3.5",
      "6320": "2.8",
      "6328": "3.2",
      "6338P": "2.3",
      "6344": "2.6",
      "6348": "2.8",
      "6366": "1.8",
      "6370P": "2.0",
      "6376": "2.3",
      "6378": "2.4",
      "6380": "2.5",
      "6386": "2.8",
      "FX|4100": "3.6",
      "FX|4120": "3.9",
      "FX|4130": "3.8",
      "FX|4150": "3.8",
      "FX|4170": "4.2",
      "FX|6100": "3.3",
      "FX|6120": "3.6",
      "FX|6130": "3.6",
      "FX|6200": "3.8",
      "FX|8100": "2.8",
      "FX|8120": "3.1",
      "FX|8140": "3.2",
      "FX|8150": "3.6",
      "FX|8170": "3.9",
      "FX|4300": "3.8",
      "FX|4320": "4.0",
      "FX|4350": "4.2",
      "FX|6300": "3.5",
      "FX|6350": "3.9",
      "FX|8300": "3.3",
      "FX|8310": "3.4",
      "FX|8320": "3.5",
      "FX|8350": "4.0",
      "FX|8370": "4.0",
      "FX|9370": "4.4",
      "FX|9590": "4.7",
      "FX|8320E": "3.2",
      "FX|8370E": "3.3",
      // ZEN Desktop CPUs
      "1200": "3.1",
      "Pro 1200": "3.1",
      "1300X": "3.5",
      "Pro 1300": "3.5",
      "1400": "3.2",
      "1500X": "3.5",
      "Pro 1500": "3.5",
      "1600": "3.2",
      "1600X": "3.6",
      "Pro 1600": "3.2",
      "1700": "3.0",
      "Pro 1700": "3.0",
      "1700X": "3.4",
      "Pro 1700X": "3.4",
      "1800X": "3.6",
      "1900X": "3.8",
      "1920": "3.2",
      "1920X": "3.5",
      "1950X": "3.4",
      // ZEN Desktop APUs
      "200GE": "3.2",
      "Pro 200GE": "3.2",
      "220GE": "3.4",
      "240GE": "3.5",
      "3000G": "3.5",
      "300GE": "3.4",
      "3050GE": "3.4",
      "2200G": "3.5",
      "Pro 2200G": "3.5",
      "2200GE": "3.2",
      "Pro 2200GE": "3.2",
      "2400G": "3.6",
      "Pro 2400G": "3.6",
      "2400GE": "3.2",
      "Pro 2400GE": "3.2",
      // ZEN Mobile APUs
      "Pro 200U": "2.3",
      "300U": "2.4",
      "2200U": "2.5",
      "3200U": "2.6",
      "2300U": "2.0",
      "Pro 2300U": "2.0",
      "2500U": "2.0",
      "Pro 2500U": "2.2",
      "2600H": "3.2",
      "2700U": "2.0",
      "Pro 2700U": "2.2",
      "2800H": "3.3",
      // ZEN Server Processors
      "7351": "2.4",
      "7351P": "2.4",
      "7401": "2.0",
      "7401P": "2.0",
      "7551P": "2.0",
      "7551": "2.0",
      "7251": "2.1",
      "7261": "2.5",
      "7281": "2.1",
      "7301": "2.2",
      "7371": "3.1",
      "7451": "2.3",
      "7501": "2.0",
      "7571": "2.2",
      "7601": "2.2",
      // ZEN Embedded Processors
      "V1500B": "2.2",
      "V1780B": "3.35",
      "V1202B": "2.3",
      "V1404I": "2.0",
      "V1605B": "2.0",
      "V1756B": "3.25",
      "V1807B": "3.35",
      "3101": "2.1",
      "3151": "2.7",
      "3201": "1.5",
      "3251": "2.5",
      "3255": "2.5",
      "3301": "2.0",
      "3351": "1.9",
      "3401": "1.85",
      "3451": "2.15",
      // ZEN+ Desktop
      "1200|AF": "3.1",
      "2300X": "3.5",
      "2500X": "3.6",
      "2600": "3.4",
      "2600E": "3.1",
      "1600|AF": "3.2",
      "2600X": "3.6",
      "2700": "3.2",
      "2700E": "2.8",
      "Pro 2700": "3.2",
      "2700X": "3.7",
      "Pro 2700X": "3.6",
      "2920X": "3.5",
      "2950X": "3.5",
      "2970WX": "3.0",
      "2990WX": "3.0",
      // ZEN+ Desktop APU
      "Pro 300GE": "3.4",
      "Pro 3125GE": "3.4",
      "3150G": "3.5",
      "Pro 3150G": "3.5",
      "3150GE": "3.3",
      "Pro 3150GE": "3.3",
      "3200G": "3.6",
      "Pro 3200G": "3.6",
      "3200GE": "3.3",
      "Pro 3200GE": "3.3",
      "3350G": "3.6",
      "Pro 3350G": "3.6",
      "3350GE": "3.3",
      "Pro 3350GE": "3.3",
      "3400G": "3.7",
      "Pro 3400G": "3.7",
      "3400GE": "3.3",
      "Pro 3400GE": "3.3",
      // ZEN+ Mobile
      "3300U": "2.1",
      "PRO 3300U": "2.1",
      "3450U": "2.1",
      "3500U": "2.1",
      "PRO 3500U": "2.1",
      "3500C": "2.1",
      "3550H": "2.1",
      "3580U": "2.1",
      "3700U": "2.3",
      "PRO 3700U": "2.3",
      "3700C": "2.3",
      "3750H": "2.3",
      "3780U": "2.3",
      // ZEN2 Desktop CPUS
      "3100": "3.6",
      "3300X": "3.8",
      "3500": "3.6",
      "3500X": "3.6",
      "3600": "3.6",
      "Pro 3600": "3.6",
      "3600X": "3.8",
      "3600XT": "3.8",
      "Pro 3700": "3.6",
      "3700X": "3.6",
      "3800X": "3.9",
      "3800XT": "3.9",
      "3900": "3.1",
      "Pro 3900": "3.1",
      "3900X": "3.8",
      "3900XT": "3.8",
      "3950X": "3.5",
      "3960X": "3.8",
      "3970X": "3.7",
      "3990X": "2.9",
      "3945WX": "4.0",
      "3955WX": "3.9",
      "3975WX": "3.5",
      "3995WX": "2.7",
      // ZEN2 Desktop APUs
      "4300GE": "3.5",
      "Pro 4300GE": "3.5",
      "4300G": "3.8",
      "Pro 4300G": "3.8",
      "4600GE": "3.3",
      "Pro 4650GE": "3.3",
      "4600G": "3.7",
      "Pro 4650G": "3.7",
      "4700GE": "3.1",
      "Pro 4750GE": "3.1",
      "4700G": "3.6",
      "Pro 4750G": "3.6",
      "4300U": "2.7",
      "4450U": "2.5",
      "Pro 4450U": "2.5",
      "4500U": "2.3",
      "4600U": "2.1",
      "PRO 4650U": "2.1",
      "4680U": "2.1",
      "4600HS": "3.0",
      "4600H": "3.0",
      "4700U": "2.0",
      "PRO 4750U": "1.7",
      "4800U": "1.8",
      "4800HS": "2.9",
      "4800H": "2.9",
      "4900HS": "3.0",
      "4900H": "3.3",
      "5300U": "2.6",
      "5500U": "2.1",
      "5700U": "1.8",
      // ZEN2 - EPYC
      "7232P": "3.1",
      "7302P": "3.0",
      "7402P": "2.8",
      "7502P": "2.5",
      "7702P": "2.0",
      "7252": "3.1",
      "7262": "3.2",
      "7272": "2.9",
      "7282": "2.8",
      "7302": "3.0",
      "7352": "2.3",
      "7402": "2.8",
      "7452": "2.35",
      "7502": "2.5",
      "7532": "2.4",
      "7542": "2.9",
      "7552": "2.2",
      "7642": "2.3",
      "7662": "2.0",
      "7702": "2.0",
      "7742": "2.25",
      "7H12": "2.6",
      "7F32": "3.7",
      "7F52": "3.5",
      "7F72": "3.2",
      // Epyc (Milan)
      "7773X": "2.2",
      "7763": "2.45",
      "7713": "2.0",
      "7713P": "2.0",
      "7663": "2.0",
      "7643": "2.3",
      "7573X": "2.8",
      "75F3": "2.95",
      "7543": "2.8",
      "7543P": "2.8",
      "7513": "2.6",
      "7473X": "2.8",
      "7453": "2.75",
      "74F3": "3.2",
      "7443": "2.85",
      "7443P": "2.85",
      "7413": "2.65",
      "7373X": "3.05",
      "73F3": "3.5",
      "7343": "3.2",
      "7313": "3.0",
      "7313P": "3.0",
      "72F3": "3.7",
      // ZEN3
      "5600X": "3.7",
      "5800X": "3.8",
      "5900X": "3.7",
      "5950X": "3.4",
      "5945WX": "4.1",
      "5955WX": "4.0",
      "5965WX": "3.8",
      "5975WX": "3.6",
      "5995WX": "2.7",
      "7960X": "4.2",
      "7970X": "4.0",
      "7980X": "3.2",
      "7965WX": "4.2",
      "7975WX": "4.0",
      "7985WX": "3.2",
      "7995WX": "2.5",
      // ZEN4
      "9754": "2.25",
      "9754S": "2.25",
      "9734": "2.2",
      "9684X": "2.55",
      "9384X": "3.1",
      "9184X": "3.55",
      "9654P": "2.4",
      "9654": "2.4",
      "9634": "2.25",
      "9554P": "3.1",
      "9554": "3.1",
      "9534": "2.45",
      "9474F": "3.6",
      "9454P": "2.75",
      "9454": "2.75",
      "9374F": "3.85",
      "9354P": "3.25",
      "9354": "3.25",
      "9334": "2.7",
      "9274F": "4.05",
      "9254": "2.9",
      "9224": "2.5",
      "9174F": "4.1",
      "9124": "3.0"
    };
    var socketTypes = {
      1: "Other",
      2: "Unknown",
      3: "Daughter Board",
      4: "ZIF Socket",
      5: "Replacement/Piggy Back",
      6: "None",
      7: "LIF Socket",
      8: "Slot 1",
      9: "Slot 2",
      10: "370 Pin Socket",
      11: "Slot A",
      12: "Slot M",
      13: "423",
      14: "A (Socket 462)",
      15: "478",
      16: "754",
      17: "940",
      18: "939",
      19: "mPGA604",
      20: "LGA771",
      21: "LGA775",
      22: "S1",
      23: "AM2",
      24: "F (1207)",
      25: "LGA1366",
      26: "G34",
      27: "AM3",
      28: "C32",
      29: "LGA1156",
      30: "LGA1567",
      31: "PGA988A",
      32: "BGA1288",
      33: "rPGA988B",
      34: "BGA1023",
      35: "BGA1224",
      36: "LGA1155",
      37: "LGA1356",
      38: "LGA2011",
      39: "FS1",
      40: "FS2",
      41: "FM1",
      42: "FM2",
      43: "LGA2011-3",
      44: "LGA1356-3",
      45: "LGA1150",
      46: "BGA1168",
      47: "BGA1234",
      48: "BGA1364",
      49: "AM4",
      50: "LGA1151",
      51: "BGA1356",
      52: "BGA1440",
      53: "BGA1515",
      54: "LGA3647-1",
      55: "SP3",
      56: "SP3r2",
      57: "LGA2066",
      58: "BGA1392",
      59: "BGA1510",
      60: "BGA1528",
      61: "LGA4189",
      62: "LGA1200",
      63: "LGA4677",
      64: "LGA1700",
      65: "BGA1744",
      66: "BGA1781",
      67: "BGA1211",
      68: "BGA2422",
      69: "LGA1211",
      70: "LGA2422",
      71: "LGA5773",
      72: "BGA5773"
    };
    var socketTypesByName = {
      "LGA1150": "i7-5775C i3-4340 i3-4170 G3250 i3-4160T i3-4160 E3-1231 G3258 G3240 i7-4790S i7-4790K i7-4790 i5-4690K i5-4690 i5-4590T i5-4590S i5-4590 i5-4460 i3-4360 i3-4150 G1820 G3420 G3220 i7-4771 i5-4440 i3-4330 i3-4130T i3-4130 E3-1230 i7-4770S i7-4770K i7-4770 i5-4670K i5-4670 i5-4570T i5-4570S i5-4570 i5-4430",
      "LGA1151": "i9-9900KS E-2288G E-2224 G5420 i9-9900T i9-9900 i7-9700T i7-9700F i7-9700E i7-9700 i5-9600 i5-9500T i5-9500F i5-9500 i5-9400T i3-9350K i3-9300 i3-9100T i3-9100F i3-9100 G4930 i9-9900KF i7-9700KF i5-9600KF i5-9400F i5-9400 i3-9350KF i9-9900K i7-9700K i5-9600K G5500 G5400 i7-8700T i7-8086K i5-8600 i5-8500T i5-8500 i5-8400T i3-8300 i3-8100T G4900 i7-8700K i7-8700 i5-8600K i5-8400 i3-8350K i3-8100 E3-1270 G4600 G4560 i7-7700T i7-7700K i7-7700 i5-7600K i5-7600 i5-7500T i5-7500 i5-7400 i3-7350K i3-7300 i3-7100T i3-7100 G3930 G3900 G4400 i7-6700T i7-6700K i7-6700 i5-6600K i5-6600 i5-6500T i5-6500 i5-6400T i5-6400 i3-6300 i3-6100T i3-6100 E3-1270 E3-1270 T4500 T4400",
      "1155": "G440 G460 G465 G470 G530T G540T G550T G1610T G1620T G530 G540 G1610 G550 G1620 G555 G1630 i3-2100T i3-2120T i3-3220T i3-3240T i3-3250T i3-2100 i3-2105 i3-2102 i3-3210 i3-3220 i3-2125 i3-2120 i3-3225 i3-2130 i3-3245 i3-3240 i3-3250 i5-3570T i5-2500T i5-2400S i5-2405S i5-2390T i5-3330S i5-2500S i5-3335S i5-2300 i5-3450S i5-3340S i5-3470S i5-3475S i5-3470T i5-2310 i5-3550S i5-2320 i5-3330 i5-3350P i5-3450 i5-2400 i5-3340 i5-3570S i5-2380P i5-2450P i5-3470 i5-2500K i5-3550 i5-2500 i5-3570 i5-3570K i5-2550K i7-3770T i7-2600S i7-3770S i7-2600K i7-2600 i7-3770 i7-3770K i7-2700K G620T G630T G640T G2020T G645T G2100T G2030T G622 G860T G620 G632 G2120T G630 G640 G2010 G840 G2020 G850 G645 G2030 G860 G2120 G870 G2130 G2140 E3-1220L E3-1220L E3-1260L E3-1265L E3-1220 E3-1225 E3-1220 E3-1235 E3-1225 E3-1230 E3-1230 E3-1240 E3-1245 E3-1270 E3-1275 E3-1240 E3-1245 E3-1270 E3-1280 E3-1275 E3-1290 E3-1280 E3-1290"
    };
    function getSocketTypesByName(str) {
      let result2 = "";
      for (const key in socketTypesByName) {
        const names = socketTypesByName[key].split(" ");
        names.forEach((element) => {
          if (str.indexOf(element) >= 0) {
            result2 = key;
          }
        });
      }
      return result2;
    }
    __name(getSocketTypesByName, "getSocketTypesByName");
    function cpuManufacturer(str) {
      let result2 = str;
      str = str.toLowerCase();
      if (str.indexOf("intel") >= 0) {
        result2 = "Intel";
      }
      if (str.indexOf("amd") >= 0) {
        result2 = "AMD";
      }
      if (str.indexOf("qemu") >= 0) {
        result2 = "QEMU";
      }
      if (str.indexOf("hygon") >= 0) {
        result2 = "Hygon";
      }
      if (str.indexOf("centaur") >= 0) {
        result2 = "WinChip/Via";
      }
      if (str.indexOf("vmware") >= 0) {
        result2 = "VMware";
      }
      if (str.indexOf("Xen") >= 0) {
        result2 = "Xen Hypervisor";
      }
      if (str.indexOf("tcg") >= 0) {
        result2 = "QEMU";
      }
      if (str.indexOf("apple") >= 0) {
        result2 = "Apple";
      }
      if (str.indexOf("sifive") >= 0) {
        result2 = "SiFive";
      }
      if (str.indexOf("thead") >= 0) {
        result2 = "T-Head";
      }
      if (str.indexOf("andestech") >= 0) {
        result2 = "Andes Technology";
      }
      return result2;
    }
    __name(cpuManufacturer, "cpuManufacturer");
    function cpuBrandManufacturer(res) {
      res.brand = res.brand.replace(/\(R\)+/g, "\xAE").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/\(TM\)+/g, "\u2122").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/\(C\)+/g, "\xA9").replace(/\s+/g, " ").trim();
      res.brand = res.brand.replace(/CPU+/g, "").replace(/\s+/g, " ").trim();
      res.manufacturer = cpuManufacturer(res.brand);
      let parts2 = res.brand.split(" ");
      parts2.shift();
      res.brand = parts2.join(" ");
      return res;
    }
    __name(cpuBrandManufacturer, "cpuBrandManufacturer");
    function getAMDSpeed(brand) {
      let result2 = "0";
      for (let key in AMDBaseFrequencies) {
        if ({}.hasOwnProperty.call(AMDBaseFrequencies, key)) {
          let parts2 = key.split("|");
          let found = 0;
          parts2.forEach((item) => {
            if (brand.indexOf(item) > -1) {
              found++;
            }
          });
          if (found === parts2.length) {
            result2 = AMDBaseFrequencies[key];
          }
        }
      }
      return parseFloat(result2);
    }
    __name(getAMDSpeed, "getAMDSpeed");
    function getCpu() {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          const UNKNOWN = "unknown";
          let result2 = {
            manufacturer: UNKNOWN,
            brand: UNKNOWN,
            vendor: "",
            family: "",
            model: "",
            stepping: "",
            revision: "",
            voltage: "",
            speed: 0,
            speedMin: 0,
            speedMax: 0,
            governor: "",
            cores: util2.cores(),
            physicalCores: util2.cores(),
            performanceCores: util2.cores(),
            efficiencyCores: 0,
            processors: 1,
            socket: "",
            flags: "",
            virtualization: false,
            cache: {}
          };
          cpuFlags().then((flags) => {
            result2.flags = flags;
            result2.virtualization = flags.indexOf("vmx") > -1 || flags.indexOf("svm") > -1;
            if (_darwin) {
              exec("sysctl machdep.cpu hw.cpufrequency_max hw.cpufrequency_min hw.packages hw.physicalcpu_max hw.ncpu hw.tbfrequency hw.cpufamily hw.cpusubfamily", function(error, stdout) {
                let lines = stdout.toString().split("\n");
                const modelline = util2.getValue(lines, "machdep.cpu.brand_string");
                const modellineParts = modelline.split("@");
                result2.brand = modellineParts[0].trim();
                const speed = modellineParts[1] ? modellineParts[1].trim() : "0";
                result2.speed = parseFloat(speed.replace(/GHz+/g, ""));
                let tbFrequency = util2.getValue(lines, "hw.tbfrequency") / 1e9;
                tbFrequency = tbFrequency < 0.1 ? tbFrequency * 100 : tbFrequency;
                result2.speed = result2.speed === 0 ? tbFrequency : result2.speed;
                _cpu_speed = result2.speed;
                result2 = cpuBrandManufacturer(result2);
                result2.speedMin = util2.getValue(lines, "hw.cpufrequency_min") ? util2.getValue(lines, "hw.cpufrequency_min") / 1e9 : result2.speed;
                result2.speedMax = util2.getValue(lines, "hw.cpufrequency_max") ? util2.getValue(lines, "hw.cpufrequency_max") / 1e9 : result2.speed;
                result2.vendor = util2.getValue(lines, "machdep.cpu.vendor") || "Apple";
                result2.family = util2.getValue(lines, "machdep.cpu.family") || util2.getValue(lines, "hw.cpufamily");
                result2.model = util2.getValue(lines, "machdep.cpu.model");
                result2.stepping = util2.getValue(lines, "machdep.cpu.stepping") || util2.getValue(lines, "hw.cpusubfamily");
                result2.virtualization = true;
                const countProcessors = util2.getValue(lines, "hw.packages");
                const countCores = util2.getValue(lines, "hw.physicalcpu_max");
                const countThreads = util2.getValue(lines, "hw.ncpu");
                if (os.arch() === "arm64") {
                  result2.socket = "SOC";
                  try {
                    const clusters = execSync("ioreg -c IOPlatformDevice -d 3 -r | grep cluster-type").toString().split("\n");
                    const efficiencyCores = clusters.filter((line) => line.indexOf('"E"') >= 0).length;
                    const performanceCores = clusters.filter((line) => line.indexOf('"P"') >= 0).length;
                    result2.efficiencyCores = efficiencyCores;
                    result2.performanceCores = performanceCores;
                  } catch (e) {
                    util2.noop();
                  }
                }
                if (countProcessors) {
                  result2.processors = parseInt(countProcessors) || 1;
                }
                if (countCores && countThreads) {
                  result2.cores = parseInt(countThreads) || util2.cores();
                  result2.physicalCores = parseInt(countCores) || util2.cores();
                }
                cpuCache().then((res) => {
                  result2.cache = res;
                  resolve5(result2);
                });
              });
            }
            if (_linux) {
              let modelline = "";
              let lines = [];
              if (os.cpus()[0] && os.cpus()[0].model) {
                modelline = os.cpus()[0].model;
              }
              exec('export LC_ALL=C; lscpu; echo -n "Governor: "; cat /sys/devices/system/cpu/cpu0/cpufreq/scaling_governor 2>/dev/null; echo; unset LC_ALL', function(error, stdout) {
                if (!error) {
                  lines = stdout.toString().split("\n");
                }
                modelline = util2.getValue(lines, "model name") || modelline;
                modelline = util2.getValue(lines, "bios model name") || modelline;
                modelline = util2.cleanString(modelline);
                const modellineParts = modelline.split("@");
                result2.brand = modellineParts[0].trim();
                result2.speed = modellineParts[1] ? parseFloat(modellineParts[1].trim()) : 0;
                if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
                  result2.speed = getAMDSpeed(result2.brand);
                }
                if (result2.speed === 0) {
                  const current = getCpuCurrentSpeedSync();
                  if (current.avg !== 0) {
                    result2.speed = current.avg;
                  }
                }
                _cpu_speed = result2.speed;
                result2.speedMin = Math.round(parseFloat(util2.getValue(lines, "cpu min mhz").replace(/,/g, ".")) / 10) / 100;
                result2.speedMax = Math.round(parseFloat(util2.getValue(lines, "cpu max mhz").replace(/,/g, ".")) / 10) / 100;
                result2 = cpuBrandManufacturer(result2);
                result2.vendor = cpuManufacturer(util2.getValue(lines, "vendor id"));
                result2.family = util2.getValue(lines, "cpu family");
                result2.model = util2.getValue(lines, "model:");
                result2.stepping = util2.getValue(lines, "stepping");
                result2.revision = util2.getValue(lines, "cpu revision");
                result2.cache.l1d = util2.getValue(lines, "l1d cache");
                if (result2.cache.l1d) {
                  result2.cache.l1d = parseInt(result2.cache.l1d) * (result2.cache.l1d.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l1d.indexOf("K") !== -1 ? 1024 : 1);
                }
                result2.cache.l1i = util2.getValue(lines, "l1i cache");
                if (result2.cache.l1i) {
                  result2.cache.l1i = parseInt(result2.cache.l1i) * (result2.cache.l1i.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l1i.indexOf("K") !== -1 ? 1024 : 1);
                }
                result2.cache.l2 = util2.getValue(lines, "l2 cache");
                if (result2.cache.l2) {
                  result2.cache.l2 = parseInt(result2.cache.l2) * (result2.cache.l2.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l2.indexOf("K") !== -1 ? 1024 : 1);
                }
                result2.cache.l3 = util2.getValue(lines, "l3 cache");
                if (result2.cache.l3) {
                  result2.cache.l3 = parseInt(result2.cache.l3) * (result2.cache.l3.indexOf("M") !== -1 ? 1024 * 1024 : result2.cache.l3.indexOf("K") !== -1 ? 1024 : 1);
                }
                const threadsPerCore = util2.getValue(lines, "thread(s) per core") || "1";
                const processors = util2.getValue(lines, "socket(s)") || "1";
                const threadsPerCoreInt = parseInt(threadsPerCore, 10);
                const processorsInt = parseInt(processors, 10) || 1;
                const coresPerSocket = parseInt(util2.getValue(lines, "core(s) per socket"), 10);
                result2.physicalCores = coresPerSocket ? coresPerSocket * processorsInt : result2.cores / threadsPerCoreInt;
                result2.performanceCores = threadsPerCoreInt > 1 ? result2.cores - result2.physicalCores : result2.cores;
                result2.efficiencyCores = threadsPerCoreInt > 1 ? result2.cores - threadsPerCoreInt * result2.performanceCores : 0;
                result2.processors = processorsInt;
                result2.governor = util2.getValue(lines, "governor") || "";
                if (result2.vendor === "ARM" && util2.isRaspberry()) {
                  const rPIRevision = util2.decodePiCpuinfo();
                  result2.family = result2.manufacturer;
                  result2.manufacturer = rPIRevision.manufacturer;
                  result2.brand = rPIRevision.processor;
                  result2.revision = rPIRevision.revisionCode;
                  result2.socket = "SOC";
                }
                if (util2.getValue(lines, "architecture") === "riscv64") {
                  const linesRiscV = fs.readFileSync("/proc/cpuinfo").toString().split("\n");
                  const uarch = util2.getValue(linesRiscV, "uarch") || "";
                  if (uarch.indexOf(",") > -1) {
                    const split = uarch.split(",");
                    result2.manufacturer = cpuManufacturer(split[0]);
                    result2.brand = split[1];
                  }
                }
                let lines2 = [];
                exec('export LC_ALL=C; dmidecode \u2013t 4 2>/dev/null | grep "Upgrade: Socket"; unset LC_ALL', function(error2, stdout2) {
                  lines2 = stdout2.toString().split("\n");
                  if (lines2 && lines2.length) {
                    result2.socket = util2.getValue(lines2, "Upgrade").replace("Socket", "").trim() || result2.socket;
                  }
                  resolve5(result2);
                });
              });
            }
            if (_freebsd || _openbsd || _netbsd) {
              let modelline = "";
              let lines = [];
              if (os.cpus()[0] && os.cpus()[0].model) {
                modelline = os.cpus()[0].model;
              }
              exec("export LC_ALL=C; dmidecode -t 4; dmidecode -t 7 unset LC_ALL", function(error, stdout) {
                let cache2 = [];
                if (!error) {
                  const data = stdout.toString().split("# dmidecode");
                  const processor = data.length > 1 ? data[1] : "";
                  cache2 = data.length > 2 ? data[2].split("Cache Information") : [];
                  lines = processor.split("\n");
                }
                result2.brand = modelline.split("@")[0].trim();
                result2.speed = modelline.split("@")[1] ? parseFloat(modelline.split("@")[1].trim()) : 0;
                if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
                  result2.speed = getAMDSpeed(result2.brand);
                }
                if (result2.speed === 0) {
                  const current = getCpuCurrentSpeedSync();
                  if (current.avg !== 0) {
                    result2.speed = current.avg;
                  }
                }
                _cpu_speed = result2.speed;
                result2.speedMin = result2.speed;
                result2.speedMax = Math.round(parseFloat(util2.getValue(lines, "max speed").replace(/Mhz/g, "")) / 10) / 100;
                result2 = cpuBrandManufacturer(result2);
                result2.vendor = cpuManufacturer(util2.getValue(lines, "manufacturer"));
                let sig = util2.getValue(lines, "signature");
                sig = sig.split(",");
                for (let i = 0; i < sig.length; i++) {
                  sig[i] = sig[i].trim();
                }
                result2.family = util2.getValue(sig, "Family", " ", true);
                result2.model = util2.getValue(sig, "Model", " ", true);
                result2.stepping = util2.getValue(sig, "Stepping", " ", true);
                result2.revision = "";
                const voltage = parseFloat(util2.getValue(lines, "voltage"));
                result2.voltage = isNaN(voltage) ? "" : voltage.toFixed(2);
                for (let i = 0; i < cache2.length; i++) {
                  lines = cache2[i].split("\n");
                  let cacheType = util2.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
                  cacheType = cacheType.length ? cacheType[0] : "";
                  const sizeParts = util2.getValue(lines, "Installed Size").split(" ");
                  let size = parseInt(sizeParts[0], 10);
                  const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
                  size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
                  if (cacheType) {
                    if (cacheType === "l1") {
                      result2.cache[cacheType + "d"] = size / 2;
                      result2.cache[cacheType + "i"] = size / 2;
                    } else {
                      result2.cache[cacheType] = size;
                    }
                  }
                }
                result2.socket = util2.getValue(lines, "Upgrade").replace("Socket", "").trim();
                const threadCount = util2.getValue(lines, "thread count").trim();
                const coreCount = util2.getValue(lines, "core count").trim();
                if (coreCount && threadCount) {
                  result2.cores = parseInt(threadCount, 10);
                  result2.physicalCores = parseInt(coreCount, 10);
                }
                resolve5(result2);
              });
            }
            if (_sunos) {
              resolve5(result2);
            }
            if (_windows) {
              try {
                const workload = [];
                workload.push(util2.powerShell("Get-CimInstance Win32_processor | select Name, Revision, L2CacheSize, L3CacheSize, Manufacturer, MaxClockSpeed, Description, UpgradeMethod, Caption, NumberOfLogicalProcessors, NumberOfCores | fl"));
                workload.push(util2.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
                workload.push(util2.powerShell("(Get-CimInstance Win32_ComputerSystem).HypervisorPresent"));
                Promise.all(workload).then((data) => {
                  let lines = data[0].split("\r\n");
                  let name = util2.getValue(lines, "name", ":") || "";
                  if (name.indexOf("@") >= 0) {
                    result2.brand = name.split("@")[0].trim();
                    result2.speed = name.split("@")[1] ? parseFloat(name.split("@")[1].trim()) : 0;
                    _cpu_speed = result2.speed;
                  } else {
                    result2.brand = name.trim();
                    result2.speed = 0;
                  }
                  result2 = cpuBrandManufacturer(result2);
                  result2.revision = util2.getValue(lines, "revision", ":");
                  result2.vendor = util2.getValue(lines, "manufacturer", ":");
                  result2.speedMax = Math.round(parseFloat(util2.getValue(lines, "maxclockspeed", ":").replace(/,/g, ".")) / 10) / 100;
                  if (result2.speed === 0 && (result2.brand.indexOf("AMD") > -1 || result2.brand.toLowerCase().indexOf("ryzen") > -1)) {
                    result2.speed = getAMDSpeed(result2.brand);
                  }
                  if (result2.speed === 0) {
                    result2.speed = result2.speedMax;
                  }
                  result2.speedMin = result2.speed;
                  let description = util2.getValue(lines, "description", ":").split(" ");
                  for (let i = 0; i < description.length; i++) {
                    if (description[i].toLowerCase().startsWith("family") && i + 1 < description.length && description[i + 1]) {
                      result2.family = description[i + 1];
                    }
                    if (description[i].toLowerCase().startsWith("model") && i + 1 < description.length && description[i + 1]) {
                      result2.model = description[i + 1];
                    }
                    if (description[i].toLowerCase().startsWith("stepping") && i + 1 < description.length && description[i + 1]) {
                      result2.stepping = description[i + 1];
                    }
                  }
                  const socketId = util2.getValue(lines, "UpgradeMethod", ":");
                  if (socketTypes[socketId]) {
                    result2.socket = socketTypes[socketId];
                  }
                  const socketByName = getSocketTypesByName(name);
                  if (socketByName) {
                    result2.socket = socketByName;
                  }
                  const countProcessors = util2.countLines(lines, "Caption");
                  const countThreads = util2.getValue(lines, "NumberOfLogicalProcessors", ":");
                  const countCores = util2.getValue(lines, "NumberOfCores", ":");
                  if (countProcessors) {
                    result2.processors = parseInt(countProcessors) || 1;
                  }
                  if (countCores && countThreads) {
                    result2.cores = parseInt(countThreads) || util2.cores();
                    result2.physicalCores = parseInt(countCores) || util2.cores();
                  }
                  if (countProcessors > 1) {
                    result2.cores = result2.cores * countProcessors;
                    result2.physicalCores = result2.physicalCores * countProcessors;
                  }
                  result2.cache = parseWinCache(data[0], data[1]);
                  const hyperv = data[2] ? data[2].toString().toLowerCase() : "";
                  result2.virtualization = hyperv.indexOf("true") !== -1;
                  resolve5(result2);
                });
              } catch (e) {
                resolve5(result2);
              }
            }
          });
        });
      });
    }
    __name(getCpu, "getCpu");
    function cpu(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          getCpu().then((result2) => {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          });
        });
      });
    }
    __name(cpu, "cpu");
    exports2.cpu = cpu;
    function getCpuCurrentSpeedSync() {
      let cpus = os.cpus();
      let minFreq = 999999999;
      let maxFreq = 0;
      let avgFreq = 0;
      let cores = [];
      let speeds = [];
      if (cpus && cpus.length && cpus[0].speed) {
        for (let i in cpus) {
          speeds.push(cpus[i].speed > 100 ? (cpus[i].speed + 1) / 1e3 : cpus[i].speed / 10);
        }
      } else if (_linux) {
        try {
          const speedStrings = execSync('cat /proc/cpuinfo | grep "cpu MHz" | cut -d " " -f 3', util2.execOptsLinux).toString().split("\n").filter((line) => line.length > 0);
          for (let i in speedStrings) {
            speeds.push(Math.floor(parseInt(speedStrings[i], 10) / 10) / 100);
          }
        } catch {
          util2.noop();
        }
      }
      if (speeds && speeds.length) {
        for (let i in speeds) {
          avgFreq = avgFreq + speeds[i];
          if (speeds[i] > maxFreq) {
            maxFreq = speeds[i];
          }
          if (speeds[i] < minFreq) {
            minFreq = speeds[i];
          }
          cores.push(parseFloat(speeds[i].toFixed(2)));
        }
        avgFreq = avgFreq / speeds.length;
        return {
          min: parseFloat(minFreq.toFixed(2)),
          max: parseFloat(maxFreq.toFixed(2)),
          avg: parseFloat(avgFreq.toFixed(2)),
          cores
        };
      } else {
        return {
          min: 0,
          max: 0,
          avg: 0,
          cores
        };
      }
    }
    __name(getCpuCurrentSpeedSync, "getCpuCurrentSpeedSync");
    function cpuCurrentSpeed(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = getCpuCurrentSpeedSync();
          if (result2.avg === 0 && _cpu_speed !== 0) {
            const currCpuSpeed = parseFloat(_cpu_speed);
            result2 = {
              min: currCpuSpeed,
              max: currCpuSpeed,
              avg: currCpuSpeed,
              cores: []
            };
          }
          if (callback) {
            callback(result2);
          }
          resolve5(result2);
        });
      });
    }
    __name(cpuCurrentSpeed, "cpuCurrentSpeed");
    exports2.cpuCurrentSpeed = cpuCurrentSpeed;
    function cpuTemperature(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            main: null,
            cores: [],
            max: null,
            socket: [],
            chipset: null
          };
          if (_linux) {
            try {
              const cmd2 = 'cat /sys/class/thermal/thermal_zone*/type  2>/dev/null; echo "-----"; cat /sys/class/thermal/thermal_zone*/temp 2>/dev/null;';
              const parts2 = execSync(cmd2, util2.execOptsLinux).toString().split("-----\n");
              if (parts2.length === 2) {
                const lines = parts2[0].split("\n");
                const lines2 = parts2[1].split("\n");
                for (let i = 0; i < lines.length; i++) {
                  const line = lines[i].trim();
                  if (line.startsWith("acpi") && lines2[i]) {
                    result2.socket.push(Math.round(parseInt(lines2[i], 10) / 100) / 10);
                  }
                  if (line.startsWith("pch") && lines2[i]) {
                    result2.chipset = Math.round(parseInt(lines2[i], 10) / 100) / 10;
                  }
                }
              }
            } catch (e) {
              util2.noop();
            }
            const cmd = 'for mon in /sys/class/hwmon/hwmon*; do for label in "$mon"/temp*_label; do if [ -f $label ]; then value=${label%_*}_input; echo $(cat "$label")___$(cat "$value"); fi; done; done;';
            try {
              exec(cmd, function(error, stdout) {
                stdout = stdout.toString();
                const tdiePos = stdout.toLowerCase().indexOf("tdie");
                if (tdiePos !== -1) {
                  stdout = stdout.substring(tdiePos);
                }
                let lines = stdout.split("\n");
                let tctl = 0;
                lines.forEach((line) => {
                  const parts2 = line.split("___");
                  const label = parts2[0];
                  const value2 = parts2.length > 1 && parts2[1] ? parts2[1] : "0";
                  if (value2 && label && label.toLowerCase() === "tctl") {
                    tctl = result2.main = Math.round(parseInt(value2, 10) / 100) / 10;
                  }
                  if (value2 && (label === void 0 || label && label.toLowerCase().startsWith("core"))) {
                    result2.cores.push(Math.round(parseInt(value2, 10) / 100) / 10);
                  } else if (value2 && label && result2.main === null && (label.toLowerCase().indexOf("package") >= 0 || label.toLowerCase().indexOf("physical") >= 0 || label.toLowerCase() === "tccd1")) {
                    result2.main = Math.round(parseInt(value2, 10) / 100) / 10;
                  }
                });
                if (tctl && result2.main === null) {
                  result2.main = tctl;
                }
                if (result2.cores.length > 0) {
                  if (result2.main === null) {
                    result2.main = Math.round(result2.cores.reduce((a, b) => a + b, 0) / result2.cores.length);
                  }
                  let maxtmp = Math.max.apply(Math, result2.cores);
                  result2.max = maxtmp > result2.main ? maxtmp : result2.main;
                }
                if (result2.main !== null) {
                  if (result2.max === null) {
                    result2.max = result2.main;
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                  return;
                }
                exec("sensors", function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    let tdieTemp = null;
                    let newSectionStarts = true;
                    let section = "";
                    lines2.forEach(function(line) {
                      if (line.trim() === "") {
                        newSectionStarts = true;
                      } else if (newSectionStarts) {
                        if (line.trim().toLowerCase().startsWith("acpi")) {
                          section = "acpi";
                        }
                        if (line.trim().toLowerCase().startsWith("pch")) {
                          section = "pch";
                        }
                        if (line.trim().toLowerCase().startsWith("core")) {
                          section = "core";
                        }
                        newSectionStarts = false;
                      }
                      let regex = /[+-]([^°]*)/g;
                      let temps = line.match(regex);
                      let firstPart = line.split(":")[0].toUpperCase();
                      if (section === "acpi") {
                        if (firstPart.indexOf("TEMP") !== -1) {
                          result2.socket.push(parseFloat(temps));
                        }
                      } else if (section === "pch") {
                        if (firstPart.indexOf("TEMP") !== -1 && !result2.chipset) {
                          result2.chipset = parseFloat(temps);
                        }
                      }
                      if (firstPart.indexOf("PHYSICAL") !== -1 || firstPart.indexOf("PACKAGE") !== -1) {
                        result2.main = parseFloat(temps);
                      }
                      if (firstPart.indexOf("CORE ") !== -1) {
                        result2.cores.push(parseFloat(temps));
                      }
                      if (firstPart.indexOf("TDIE") !== -1 && tdieTemp === null) {
                        tdieTemp = parseFloat(temps);
                      }
                    });
                    if (result2.cores.length > 0) {
                      result2.main = Math.round(result2.cores.reduce((a, b) => a + b, 0) / result2.cores.length);
                      let maxtmp = Math.max.apply(Math, result2.cores);
                      result2.max = maxtmp > result2.main ? maxtmp : result2.main;
                    } else {
                      if (result2.main === null && tdieTemp !== null) {
                        result2.main = tdieTemp;
                        result2.max = tdieTemp;
                      }
                    }
                    if (result2.main !== null || result2.max !== null) {
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                      return;
                    }
                  }
                  fs.stat("/sys/class/thermal/thermal_zone0/temp", function(err) {
                    if (err === null) {
                      fs.readFile("/sys/class/thermal/thermal_zone0/temp", function(error3, stdout3) {
                        if (!error3) {
                          let lines2 = stdout3.toString().split("\n");
                          if (lines2.length > 0) {
                            result2.main = parseFloat(lines2[0]) / 1e3;
                            result2.max = result2.main;
                          }
                        }
                        if (callback) {
                          callback(result2);
                        }
                        resolve5(result2);
                      });
                    } else {
                      exec("/opt/vc/bin/vcgencmd measure_temp", function(error3, stdout3) {
                        if (!error3) {
                          let lines2 = stdout3.toString().split("\n");
                          if (lines2.length > 0 && lines2[0].indexOf("=")) {
                            result2.main = parseFloat(lines2[0].split("=")[1]);
                            result2.max = result2.main;
                          }
                        }
                        if (callback) {
                          callback(result2);
                        }
                        resolve5(result2);
                      });
                    }
                  });
                });
              });
            } catch (er) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec("sysctl dev.cpu | grep temp", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                let sum = 0;
                lines.forEach(function(line) {
                  const parts2 = line.split(":");
                  if (parts2.length > 1) {
                    const temp = parseFloat(parts2[1].replace(",", "."));
                    if (temp > result2.max) {
                      result2.max = temp;
                    }
                    sum = sum + temp;
                    result2.cores.push(temp);
                  }
                });
                if (result2.cores.length) {
                  result2.main = Math.round(sum / result2.cores.length * 100) / 100;
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            let osxTemp = null;
            try {
              osxTemp = require("osx-temperature-sensor");
            } catch (er) {
              osxTemp = null;
            }
            if (osxTemp) {
              result2 = osxTemp.cpuTemperature();
              if (result2.main) {
                result2.main = Math.round(result2.main * 100) / 100;
              }
              if (result2.max) {
                result2.max = Math.round(result2.max * 100) / 100;
              }
              if (result2.cores && result2.cores.length) {
                for (let i = 0; i < result2.cores.length; i++) {
                  result2.cores[i] = Math.round(result2.cores[i] * 100) / 100;
                }
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_windows) {
            try {
              util2.powerShell('Get-CimInstance MSAcpi_ThermalZoneTemperature -Namespace "root/wmi" | Select CurrentTemperature').then((stdout, error) => {
                if (!error) {
                  let sum = 0;
                  let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                  lines.forEach(function(line) {
                    let value2 = (parseInt(line, 10) - 2732) / 10;
                    if (!isNaN(value2)) {
                      sum = sum + value2;
                      if (value2 > result2.max) {
                        result2.max = value2;
                      }
                      result2.cores.push(value2);
                    }
                  });
                  if (result2.cores.length) {
                    result2.main = sum / result2.cores.length;
                  }
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(cpuTemperature, "cpuTemperature");
    exports2.cpuTemperature = cpuTemperature;
    function cpuFlags(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = "";
          if (_windows) {
            try {
              exec('reg query "HKEY_LOCAL_MACHINE\\HARDWARE\\DESCRIPTION\\System\\CentralProcessor\\0" /v FeatureSet', util2.execOptsWin, function(error, stdout) {
                if (!error) {
                  let flag_hex = stdout.split("0x").pop().trim();
                  let flag_bin_unpadded = parseInt(flag_hex, 16).toString(2);
                  let flag_bin = "0".repeat(32 - flag_bin_unpadded.length) + flag_bin_unpadded;
                  let all_flags = [
                    "fpu",
                    "vme",
                    "de",
                    "pse",
                    "tsc",
                    "msr",
                    "pae",
                    "mce",
                    "cx8",
                    "apic",
                    "",
                    "sep",
                    "mtrr",
                    "pge",
                    "mca",
                    "cmov",
                    "pat",
                    "pse-36",
                    "psn",
                    "clfsh",
                    "",
                    "ds",
                    "acpi",
                    "mmx",
                    "fxsr",
                    "sse",
                    "sse2",
                    "ss",
                    "htt",
                    "tm",
                    "ia64",
                    "pbe"
                  ];
                  for (let f = 0; f < all_flags.length; f++) {
                    if (flag_bin[f] === "1" && all_flags[f] !== "") {
                      result2 += " " + all_flags[f];
                    }
                  }
                  result2 = result2.trim().toLowerCase();
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_linux) {
            try {
              exec("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    if (line.split(":")[0].toUpperCase().indexOf("FLAGS") !== -1) {
                      result2 = line.split(":")[1].trim().toLowerCase();
                    }
                  });
                }
                if (!result2) {
                  fs.readFile("/proc/cpuinfo", function(error2, stdout2) {
                    if (!error2) {
                      let lines = stdout2.toString().split("\n");
                      result2 = util2.getValue(lines, "features", ":", true).toLowerCase();
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec("export LC_ALL=C; dmidecode -t 4 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let flags = [];
              if (!error) {
                let parts2 = stdout.toString().split("	Flags:");
                const lines = parts2.length > 1 ? parts2[1].split("	Version:")[0].split("\n") : [];
                lines.forEach(function(line) {
                  let flag = (line.indexOf("(") ? line.split("(")[0].toLowerCase() : "").trim().replace(/\t/g, "");
                  if (flag) {
                    flags.push(flag);
                  }
                });
              }
              result2 = flags.join(" ").trim().toLowerCase();
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            exec("sysctl machdep.cpu.features", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                if (lines.length > 0 && lines[0].indexOf("machdep.cpu.features:") !== -1) {
                  result2 = lines[0].split(":")[1].trim().toLowerCase();
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(cpuFlags, "cpuFlags");
    exports2.cpuFlags = cpuFlags;
    function cpuCache(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            l1d: null,
            l1i: null,
            l2: null,
            l3: null
          };
          if (_linux) {
            try {
              exec("export LC_ALL=C; lscpu; unset LC_ALL", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    let parts2 = line.split(":");
                    if (parts2[0].toUpperCase().indexOf("L1D CACHE") !== -1) {
                      result2.l1d = parseInt(parts2[1].trim()) * (parts2[1].indexOf("M") !== -1 ? 1024 * 1024 : parts2[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts2[0].toUpperCase().indexOf("L1I CACHE") !== -1) {
                      result2.l1i = parseInt(parts2[1].trim()) * (parts2[1].indexOf("M") !== -1 ? 1024 * 1024 : parts2[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts2[0].toUpperCase().indexOf("L2 CACHE") !== -1) {
                      result2.l2 = parseInt(parts2[1].trim()) * (parts2[1].indexOf("M") !== -1 ? 1024 * 1024 : parts2[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                    if (parts2[0].toUpperCase().indexOf("L3 CACHE") !== -1) {
                      result2.l3 = parseInt(parts2[1].trim()) * (parts2[1].indexOf("M") !== -1 ? 1024 * 1024 : parts2[1].indexOf("K") !== -1 ? 1024 : 1);
                    }
                  });
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec("export LC_ALL=C; dmidecode -t 7 2>/dev/null; unset LC_ALL", function(error, stdout) {
              let cache2 = [];
              if (!error) {
                const data = stdout.toString();
                cache2 = data.split("Cache Information");
                cache2.shift();
              }
              for (let i = 0; i < cache2.length; i++) {
                const lines = cache2[i].split("\n");
                let cacheType = util2.getValue(lines, "Socket Designation").toLowerCase().replace(" ", "-").split("-");
                cacheType = cacheType.length ? cacheType[0] : "";
                const sizeParts = util2.getValue(lines, "Installed Size").split(" ");
                let size = parseInt(sizeParts[0], 10);
                const unit = sizeParts.length > 1 ? sizeParts[1] : "kb";
                size = size * (unit === "kb" ? 1024 : unit === "mb" ? 1024 * 1024 : unit === "gb" ? 1024 * 1024 * 1024 : 1);
                if (cacheType) {
                  if (cacheType === "l1") {
                    result2.cache[cacheType + "d"] = size / 2;
                    result2.cache[cacheType + "i"] = size / 2;
                  } else {
                    result2.cache[cacheType] = size;
                  }
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            exec("sysctl hw.l1icachesize hw.l1dcachesize hw.l2cachesize hw.l3cachesize", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                lines.forEach(function(line) {
                  let parts2 = line.split(":");
                  if (parts2[0].toLowerCase().indexOf("hw.l1icachesize") !== -1) {
                    result2.l1d = parseInt(parts2[1].trim()) * (parts2[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts2[0].toLowerCase().indexOf("hw.l1dcachesize") !== -1) {
                    result2.l1i = parseInt(parts2[1].trim()) * (parts2[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts2[0].toLowerCase().indexOf("hw.l2cachesize") !== -1) {
                    result2.l2 = parseInt(parts2[1].trim()) * (parts2[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                  if (parts2[0].toLowerCase().indexOf("hw.l3cachesize") !== -1) {
                    result2.l3 = parseInt(parts2[1].trim()) * (parts2[1].indexOf("K") !== -1 ? 1024 : 1);
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util2.powerShell("Get-CimInstance Win32_processor | select L2CacheSize, L3CacheSize | fl"));
              workload.push(util2.powerShell("Get-CimInstance Win32_CacheMemory | select CacheType,InstalledSize,Level | fl"));
              Promise.all(workload).then((data) => {
                result2 = parseWinCache(data[0], data[1]);
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(cpuCache, "cpuCache");
    function parseWinCache(linesProc, linesCache) {
      let result2 = {
        l1d: null,
        l1i: null,
        l2: null,
        l3: null
      };
      let lines = linesProc.split("\r\n");
      result2.l1d = 0;
      result2.l1i = 0;
      result2.l2 = util2.getValue(lines, "l2cachesize", ":");
      result2.l3 = util2.getValue(lines, "l3cachesize", ":");
      if (result2.l2) {
        result2.l2 = parseInt(result2.l2, 10) * 1024;
      } else {
        result2.l2 = 0;
      }
      if (result2.l3) {
        result2.l3 = parseInt(result2.l3, 10) * 1024;
      } else {
        result2.l3 = 0;
      }
      const parts2 = linesCache.split(/\n\s*\n/);
      let l1i = 0;
      let l1d = 0;
      let l2 = 0;
      parts2.forEach(function(part) {
        const lines2 = part.split("\r\n");
        const cacheType = util2.getValue(lines2, "CacheType");
        const level = util2.getValue(lines2, "Level");
        const installedSize = util2.getValue(lines2, "InstalledSize");
        if (level === "3" && cacheType === "3") {
          result2.l1i = result2.l1i + parseInt(installedSize, 10) * 1024;
        }
        if (level === "3" && cacheType === "4") {
          result2.l1d = result2.l1d + parseInt(installedSize, 10) * 1024;
        }
        if (level === "3" && cacheType === "5") {
          l1i = parseInt(installedSize, 10) / 2;
          l1d = parseInt(installedSize, 10) / 2;
        }
        if (level === "4" && cacheType === "5") {
          l2 = l2 + parseInt(installedSize, 10) * 1024;
        }
      });
      if (!result2.l1i && !result2.l1d) {
        result2.l1i = l1i;
        result2.l1d = l1d;
      }
      if (l2) {
        result2.l2 = l2;
      }
      return result2;
    }
    __name(parseWinCache, "parseWinCache");
    exports2.cpuCache = cpuCache;
    function getLoad() {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let loads = os.loadavg().map(function(x) {
            return x / util2.cores();
          });
          let avgLoad = parseFloat(Math.max.apply(Math, loads).toFixed(2));
          let result2 = {};
          let now = Date.now() - _current_cpu.ms;
          if (now >= 200) {
            _current_cpu.ms = Date.now();
            const cpus = os.cpus().map(function(cpu2) {
              cpu2.times.steal = 0;
              cpu2.times.guest = 0;
              return cpu2;
            });
            let totalUser = 0;
            let totalSystem = 0;
            let totalNice = 0;
            let totalIrq = 0;
            let totalIdle = 0;
            let totalSteal = 0;
            let totalGuest = 0;
            let cores = [];
            _corecount = cpus && cpus.length ? cpus.length : 0;
            if (_linux) {
              try {
                const lines = execSync("cat /proc/stat 2>/dev/null | grep cpu", util2.execOptsLinux).toString().split("\n");
                if (lines.length > 1) {
                  lines.shift();
                  if (lines.length === cpus.length) {
                    for (let i = 0; i < lines.length; i++) {
                      let parts2 = lines[i].split(" ");
                      if (parts2.length >= 10) {
                        const steal = parseFloat(parts2[8]) || 0;
                        const guest = parseFloat(parts2[9]) || 0;
                        cpus[i].times.steal = steal;
                        cpus[i].times.guest = guest;
                      }
                    }
                  }
                }
              } catch (e) {
                util2.noop();
              }
            }
            for (let i = 0; i < _corecount; i++) {
              const cpu2 = cpus[i].times;
              totalUser += cpu2.user;
              totalSystem += cpu2.sys;
              totalNice += cpu2.nice;
              totalIdle += cpu2.idle;
              totalIrq += cpu2.irq;
              totalSteal += cpu2.steal || 0;
              totalGuest += cpu2.guest || 0;
              let tmpTick = _cpus && _cpus[i] && _cpus[i].totalTick ? _cpus[i].totalTick : 0;
              let tmpLoad = _cpus && _cpus[i] && _cpus[i].totalLoad ? _cpus[i].totalLoad : 0;
              let tmpUser = _cpus && _cpus[i] && _cpus[i].user ? _cpus[i].user : 0;
              let tmpSystem = _cpus && _cpus[i] && _cpus[i].sys ? _cpus[i].sys : 0;
              let tmpNice = _cpus && _cpus[i] && _cpus[i].nice ? _cpus[i].nice : 0;
              let tmpIdle = _cpus && _cpus[i] && _cpus[i].idle ? _cpus[i].idle : 0;
              let tmpIrq = _cpus && _cpus[i] && _cpus[i].irq ? _cpus[i].irq : 0;
              let tmpSteal = _cpus && _cpus[i] && _cpus[i].steal ? _cpus[i].steal : 0;
              let tmpGuest = _cpus && _cpus[i] && _cpus[i].guest ? _cpus[i].guest : 0;
              _cpus[i] = cpu2;
              _cpus[i].totalTick = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest + _cpus[i].idle;
              _cpus[i].totalLoad = _cpus[i].user + _cpus[i].sys + _cpus[i].nice + _cpus[i].irq + _cpus[i].steal + _cpus[i].guest;
              _cpus[i].currentTick = _cpus[i].totalTick - tmpTick;
              _cpus[i].load = _cpus[i].totalLoad - tmpLoad;
              _cpus[i].loadUser = _cpus[i].user - tmpUser;
              _cpus[i].loadSystem = _cpus[i].sys - tmpSystem;
              _cpus[i].loadNice = _cpus[i].nice - tmpNice;
              _cpus[i].loadIdle = _cpus[i].idle - tmpIdle;
              _cpus[i].loadIrq = _cpus[i].irq - tmpIrq;
              _cpus[i].loadSteal = _cpus[i].steal - tmpSteal;
              _cpus[i].loadGuest = _cpus[i].guest - tmpGuest;
              cores[i] = {};
              cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
              cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
              cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
              cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
              cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
              cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
              cores[i].loadSteal = _cpus[i].loadSteal / _cpus[i].currentTick * 100;
              cores[i].loadGuest = _cpus[i].loadGuest / _cpus[i].currentTick * 100;
              cores[i].rawLoad = _cpus[i].load;
              cores[i].rawLoadUser = _cpus[i].loadUser;
              cores[i].rawLoadSystem = _cpus[i].loadSystem;
              cores[i].rawLoadNice = _cpus[i].loadNice;
              cores[i].rawLoadIdle = _cpus[i].loadIdle;
              cores[i].rawLoadIrq = _cpus[i].loadIrq;
              cores[i].rawLoadSteal = _cpus[i].loadSteal;
              cores[i].rawLoadGuest = _cpus[i].loadGuest;
            }
            let totalTick = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest + totalIdle;
            let totalLoad = totalUser + totalSystem + totalNice + totalIrq + totalSteal + totalGuest;
            let currentTick = totalTick - _current_cpu.tick;
            result2 = {
              avgLoad,
              currentLoad: (totalLoad - _current_cpu.load) / currentTick * 100,
              currentLoadUser: (totalUser - _current_cpu.user) / currentTick * 100,
              currentLoadSystem: (totalSystem - _current_cpu.system) / currentTick * 100,
              currentLoadNice: (totalNice - _current_cpu.nice) / currentTick * 100,
              currentLoadIdle: (totalIdle - _current_cpu.idle) / currentTick * 100,
              currentLoadIrq: (totalIrq - _current_cpu.irq) / currentTick * 100,
              currentLoadSteal: (totalSteal - _current_cpu.steal) / currentTick * 100,
              currentLoadGuest: (totalGuest - _current_cpu.guest) / currentTick * 100,
              rawCurrentLoad: totalLoad - _current_cpu.load,
              rawCurrentLoadUser: totalUser - _current_cpu.user,
              rawCurrentLoadSystem: totalSystem - _current_cpu.system,
              rawCurrentLoadNice: totalNice - _current_cpu.nice,
              rawCurrentLoadIdle: totalIdle - _current_cpu.idle,
              rawCurrentLoadIrq: totalIrq - _current_cpu.irq,
              rawCurrentLoadSteal: totalSteal - _current_cpu.steal,
              rawCurrentLoadGuest: totalGuest - _current_cpu.guest,
              cpus: cores
            };
            _current_cpu = {
              user: totalUser,
              nice: totalNice,
              system: totalSystem,
              idle: totalIdle,
              irq: totalIrq,
              steal: totalSteal,
              guest: totalGuest,
              tick: totalTick,
              load: totalLoad,
              ms: _current_cpu.ms,
              currentLoad: result2.currentLoad,
              currentLoadUser: result2.currentLoadUser,
              currentLoadSystem: result2.currentLoadSystem,
              currentLoadNice: result2.currentLoadNice,
              currentLoadIdle: result2.currentLoadIdle,
              currentLoadIrq: result2.currentLoadIrq,
              currentLoadSteal: result2.currentLoadSteal,
              currentLoadGuest: result2.currentLoadGuest,
              rawCurrentLoad: result2.rawCurrentLoad,
              rawCurrentLoadUser: result2.rawCurrentLoadUser,
              rawCurrentLoadSystem: result2.rawCurrentLoadSystem,
              rawCurrentLoadNice: result2.rawCurrentLoadNice,
              rawCurrentLoadIdle: result2.rawCurrentLoadIdle,
              rawCurrentLoadIrq: result2.rawCurrentLoadIrq,
              rawCurrentLoadSteal: result2.rawCurrentLoadSteal,
              rawCurrentLoadGuest: result2.rawCurrentLoadGuest
            };
          } else {
            let cores = [];
            for (let i = 0; i < _corecount; i++) {
              cores[i] = {};
              cores[i].load = _cpus[i].load / _cpus[i].currentTick * 100;
              cores[i].loadUser = _cpus[i].loadUser / _cpus[i].currentTick * 100;
              cores[i].loadSystem = _cpus[i].loadSystem / _cpus[i].currentTick * 100;
              cores[i].loadNice = _cpus[i].loadNice / _cpus[i].currentTick * 100;
              cores[i].loadIdle = _cpus[i].loadIdle / _cpus[i].currentTick * 100;
              cores[i].loadIrq = _cpus[i].loadIrq / _cpus[i].currentTick * 100;
              cores[i].rawLoad = _cpus[i].load;
              cores[i].rawLoadUser = _cpus[i].loadUser;
              cores[i].rawLoadSystem = _cpus[i].loadSystem;
              cores[i].rawLoadNice = _cpus[i].loadNice;
              cores[i].rawLoadIdle = _cpus[i].loadIdle;
              cores[i].rawLoadIrq = _cpus[i].loadIrq;
              cores[i].rawLoadSteal = _cpus[i].loadSteal;
              cores[i].rawLoadGuest = _cpus[i].loadGuest;
            }
            result2 = {
              avgLoad,
              currentLoad: _current_cpu.currentLoad,
              currentLoadUser: _current_cpu.currentLoadUser,
              currentLoadSystem: _current_cpu.currentLoadSystem,
              currentLoadNice: _current_cpu.currentLoadNice,
              currentLoadIdle: _current_cpu.currentLoadIdle,
              currentLoadIrq: _current_cpu.currentLoadIrq,
              currentLoadSteal: _current_cpu.currentLoadSteal,
              currentLoadGuest: _current_cpu.currentLoadGuest,
              rawCurrentLoad: _current_cpu.rawCurrentLoad,
              rawCurrentLoadUser: _current_cpu.rawCurrentLoadUser,
              rawCurrentLoadSystem: _current_cpu.rawCurrentLoadSystem,
              rawCurrentLoadNice: _current_cpu.rawCurrentLoadNice,
              rawCurrentLoadIdle: _current_cpu.rawCurrentLoadIdle,
              rawCurrentLoadIrq: _current_cpu.rawCurrentLoadIrq,
              rawCurrentLoadSteal: _current_cpu.rawCurrentLoadSteal,
              rawCurrentLoadGuest: _current_cpu.rawCurrentLoadGuest,
              cpus: cores
            };
          }
          resolve5(result2);
        });
      });
    }
    __name(getLoad, "getLoad");
    function currentLoad2(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          getLoad().then((result2) => {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          });
        });
      });
    }
    __name(currentLoad2, "currentLoad");
    exports2.currentLoad = currentLoad2;
    function getFullLoad() {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          const cpus = os.cpus();
          let totalUser = 0;
          let totalSystem = 0;
          let totalNice = 0;
          let totalIrq = 0;
          let totalIdle = 0;
          let result2 = 0;
          if (cpus && cpus.length) {
            for (let i = 0, len = cpus.length; i < len; i++) {
              const cpu2 = cpus[i].times;
              totalUser += cpu2.user;
              totalSystem += cpu2.sys;
              totalNice += cpu2.nice;
              totalIrq += cpu2.irq;
              totalIdle += cpu2.idle;
            }
            let totalTicks = totalIdle + totalIrq + totalNice + totalSystem + totalUser;
            result2 = (totalTicks - totalIdle) / totalTicks * 100;
          }
          resolve5(result2);
        });
      });
    }
    __name(getFullLoad, "getFullLoad");
    function fullLoad(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          getFullLoad().then((result2) => {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          });
        });
      });
    }
    __name(fullLoad, "fullLoad");
    exports2.fullLoad = fullLoad;
  }
});

// node_modules/systeminformation/lib/memory.js
var require_memory = __commonJS({
  "node_modules/systeminformation/lib/memory.js"(exports2) {
    "use strict";
    var os = require("os");
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util2 = require_util();
    var fs = require("fs");
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var OSX_RAM_manufacturers = {
      "0x014F": "Transcend Information",
      "0x2C00": "Micron Technology Inc.",
      "0x802C": "Micron Technology Inc.",
      "0x80AD": "Hynix Semiconductor Inc.",
      "0x80CE": "Samsung Electronics Inc.",
      "0xAD00": "Hynix Semiconductor Inc.",
      "0xCE00": "Samsung Electronics Inc.",
      "0x02FE": "Elpida",
      "0x5105": "Qimonda AG i. In.",
      "0x8551": "Qimonda AG i. In.",
      "0x859B": "Crucial",
      "0x04CD": "G-Skill"
    };
    var LINUX_RAM_manufacturers = {
      "017A": "Apacer",
      "0198": "HyperX",
      "029E": "Corsair",
      "04CB": "A-DATA",
      "04CD": "G-Skill",
      "059B": "Crucial",
      "00CE": "Samsung",
      "1315": "Crucial",
      "014F": "Transcend Information",
      "2C00": "Micron Technology Inc.",
      "802C": "Micron Technology Inc.",
      "80AD": "Hynix Semiconductor Inc.",
      "80CE": "Samsung Electronics Inc.",
      "AD00": "Hynix Semiconductor Inc.",
      "CE00": "Samsung Electronics Inc.",
      "02FE": "Elpida",
      "5105": "Qimonda AG i. In.",
      "8551": "Qimonda AG i. In.",
      "859B": "Crucial"
    };
    function mem2(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            total: os.totalmem(),
            free: os.freemem(),
            used: os.totalmem() - os.freemem(),
            active: os.totalmem() - os.freemem(),
            available: os.freemem(),
            buffers: 0,
            cached: 0,
            slab: 0,
            buffcache: 0,
            swaptotal: 0,
            swapused: 0,
            swapfree: 0,
            writeback: null,
            dirty: null
          };
          if (_linux) {
            try {
              fs.readFile("/proc/meminfo", function(error, stdout) {
                if (!error) {
                  const lines = stdout.toString().split("\n");
                  result2.total = parseInt(util2.getValue(lines, "memtotal"), 10);
                  result2.total = result2.total ? result2.total * 1024 : os.totalmem();
                  result2.free = parseInt(util2.getValue(lines, "memfree"), 10);
                  result2.free = result2.free ? result2.free * 1024 : os.freemem();
                  result2.used = result2.total - result2.free;
                  result2.buffers = parseInt(util2.getValue(lines, "buffers"), 10);
                  result2.buffers = result2.buffers ? result2.buffers * 1024 : 0;
                  result2.cached = parseInt(util2.getValue(lines, "cached"), 10);
                  result2.cached = result2.cached ? result2.cached * 1024 : 0;
                  result2.slab = parseInt(util2.getValue(lines, "slab"), 10);
                  result2.slab = result2.slab ? result2.slab * 1024 : 0;
                  result2.buffcache = result2.buffers + result2.cached + result2.slab;
                  let available = parseInt(util2.getValue(lines, "memavailable"), 10);
                  result2.available = available ? available * 1024 : result2.free + result2.buffcache;
                  result2.active = result2.total - result2.available;
                  result2.swaptotal = parseInt(util2.getValue(lines, "swaptotal"), 10);
                  result2.swaptotal = result2.swaptotal ? result2.swaptotal * 1024 : 0;
                  result2.swapfree = parseInt(util2.getValue(lines, "swapfree"), 10);
                  result2.swapfree = result2.swapfree ? result2.swapfree * 1024 : 0;
                  result2.swapused = result2.swaptotal - result2.swapfree;
                  result2.writeback = parseInt(util2.getValue(lines, "writeback"), 10);
                  result2.writeback = result2.writeback ? result2.writeback * 1024 : 0;
                  result2.dirty = parseInt(util2.getValue(lines, "dirty"), 10);
                  result2.dirty = result2.dirty ? result2.dirty * 1024 : 0;
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            try {
              exec("/sbin/sysctl hw.realmem hw.physmem vm.stats.vm.v_page_count vm.stats.vm.v_wire_count vm.stats.vm.v_active_count vm.stats.vm.v_inactive_count vm.stats.vm.v_cache_count vm.stats.vm.v_free_count vm.stats.vm.v_page_size", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  const pagesize = parseInt(util2.getValue(lines, "vm.stats.vm.v_page_size"), 10);
                  const inactive = parseInt(util2.getValue(lines, "vm.stats.vm.v_inactive_count"), 10) * pagesize;
                  const cache2 = parseInt(util2.getValue(lines, "vm.stats.vm.v_cache_count"), 10) * pagesize;
                  result2.total = parseInt(util2.getValue(lines, "hw.realmem"), 10);
                  if (isNaN(result2.total)) {
                    result2.total = parseInt(util2.getValue(lines, "hw.physmem"), 10);
                  }
                  result2.free = parseInt(util2.getValue(lines, "vm.stats.vm.v_free_count"), 10) * pagesize;
                  result2.buffcache = inactive + cache2;
                  result2.available = result2.buffcache + result2.free;
                  result2.active = result2.total - result2.free - result2.buffcache;
                  result2.swaptotal = 0;
                  result2.swapfree = 0;
                  result2.swapused = 0;
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_darwin) {
            let pageSize = 4096;
            try {
              let sysPpageSize = util2.toInt(execSync("sysctl -n vm.pagesize").toString());
              pageSize = sysPpageSize || pageSize;
            } catch (e) {
              util2.noop();
            }
            try {
              exec('vm_stat 2>/dev/null | grep "Pages active"', function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  result2.active = parseInt(lines[0].split(":")[1], 10) * pageSize;
                  result2.buffcache = result2.used - result2.active;
                  result2.available = result2.free + result2.buffcache;
                }
                exec("sysctl -n vm.swapusage 2>/dev/null", function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    if (lines.length > 0) {
                      let firstline = lines[0].replace(/,/g, ".").replace(/M/g, "");
                      let lineArray = firstline.trim().split("  ");
                      lineArray.forEach((line) => {
                        if (line.toLowerCase().indexOf("total") !== -1) {
                          result2.swaptotal = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                        }
                        if (line.toLowerCase().indexOf("used") !== -1) {
                          result2.swapused = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                        }
                        if (line.toLowerCase().indexOf("free") !== -1) {
                          result2.swapfree = parseFloat(line.split("=")[1].trim()) * 1024 * 1024;
                        }
                      });
                    }
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                });
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_windows) {
            let swaptotal = 0;
            let swapused = 0;
            try {
              util2.powerShell("Get-CimInstance Win32_PageFileUsage | Select AllocatedBaseSize, CurrentUsage").then((stdout, error) => {
                if (!error) {
                  let lines = stdout.split("\r\n").filter((line) => line.trim() !== "").filter((line, idx) => idx > 0);
                  lines.forEach(function(line) {
                    if (line !== "") {
                      line = line.trim().split(/\s\s+/);
                      swaptotal = swaptotal + (parseInt(line[0], 10) || 0);
                      swapused = swapused + (parseInt(line[1], 10) || 0);
                    }
                  });
                }
                result2.swaptotal = swaptotal * 1024 * 1024;
                result2.swapused = swapused * 1024 * 1024;
                result2.swapfree = result2.swaptotal - result2.swapused;
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(mem2, "mem");
    exports2.mem = mem2;
    function memLayout(callback) {
      function getManufacturerDarwin(manId) {
        if ({}.hasOwnProperty.call(OSX_RAM_manufacturers, manId)) {
          return OSX_RAM_manufacturers[manId];
        }
        return manId;
      }
      __name(getManufacturerDarwin, "getManufacturerDarwin");
      function getManufacturerLinux(manId) {
        const manIdSearch = manId.replace("0x", "").toUpperCase();
        if (manIdSearch.length === 4 && {}.hasOwnProperty.call(LINUX_RAM_manufacturers, manIdSearch)) {
          return LINUX_RAM_manufacturers[manIdSearch];
        }
        return manId;
      }
      __name(getManufacturerLinux, "getManufacturerLinux");
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            exec('export LC_ALL=C; dmidecode -t memory 2>/dev/null | grep -iE "Size:|Type|Speed|Manufacturer|Form Factor|Locator|Memory Device|Serial Number|Voltage|Part Number"; unset LC_ALL', function(error, stdout) {
              if (!error) {
                let devices = stdout.toString().split("Memory Device");
                devices.shift();
                devices.forEach(function(device) {
                  let lines = device.split("\n");
                  const sizeString = util2.getValue(lines, "Size");
                  const size = sizeString.indexOf("GB") >= 0 ? parseInt(sizeString, 10) * 1024 * 1024 * 1024 : parseInt(sizeString, 10) * 1024 * 1024;
                  let bank = util2.getValue(lines, "Bank Locator");
                  if (bank.toLowerCase().indexOf("bad") >= 0) {
                    bank = "";
                  }
                  if (parseInt(util2.getValue(lines, "Size"), 10) > 0) {
                    const totalWidth = util2.toInt(util2.getValue(lines, "Total Width"));
                    const dataWidth = util2.toInt(util2.getValue(lines, "Data Width"));
                    result2.push({
                      size,
                      bank,
                      type: util2.getValue(lines, "Type:"),
                      ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                      clockSpeed: util2.getValue(lines, "Configured Clock Speed:") ? parseInt(util2.getValue(lines, "Configured Clock Speed:"), 10) : util2.getValue(lines, "Speed:") ? parseInt(util2.getValue(lines, "Speed:"), 10) : null,
                      formFactor: util2.getValue(lines, "Form Factor:"),
                      manufacturer: getManufacturerLinux(util2.getValue(lines, "Manufacturer:")),
                      partNum: util2.getValue(lines, "Part Number:"),
                      serialNum: util2.getValue(lines, "Serial Number:"),
                      voltageConfigured: parseFloat(util2.getValue(lines, "Configured Voltage:")) || null,
                      voltageMin: parseFloat(util2.getValue(lines, "Minimum Voltage:")) || null,
                      voltageMax: parseFloat(util2.getValue(lines, "Maximum Voltage:")) || null
                    });
                  } else {
                    result2.push({
                      size: 0,
                      bank,
                      type: "Empty",
                      ecc: null,
                      clockSpeed: 0,
                      formFactor: util2.getValue(lines, "Form Factor:"),
                      partNum: "",
                      serialNum: "",
                      voltageConfigured: null,
                      voltageMin: null,
                      voltageMax: null
                    });
                  }
                });
              }
              if (!result2.length) {
                result2.push({
                  size: os.totalmem(),
                  bank: "",
                  type: "",
                  ecc: null,
                  clockSpeed: 0,
                  formFactor: "",
                  partNum: "",
                  serialNum: "",
                  voltageConfigured: null,
                  voltageMin: null,
                  voltageMax: null
                });
                try {
                  let stdout2 = execSync("cat /proc/cpuinfo 2>/dev/null", util2.execOptsLinux);
                  let lines = stdout2.toString().split("\n");
                  let version2 = util2.getValue(lines, "revision", ":", true).toLowerCase();
                  if (util2.isRaspberry(lines)) {
                    const clockSpeed = {
                      "0": 400,
                      "1": 450,
                      "2": 450,
                      "3": 3200,
                      "4": 4267
                    };
                    result2[0].type = "LPDDR2";
                    result2[0].type = version2 && version2[2] && version2[2] === "3" ? "LPDDR4" : result2[0].type;
                    result2[0].type = version2 && version2[2] && version2[2] === "4" ? "LPDDR4X" : result2[0].type;
                    result2[0].ecc = false;
                    result2[0].clockSpeed = version2 && version2[2] && clockSpeed[version2[2]] || 400;
                    result2[0].clockSpeed = version2 && version2[4] && version2[4] === "d" ? 500 : result2[0].clockSpeed;
                    result2[0].formFactor = "SoC";
                    stdout2 = execSync("vcgencmd get_config sdram_freq 2>/dev/null", util2.execOptsLinux);
                    lines = stdout2.toString().split("\n");
                    let freq = parseInt(util2.getValue(lines, "sdram_freq", "=", true), 10) || 0;
                    if (freq) {
                      result2[0].clockSpeed = freq;
                    }
                    stdout2 = execSync("vcgencmd measure_volts sdram_p 2>/dev/null", util2.execOptsLinux);
                    lines = stdout2.toString().split("\n");
                    let voltage = parseFloat(util2.getValue(lines, "volt", "=", true)) || 0;
                    if (voltage) {
                      result2[0].voltageConfigured = voltage;
                      result2[0].voltageMin = voltage;
                      result2[0].voltageMax = voltage;
                    }
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            exec("system_profiler SPMemoryDataType", function(error, stdout) {
              if (!error) {
                const allLines = stdout.toString().split("\n");
                const eccStatus = util2.getValue(allLines, "ecc", ":", true).toLowerCase();
                let devices = stdout.toString().split("        BANK ");
                let hasBank = true;
                if (devices.length === 1) {
                  devices = stdout.toString().split("        DIMM");
                  hasBank = false;
                }
                devices.shift();
                devices.forEach(function(device) {
                  let lines = device.split("\n");
                  const bank = (hasBank ? "BANK " : "DIMM") + lines[0].trim().split("/")[0];
                  const size = parseInt(util2.getValue(lines, "          Size"));
                  if (size) {
                    result2.push({
                      size: size * 1024 * 1024 * 1024,
                      bank,
                      type: util2.getValue(lines, "          Type:"),
                      ecc: eccStatus ? eccStatus === "enabled" : null,
                      clockSpeed: parseInt(util2.getValue(lines, "          Speed:"), 10),
                      formFactor: "",
                      manufacturer: getManufacturerDarwin(util2.getValue(lines, "          Manufacturer:")),
                      partNum: util2.getValue(lines, "          Part Number:"),
                      serialNum: util2.getValue(lines, "          Serial Number:"),
                      voltageConfigured: null,
                      voltageMin: null,
                      voltageMax: null
                    });
                  } else {
                    result2.push({
                      size: 0,
                      bank,
                      type: "Empty",
                      ecc: null,
                      clockSpeed: 0,
                      formFactor: "",
                      manufacturer: "",
                      partNum: "",
                      serialNum: "",
                      voltageConfigured: null,
                      voltageMin: null,
                      voltageMax: null
                    });
                  }
                });
              }
              if (!result2.length) {
                const lines = stdout.toString().split("\n");
                const size = parseInt(util2.getValue(lines, "      Memory:"));
                const type = util2.getValue(lines, "      Type:");
                const manufacturerId = util2.getValue(lines, "      Manufacturer:");
                if (size && type) {
                  result2.push({
                    size: size * 1024 * 1024 * 1024,
                    bank: "0",
                    type,
                    ecc: false,
                    clockSpeed: null,
                    formFactor: "SOC",
                    manufacturer: getManufacturerDarwin(manufacturerId),
                    partNum: "",
                    serialNum: "",
                    voltageConfigured: null,
                    voltageMin: null,
                    voltageMax: null
                  });
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_windows) {
            const memoryTypes = "Unknown|Other|DRAM|Synchronous DRAM|Cache DRAM|EDO|EDRAM|VRAM|SRAM|RAM|ROM|FLASH|EEPROM|FEPROM|EPROM|CDRAM|3DRAM|SDRAM|SGRAM|RDRAM|DDR|DDR2|DDR2 FB-DIMM|Reserved|DDR3|FBD2|DDR4|LPDDR|LPDDR2|LPDDR3|LPDDR4|Logical non-volatile device|HBM|HBM2|DDR5|LPDDR5".split("|");
            const FormFactors = "Unknown|Other|SIP|DIP|ZIP|SOJ|Proprietary|SIMM|DIMM|TSOP|PGA|RIMM|SODIMM|SRIMM|SMD|SSMP|QFP|TQFP|SOIC|LCC|PLCC|BGA|FPBGA|LGA".split("|");
            try {
              util2.powerShell("Get-CimInstance Win32_PhysicalMemory | select DataWidth,TotalWidth,Capacity,BankLabel,MemoryType,SMBIOSMemoryType,ConfiguredClockSpeed,Speed,FormFactor,Manufacturer,PartNumber,SerialNumber,ConfiguredVoltage,MinVoltage,MaxVoltage,Tag | fl").then((stdout, error) => {
                if (!error) {
                  let devices = stdout.toString().split(/\n\s*\n/);
                  devices.shift();
                  devices.forEach(function(device) {
                    let lines = device.split("\r\n");
                    const dataWidth = util2.toInt(util2.getValue(lines, "DataWidth", ":"));
                    const totalWidth = util2.toInt(util2.getValue(lines, "TotalWidth", ":"));
                    const size = parseInt(util2.getValue(lines, "Capacity", ":"), 10) || 0;
                    const tag = util2.getValue(lines, "Tag", ":");
                    const tagInt = util2.splitByNumber(tag);
                    if (size) {
                      result2.push({
                        size,
                        bank: util2.getValue(lines, "BankLabel", ":") + (tagInt[1] ? "/" + tagInt[1] : ""),
                        type: memoryTypes[parseInt(util2.getValue(lines, "MemoryType", ":"), 10) || parseInt(util2.getValue(lines, "SMBIOSMemoryType", ":"), 10)],
                        ecc: dataWidth && totalWidth ? totalWidth > dataWidth : false,
                        clockSpeed: parseInt(util2.getValue(lines, "ConfiguredClockSpeed", ":"), 10) || parseInt(util2.getValue(lines, "Speed", ":"), 10) || 0,
                        formFactor: FormFactors[parseInt(util2.getValue(lines, "FormFactor", ":"), 10) || 0],
                        manufacturer: util2.getValue(lines, "Manufacturer", ":"),
                        partNum: util2.getValue(lines, "PartNumber", ":"),
                        serialNum: util2.getValue(lines, "SerialNumber", ":"),
                        voltageConfigured: (parseInt(util2.getValue(lines, "ConfiguredVoltage", ":"), 10) || 0) / 1e3,
                        voltageMin: (parseInt(util2.getValue(lines, "MinVoltage", ":"), 10) || 0) / 1e3,
                        voltageMax: (parseInt(util2.getValue(lines, "MaxVoltage", ":"), 10) || 0) / 1e3
                      });
                    }
                  });
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(memLayout, "memLayout");
    exports2.memLayout = memLayout;
  }
});

// node_modules/systeminformation/lib/battery.js
var require_battery = __commonJS({
  "node_modules/systeminformation/lib/battery.js"(exports2, module2) {
    "use strict";
    var exec = require("child_process").exec;
    var fs = require("fs");
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity) {
      const result2 = {};
      let status = util2.getValue(lines, "BatteryStatus", ":").trim();
      if (status >= 0) {
        const statusValue = status ? parseInt(status) : 0;
        result2.status = statusValue;
        result2.hasBattery = true;
        result2.maxCapacity = fullChargeCapacity || parseInt(util2.getValue(lines, "DesignCapacity", ":") || 0);
        result2.designedCapacity = parseInt(util2.getValue(lines, "DesignCapacity", ":") || designedCapacity);
        result2.voltage = parseInt(util2.getValue(lines, "DesignVoltage", ":") || 0) / 1e3;
        result2.capacityUnit = "mWh";
        result2.percent = parseInt(util2.getValue(lines, "EstimatedChargeRemaining", ":") || 0);
        result2.currentCapacity = parseInt(result2.maxCapacity * result2.percent / 100);
        result2.isCharging = statusValue >= 6 && statusValue <= 9 || statusValue === 11 || statusValue !== 3 && statusValue !== 1 && result2.percent < 100;
        result2.acConnected = result2.isCharging || statusValue === 2;
        result2.model = util2.getValue(lines, "DeviceID", ":");
      } else {
        result2.status = -1;
      }
      return result2;
    }
    __name(parseWinBatteryPart, "parseWinBatteryPart");
    module2.exports = function(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            hasBattery: false,
            cycleCount: 0,
            isCharging: false,
            designedCapacity: 0,
            maxCapacity: 0,
            currentCapacity: 0,
            voltage: 0,
            capacityUnit: "",
            percent: 0,
            timeRemaining: null,
            acConnected: true,
            type: "",
            model: "",
            manufacturer: "",
            serial: ""
          };
          if (_linux) {
            let battery_path = "";
            if (fs.existsSync("/sys/class/power_supply/BAT1/uevent")) {
              battery_path = "/sys/class/power_supply/BAT1/";
            } else if (fs.existsSync("/sys/class/power_supply/BAT0/uevent")) {
              battery_path = "/sys/class/power_supply/BAT0/";
            }
            let acConnected = false;
            let acPath = "";
            if (fs.existsSync("/sys/class/power_supply/AC/online")) {
              acPath = "/sys/class/power_supply/AC/online";
            } else if (fs.existsSync("/sys/class/power_supply/AC0/online")) {
              acPath = "/sys/class/power_supply/AC0/online";
            }
            if (acPath) {
              const file = fs.readFileSync(acPath);
              acConnected = file.toString().trim() === "1";
            }
            if (battery_path) {
              fs.readFile(battery_path + "uevent", function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  result2.isCharging = util2.getValue(lines, "POWER_SUPPLY_STATUS", "=").toLowerCase() === "charging";
                  result2.acConnected = acConnected || result2.isCharging;
                  result2.voltage = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_VOLTAGE_NOW", "="), 10) / 1e6;
                  result2.capacityUnit = result2.voltage ? "mWh" : "mAh";
                  result2.cycleCount = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_CYCLE_COUNT", "="), 10);
                  result2.maxCapacity = Math.round(parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_CHARGE_FULL", "=", true, true), 10) / 1e3 * (result2.voltage || 1));
                  const desingedMinVoltage = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_VOLTAGE_MIN_DESIGN", "="), 10) / 1e6;
                  result2.designedCapacity = Math.round(parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_CHARGE_FULL_DESIGN", "=", true, true), 10) / 1e3 * (desingedMinVoltage || result2.voltage || 1));
                  result2.currentCapacity = Math.round(parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10) / 1e3 * (result2.voltage || 1));
                  if (!result2.maxCapacity) {
                    result2.maxCapacity = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_ENERGY_FULL", "=", true, true), 10) / 1e3;
                    result2.designedCapacity = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_ENERGY_FULL_DESIGN", "=", true, true), 10) / 1e3 | result2.maxCapacity;
                    result2.currentCapacity = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10) / 1e3;
                  }
                  const percent = util2.getValue(lines, "POWER_SUPPLY_CAPACITY", "=");
                  const energy = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_ENERGY_NOW", "="), 10);
                  const power = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_POWER_NOW", "="), 10);
                  const current = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_CURRENT_NOW", "="), 10);
                  const charge = parseInt("0" + util2.getValue(lines, "POWER_SUPPLY_CHARGE_NOW", "="), 10);
                  result2.percent = parseInt("0" + percent, 10);
                  if (result2.maxCapacity && result2.currentCapacity) {
                    result2.hasBattery = true;
                    if (!percent) {
                      result2.percent = 100 * result2.currentCapacity / result2.maxCapacity;
                    }
                  }
                  if (result2.isCharging) {
                    result2.hasBattery = true;
                  }
                  if (energy && power) {
                    result2.timeRemaining = Math.floor(energy / power * 60);
                  } else if (current && charge) {
                    result2.timeRemaining = Math.floor(charge / current * 60);
                  } else if (current && result2.currentCapacity) {
                    result2.timeRemaining = Math.floor(result2.currentCapacity / current * 60);
                  }
                  result2.type = util2.getValue(lines, "POWER_SUPPLY_TECHNOLOGY", "=");
                  result2.model = util2.getValue(lines, "POWER_SUPPLY_MODEL_NAME", "=");
                  result2.manufacturer = util2.getValue(lines, "POWER_SUPPLY_MANUFACTURER", "=");
                  result2.serial = util2.getValue(lines, "POWER_SUPPLY_SERIAL_NUMBER", "=");
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec("sysctl -i hw.acpi.battery hw.acpi.acline", function(error, stdout) {
              let lines = stdout.toString().split("\n");
              const batteries = parseInt("0" + util2.getValue(lines, "hw.acpi.battery.units"), 10);
              const percent = parseInt("0" + util2.getValue(lines, "hw.acpi.battery.life"), 10);
              result2.hasBattery = batteries > 0;
              result2.cycleCount = null;
              result2.isCharging = util2.getValue(lines, "hw.acpi.acline") !== "1";
              result2.acConnected = result2.isCharging;
              result2.maxCapacity = null;
              result2.currentCapacity = null;
              result2.capacityUnit = "unknown";
              result2.percent = batteries ? percent : null;
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            exec('ioreg -n AppleSmartBattery -r | egrep "CycleCount|IsCharging|DesignCapacity|MaxCapacity|CurrentCapacity|DeviceName|BatterySerialNumber|Serial|TimeRemaining|Voltage"; pmset -g batt | grep %', function(error, stdout) {
              if (stdout) {
                let lines = stdout.toString().replace(/ +/g, "").replace(/"+/g, "").replace(/-/g, "").split("\n");
                result2.cycleCount = parseInt("0" + util2.getValue(lines, "cyclecount", "="), 10);
                result2.voltage = parseInt("0" + util2.getValue(lines, "voltage", "="), 10) / 1e3;
                result2.capacityUnit = result2.voltage ? "mWh" : "mAh";
                result2.maxCapacity = Math.round(parseInt("0" + util2.getValue(lines, "applerawmaxcapacity", "="), 10) * (result2.voltage || 1));
                result2.currentCapacity = Math.round(parseInt("0" + util2.getValue(lines, "applerawcurrentcapacity", "="), 10) * (result2.voltage || 1));
                result2.designedCapacity = Math.round(parseInt("0" + util2.getValue(lines, "DesignCapacity", "="), 10) * (result2.voltage || 1));
                result2.manufacturer = "Apple";
                result2.serial = util2.getValue(lines, "BatterySerialNumber", "=") || util2.getValue(lines, "Serial", "=");
                result2.model = util2.getValue(lines, "DeviceName", "=");
                let percent = null;
                const line = util2.getValue(lines, "internal", "Battery");
                let parts2 = line.split(";");
                if (parts2 && parts2[0]) {
                  let parts22 = parts2[0].split("	");
                  if (parts22 && parts22[1]) {
                    percent = parseFloat(parts22[1].trim().replace(/%/g, ""));
                  }
                }
                if (parts2 && parts2[1]) {
                  result2.isCharging = parts2[1].trim() === "charging";
                  result2.acConnected = parts2[1].trim() !== "discharging";
                } else {
                  result2.isCharging = util2.getValue(lines, "ischarging", "=").toLowerCase() === "yes";
                  result2.acConnected = result2.isCharging;
                }
                if (result2.maxCapacity && result2.currentCapacity) {
                  result2.hasBattery = true;
                  result2.type = "Li-ion";
                  result2.percent = percent !== null ? percent : Math.round(100 * result2.currentCapacity / result2.maxCapacity);
                  if (!result2.isCharging) {
                    result2.timeRemaining = parseInt("0" + util2.getValue(lines, "TimeRemaining", "="), 10);
                  }
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util2.powerShell("Get-CimInstance Win32_Battery | select BatteryStatus, DesignCapacity, DesignVoltage, EstimatedChargeRemaining, DeviceID | fl"));
              workload.push(util2.powerShell("(Get-WmiObject -Class BatteryStaticData -Namespace ROOT/WMI).DesignedCapacity"));
              workload.push(util2.powerShell("(Get-CimInstance -Class BatteryFullChargedCapacity -Namespace ROOT/WMI).FullChargedCapacity"));
              util2.promiseAll(workload).then((data) => {
                if (data) {
                  let parts2 = data.results[0].split(/\n\s*\n/);
                  let batteries = [];
                  const hasValue = /* @__PURE__ */ __name((value2) => /\S/.test(value2), "hasValue");
                  for (let i = 0; i < parts2.length; i++) {
                    if (hasValue(parts2[i]) && (!batteries.length || !hasValue(parts2[i - 1]))) {
                      batteries.push([]);
                    }
                    if (hasValue(parts2[i])) {
                      batteries[batteries.length - 1].push(parts2[i]);
                    }
                  }
                  let designCapacities = data.results[1].split("\r\n").filter((e) => e);
                  let fullChargeCapacities = data.results[2].split("\r\n").filter((e) => e);
                  if (batteries.length) {
                    let first = false;
                    let additionalBatteries = [];
                    for (let i = 0; i < batteries.length; i++) {
                      let lines = batteries[i][0].split("\r\n");
                      const designedCapacity = designCapacities && designCapacities.length >= i + 1 && designCapacities[i] ? util2.toInt(designCapacities[i]) : 0;
                      const fullChargeCapacity = fullChargeCapacities && fullChargeCapacities.length >= i + 1 && fullChargeCapacities[i] ? util2.toInt(fullChargeCapacities[i]) : 0;
                      const parsed = parseWinBatteryPart(lines, designedCapacity, fullChargeCapacity);
                      if (!first && parsed.status > 0 && parsed.status !== 10) {
                        result2.hasBattery = parsed.hasBattery;
                        result2.maxCapacity = parsed.maxCapacity;
                        result2.designedCapacity = parsed.designedCapacity;
                        result2.voltage = parsed.voltage;
                        result2.capacityUnit = parsed.capacityUnit;
                        result2.percent = parsed.percent;
                        result2.currentCapacity = parsed.currentCapacity;
                        result2.isCharging = parsed.isCharging;
                        result2.acConnected = parsed.acConnected;
                        result2.model = parsed.model;
                        first = true;
                      } else if (parsed.status !== -1) {
                        additionalBatteries.push({
                          hasBattery: parsed.hasBattery,
                          maxCapacity: parsed.maxCapacity,
                          designedCapacity: parsed.designedCapacity,
                          voltage: parsed.voltage,
                          capacityUnit: parsed.capacityUnit,
                          percent: parsed.percent,
                          currentCapacity: parsed.currentCapacity,
                          isCharging: parsed.isCharging,
                          timeRemaining: null,
                          acConnected: parsed.acConnected,
                          model: parsed.model,
                          type: "",
                          manufacturer: "",
                          serial: ""
                        });
                      }
                    }
                    if (!first && additionalBatteries.length) {
                      result2 = additionalBatteries[0];
                      additionalBatteries.shift();
                    }
                    if (additionalBatteries.length) {
                      result2.additionalBatteries = additionalBatteries;
                    }
                  }
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    };
  }
});

// node_modules/systeminformation/lib/graphics.js
var require_graphics = __commonJS({
  "node_modules/systeminformation/lib/graphics.js"(exports2) {
    "use strict";
    var fs = require("fs");
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util2 = require_util();
    var _platform = process.platform;
    var _nvidiaSmiPath = "";
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _resolutionX = 0;
    var _resolutionY = 0;
    var _pixelDepth = 0;
    var _refreshRate = 0;
    var videoTypes = {
      "-2": "UNINITIALIZED",
      "-1": "OTHER",
      "0": "HD15",
      "1": "SVIDEO",
      "2": "Composite video",
      "3": "Component video",
      "4": "DVI",
      "5": "HDMI",
      "6": "LVDS",
      "8": "D_JPN",
      "9": "SDI",
      "10": "DP",
      "11": "DP embedded",
      "12": "UDI",
      "13": "UDI embedded",
      "14": "SDTVDONGLE",
      "15": "MIRACAST",
      "2147483648": "INTERNAL"
    };
    function getVendorFromModel(model) {
      const manufacturers = [
        {
          pattern: "^LG.+",
          manufacturer: "LG"
        },
        {
          pattern: "^BENQ.+",
          manufacturer: "BenQ"
        },
        {
          pattern: "^ASUS.+",
          manufacturer: "Asus"
        },
        {
          pattern: "^DELL.+",
          manufacturer: "Dell"
        },
        {
          pattern: "^SAMSUNG.+",
          manufacturer: "Samsung"
        },
        {
          pattern: "^VIEWSON.+",
          manufacturer: "ViewSonic"
        },
        {
          pattern: "^SONY.+",
          manufacturer: "Sony"
        },
        {
          pattern: "^ACER.+",
          manufacturer: "Acer"
        },
        {
          pattern: "^AOC.+",
          manufacturer: "AOC Monitors"
        },
        {
          pattern: "^HP.+",
          manufacturer: "HP"
        },
        {
          pattern: "^EIZO.?",
          manufacturer: "Eizo"
        },
        {
          pattern: "^PHILIPS.?",
          manufacturer: "Philips"
        },
        {
          pattern: "^IIYAMA.?",
          manufacturer: "Iiyama"
        },
        {
          pattern: "^SHARP.?",
          manufacturer: "Sharp"
        },
        {
          pattern: "^NEC.?",
          manufacturer: "NEC"
        },
        {
          pattern: "^LENOVO.?",
          manufacturer: "Lenovo"
        },
        {
          pattern: "COMPAQ.?",
          manufacturer: "Compaq"
        },
        {
          pattern: "APPLE.?",
          manufacturer: "Apple"
        },
        {
          pattern: "INTEL.?",
          manufacturer: "Intel"
        },
        {
          pattern: "AMD.?",
          manufacturer: "AMD"
        },
        {
          pattern: "NVIDIA.?",
          manufacturer: "NVDIA"
        }
      ];
      let result2 = "";
      if (model) {
        model = model.toUpperCase();
        manufacturers.forEach((manufacturer) => {
          const re2 = RegExp(manufacturer.pattern);
          if (re2.test(model)) {
            result2 = manufacturer.manufacturer;
          }
        });
      }
      return result2;
    }
    __name(getVendorFromModel, "getVendorFromModel");
    function getVendorFromId(id) {
      const vendors = {
        "610": "Apple",
        "1e6d": "LG",
        "10ac": "DELL",
        "4dd9": "Sony",
        "38a3": "NEC"
      };
      return vendors[id] || "";
    }
    __name(getVendorFromId, "getVendorFromId");
    function vendorToId(str) {
      let result2 = "";
      str = (str || "").toLowerCase();
      if (str.indexOf("apple") >= 0) {
        result2 = "0x05ac";
      } else if (str.indexOf("nvidia") >= 0) {
        result2 = "0x10de";
      } else if (str.indexOf("intel") >= 0) {
        result2 = "0x8086";
      } else if (str.indexOf("ati") >= 0 || str.indexOf("amd") >= 0) {
        result2 = "0x1002";
      }
      return result2;
    }
    __name(vendorToId, "vendorToId");
    function getMetalVersion(id) {
      const families = {
        "spdisplays_mtlgpufamilymac1": "mac1",
        "spdisplays_mtlgpufamilymac2": "mac2",
        "spdisplays_mtlgpufamilyapple1": "apple1",
        "spdisplays_mtlgpufamilyapple2": "apple2",
        "spdisplays_mtlgpufamilyapple3": "apple3",
        "spdisplays_mtlgpufamilyapple4": "apple4",
        "spdisplays_mtlgpufamilyapple5": "apple5",
        "spdisplays_mtlgpufamilyapple6": "apple6",
        "spdisplays_mtlgpufamilyapple7": "apple7",
        "spdisplays_metalfeaturesetfamily11": "family1_v1",
        "spdisplays_metalfeaturesetfamily12": "family1_v2",
        "spdisplays_metalfeaturesetfamily13": "family1_v3",
        "spdisplays_metalfeaturesetfamily14": "family1_v4",
        "spdisplays_metalfeaturesetfamily21": "family2_v1"
      };
      return families[id] || "";
    }
    __name(getMetalVersion, "getMetalVersion");
    function graphics(callback) {
      function parseLinesDarwin(graphicsArr) {
        const res = {
          controllers: [],
          displays: []
        };
        try {
          graphicsArr.forEach(function(item) {
            const bus = (item.sppci_bus || "").indexOf("builtin") > -1 ? "Built-In" : (item.sppci_bus || "").indexOf("pcie") > -1 ? "PCIe" : "";
            const vram = (parseInt(item.spdisplays_vram || "", 10) || 0) * ((item.spdisplays_vram || "").indexOf("GB") > -1 ? 1024 : 1);
            const vramDyn = (parseInt(item.spdisplays_vram_shared || "", 10) || 0) * ((item.spdisplays_vram_shared || "").indexOf("GB") > -1 ? 1024 : 1);
            let metalVersion = getMetalVersion(item.spdisplays_metal || item.spdisplays_metalfamily || "");
            res.controllers.push({
              vendor: getVendorFromModel(item.spdisplays_vendor || "") || item.spdisplays_vendor || "",
              model: item.sppci_model || "",
              bus,
              vramDynamic: bus === "Built-In",
              vram: vram || vramDyn || null,
              deviceId: item["spdisplays_device-id"] || "",
              vendorId: item["spdisplays_vendor-id"] || vendorToId((item["spdisplays_vendor"] || "") + (item.sppci_model || "")),
              external: item.sppci_device_type === "spdisplays_egpu",
              cores: item["sppci_cores"] || null,
              metalVersion
            });
            if (item.spdisplays_ndrvs && item.spdisplays_ndrvs.length) {
              item.spdisplays_ndrvs.forEach(function(displayItem) {
                const connectionType = displayItem["spdisplays_connection_type"] || "";
                const currentResolutionParts = (displayItem["_spdisplays_resolution"] || "").split("@");
                const currentResolution = currentResolutionParts[0].split("x");
                const pixelParts = (displayItem["_spdisplays_pixels"] || "").split("x");
                const pixelDepthString = displayItem["spdisplays_depth"] || "";
                const serial = displayItem["_spdisplays_display-serial-number"] || displayItem["_spdisplays_display-serial-number2"] || null;
                res.displays.push({
                  vendor: getVendorFromId(displayItem["_spdisplays_display-vendor-id"] || "") || getVendorFromModel(displayItem["_name"] || ""),
                  vendorId: displayItem["_spdisplays_display-vendor-id"] || "",
                  model: displayItem["_name"] || "",
                  productionYear: displayItem["_spdisplays_display-year"] || null,
                  serial: serial !== "0" ? serial : null,
                  displayId: displayItem["_spdisplays_displayID"] || null,
                  main: displayItem["spdisplays_main"] ? displayItem["spdisplays_main"] === "spdisplays_yes" : false,
                  builtin: (displayItem["spdisplays_display_type"] || "").indexOf("built-in") > -1,
                  connection: connectionType.indexOf("_internal") > -1 ? "Internal" : connectionType.indexOf("_displayport") > -1 ? "Display Port" : connectionType.indexOf("_hdmi") > -1 ? "HDMI" : null,
                  sizeX: null,
                  sizeY: null,
                  pixelDepth: pixelDepthString === "CGSThirtyBitColor" ? 30 : pixelDepthString === "CGSThirtytwoBitColor" ? 32 : pixelDepthString === "CGSTwentyfourBitColor" ? 24 : null,
                  resolutionX: pixelParts.length > 1 ? parseInt(pixelParts[0], 10) : null,
                  resolutionY: pixelParts.length > 1 ? parseInt(pixelParts[1], 10) : null,
                  currentResX: currentResolution.length > 1 ? parseInt(currentResolution[0], 10) : null,
                  currentResY: currentResolution.length > 1 ? parseInt(currentResolution[1], 10) : null,
                  positionX: 0,
                  positionY: 0,
                  currentRefreshRate: currentResolutionParts.length > 1 ? parseInt(currentResolutionParts[1], 10) : null
                });
              });
            }
          });
          return res;
        } catch (e) {
          return res;
        }
      }
      __name(parseLinesDarwin, "parseLinesDarwin");
      function parseLinesLinuxControllers(lines) {
        let controllers = [];
        let currentController = {
          vendor: "",
          subVendor: "",
          model: "",
          bus: "",
          busAddress: "",
          vram: null,
          vramDynamic: false,
          pciID: ""
        };
        let isGraphicsController = false;
        let pciIDs = [];
        try {
          pciIDs = execSync('export LC_ALL=C; dmidecode -t 9 2>/dev/null; unset LC_ALL | grep "Bus Address: "', util2.execOptsLinux).toString().split("\n");
          for (let i2 = 0; i2 < pciIDs.length; i2++) {
            pciIDs[i2] = pciIDs[i2].replace("Bus Address:", "").replace("0000:", "").trim();
          }
          pciIDs = pciIDs.filter(function(el) {
            return el != null && el;
          });
        } catch (e) {
          util2.noop();
        }
        let i = 1;
        lines.forEach((line) => {
          let subsystem = "";
          if (i < lines.length && lines[i]) {
            subsystem = lines[i];
            if (subsystem.indexOf(":") > 0) {
              subsystem = subsystem.split(":")[1];
            }
          }
          if ("" !== line.trim()) {
            if (" " !== line[0] && "	" !== line[0]) {
              let isExternal = pciIDs.indexOf(line.split(" ")[0]) >= 0;
              let vgapos = line.toLowerCase().indexOf(" vga ");
              let _3dcontrollerpos = line.toLowerCase().indexOf("3d controller");
              if (vgapos !== -1 || _3dcontrollerpos !== -1) {
                if (_3dcontrollerpos !== -1 && vgapos === -1) {
                  vgapos = _3dcontrollerpos;
                }
                if (currentController.vendor || currentController.model || currentController.bus || currentController.vram !== null || currentController.vramDynamic) {
                  controllers.push(currentController);
                  currentController = {
                    vendor: "",
                    model: "",
                    bus: "",
                    busAddress: "",
                    vram: null,
                    vramDynamic: false
                  };
                }
                const pciIDCandidate = line.split(" ")[0];
                if (/[\da-fA-F]{2}:[\da-fA-F]{2}\.[\da-fA-F]/.test(pciIDCandidate)) {
                  currentController.busAddress = pciIDCandidate;
                }
                isGraphicsController = true;
                let endpos = line.search(/\[[0-9a-f]{4}:[0-9a-f]{4}]|$/);
                let parts2 = line.substr(vgapos, endpos - vgapos).split(":");
                currentController.busAddress = line.substr(0, vgapos).trim();
                if (parts2.length > 1) {
                  parts2[1] = parts2[1].trim();
                  if (parts2[1].toLowerCase().indexOf("corporation") >= 0) {
                    currentController.vendor = parts2[1].substr(0, parts2[1].toLowerCase().indexOf("corporation") + 11).trim();
                    currentController.model = parts2[1].substr(parts2[1].toLowerCase().indexOf("corporation") + 11, 200).split("(")[0].trim();
                    currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                    currentController.vram = null;
                    currentController.vramDynamic = false;
                  } else if (parts2[1].toLowerCase().indexOf(" inc.") >= 0) {
                    if ((parts2[1].match(/]/g) || []).length > 1) {
                      currentController.vendor = parts2[1].substr(0, parts2[1].toLowerCase().indexOf("]") + 1).trim();
                      currentController.model = parts2[1].substr(parts2[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                    } else {
                      currentController.vendor = parts2[1].substr(0, parts2[1].toLowerCase().indexOf(" inc.") + 5).trim();
                      currentController.model = parts2[1].substr(parts2[1].toLowerCase().indexOf(" inc.") + 5, 200).trim().split("(")[0].trim();
                    }
                    currentController.bus = pciIDs.length > 0 && isExternal ? "PCIe" : "Onboard";
                    currentController.vram = null;
                    currentController.vramDynamic = false;
                  } else if (parts2[1].toLowerCase().indexOf(" ltd.") >= 0) {
                    if ((parts2[1].match(/]/g) || []).length > 1) {
                      currentController.vendor = parts2[1].substr(0, parts2[1].toLowerCase().indexOf("]") + 1).trim();
                      currentController.model = parts2[1].substr(parts2[1].toLowerCase().indexOf("]") + 1, 200).trim().split("(")[0].trim();
                    } else {
                      currentController.vendor = parts2[1].substr(0, parts2[1].toLowerCase().indexOf(" ltd.") + 5).trim();
                      currentController.model = parts2[1].substr(parts2[1].toLowerCase().indexOf(" ltd.") + 5, 200).trim().split("(")[0].trim();
                    }
                  }
                  if (currentController.model && subsystem.indexOf(currentController.model) !== -1) {
                    const subVendor = subsystem.split(currentController.model)[0].trim();
                    if (subVendor) {
                      currentController.subVendor = subVendor;
                    }
                  }
                }
              } else {
                isGraphicsController = false;
              }
            }
            if (isGraphicsController) {
              let parts2 = line.split(":");
              if (parts2.length > 1 && parts2[0].replace(/ +/g, "").toLowerCase().indexOf("devicename") !== -1 && parts2[1].toLowerCase().indexOf("onboard") !== -1) {
                currentController.bus = "Onboard";
              }
              if (parts2.length > 1 && parts2[0].replace(/ +/g, "").toLowerCase().indexOf("region") !== -1 && parts2[1].toLowerCase().indexOf("memory") !== -1) {
                let memparts = parts2[1].split("=");
                if (memparts.length > 1) {
                  currentController.vram = parseInt(memparts[1]);
                }
              }
            }
          }
          i++;
        });
        if (currentController.vendor || currentController.model || currentController.bus || currentController.busAddress || currentController.vram !== null || currentController.vramDynamic) {
          controllers.push(currentController);
        }
        return controllers;
      }
      __name(parseLinesLinuxControllers, "parseLinesLinuxControllers");
      function parseLinesLinuxClinfo(controllers, lines) {
        const fieldPattern = /\[([^\]]+)\]\s+(\w+)\s+(.*)/;
        const devices = lines.reduce((devices2, line) => {
          const field = fieldPattern.exec(line.trim());
          if (field) {
            if (!devices2[field[1]]) {
              devices2[field[1]] = {};
            }
            devices2[field[1]][field[2]] = field[3];
          }
          return devices2;
        }, {});
        for (let deviceId in devices) {
          const device = devices[deviceId];
          if (device["CL_DEVICE_TYPE"] === "CL_DEVICE_TYPE_GPU") {
            let busAddress;
            if (device["CL_DEVICE_TOPOLOGY_AMD"]) {
              const bdf = device["CL_DEVICE_TOPOLOGY_AMD"].match(/[a-zA-Z0-9]+:\d+\.\d+/);
              if (bdf) {
                busAddress = bdf[0];
              }
            } else if (device["CL_DEVICE_PCI_BUS_ID_NV"] && device["CL_DEVICE_PCI_SLOT_ID_NV"]) {
              const bus = parseInt(device["CL_DEVICE_PCI_BUS_ID_NV"]);
              const slot = parseInt(device["CL_DEVICE_PCI_SLOT_ID_NV"]);
              if (!isNaN(bus) && !isNaN(slot)) {
                const b = bus & 255;
                const d = slot >> 3 & 255;
                const f = slot & 7;
                busAddress = `${b.toString().padStart(2, "0")}:${d.toString().padStart(2, "0")}.${f}`;
              }
            }
            if (busAddress) {
              let controller = controllers.find((controller2) => controller2.busAddress === busAddress);
              if (!controller) {
                controller = {
                  vendor: "",
                  model: "",
                  bus: "",
                  busAddress,
                  vram: null,
                  vramDynamic: false
                };
                controllers.push(controller);
              }
              controller.vendor = device["CL_DEVICE_VENDOR"];
              if (device["CL_DEVICE_BOARD_NAME_AMD"]) {
                controller.model = device["CL_DEVICE_BOARD_NAME_AMD"];
              } else {
                controller.model = device["CL_DEVICE_NAME"];
              }
              const memory = parseInt(device["CL_DEVICE_GLOBAL_MEM_SIZE"]);
              if (!isNaN(memory)) {
                controller.vram = Math.round(memory / 1024 / 1024);
              }
            }
          }
        }
        return controllers;
      }
      __name(parseLinesLinuxClinfo, "parseLinesLinuxClinfo");
      function getNvidiaSmi() {
        if (_nvidiaSmiPath) {
          return _nvidiaSmiPath;
        }
        if (_windows) {
          try {
            const basePath = util2.WINDIR + "\\System32\\DriverStore\\FileRepository";
            const candidateDirs = fs.readdirSync(basePath).filter((dir) => {
              return fs.readdirSync([
                basePath,
                dir
              ].join("/")).includes("nvidia-smi.exe");
            });
            const targetDir = candidateDirs.reduce((prevDir, currentDir) => {
              const previousNvidiaSmi = fs.statSync([
                basePath,
                prevDir,
                "nvidia-smi.exe"
              ].join("/"));
              const currentNvidiaSmi = fs.statSync([
                basePath,
                currentDir,
                "nvidia-smi.exe"
              ].join("/"));
              return previousNvidiaSmi.ctimeMs > currentNvidiaSmi.ctimeMs ? prevDir : currentDir;
            });
            if (targetDir) {
              _nvidiaSmiPath = [
                basePath,
                targetDir,
                "nvidia-smi.exe"
              ].join("/");
            }
          } catch (e) {
            util2.noop();
          }
        } else if (_linux) {
          _nvidiaSmiPath = "nvidia-smi";
        }
        return _nvidiaSmiPath;
      }
      __name(getNvidiaSmi, "getNvidiaSmi");
      function nvidiaSmi(options) {
        const nvidiaSmiExe = getNvidiaSmi();
        options = options || util2.execOptsWin;
        if (nvidiaSmiExe) {
          const nvidiaSmiOpts = "--query-gpu=driver_version,pci.sub_device_id,name,pci.bus_id,fan.speed,memory.total,memory.used,memory.free,utilization.gpu,utilization.memory,temperature.gpu,temperature.memory,power.draw,power.limit,clocks.gr,clocks.mem --format=csv,noheader,nounits";
          const cmd = nvidiaSmiExe + " " + nvidiaSmiOpts + (_linux ? "  2>/dev/null" : "");
          if (_linux) {
            options.stdio = [
              "pipe",
              "pipe",
              "ignore"
            ];
          }
          try {
            const res = execSync(cmd, options).toString();
            return res;
          } catch (e) {
            util2.noop();
          }
        }
        return "";
      }
      __name(nvidiaSmi, "nvidiaSmi");
      function nvidiaDevices() {
        function safeParseNumber(value2) {
          if ([
            null,
            void 0
          ].includes(value2)) {
            return value2;
          }
          return parseFloat(value2);
        }
        __name(safeParseNumber, "safeParseNumber");
        const stdout = nvidiaSmi();
        if (!stdout) {
          return [];
        }
        const gpus = stdout.split("\n").filter(Boolean);
        let results = gpus.map((gpu) => {
          const splittedData = gpu.split(", ").map((value2) => value2.includes("N/A") ? void 0 : value2);
          if (splittedData.length === 16) {
            return {
              driverVersion: splittedData[0],
              subDeviceId: splittedData[1],
              name: splittedData[2],
              pciBus: splittedData[3],
              fanSpeed: safeParseNumber(splittedData[4]),
              memoryTotal: safeParseNumber(splittedData[5]),
              memoryUsed: safeParseNumber(splittedData[6]),
              memoryFree: safeParseNumber(splittedData[7]),
              utilizationGpu: safeParseNumber(splittedData[8]),
              utilizationMemory: safeParseNumber(splittedData[9]),
              temperatureGpu: safeParseNumber(splittedData[10]),
              temperatureMemory: safeParseNumber(splittedData[11]),
              powerDraw: safeParseNumber(splittedData[12]),
              powerLimit: safeParseNumber(splittedData[13]),
              clockCore: safeParseNumber(splittedData[14]),
              clockMemory: safeParseNumber(splittedData[15])
            };
          } else {
            return {};
          }
        });
        results = results.filter((item) => {
          return "pciBus" in item;
        });
        return results;
      }
      __name(nvidiaDevices, "nvidiaDevices");
      function mergeControllerNvidia(controller, nvidia) {
        if (nvidia.driverVersion) {
          controller.driverVersion = nvidia.driverVersion;
        }
        if (nvidia.subDeviceId) {
          controller.subDeviceId = nvidia.subDeviceId;
        }
        if (nvidia.name) {
          controller.name = nvidia.name;
        }
        if (nvidia.pciBus) {
          controller.pciBus = nvidia.pciBus;
        }
        if (nvidia.fanSpeed) {
          controller.fanSpeed = nvidia.fanSpeed;
        }
        if (nvidia.memoryTotal) {
          controller.memoryTotal = nvidia.memoryTotal;
          controller.vram = nvidia.memoryTotal;
          controller.vramDynamic = false;
        }
        if (nvidia.memoryUsed) {
          controller.memoryUsed = nvidia.memoryUsed;
        }
        if (nvidia.memoryFree) {
          controller.memoryFree = nvidia.memoryFree;
        }
        if (nvidia.utilizationGpu) {
          controller.utilizationGpu = nvidia.utilizationGpu;
        }
        if (nvidia.utilizationMemory) {
          controller.utilizationMemory = nvidia.utilizationMemory;
        }
        if (nvidia.temperatureGpu) {
          controller.temperatureGpu = nvidia.temperatureGpu;
        }
        if (nvidia.temperatureMemory) {
          controller.temperatureMemory = nvidia.temperatureMemory;
        }
        if (nvidia.powerDraw) {
          controller.powerDraw = nvidia.powerDraw;
        }
        if (nvidia.powerLimit) {
          controller.powerLimit = nvidia.powerLimit;
        }
        if (nvidia.clockCore) {
          controller.clockCore = nvidia.clockCore;
        }
        if (nvidia.clockMemory) {
          controller.clockMemory = nvidia.clockMemory;
        }
        return controller;
      }
      __name(mergeControllerNvidia, "mergeControllerNvidia");
      function parseLinesLinuxEdid(edid) {
        let result2 = {
          vendor: "",
          model: "",
          deviceName: "",
          main: false,
          builtin: false,
          connection: "",
          sizeX: null,
          sizeY: null,
          pixelDepth: null,
          resolutionX: null,
          resolutionY: null,
          currentResX: null,
          currentResY: null,
          positionX: 0,
          positionY: 0,
          currentRefreshRate: null
        };
        let start = 108;
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        if (edid.substr(start, 6) === "000000") {
          start += 36;
        }
        result2.resolutionX = parseInt("0x0" + edid.substr(start + 8, 1) + edid.substr(start + 4, 2));
        result2.resolutionY = parseInt("0x0" + edid.substr(start + 14, 1) + edid.substr(start + 10, 2));
        result2.sizeX = parseInt("0x0" + edid.substr(start + 28, 1) + edid.substr(start + 24, 2));
        result2.sizeY = parseInt("0x0" + edid.substr(start + 29, 1) + edid.substr(start + 26, 2));
        start = edid.indexOf("000000fc00");
        if (start >= 0) {
          let model_raw = edid.substr(start + 10, 26);
          if (model_raw.indexOf("0a") !== -1) {
            model_raw = model_raw.substr(0, model_raw.indexOf("0a"));
          }
          try {
            if (model_raw.length > 2) {
              result2.model = model_raw.match(/.{1,2}/g).map(function(v) {
                return String.fromCharCode(parseInt(v, 16));
              }).join("");
            }
          } catch (e) {
            util2.noop();
          }
        } else {
          result2.model = "";
        }
        return result2;
      }
      __name(parseLinesLinuxEdid, "parseLinesLinuxEdid");
      function parseLinesLinuxDisplays(lines, depth) {
        let displays = [];
        let currentDisplay = {
          vendor: "",
          model: "",
          deviceName: "",
          main: false,
          builtin: false,
          connection: "",
          sizeX: null,
          sizeY: null,
          pixelDepth: null,
          resolutionX: null,
          resolutionY: null,
          currentResX: null,
          currentResY: null,
          positionX: 0,
          positionY: 0,
          currentRefreshRate: null
        };
        let is_edid = false;
        let is_current = false;
        let edid_raw = "";
        let start = 0;
        for (let i = 1; i < lines.length; i++) {
          if ("" !== lines[i].trim()) {
            if (" " !== lines[i][0] && "	" !== lines[i][0] && lines[i].toLowerCase().indexOf(" connected ") !== -1) {
              if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
                displays.push(currentDisplay);
                currentDisplay = {
                  vendor: "",
                  model: "",
                  main: false,
                  builtin: false,
                  connection: "",
                  sizeX: null,
                  sizeY: null,
                  pixelDepth: null,
                  resolutionX: null,
                  resolutionY: null,
                  currentResX: null,
                  currentResY: null,
                  positionX: 0,
                  positionY: 0,
                  currentRefreshRate: null
                };
              }
              let parts2 = lines[i].split(" ");
              currentDisplay.connection = parts2[0];
              currentDisplay.main = lines[i].toLowerCase().indexOf(" primary ") >= 0;
              currentDisplay.builtin = parts2[0].toLowerCase().indexOf("edp") >= 0;
            }
            if (is_edid) {
              if (lines[i].search(/\S|$/) > start) {
                edid_raw += lines[i].toLowerCase().trim();
              } else {
                let edid_decoded = parseLinesLinuxEdid(edid_raw);
                currentDisplay.vendor = edid_decoded.vendor;
                currentDisplay.model = edid_decoded.model;
                currentDisplay.resolutionX = edid_decoded.resolutionX;
                currentDisplay.resolutionY = edid_decoded.resolutionY;
                currentDisplay.sizeX = edid_decoded.sizeX;
                currentDisplay.sizeY = edid_decoded.sizeY;
                currentDisplay.pixelDepth = depth;
                is_edid = false;
              }
            }
            if (lines[i].toLowerCase().indexOf("edid:") >= 0) {
              is_edid = true;
              start = lines[i].search(/\S|$/);
            }
            if (lines[i].toLowerCase().indexOf("*current") >= 0) {
              const parts1 = lines[i].split("(");
              if (parts1 && parts1.length > 1 && parts1[0].indexOf("x") >= 0) {
                const resParts = parts1[0].trim().split("x");
                currentDisplay.currentResX = util2.toInt(resParts[0]);
                currentDisplay.currentResY = util2.toInt(resParts[1]);
              }
              is_current = true;
            }
            if (is_current && lines[i].toLowerCase().indexOf("clock") >= 0 && lines[i].toLowerCase().indexOf("hz") >= 0 && lines[i].toLowerCase().indexOf("v: height") >= 0) {
              const parts1 = lines[i].split("clock");
              if (parts1 && parts1.length > 1 && parts1[1].toLowerCase().indexOf("hz") >= 0) {
                currentDisplay.currentRefreshRate = util2.toInt(parts1[1]);
              }
              is_current = false;
            }
          }
        }
        if (currentDisplay.model || currentDisplay.main || currentDisplay.builtin || currentDisplay.connection || currentDisplay.sizeX !== null || currentDisplay.pixelDepth !== null || currentDisplay.resolutionX !== null) {
          displays.push(currentDisplay);
        }
        return displays;
      }
      __name(parseLinesLinuxDisplays, "parseLinesLinuxDisplays");
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            controllers: [],
            displays: []
          };
          if (_darwin) {
            let cmd = "system_profiler -xml -detailLevel full SPDisplaysDataType";
            exec(cmd, function(error, stdout) {
              if (!error) {
                try {
                  const output = stdout.toString();
                  result2 = parseLinesDarwin(util2.plistParser(output)[0]._items);
                } catch (e) {
                  util2.noop();
                }
                try {
                  stdout = execSync('defaults read /Library/Preferences/com.apple.windowserver.plist 2>/dev/null;defaults read /Library/Preferences/com.apple.windowserver.displays.plist 2>/dev/null; echo ""', {
                    maxBuffer: 1024 * 2e4
                  });
                  const output = (stdout || "").toString();
                  const obj = util2.plistReader(output);
                  if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"]["Configs"] && obj["DisplayAnyUserSets"]["Configs"][0] && obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"]) {
                    const current = obj["DisplayAnyUserSets"]["Configs"][0]["DisplayConfig"];
                    let i = 0;
                    current.forEach((o) => {
                      if (o["CurrentInfo"] && o["CurrentInfo"]["OriginX"] !== void 0 && result2.displays && result2.displays[i]) {
                        result2.displays[i].positionX = o["CurrentInfo"]["OriginX"];
                      }
                      if (o["CurrentInfo"] && o["CurrentInfo"]["OriginY"] !== void 0 && result2.displays && result2.displays[i]) {
                        result2.displays[i].positionY = o["CurrentInfo"]["OriginY"];
                      }
                      i++;
                    });
                  }
                  if (obj["DisplayAnyUserSets"] && obj["DisplayAnyUserSets"].length > 0 && obj["DisplayAnyUserSets"][0].length > 0 && obj["DisplayAnyUserSets"][0][0]["DisplayID"]) {
                    const current = obj["DisplayAnyUserSets"][0];
                    let i = 0;
                    current.forEach((o) => {
                      if ("OriginX" in o && result2.displays && result2.displays[i]) {
                        result2.displays[i].positionX = o["OriginX"];
                      }
                      if ("OriginY" in o && result2.displays && result2.displays[i]) {
                        result2.displays[i].positionY = o["OriginY"];
                      }
                      if (o["Mode"] && o["Mode"]["BitsPerPixel"] !== void 0 && result2.displays && result2.displays[i]) {
                        result2.displays[i].pixelDepth = o["Mode"]["BitsPerPixel"];
                      }
                      i++;
                    });
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_linux) {
            if (util2.isRaspberry()) {
              let cmd2 = `fbset -s 2> /dev/null | grep 'mode "' ; vcgencmd get_mem gpu 2> /dev/null; tvservice -s 2> /dev/null; tvservice -n 2> /dev/null;`;
              exec(cmd2, function(error, stdout) {
                let lines = stdout.toString().split("\n");
                if (lines.length > 3 && lines[0].indexOf('mode "') >= -1 && lines[2].indexOf("0x12000a") > -1) {
                  const parts2 = lines[0].replace("mode", "").replace(/"/g, "").trim().split("x");
                  if (parts2.length === 2) {
                    result2.displays.push({
                      vendor: "",
                      model: util2.getValue(lines, "device_name", "="),
                      main: true,
                      builtin: false,
                      connection: "HDMI",
                      sizeX: null,
                      sizeY: null,
                      pixelDepth: null,
                      resolutionX: parseInt(parts2[0], 10),
                      resolutionY: parseInt(parts2[1], 10),
                      currentResX: null,
                      currentResY: null,
                      positionX: 0,
                      positionY: 0,
                      currentRefreshRate: null
                    });
                  }
                }
                if (lines.length >= 1 && stdout.toString().indexOf("gpu=") >= -1) {
                  result2.controllers.push({
                    vendor: "Broadcom",
                    model: util2.getRpiGpu(),
                    bus: "",
                    vram: util2.getValue(lines, "gpu", "=").replace("M", ""),
                    vramDynamic: true
                  });
                }
              });
            }
            let cmd = "lspci -vvv  2>/dev/null";
            exec(cmd, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                if (result2.controllers.length === 0) {
                  result2.controllers = parseLinesLinuxControllers(lines);
                  const nvidiaData = nvidiaDevices();
                  result2.controllers = result2.controllers.map((controller) => {
                    return mergeControllerNvidia(controller, nvidiaData.find((contr) => contr.pciBus.toLowerCase().endsWith(controller.busAddress.toLowerCase())) || {});
                  });
                }
              }
              let cmd2 = "clinfo --raw";
              exec(cmd2, function(error2, stdout2) {
                if (!error2) {
                  let lines = stdout2.toString().split("\n");
                  result2.controllers = parseLinesLinuxClinfo(result2.controllers, lines);
                }
                let cmd3 = "xdpyinfo 2>/dev/null | grep 'depth of root window' | awk '{ print $5 }'";
                exec(cmd3, function(error3, stdout3) {
                  let depth = 0;
                  if (!error3) {
                    let lines = stdout3.toString().split("\n");
                    depth = parseInt(lines[0]) || 0;
                  }
                  let cmd4 = "xrandr --verbose 2>/dev/null";
                  exec(cmd4, function(error4, stdout4) {
                    if (!error4) {
                      let lines = stdout4.toString().split("\n");
                      result2.displays = parseLinesLinuxDisplays(lines, depth);
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  });
                });
              });
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            if (callback) {
              callback(null);
            }
            resolve5(null);
          }
          if (_sunos) {
            if (callback) {
              callback(null);
            }
            resolve5(null);
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util2.powerShell("Get-CimInstance win32_VideoController | fl *"));
              workload.push(util2.powerShell('gp "HKLM:\\SYSTEM\\ControlSet001\\Control\\Class\\{4d36e968-e325-11ce-bfc1-08002be10318}\\*" -ErrorAction SilentlyContinue | where MatchingDeviceId $null -NE | select MatchingDeviceId,HardwareInformation.qwMemorySize | fl'));
              workload.push(util2.powerShell("Get-CimInstance win32_desktopmonitor | fl *"));
              workload.push(util2.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorBasicDisplayParams | fl"));
              workload.push(util2.powerShell("Add-Type -AssemblyName System.Windows.Forms; [System.Windows.Forms.Screen]::AllScreens"));
              workload.push(util2.powerShell("Get-CimInstance -Namespace root\\wmi -ClassName WmiMonitorConnectionParams | fl"));
              workload.push(util2.powerShell('gwmi WmiMonitorID -Namespace root\\wmi | ForEach-Object {(($_.ManufacturerName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.ProductCodeID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.UserFriendlyName -notmatch 0 | foreach {[char]$_}) -join "") + "|" + (($_.SerialNumberID -notmatch 0 | foreach {[char]$_}) -join "") + "|" + $_.InstanceName}'));
              const nvidiaData = nvidiaDevices();
              Promise.all(workload).then((data) => {
                let csections = data[0].replace(/\r/g, "").split(/\n\s*\n/);
                let vsections = data[1].replace(/\r/g, "").split(/\n\s*\n/);
                result2.controllers = parseLinesWindowsControllers(csections, vsections);
                result2.controllers = result2.controllers.map((controller) => {
                  if (controller.vendor.toLowerCase() === "nvidia") {
                    return mergeControllerNvidia(controller, nvidiaData.find((device) => {
                      let windowsSubDeviceId = (controller.subDeviceId || "").toLowerCase();
                      const nvidiaSubDeviceIdParts = device.subDeviceId.split("x");
                      let nvidiaSubDeviceId = nvidiaSubDeviceIdParts.length > 1 ? nvidiaSubDeviceIdParts[1].toLowerCase() : nvidiaSubDeviceIdParts[0].toLowerCase();
                      const lengthDifference = Math.abs(windowsSubDeviceId.length - nvidiaSubDeviceId.length);
                      if (windowsSubDeviceId.length > nvidiaSubDeviceId.length) {
                        for (let i = 0; i < lengthDifference; i++) {
                          nvidiaSubDeviceId = "0" + nvidiaSubDeviceId;
                        }
                      } else if (windowsSubDeviceId.length < nvidiaSubDeviceId.length) {
                        for (let i = 0; i < lengthDifference; i++) {
                          windowsSubDeviceId = "0" + windowsSubDeviceId;
                        }
                      }
                      return windowsSubDeviceId === nvidiaSubDeviceId;
                    }) || {});
                  } else {
                    return controller;
                  }
                });
                let dsections = data[2].replace(/\r/g, "").split(/\n\s*\n/);
                if (dsections[0].trim() === "") {
                  dsections.shift();
                }
                if (dsections.length && dsections[dsections.length - 1].trim() === "") {
                  dsections.pop();
                }
                let msections = data[3].replace(/\r/g, "").split("Active ");
                msections.shift();
                let ssections = data[4].replace(/\r/g, "").split("BitsPerPixel ");
                ssections.shift();
                let tsections = data[5].replace(/\r/g, "").split(/\n\s*\n/);
                tsections.shift();
                const res = data[6].replace(/\r/g, "").split(/\n/);
                let isections = [];
                res.forEach((element) => {
                  const parts2 = element.split("|");
                  if (parts2.length === 5) {
                    isections.push({
                      vendor: parts2[0],
                      code: parts2[1],
                      model: parts2[2],
                      serial: parts2[3],
                      instanceId: parts2[4]
                    });
                  }
                });
                result2.displays = parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections);
                if (result2.displays.length === 1) {
                  if (_resolutionX) {
                    result2.displays[0].resolutionX = _resolutionX;
                    if (!result2.displays[0].currentResX) {
                      result2.displays[0].currentResX = _resolutionX;
                    }
                  }
                  if (_resolutionY) {
                    result2.displays[0].resolutionY = _resolutionY;
                    if (result2.displays[0].currentResY === 0) {
                      result2.displays[0].currentResY = _resolutionY;
                    }
                  }
                  if (_pixelDepth) {
                    result2.displays[0].pixelDepth = _pixelDepth;
                  }
                }
                result2.displays = result2.displays.map((element) => {
                  if (_refreshRate && !element.currentRefreshRate) {
                    element.currentRefreshRate = _refreshRate;
                  }
                  return element;
                });
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }).catch(() => {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
      function parseLinesWindowsControllers(sections, vections) {
        const memorySizes = {};
        for (const i in vections) {
          if ({}.hasOwnProperty.call(vections, i)) {
            if (vections[i].trim() !== "") {
              const lines = vections[i].trim().split("\n");
              const matchingDeviceId = util2.getValue(lines, "MatchingDeviceId").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
              if (matchingDeviceId) {
                const quadWordmemorySize = parseInt(util2.getValue(lines, "HardwareInformation.qwMemorySize"));
                if (!isNaN(quadWordmemorySize)) {
                  let deviceId = matchingDeviceId[1].toUpperCase() + "&" + matchingDeviceId[2].toUpperCase();
                  if (matchingDeviceId[3]) {
                    deviceId += "&" + matchingDeviceId[3].toUpperCase();
                  }
                  if (matchingDeviceId[4]) {
                    deviceId += "&" + matchingDeviceId[4].toUpperCase();
                  }
                  memorySizes[deviceId] = quadWordmemorySize;
                }
              }
            }
          }
        }
        let controllers = [];
        for (let i in sections) {
          if ({}.hasOwnProperty.call(sections, i)) {
            if (sections[i].trim() !== "") {
              let lines = sections[i].trim().split("\n");
              let pnpDeviceId = util2.getValue(lines, "PNPDeviceID", ":").match(/PCI\\(VEN_[0-9A-F]{4})&(DEV_[0-9A-F]{4})(?:&(SUBSYS_[0-9A-F]{8}))?(?:&(REV_[0-9A-F]{2}))?/i);
              let subDeviceId = null;
              let memorySize = null;
              if (pnpDeviceId) {
                subDeviceId = pnpDeviceId[3] || "";
                if (subDeviceId) {
                  subDeviceId = subDeviceId.split("_")[1];
                }
                if (memorySize == null && pnpDeviceId[3] && pnpDeviceId[4]) {
                  const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
                  if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                    memorySize = memorySizes[deviceId];
                  }
                }
                if (memorySize == null && pnpDeviceId[3]) {
                  const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[3].toUpperCase();
                  if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                    memorySize = memorySizes[deviceId];
                  }
                }
                if (memorySize == null && pnpDeviceId[4]) {
                  const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase() + "&" + pnpDeviceId[4].toUpperCase();
                  if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                    memorySize = memorySizes[deviceId];
                  }
                }
                if (memorySize == null) {
                  const deviceId = pnpDeviceId[1].toUpperCase() + "&" + pnpDeviceId[2].toUpperCase();
                  if ({}.hasOwnProperty.call(memorySizes, deviceId)) {
                    memorySize = memorySizes[deviceId];
                  }
                }
              }
              controllers.push({
                vendor: util2.getValue(lines, "AdapterCompatibility", ":"),
                model: util2.getValue(lines, "name", ":"),
                bus: util2.getValue(lines, "PNPDeviceID", ":").startsWith("PCI") ? "PCI" : "",
                vram: (memorySize == null ? util2.toInt(util2.getValue(lines, "AdapterRAM", ":")) : memorySize) / 1024 / 1024,
                vramDynamic: util2.getValue(lines, "VideoMemoryType", ":") === "2",
                subDeviceId
              });
              _resolutionX = util2.toInt(util2.getValue(lines, "CurrentHorizontalResolution", ":")) || _resolutionX;
              _resolutionY = util2.toInt(util2.getValue(lines, "CurrentVerticalResolution", ":")) || _resolutionY;
              _refreshRate = util2.toInt(util2.getValue(lines, "CurrentRefreshRate", ":")) || _refreshRate;
              _pixelDepth = util2.toInt(util2.getValue(lines, "CurrentBitsPerPixel", ":")) || _pixelDepth;
            }
          }
        }
        return controllers;
      }
      __name(parseLinesWindowsControllers, "parseLinesWindowsControllers");
      function parseLinesWindowsDisplaysPowershell(ssections, msections, dsections, tsections, isections) {
        let displays = [];
        let vendor = "";
        let model = "";
        let deviceID = "";
        let resolutionX = 0;
        let resolutionY = 0;
        if (dsections && dsections.length) {
          let linesDisplay = dsections[0].split("\n");
          vendor = util2.getValue(linesDisplay, "MonitorManufacturer", ":");
          model = util2.getValue(linesDisplay, "Name", ":");
          deviceID = util2.getValue(linesDisplay, "PNPDeviceID", ":").replace(/&amp;/g, "&").toLowerCase();
          resolutionX = util2.toInt(util2.getValue(linesDisplay, "ScreenWidth", ":"));
          resolutionY = util2.toInt(util2.getValue(linesDisplay, "ScreenHeight", ":"));
        }
        for (let i = 0; i < ssections.length; i++) {
          if (ssections[i].trim() !== "") {
            ssections[i] = "BitsPerPixel " + ssections[i];
            msections[i] = "Active " + msections[i];
            if (tsections.length === 0 || tsections[i] === void 0) {
              tsections[i] = "Unknown";
            }
            let linesScreen = ssections[i].split("\n");
            let linesMonitor = msections[i].split("\n");
            let linesConnection = tsections[i].split("\n");
            const bitsPerPixel = util2.getValue(linesScreen, "BitsPerPixel");
            const bounds = util2.getValue(linesScreen, "Bounds").replace("{", "").replace("}", "").replace(/=/g, ":").split(",");
            const primary = util2.getValue(linesScreen, "Primary");
            const sizeX = util2.getValue(linesMonitor, "MaxHorizontalImageSize");
            const sizeY = util2.getValue(linesMonitor, "MaxVerticalImageSize");
            const instanceName = util2.getValue(linesMonitor, "InstanceName").toLowerCase();
            const videoOutputTechnology = util2.getValue(linesConnection, "VideoOutputTechnology");
            const deviceName = util2.getValue(linesScreen, "DeviceName");
            let displayVendor = "";
            let displayModel = "";
            isections.forEach((element) => {
              if (element.instanceId.toLowerCase().startsWith(instanceName) && vendor.startsWith("(") && model.startsWith("PnP")) {
                displayVendor = element.vendor;
                displayModel = element.model;
              }
            });
            displays.push({
              vendor: instanceName.startsWith(deviceID) && displayVendor === "" ? vendor : displayVendor,
              model: instanceName.startsWith(deviceID) && displayModel === "" ? model : displayModel,
              deviceName,
              main: primary.toLowerCase() === "true",
              builtin: videoOutputTechnology === "2147483648",
              connection: videoOutputTechnology && videoTypes[videoOutputTechnology] ? videoTypes[videoOutputTechnology] : "",
              resolutionX: util2.toInt(util2.getValue(bounds, "Width", ":")),
              resolutionY: util2.toInt(util2.getValue(bounds, "Height", ":")),
              sizeX: sizeX ? parseInt(sizeX, 10) : null,
              sizeY: sizeY ? parseInt(sizeY, 10) : null,
              pixelDepth: bitsPerPixel,
              currentResX: util2.toInt(util2.getValue(bounds, "Width", ":")),
              currentResY: util2.toInt(util2.getValue(bounds, "Height", ":")),
              positionX: util2.toInt(util2.getValue(bounds, "X", ":")),
              positionY: util2.toInt(util2.getValue(bounds, "Y", ":"))
            });
          }
        }
        if (ssections.length === 0) {
          displays.push({
            vendor,
            model,
            main: true,
            sizeX: null,
            sizeY: null,
            resolutionX,
            resolutionY,
            pixelDepth: null,
            currentResX: resolutionX,
            currentResY: resolutionY,
            positionX: 0,
            positionY: 0
          });
        }
        return displays;
      }
      __name(parseLinesWindowsDisplaysPowershell, "parseLinesWindowsDisplaysPowershell");
    }
    __name(graphics, "graphics");
    exports2.graphics = graphics;
  }
});

// node_modules/systeminformation/lib/filesystem.js
var require_filesystem = __commonJS({
  "node_modules/systeminformation/lib/filesystem.js"(exports2) {
    "use strict";
    var util2 = require_util();
    var fs = require("fs");
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var execPromiseSave = util2.promisifySave(require("child_process").exec);
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _fs_speed = {};
    var _disk_io = {};
    function fsSize(drive, callback) {
      if (util2.isFunction(drive)) {
        callback = drive;
        drive = "";
      }
      let macOsDisks = [];
      let osMounts = [];
      function getmacOsFsType(fs2) {
        if (!fs2.startsWith("/")) {
          return "NFS";
        }
        const parts2 = fs2.split("/");
        const fsShort = parts2[parts2.length - 1];
        const macOsDisksSingle = macOsDisks.filter((item) => item.indexOf(fsShort) >= 0);
        if (macOsDisksSingle.length === 1 && macOsDisksSingle[0].indexOf("APFS") >= 0) {
          return "APFS";
        }
        return "HFS";
      }
      __name(getmacOsFsType, "getmacOsFsType");
      function isLinuxTmpFs(fs2) {
        const linuxTmpFileSystems = [
          "rootfs",
          "unionfs",
          "squashfs",
          "cramfs",
          "initrd",
          "initramfs",
          "devtmpfs",
          "tmpfs",
          "udev",
          "devfs",
          "specfs",
          "type",
          "appimaged"
        ];
        let result2 = false;
        linuxTmpFileSystems.forEach((linuxFs) => {
          if (fs2.toLowerCase().indexOf(linuxFs) >= 0) {
            result2 = true;
          }
        });
        return result2;
      }
      __name(isLinuxTmpFs, "isLinuxTmpFs");
      function filterLines(stdout) {
        let lines = stdout.toString().split("\n");
        lines.shift();
        if (stdout.toString().toLowerCase().indexOf("filesystem")) {
          let removeLines = 0;
          for (let i = 0; i < lines.length; i++) {
            if (lines[i] && lines[i].toLowerCase().startsWith("filesystem")) {
              removeLines = i;
            }
          }
          for (let i = 0; i < removeLines; i++) {
            lines.shift();
          }
        }
        return lines;
      }
      __name(filterLines, "filterLines");
      function parseDf(lines) {
        let data = [];
        lines.forEach(function(line) {
          if (line !== "") {
            line = line.replace(/ +/g, " ").split(" ");
            if (line && (line[0].startsWith("/") || line[6] && line[6] === "/" || line[0].indexOf("/") > 0 || line[0].indexOf(":") === 1 || !_darwin && !isLinuxTmpFs(line[1]))) {
              const fs2 = line[0];
              const fsType = _linux || _freebsd || _openbsd || _netbsd ? line[1] : getmacOsFsType(line[0]);
              const size = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[2] : line[1]) * 1024;
              const used = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[3] : line[2]) * 1024;
              const available = parseInt(_linux || _freebsd || _openbsd || _netbsd ? line[4] : line[3]) * 1024;
              const use = parseFloat((100 * (used / (used + available))).toFixed(2));
              let rw = osMounts && Object.keys(osMounts).length > 0 ? osMounts[fs2] || false : null;
              line.splice(0, _linux || _freebsd || _openbsd || _netbsd ? 6 : 5);
              const mount = line.join(" ");
              if (!data.find((el) => el.fs === fs2 && el.type === fsType)) {
                data.push({
                  fs: fs2,
                  type: fsType,
                  size,
                  used,
                  available,
                  use,
                  mount,
                  rw
                });
              }
            }
          }
        });
        return data;
      }
      __name(parseDf, "parseDf");
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let data = [];
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
            let cmd = "";
            macOsDisks = [];
            osMounts = {};
            if (_darwin) {
              cmd = "df -kP";
              try {
                macOsDisks = execSync("diskutil list").toString().split("\n").filter((line) => {
                  return !line.startsWith("/") && line.indexOf(":") > 0;
                });
                execSync("mount").toString().split("\n").filter((line) => {
                  return line.startsWith("/");
                }).forEach((line) => {
                  osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
                });
              } catch (e) {
                util2.noop();
              }
            }
            if (_linux) {
              try {
                cmd = "export LC_ALL=C; df -lkPTx squashfs; unset LC_ALL";
                execSync("cat /proc/mounts 2>/dev/null", util2.execOptsLinux).toString().split("\n").filter((line) => {
                  return line.startsWith("/");
                }).forEach((line) => {
                  osMounts[line.split(" ")[0]] = osMounts[line.split(" ")[0]] || false;
                  if (line.toLowerCase().indexOf("/snap/") === -1) {
                    osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("rw,") >= 0 || line.toLowerCase().indexOf(" rw ") >= 0;
                  }
                });
              } catch (e) {
                util2.noop();
              }
            }
            if (_freebsd || _openbsd || _netbsd) {
              try {
                cmd = "df -lkPT";
                execSync("mount").toString().split("\n").forEach((line) => {
                  osMounts[line.split(" ")[0]] = line.toLowerCase().indexOf("read-only") === -1;
                });
              } catch (e) {
                util2.noop();
              }
            }
            exec(cmd, {
              maxBuffer: 1024 * 1024
            }, function(error, stdout) {
              let lines = filterLines(stdout);
              data = parseDf(lines);
              if (drive) {
                data = data.filter((item) => {
                  return item.fs.toLowerCase().indexOf(drive.toLowerCase()) >= 0 || item.mount.toLowerCase().indexOf(drive.toLowerCase()) >= 0;
                });
              }
              if ((!error || data.length) && stdout.toString().trim() !== "") {
                if (callback) {
                  callback(data);
                }
                resolve5(data);
              } else {
                exec("df -kPT", {
                  maxBuffer: 1024 * 1024
                }, function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = filterLines(stdout2);
                    data = parseDf(lines2);
                  }
                  if (callback) {
                    callback(data);
                  }
                  resolve5(data);
                });
              }
            });
          }
          if (_sunos) {
            if (callback) {
              callback(data);
            }
            resolve5(data);
          }
          if (_windows) {
            try {
              const cmd = `Get-WmiObject Win32_logicaldisk | select Access,Caption,FileSystem,FreeSpace,Size ${drive ? "| where -property Caption -eq " + drive : ""} | fl`;
              util2.powerShell(cmd).then((stdout, error) => {
                if (!error) {
                  let devices = stdout.toString().split(/\n\s*\n/);
                  devices.forEach(function(device) {
                    let lines = device.split("\r\n");
                    const size = util2.toInt(util2.getValue(lines, "size", ":"));
                    const free = util2.toInt(util2.getValue(lines, "freespace", ":"));
                    const caption = util2.getValue(lines, "caption", ":");
                    const rwValue = util2.getValue(lines, "access", ":");
                    const rw = rwValue ? util2.toInt(rwValue) !== 1 : null;
                    if (size) {
                      data.push({
                        fs: caption,
                        type: util2.getValue(lines, "filesystem", ":"),
                        size,
                        used: size - free,
                        available: free,
                        use: parseFloat((100 * (size - free) / size).toFixed(2)),
                        mount: caption,
                        rw
                      });
                    }
                  });
                }
                if (callback) {
                  callback(data);
                }
                resolve5(data);
              });
            } catch (e) {
              if (callback) {
                callback(data);
              }
              resolve5(data);
            }
          }
        });
      });
    }
    __name(fsSize, "fsSize");
    exports2.fsSize = fsSize;
    function fsOpenFiles(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          const result2 = {
            max: null,
            allocated: null,
            available: null
          };
          if (_freebsd || _openbsd || _netbsd || _darwin) {
            let cmd = "sysctl -i kern.maxfiles kern.num_files kern.open_files";
            exec(cmd, {
              maxBuffer: 1024 * 1024
            }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result2.max = parseInt(util2.getValue(lines, "kern.maxfiles", ":"), 10);
                result2.allocated = parseInt(util2.getValue(lines, "kern.num_files", ":"), 10) || parseInt(util2.getValue(lines, "kern.open_files", ":"), 10);
                result2.available = result2.max - result2.allocated;
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_linux) {
            fs.readFile("/proc/sys/fs/file-nr", function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                if (lines[0]) {
                  const parts2 = lines[0].replace(/\s+/g, " ").split(" ");
                  if (parts2.length === 3) {
                    result2.allocated = parseInt(parts2[0], 10);
                    result2.available = parseInt(parts2[1], 10);
                    result2.max = parseInt(parts2[2], 10);
                    if (!result2.available) {
                      result2.available = result2.max - result2.allocated;
                    }
                  }
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              } else {
                fs.readFile("/proc/sys/fs/file-max", function(error2, stdout2) {
                  if (!error2) {
                    let lines = stdout2.toString().split("\n");
                    if (lines[0]) {
                      result2.max = parseInt(lines[0], 10);
                    }
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                });
              }
            });
          }
          if (_sunos) {
            if (callback) {
              callback(null);
            }
            resolve5(null);
          }
          if (_windows) {
            if (callback) {
              callback(null);
            }
            resolve5(null);
          }
        });
      });
    }
    __name(fsOpenFiles, "fsOpenFiles");
    exports2.fsOpenFiles = fsOpenFiles;
    function parseBytes(s) {
      return parseInt(s.substr(s.indexOf(" (") + 2, s.indexOf(" Bytes)") - 10));
    }
    __name(parseBytes, "parseBytes");
    function parseDevices(lines) {
      let devices = [];
      let i = 0;
      lines.forEach((line) => {
        if (line.length > 0) {
          if (line[0] === "*") {
            i++;
          } else {
            let parts2 = line.split(":");
            if (parts2.length > 1) {
              if (!devices[i]) {
                devices[i] = {
                  name: "",
                  identifier: "",
                  type: "disk",
                  fsType: "",
                  mount: "",
                  size: 0,
                  physical: "HDD",
                  uuid: "",
                  label: "",
                  model: "",
                  serial: "",
                  removable: false,
                  protocol: "",
                  group: "",
                  device: ""
                };
              }
              parts2[0] = parts2[0].trim().toUpperCase().replace(/ +/g, "");
              parts2[1] = parts2[1].trim();
              if ("DEVICEIDENTIFIER" === parts2[0]) {
                devices[i].identifier = parts2[1];
              }
              if ("DEVICENODE" === parts2[0]) {
                devices[i].name = parts2[1];
              }
              if ("VOLUMENAME" === parts2[0]) {
                if (parts2[1].indexOf("Not applicable") === -1) {
                  devices[i].label = parts2[1];
                }
              }
              if ("PROTOCOL" === parts2[0]) {
                devices[i].protocol = parts2[1];
              }
              if ("DISKSIZE" === parts2[0]) {
                devices[i].size = parseBytes(parts2[1]);
              }
              if ("FILESYSTEMPERSONALITY" === parts2[0]) {
                devices[i].fsType = parts2[1];
              }
              if ("MOUNTPOINT" === parts2[0]) {
                devices[i].mount = parts2[1];
              }
              if ("VOLUMEUUID" === parts2[0]) {
                devices[i].uuid = parts2[1];
              }
              if ("READ-ONLYMEDIA" === parts2[0] && parts2[1] === "Yes") {
                devices[i].physical = "CD/DVD";
              }
              if ("SOLIDSTATE" === parts2[0] && parts2[1] === "Yes") {
                devices[i].physical = "SSD";
              }
              if ("VIRTUAL" === parts2[0]) {
                devices[i].type = "virtual";
              }
              if ("REMOVABLEMEDIA" === parts2[0]) {
                devices[i].removable = parts2[1] === "Removable";
              }
              if ("PARTITIONTYPE" === parts2[0]) {
                devices[i].type = "part";
              }
              if ("DEVICE/MEDIANAME" === parts2[0]) {
                devices[i].model = parts2[1];
              }
            }
          }
        }
      });
      return devices;
    }
    __name(parseDevices, "parseDevices");
    function parseBlk(lines) {
      let data = [];
      lines.filter((line) => line !== "").forEach((line) => {
        try {
          line = decodeURIComponent(line.replace(/\\x/g, "%"));
          line = line.replace(/\\/g, "\\\\");
          let disk = JSON.parse(line);
          data.push({
            "name": disk.name,
            "type": disk.type,
            "fsType": disk.fsType,
            "mount": disk.mountpoint,
            "size": parseInt(disk.size),
            "physical": disk.type === "disk" ? disk.rota === "0" ? "SSD" : "HDD" : disk.type === "rom" ? "CD/DVD" : "",
            "uuid": disk.uuid,
            "label": disk.label,
            "model": (disk.model || "").trim(),
            "serial": disk.serial,
            "removable": disk.rm === "1",
            "protocol": disk.tran,
            "group": disk.group || ""
          });
        } catch (e) {
          util2.noop();
        }
      });
      data = util2.unique(data);
      data = util2.sortByKey(data, [
        "type",
        "name"
      ]);
      return data;
    }
    __name(parseBlk, "parseBlk");
    function decodeMdabmData(lines) {
      const raid = util2.getValue(lines, "md_level", "=");
      const label = util2.getValue(lines, "md_name", "=");
      const uuid = util2.getValue(lines, "md_uuid", "=");
      const members = [];
      lines.forEach((line) => {
        if (line.toLowerCase().startsWith("md_device_dev") && line.toLowerCase().indexOf("/dev/") > 0) {
          members.push(line.split("/dev/")[1]);
        }
      });
      return {
        raid,
        label,
        uuid,
        members
      };
    }
    __name(decodeMdabmData, "decodeMdabmData");
    function raidMatchLinux(data) {
      let result2 = data;
      try {
        data.forEach((element) => {
          if (element.type.startsWith("raid")) {
            const lines = execSync(`mdadm --export --detail /dev/${element.name}`, util2.execOptsLinux).toString().split("\n");
            const mdData = decodeMdabmData(lines);
            element.label = mdData.label;
            element.uuid = mdData.uuid;
            if (mdData.members && mdData.members.length && mdData.raid === element.type) {
              result2 = result2.map((blockdevice) => {
                if (blockdevice.fsType === "linux_raid_member" && mdData.members.indexOf(blockdevice.name) >= 0) {
                  blockdevice.group = element.name;
                }
                return blockdevice;
              });
            }
          }
        });
      } catch (e) {
        util2.noop();
      }
      return result2;
    }
    __name(raidMatchLinux, "raidMatchLinux");
    function getDevicesLinux(data) {
      const result2 = [];
      data.forEach((element) => {
        if (element.type.startsWith("disk")) {
          result2.push(element.name);
        }
      });
      return result2;
    }
    __name(getDevicesLinux, "getDevicesLinux");
    function matchDevicesLinux(data) {
      let result2 = data;
      try {
        const devices = getDevicesLinux(data);
        result2 = result2.map((blockdevice) => {
          if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk")) {
            devices.forEach((element) => {
              if (blockdevice.name.startsWith(element)) {
                blockdevice.device = "/dev/" + element;
              }
            });
          }
          return blockdevice;
        });
      } catch (e) {
        util2.noop();
      }
      return result2;
    }
    __name(matchDevicesLinux, "matchDevicesLinux");
    function getDevicesMac(data) {
      const result2 = [];
      data.forEach((element) => {
        if (element.type.startsWith("disk")) {
          result2.push({
            name: element.name,
            model: element.model,
            device: element.name
          });
        }
        if (element.type.startsWith("virtual")) {
          let device = "";
          result2.forEach((e) => {
            if (e.model === element.model) {
              device = e.device;
            }
          });
          if (device) {
            result2.push({
              name: element.name,
              model: element.model,
              device
            });
          }
        }
      });
      return result2;
    }
    __name(getDevicesMac, "getDevicesMac");
    function matchDevicesMac(data) {
      let result2 = data;
      try {
        const devices = getDevicesMac(data);
        result2 = result2.map((blockdevice) => {
          if (blockdevice.type.startsWith("part") || blockdevice.type.startsWith("disk") || blockdevice.type.startsWith("virtual")) {
            devices.forEach((element) => {
              if (blockdevice.name.startsWith(element.name)) {
                blockdevice.device = element.device;
              }
            });
          }
          return blockdevice;
        });
      } catch (e) {
        util2.noop();
      }
      return result2;
    }
    __name(matchDevicesMac, "matchDevicesMac");
    function getDevicesWin(diskDrives) {
      const result2 = [];
      diskDrives.forEach((element) => {
        const lines = element.split("\r\n");
        const device = util2.getValue(lines, "DeviceID", ":");
        let partitions = element.split("@{DeviceID=");
        if (partitions.length > 1) {
          partitions = partitions.slice(1);
          partitions.forEach((partition) => {
            result2.push({
              name: partition.split(";")[0].toUpperCase(),
              device
            });
          });
        }
      });
      return result2;
    }
    __name(getDevicesWin, "getDevicesWin");
    function matchDevicesWin(data, diskDrives) {
      const devices = getDevicesWin(diskDrives);
      data.map((element) => {
        const filteresDevices = devices.filter((e) => {
          return e.name === element.name.toUpperCase();
        });
        if (filteresDevices.length > 0) {
          element.device = filteresDevices[0].device;
        }
        return element;
      });
      return data;
    }
    __name(matchDevicesWin, "matchDevicesWin");
    function blkStdoutToObject(stdout) {
      return stdout.toString().replace(/NAME=/g, '{"name":').replace(/FSTYPE=/g, ',"fsType":').replace(/TYPE=/g, ',"type":').replace(/SIZE=/g, ',"size":').replace(/MOUNTPOINT=/g, ',"mountpoint":').replace(/UUID=/g, ',"uuid":').replace(/ROTA=/g, ',"rota":').replace(/RO=/g, ',"ro":').replace(/RM=/g, ',"rm":').replace(/TRAN=/g, ',"tran":').replace(/SERIAL=/g, ',"serial":').replace(/LABEL=/g, ',"label":').replace(/MODEL=/g, ',"model":').replace(/OWNER=/g, ',"owner":').replace(/GROUP=/g, ',"group":').replace(/\n/g, "}\n");
    }
    __name(blkStdoutToObject, "blkStdoutToObject");
    function blockDevices(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let data = [];
          if (_linux) {
            exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,TRAN,SERIAL,LABEL,MODEL,OWNER 2>/dev/null", {
              maxBuffer: 1024 * 1024
            }, function(error, stdout) {
              if (!error) {
                let lines = blkStdoutToObject(stdout).split("\n");
                data = parseBlk(lines);
                data = raidMatchLinux(data);
                data = matchDevicesLinux(data);
                if (callback) {
                  callback(data);
                }
                resolve5(data);
              } else {
                exec("lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER 2>/dev/null", {
                  maxBuffer: 1024 * 1024
                }, function(error2, stdout2) {
                  if (!error2) {
                    let lines = blkStdoutToObject(stdout2).split("\n");
                    data = parseBlk(lines);
                    data = raidMatchLinux(data);
                  }
                  if (callback) {
                    callback(data);
                  }
                  resolve5(data);
                });
              }
            });
          }
          if (_darwin) {
            exec("diskutil info -all", {
              maxBuffer: 1024 * 1024
            }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                data = parseDevices(lines);
                data = matchDevicesMac(data);
              }
              if (callback) {
                callback(data);
              }
              resolve5(data);
            });
          }
          if (_sunos) {
            if (callback) {
              callback(data);
            }
            resolve5(data);
          }
          if (_windows) {
            let drivetypes = [
              "Unknown",
              "NoRoot",
              "Removable",
              "Local",
              "Network",
              "CD/DVD",
              "RAM"
            ];
            try {
              const workload = [];
              workload.push(util2.powerShell("Get-CimInstance -ClassName Win32_LogicalDisk | select Caption,DriveType,Name,FileSystem,Size,VolumeSerialNumber,VolumeName | fl"));
              workload.push(util2.powerShell("Get-WmiObject -Class Win32_diskdrive | Select-Object -Property PNPDeviceId,DeviceID, Model, Size, @{L='Partitions'; E={$_.GetRelated('Win32_DiskPartition').GetRelated('Win32_LogicalDisk') | Select-Object -Property DeviceID, VolumeName, Size, FreeSpace}} | fl"));
              util2.promiseAll(workload).then((res) => {
                let logicalDisks = res.results[0].toString().split(/\n\s*\n/);
                let diskDrives = res.results[1].toString().split(/\n\s*\n/);
                logicalDisks.forEach(function(device) {
                  let lines = device.split("\r\n");
                  let drivetype = util2.getValue(lines, "drivetype", ":");
                  if (drivetype) {
                    data.push({
                      name: util2.getValue(lines, "name", ":"),
                      identifier: util2.getValue(lines, "caption", ":"),
                      type: "disk",
                      fsType: util2.getValue(lines, "filesystem", ":").toLowerCase(),
                      mount: util2.getValue(lines, "caption", ":"),
                      size: util2.getValue(lines, "size", ":"),
                      physical: drivetype >= 0 && drivetype <= 6 ? drivetypes[drivetype] : drivetypes[0],
                      uuid: util2.getValue(lines, "volumeserialnumber", ":"),
                      label: util2.getValue(lines, "volumename", ":"),
                      model: "",
                      serial: util2.getValue(lines, "volumeserialnumber", ":"),
                      removable: drivetype === "2",
                      protocol: "",
                      group: "",
                      device: ""
                    });
                  }
                });
                data = matchDevicesWin(data, diskDrives);
                if (callback) {
                  callback(data);
                }
                resolve5(data);
              });
            } catch (e) {
              if (callback) {
                callback(data);
              }
              resolve5(data);
            }
          }
          if (_freebsd || _openbsd || _netbsd) {
            if (callback) {
              callback(null);
            }
            resolve5(null);
          }
        });
      });
    }
    __name(blockDevices, "blockDevices");
    exports2.blockDevices = blockDevices;
    function calcFsSpeed(rx, wx) {
      let result2 = {
        rx: 0,
        wx: 0,
        tx: 0,
        rx_sec: null,
        wx_sec: null,
        tx_sec: null,
        ms: 0
      };
      if (_fs_speed && _fs_speed.ms) {
        result2.rx = rx;
        result2.wx = wx;
        result2.tx = result2.rx + result2.wx;
        result2.ms = Date.now() - _fs_speed.ms;
        result2.rx_sec = (result2.rx - _fs_speed.bytes_read) / (result2.ms / 1e3);
        result2.wx_sec = (result2.wx - _fs_speed.bytes_write) / (result2.ms / 1e3);
        result2.tx_sec = result2.rx_sec + result2.wx_sec;
        _fs_speed.rx_sec = result2.rx_sec;
        _fs_speed.wx_sec = result2.wx_sec;
        _fs_speed.tx_sec = result2.tx_sec;
        _fs_speed.bytes_read = result2.rx;
        _fs_speed.bytes_write = result2.wx;
        _fs_speed.bytes_overall = result2.rx + result2.wx;
        _fs_speed.ms = Date.now();
        _fs_speed.last_ms = result2.ms;
      } else {
        result2.rx = rx;
        result2.wx = wx;
        result2.tx = result2.rx + result2.wx;
        _fs_speed.rx_sec = null;
        _fs_speed.wx_sec = null;
        _fs_speed.tx_sec = null;
        _fs_speed.bytes_read = result2.rx;
        _fs_speed.bytes_write = result2.wx;
        _fs_speed.bytes_overall = result2.rx + result2.wx;
        _fs_speed.ms = Date.now();
        _fs_speed.last_ms = 0;
      }
      return result2;
    }
    __name(calcFsSpeed, "calcFsSpeed");
    function fsStats(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (_windows || _freebsd || _openbsd || _netbsd || _sunos) {
            return resolve5(null);
          }
          let result2 = {
            rx: 0,
            wx: 0,
            tx: 0,
            rx_sec: null,
            wx_sec: null,
            tx_sec: null,
            ms: 0
          };
          let rx = 0;
          let wx = 0;
          if (_fs_speed && !_fs_speed.ms || _fs_speed && _fs_speed.ms && Date.now() - _fs_speed.ms >= 500) {
            if (_linux) {
              exec("lsblk -r 2>/dev/null | grep /", {
                maxBuffer: 1024 * 1024
              }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  let fs_filter = [];
                  lines.forEach(function(line) {
                    if (line !== "") {
                      line = line.trim().split(" ");
                      if (fs_filter.indexOf(line[0]) === -1) {
                        fs_filter.push(line[0]);
                      }
                    }
                  });
                  let output = fs_filter.join("|");
                  exec('cat /proc/diskstats | egrep "' + output + '"', {
                    maxBuffer: 1024 * 1024
                  }, function(error2, stdout2) {
                    if (!error2) {
                      let lines2 = stdout2.toString().split("\n");
                      lines2.forEach(function(line) {
                        line = line.trim();
                        if (line !== "") {
                          line = line.replace(/ +/g, " ").split(" ");
                          rx += parseInt(line[5]) * 512;
                          wx += parseInt(line[9]) * 512;
                        }
                      });
                      result2 = calcFsSpeed(rx, wx);
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            }
            if (_darwin) {
              exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', {
                maxBuffer: 1024 * 1024
              }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    line = line.trim();
                    if (line !== "") {
                      line = line.split(",");
                      rx += parseInt(line[2]);
                      wx += parseInt(line[9]);
                    }
                  });
                  result2 = calcFsSpeed(rx, wx);
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            }
          } else {
            result2.ms = _fs_speed.last_ms;
            result2.rx = _fs_speed.bytes_read;
            result2.wx = _fs_speed.bytes_write;
            result2.tx = _fs_speed.bytes_read + _fs_speed.bytes_write;
            result2.rx_sec = _fs_speed.rx_sec;
            result2.wx_sec = _fs_speed.wx_sec;
            result2.tx_sec = _fs_speed.tx_sec;
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(fsStats, "fsStats");
    exports2.fsStats = fsStats;
    function calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime) {
      let result2 = {
        rIO: 0,
        wIO: 0,
        tIO: 0,
        rIO_sec: null,
        wIO_sec: null,
        tIO_sec: null,
        rWaitTime: 0,
        wWaitTime: 0,
        tWaitTime: 0,
        rWaitPercent: null,
        wWaitPercent: null,
        tWaitPercent: null,
        ms: 0
      };
      if (_disk_io && _disk_io.ms) {
        result2.rIO = rIO;
        result2.wIO = wIO;
        result2.tIO = rIO + wIO;
        result2.ms = Date.now() - _disk_io.ms;
        result2.rIO_sec = (result2.rIO - _disk_io.rIO) / (result2.ms / 1e3);
        result2.wIO_sec = (result2.wIO - _disk_io.wIO) / (result2.ms / 1e3);
        result2.tIO_sec = result2.rIO_sec + result2.wIO_sec;
        result2.rWaitTime = rWaitTime;
        result2.wWaitTime = wWaitTime;
        result2.tWaitTime = tWaitTime;
        result2.rWaitPercent = (result2.rWaitTime - _disk_io.rWaitTime) * 100 / result2.ms;
        result2.wWaitPercent = (result2.wWaitTime - _disk_io.wWaitTime) * 100 / result2.ms;
        result2.tWaitPercent = (result2.tWaitTime - _disk_io.tWaitTime) * 100 / result2.ms;
        _disk_io.rIO = rIO;
        _disk_io.wIO = wIO;
        _disk_io.rIO_sec = result2.rIO_sec;
        _disk_io.wIO_sec = result2.wIO_sec;
        _disk_io.tIO_sec = result2.tIO_sec;
        _disk_io.rWaitTime = rWaitTime;
        _disk_io.wWaitTime = wWaitTime;
        _disk_io.tWaitTime = tWaitTime;
        _disk_io.rWaitPercent = result2.rWaitPercent;
        _disk_io.wWaitPercent = result2.wWaitPercent;
        _disk_io.tWaitPercent = result2.tWaitPercent;
        _disk_io.last_ms = result2.ms;
        _disk_io.ms = Date.now();
      } else {
        result2.rIO = rIO;
        result2.wIO = wIO;
        result2.tIO = rIO + wIO;
        result2.rWaitTime = rWaitTime;
        result2.wWaitTime = wWaitTime;
        result2.tWaitTime = tWaitTime;
        _disk_io.rIO = rIO;
        _disk_io.wIO = wIO;
        _disk_io.rIO_sec = null;
        _disk_io.wIO_sec = null;
        _disk_io.tIO_sec = null;
        _disk_io.rWaitTime = rWaitTime;
        _disk_io.wWaitTime = wWaitTime;
        _disk_io.tWaitTime = tWaitTime;
        _disk_io.rWaitPercent = null;
        _disk_io.wWaitPercent = null;
        _disk_io.tWaitPercent = null;
        _disk_io.last_ms = 0;
        _disk_io.ms = Date.now();
      }
      return result2;
    }
    __name(calcDiskIO, "calcDiskIO");
    function disksIO(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (_windows) {
            return resolve5(null);
          }
          if (_sunos) {
            return resolve5(null);
          }
          let result2 = {
            rIO: 0,
            wIO: 0,
            tIO: 0,
            rIO_sec: null,
            wIO_sec: null,
            tIO_sec: null,
            rWaitTime: 0,
            wWaitTime: 0,
            tWaitTime: 0,
            rWaitPercent: null,
            wWaitPercent: null,
            tWaitPercent: null,
            ms: 0
          };
          let rIO = 0;
          let wIO = 0;
          let rWaitTime = 0;
          let wWaitTime = 0;
          let tWaitTime = 0;
          if (_disk_io && !_disk_io.ms || _disk_io && _disk_io.ms && Date.now() - _disk_io.ms >= 500) {
            if (_linux || _freebsd || _openbsd || _netbsd) {
              let cmd = 'for mount in `lsblk 2>/dev/null | grep " disk " | sed "s/[\u2502\u2514\u2500\u251C]//g" | awk \'{$1=$1};1\' | cut -d " " -f 1 | sort -u`; do cat /sys/block/$mount/stat | sed -r "s/ +/;/g" | sed -r "s/^;//"; done';
              exec(cmd, {
                maxBuffer: 1024 * 1024
              }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.split("\n");
                  lines.forEach(function(line) {
                    if (!line) {
                      return;
                    }
                    let stats = line.split(";");
                    rIO += parseInt(stats[0]);
                    wIO += parseInt(stats[4]);
                    rWaitTime += parseInt(stats[3]);
                    wWaitTime += parseInt(stats[7]);
                    tWaitTime += parseInt(stats[10]);
                  });
                  result2 = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            }
            if (_darwin) {
              exec('ioreg -c IOBlockStorageDriver -k Statistics -r -w0 | sed -n "/IOBlockStorageDriver/,/Statistics/p" | grep "Statistics" | tr -cd "01234567890,\n"', {
                maxBuffer: 1024 * 1024
              }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  lines.forEach(function(line) {
                    line = line.trim();
                    if (line !== "") {
                      line = line.split(",");
                      rIO += parseInt(line[10]);
                      wIO += parseInt(line[0]);
                    }
                  });
                  result2 = calcDiskIO(rIO, wIO, rWaitTime, wWaitTime, tWaitTime);
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            }
          } else {
            result2.rIO = _disk_io.rIO;
            result2.wIO = _disk_io.wIO;
            result2.tIO = _disk_io.rIO + _disk_io.wIO;
            result2.ms = _disk_io.last_ms;
            result2.rIO_sec = _disk_io.rIO_sec;
            result2.wIO_sec = _disk_io.wIO_sec;
            result2.tIO_sec = _disk_io.tIO_sec;
            result2.rWaitTime = _disk_io.rWaitTime;
            result2.wWaitTime = _disk_io.wWaitTime;
            result2.tWaitTime = _disk_io.tWaitTime;
            result2.rWaitPercent = _disk_io.rWaitPercent;
            result2.wWaitPercent = _disk_io.wWaitPercent;
            result2.tWaitPercent = _disk_io.tWaitPercent;
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(disksIO, "disksIO");
    exports2.disksIO = disksIO;
    function diskLayout(callback) {
      function getVendorFromModel(model) {
        const diskManufacturers = [
          {
            pattern: "WESTERN.*",
            manufacturer: "Western Digital"
          },
          {
            pattern: "^WDC.*",
            manufacturer: "Western Digital"
          },
          {
            pattern: "WD.*",
            manufacturer: "Western Digital"
          },
          {
            pattern: "TOSHIBA.*",
            manufacturer: "Toshiba"
          },
          {
            pattern: "HITACHI.*",
            manufacturer: "Hitachi"
          },
          {
            pattern: "^IC.*",
            manufacturer: "Hitachi"
          },
          {
            pattern: "^HTS.*",
            manufacturer: "Hitachi"
          },
          {
            pattern: "SANDISK.*",
            manufacturer: "SanDisk"
          },
          {
            pattern: "KINGSTON.*",
            manufacturer: "Kingston Technology"
          },
          {
            pattern: "^SONY.*",
            manufacturer: "Sony"
          },
          {
            pattern: "TRANSCEND.*",
            manufacturer: "Transcend"
          },
          {
            pattern: "SAMSUNG.*",
            manufacturer: "Samsung"
          },
          {
            pattern: "^ST(?!I\\ ).*",
            manufacturer: "Seagate"
          },
          {
            pattern: "^STI\\ .*",
            manufacturer: "SimpleTech"
          },
          {
            pattern: "^D...-.*",
            manufacturer: "IBM"
          },
          {
            pattern: "^IBM.*",
            manufacturer: "IBM"
          },
          {
            pattern: "^FUJITSU.*",
            manufacturer: "Fujitsu"
          },
          {
            pattern: "^MP.*",
            manufacturer: "Fujitsu"
          },
          {
            pattern: "^MK.*",
            manufacturer: "Toshiba"
          },
          {
            pattern: "MAXTO.*",
            manufacturer: "Maxtor"
          },
          {
            pattern: "PIONEER.*",
            manufacturer: "Pioneer"
          },
          {
            pattern: "PHILIPS.*",
            manufacturer: "Philips"
          },
          {
            pattern: "QUANTUM.*",
            manufacturer: "Quantum Technology"
          },
          {
            pattern: "FIREBALL.*",
            manufacturer: "Quantum Technology"
          },
          {
            pattern: "^VBOX.*",
            manufacturer: "VirtualBox"
          },
          {
            pattern: "CORSAIR.*",
            manufacturer: "Corsair Components"
          },
          {
            pattern: "CRUCIAL.*",
            manufacturer: "Crucial"
          },
          {
            pattern: "ECM.*",
            manufacturer: "ECM"
          },
          {
            pattern: "INTEL.*",
            manufacturer: "INTEL"
          },
          {
            pattern: "EVO.*",
            manufacturer: "Samsung"
          },
          {
            pattern: "APPLE.*",
            manufacturer: "Apple"
          }
        ];
        let result2 = "";
        if (model) {
          model = model.toUpperCase();
          diskManufacturers.forEach((manufacturer) => {
            const re2 = RegExp(manufacturer.pattern);
            if (re2.test(model)) {
              result2 = manufacturer.manufacturer;
            }
          });
        }
        return result2;
      }
      __name(getVendorFromModel, "getVendorFromModel");
      return new Promise((resolve5) => {
        process.nextTick(() => {
          const commitResult = /* @__PURE__ */ __name((res) => {
            for (let i = 0; i < res.length; i++) {
              delete res[i].BSDName;
            }
            if (callback) {
              callback(res);
            }
            resolve5(res);
          }, "commitResult");
          let result2 = [];
          let cmd = "";
          if (_linux) {
            let cmdFullSmart = "";
            exec("export LC_ALL=C; lsblk -ablJO 2>/dev/null; unset LC_ALL", {
              maxBuffer: 1024 * 1024
            }, function(error, stdout) {
              if (!error) {
                try {
                  const out = stdout.toString().trim();
                  let devices = [];
                  try {
                    const outJSON = JSON.parse(out);
                    if (outJSON && {}.hasOwnProperty.call(outJSON, "blockdevices")) {
                      devices = outJSON.blockdevices.filter((item) => {
                        return item.type === "disk" && item.size > 0 && (item.model !== null || item.mountpoint === null && item.label === null && item.fstype === null && item.parttype === null && item.path && item.path.indexOf("/ram") !== 0 && item.path.indexOf("/loop") !== 0 && item["disc-max"] && item["disc-max"] !== 0);
                      });
                    }
                  } catch (e) {
                    try {
                      const out2 = execSync("export LC_ALL=C; lsblk -bPo NAME,TYPE,SIZE,FSTYPE,MOUNTPOINT,UUID,ROTA,RO,RM,LABEL,MODEL,OWNER,GROUP 2>/dev/null; unset LC_ALL", util2.execOptsLinux).toString();
                      let lines = blkStdoutToObject(out2).split("\n");
                      const data = parseBlk(lines);
                      devices = data.filter((item) => {
                        return item.type === "disk" && item.size > 0 && (item.model !== null && item.model !== "" || item.mount === "" && item.label === "" && item.fsType === "");
                      });
                    } catch (e2) {
                      util2.noop();
                    }
                  }
                  devices.forEach((device) => {
                    let mediumType = "";
                    const BSDName = "/dev/" + device.name;
                    const logical = device.name;
                    try {
                      mediumType = execSync("cat /sys/block/" + logical + "/queue/rotational 2>/dev/null", util2.execOptsLinux).toString().split("\n")[0];
                    } catch (e) {
                      util2.noop();
                    }
                    let interfaceType = device.tran ? device.tran.toUpperCase().trim() : "";
                    if (interfaceType === "NVME") {
                      mediumType = "2";
                      interfaceType = "PCIe";
                    }
                    result2.push({
                      device: BSDName,
                      type: mediumType === "0" ? "SSD" : mediumType === "1" ? "HD" : mediumType === "2" ? "NVMe" : device.model && device.model.indexOf("SSD") > -1 ? "SSD" : device.model && device.model.indexOf("NVM") > -1 ? "NVMe" : "HD",
                      name: device.model || "",
                      vendor: getVendorFromModel(device.model) || (device.vendor ? device.vendor.trim() : ""),
                      size: device.size || 0,
                      bytesPerSector: null,
                      totalCylinders: null,
                      totalHeads: null,
                      totalSectors: null,
                      totalTracks: null,
                      tracksPerCylinder: null,
                      sectorsPerTrack: null,
                      firmwareRevision: device.rev ? device.rev.trim() : "",
                      serialNum: device.serial ? device.serial.trim() : "",
                      interfaceType,
                      smartStatus: "unknown",
                      temperature: null,
                      BSDName
                    });
                    cmd += `printf "
${BSDName}|"; smartctl -H ${BSDName} | grep overall;`;
                    cmdFullSmart += `${cmdFullSmart ? 'printf ",";' : ""}smartctl -a -j ${BSDName};`;
                  });
                } catch (e) {
                  util2.noop();
                }
              }
              if (cmdFullSmart) {
                exec(cmdFullSmart, {
                  maxBuffer: 1024 * 1024
                }, function(error2, stdout2) {
                  try {
                    const data = JSON.parse(`[${stdout2}]`);
                    data.forEach((disk) => {
                      const diskBSDName = disk.smartctl.argv[disk.smartctl.argv.length - 1];
                      for (let i = 0; i < result2.length; i++) {
                        if (result2[i].BSDName === diskBSDName) {
                          result2[i].smartStatus = disk.smart_status.passed ? "Ok" : disk.smart_status.passed === false ? "Predicted Failure" : "unknown";
                          if (disk.temperature && disk.temperature.current) {
                            result2[i].temperature = disk.temperature.current;
                          }
                          result2[i].smartData = disk;
                        }
                      }
                    });
                    commitResult(result2);
                  } catch (e) {
                    if (cmd) {
                      cmd = cmd + 'printf "\n"';
                      exec(cmd, {
                        maxBuffer: 1024 * 1024
                      }, function(error3, stdout3) {
                        let lines = stdout3.toString().split("\n");
                        lines.forEach((line) => {
                          if (line) {
                            let parts2 = line.split("|");
                            if (parts2.length === 2) {
                              let BSDName = parts2[0];
                              parts2[1] = parts2[1].trim();
                              let parts22 = parts2[1].split(":");
                              if (parts22.length === 2) {
                                parts22[1] = parts22[1].trim();
                                let status = parts22[1].toLowerCase();
                                for (let i = 0; i < result2.length; i++) {
                                  if (result2[i].BSDName === BSDName) {
                                    result2[i].smartStatus = status === "passed" ? "Ok" : status === "failed!" ? "Predicted Failure" : "unknown";
                                  }
                                }
                              }
                            }
                          }
                        });
                        commitResult(result2);
                      });
                    } else {
                      commitResult(result2);
                    }
                  }
                });
              } else {
                commitResult(result2);
              }
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_sunos) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_darwin) {
            exec("system_profiler SPSerialATADataType SPNVMeDataType SPUSBDataType", {
              maxBuffer: 1024 * 1024
            }, function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                let linesSATA = [];
                let linesNVMe = [];
                let linesUSB = [];
                let dataType = "SATA";
                lines.forEach((line) => {
                  if (line === "NVMExpress:") {
                    dataType = "NVMe";
                  } else if (line === "USB:") {
                    dataType = "USB";
                  } else if (line === "SATA/SATA Express:") {
                    dataType = "SATA";
                  } else if (dataType === "SATA") {
                    linesSATA.push(line);
                  } else if (dataType === "NVMe") {
                    linesNVMe.push(line);
                  } else if (dataType === "USB") {
                    linesUSB.push(line);
                  }
                });
                try {
                  let devices = linesSATA.join("\n").split(" Physical Interconnect: ");
                  devices.shift();
                  devices.forEach(function(device) {
                    device = "InterfaceType: " + device;
                    let lines2 = device.split("\n");
                    const mediumType = util2.getValue(lines2, "Medium Type", ":", true).trim();
                    const sizeStr = util2.getValue(lines2, "capacity", ":", true).trim();
                    const BSDName = util2.getValue(lines2, "BSD Name", ":", true).trim();
                    if (sizeStr) {
                      let sizeValue = 0;
                      if (sizeStr.indexOf("(") >= 0) {
                        sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                      }
                      if (!sizeValue) {
                        sizeValue = parseInt(sizeStr);
                      }
                      if (sizeValue) {
                        const smartStatusString = util2.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                        result2.push({
                          device: BSDName,
                          type: mediumType.startsWith("Solid") ? "SSD" : "HD",
                          name: util2.getValue(lines2, "Model", ":", true).trim(),
                          vendor: getVendorFromModel(util2.getValue(lines2, "Model", ":", true).trim()) || util2.getValue(lines2, "Manufacturer", ":", true),
                          size: sizeValue,
                          bytesPerSector: null,
                          totalCylinders: null,
                          totalHeads: null,
                          totalSectors: null,
                          totalTracks: null,
                          tracksPerCylinder: null,
                          sectorsPerTrack: null,
                          firmwareRevision: util2.getValue(lines2, "Revision", ":", true).trim(),
                          serialNum: util2.getValue(lines2, "Serial Number", ":", true).trim(),
                          interfaceType: util2.getValue(lines2, "InterfaceType", ":", true).trim(),
                          smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                          temperature: null,
                          BSDName
                        });
                        cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                      }
                    }
                  });
                } catch (e) {
                  util2.noop();
                }
                try {
                  let devices = linesNVMe.join("\n").split("\n\n          Capacity:");
                  devices.shift();
                  devices.forEach(function(device) {
                    device = "!Capacity: " + device;
                    let lines2 = device.split("\n");
                    const linkWidth = util2.getValue(lines2, "link width", ":", true).trim();
                    const sizeStr = util2.getValue(lines2, "!capacity", ":", true).trim();
                    const BSDName = util2.getValue(lines2, "BSD Name", ":", true).trim();
                    if (sizeStr) {
                      let sizeValue = 0;
                      if (sizeStr.indexOf("(") >= 0) {
                        sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                      }
                      if (!sizeValue) {
                        sizeValue = parseInt(sizeStr);
                      }
                      if (sizeValue) {
                        const smartStatusString = util2.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                        result2.push({
                          device: BSDName,
                          type: "NVMe",
                          name: util2.getValue(lines2, "Model", ":", true).trim(),
                          vendor: getVendorFromModel(util2.getValue(lines2, "Model", ":", true).trim()),
                          size: sizeValue,
                          bytesPerSector: null,
                          totalCylinders: null,
                          totalHeads: null,
                          totalSectors: null,
                          totalTracks: null,
                          tracksPerCylinder: null,
                          sectorsPerTrack: null,
                          firmwareRevision: util2.getValue(lines2, "Revision", ":", true).trim(),
                          serialNum: util2.getValue(lines2, "Serial Number", ":", true).trim(),
                          interfaceType: ("PCIe " + linkWidth).trim(),
                          smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                          temperature: null,
                          BSDName
                        });
                        cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                      }
                    }
                  });
                } catch (e) {
                  util2.noop();
                }
                try {
                  let devices = linesUSB.join("\n").replaceAll("Media:\n ", "Model:").split("\n\n          Product ID:");
                  devices.shift();
                  devices.forEach(function(device) {
                    let lines2 = device.split("\n");
                    const sizeStr = util2.getValue(lines2, "Capacity", ":", true).trim();
                    const BSDName = util2.getValue(lines2, "BSD Name", ":", true).trim();
                    if (sizeStr) {
                      let sizeValue = 0;
                      if (sizeStr.indexOf("(") >= 0) {
                        sizeValue = parseInt(sizeStr.match(/\(([^)]+)\)/)[1].replace(/\./g, "").replace(/,/g, "").replace(/\s/g, ""));
                      }
                      if (!sizeValue) {
                        sizeValue = parseInt(sizeStr);
                      }
                      if (sizeValue) {
                        const smartStatusString = util2.getValue(lines2, "S.M.A.R.T. status", ":", true).trim().toLowerCase();
                        result2.push({
                          device: BSDName,
                          type: "USB",
                          name: util2.getValue(lines2, "Model", ":", true).trim().replaceAll(":", ""),
                          vendor: getVendorFromModel(util2.getValue(lines2, "Model", ":", true).trim()),
                          size: sizeValue,
                          bytesPerSector: null,
                          totalCylinders: null,
                          totalHeads: null,
                          totalSectors: null,
                          totalTracks: null,
                          tracksPerCylinder: null,
                          sectorsPerTrack: null,
                          firmwareRevision: util2.getValue(lines2, "Revision", ":", true).trim(),
                          serialNum: util2.getValue(lines2, "Serial Number", ":", true).trim(),
                          interfaceType: "USB",
                          smartStatus: smartStatusString === "verified" ? "OK" : smartStatusString || "unknown",
                          temperature: null,
                          BSDName
                        });
                        cmd = cmd + 'printf "\n' + BSDName + '|"; diskutil info /dev/' + BSDName + " | grep SMART;";
                      }
                    }
                  });
                } catch (e) {
                  util2.noop();
                }
                if (cmd) {
                  cmd = cmd + 'printf "\n"';
                  exec(cmd, {
                    maxBuffer: 1024 * 1024
                  }, function(error2, stdout2) {
                    let lines2 = stdout2.toString().split("\n");
                    lines2.forEach((line) => {
                      if (line) {
                        let parts2 = line.split("|");
                        if (parts2.length === 2) {
                          let BSDName = parts2[0];
                          parts2[1] = parts2[1].trim();
                          let parts22 = parts2[1].split(":");
                          if (parts22.length === 2) {
                            parts22[1] = parts22[1].trim();
                            let status = parts22[1].toLowerCase();
                            for (let i = 0; i < result2.length; i++) {
                              if (result2[i].BSDName === BSDName) {
                                result2[i].smartStatus = status === "not supported" ? "not supported" : status === "verified" ? "Ok" : status === "failing" ? "Predicted Failure" : "unknown";
                              }
                            }
                          }
                        }
                      }
                    });
                    for (let i = 0; i < result2.length; i++) {
                      delete result2[i].BSDName;
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  });
                } else {
                  for (let i = 0; i < result2.length; i++) {
                    delete result2[i].BSDName;
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              }
            });
          }
          if (_windows) {
            try {
              const workload = [];
              workload.push(util2.powerShell("Get-CimInstance Win32_DiskDrive | select Caption,Size,Status,PNPDeviceId,DeviceId,BytesPerSector,TotalCylinders,TotalHeads,TotalSectors,TotalTracks,TracksPerCylinder,SectorsPerTrack,FirmwareRevision,SerialNumber,InterfaceType | fl"));
              workload.push(util2.powerShell("Get-PhysicalDisk | select BusType,MediaType,FriendlyName,Model,SerialNumber,Size | fl"));
              if (util2.smartMonToolsInstalled()) {
                try {
                  const smartDev = JSON.parse(execSync("smartctl --scan -j").toString());
                  if (smartDev && smartDev.devices && smartDev.devices.length > 0) {
                    smartDev.devices.forEach((dev) => {
                      workload.push(execPromiseSave(`smartctl -j -a ${dev.name}`, util2.execOptsWin));
                    });
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              util2.promiseAll(workload).then((data) => {
                let devices = data.results[0].toString().split(/\n\s*\n/);
                devices.forEach(function(device) {
                  let lines = device.split("\r\n");
                  const size = util2.getValue(lines, "Size", ":").trim();
                  const status = util2.getValue(lines, "Status", ":").trim().toLowerCase();
                  if (size) {
                    result2.push({
                      device: util2.getValue(lines, "DeviceId", ":"),
                      type: device.indexOf("SSD") > -1 ? "SSD" : "HD",
                      name: util2.getValue(lines, "Caption", ":"),
                      vendor: getVendorFromModel(util2.getValue(lines, "Caption", ":", true).trim()),
                      size: parseInt(size),
                      bytesPerSector: parseInt(util2.getValue(lines, "BytesPerSector", ":")),
                      totalCylinders: parseInt(util2.getValue(lines, "TotalCylinders", ":")),
                      totalHeads: parseInt(util2.getValue(lines, "TotalHeads", ":")),
                      totalSectors: parseInt(util2.getValue(lines, "TotalSectors", ":")),
                      totalTracks: parseInt(util2.getValue(lines, "TotalTracks", ":")),
                      tracksPerCylinder: parseInt(util2.getValue(lines, "TracksPerCylinder", ":")),
                      sectorsPerTrack: parseInt(util2.getValue(lines, "SectorsPerTrack", ":")),
                      firmwareRevision: util2.getValue(lines, "FirmwareRevision", ":").trim(),
                      serialNum: util2.getValue(lines, "SerialNumber", ":").trim(),
                      interfaceType: util2.getValue(lines, "InterfaceType", ":").trim(),
                      smartStatus: status === "ok" ? "Ok" : status === "degraded" ? "Degraded" : status === "pred fail" ? "Predicted Failure" : "Unknown",
                      temperature: null
                    });
                  }
                });
                devices = data.results[1].split(/\n\s*\n/);
                devices.forEach(function(device) {
                  let lines = device.split("\r\n");
                  const serialNum = util2.getValue(lines, "SerialNumber", ":").trim();
                  const name = util2.getValue(lines, "FriendlyName", ":").trim().replace("Msft ", "Microsoft");
                  const size = util2.getValue(lines, "Size", ":").trim();
                  const model = util2.getValue(lines, "Model", ":").trim();
                  const interfaceType = util2.getValue(lines, "BusType", ":").trim();
                  let mediaType = util2.getValue(lines, "MediaType", ":").trim();
                  if (mediaType === "3" || mediaType === "HDD") {
                    mediaType = "HD";
                  }
                  if (mediaType === "4") {
                    mediaType = "SSD";
                  }
                  if (mediaType === "5") {
                    mediaType = "SCM";
                  }
                  if (mediaType === "Unspecified" && (model.toLowerCase().indexOf("virtual") > -1 || model.toLowerCase().indexOf("vbox") > -1)) {
                    mediaType = "Virtual";
                  }
                  if (size) {
                    let i = util2.findObjectByKey(result2, "serialNum", serialNum);
                    if (i === -1 || serialNum === "") {
                      i = util2.findObjectByKey(result2, "name", name);
                    }
                    if (i != -1) {
                      result2[i].type = mediaType;
                      result2[i].interfaceType = interfaceType;
                    }
                  }
                });
                data.results.shift();
                data.results.shift();
                if (data.results.length) {
                  data.results.forEach((smartStr) => {
                    try {
                      const smartData = JSON.parse(smartStr);
                      if (smartData.serial_number) {
                        const serialNum = smartData.serial_number;
                        let i = util2.findObjectByKey(result2, "serialNum", serialNum);
                        if (i != -1) {
                          result2[i].smartStatus = smartData.smart_status && smartData.smart_status.passed ? "Ok" : smartData.smart_status && smartData.smart_status.passed === false ? "Predicted Failure" : "unknown";
                          if (smartData.temperature && smartData.temperature.current) {
                            result2[i].temperature = smartData.temperature.current;
                          }
                          result2[i].smartData = smartData;
                        }
                      }
                    } catch (e) {
                      util2.noop();
                    }
                  });
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(diskLayout, "diskLayout");
    exports2.diskLayout = diskLayout;
  }
});

// node_modules/systeminformation/lib/network.js
var require_network = __commonJS({
  "node_modules/systeminformation/lib/network.js"(exports2) {
    "use strict";
    var os = require("os");
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var fs = require("fs");
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _network = {};
    var _default_iface = "";
    var _ifaces = {};
    var _dhcpNics = [];
    var _networkInterfaces = [];
    var _mac = {};
    var pathToIp;
    function getDefaultNetworkInterface() {
      let ifacename = "";
      let ifacenameFirst = "";
      try {
        let ifaces = os.networkInterfaces();
        let scopeid = 9999;
        for (let dev in ifaces) {
          if ({}.hasOwnProperty.call(ifaces, dev)) {
            ifaces[dev].forEach(function(details) {
              if (details && details.internal === false) {
                ifacenameFirst = ifacenameFirst || dev;
                if (details.scopeid && details.scopeid < scopeid) {
                  ifacename = dev;
                  scopeid = details.scopeid;
                }
              }
            });
          }
        }
        ifacename = ifacename || ifacenameFirst || "";
        if (_windows) {
          let defaultIp = "";
          const cmd = "netstat -r";
          const result2 = execSync(cmd, util2.execOptsWin);
          const lines = result2.toString().split(os.EOL);
          lines.forEach((line) => {
            line = line.replace(/\s+/g, " ").trim();
            if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
              const parts2 = line.split(" ");
              if (parts2.length >= 5) {
                defaultIp = parts2[parts2.length - 2];
              }
            }
          });
          if (defaultIp) {
            for (let dev in ifaces) {
              if ({}.hasOwnProperty.call(ifaces, dev)) {
                ifaces[dev].forEach(function(details) {
                  if (details && details.address && details.address === defaultIp) {
                    ifacename = dev;
                  }
                });
              }
            }
          }
        }
        if (_linux) {
          let cmd = "ip route 2> /dev/null | grep default";
          let result2 = execSync(cmd, util2.execOptsLinux);
          let parts2 = result2.toString().split("\n")[0].split(/\s+/);
          if (parts2[0] === "none" && parts2[5]) {
            ifacename = parts2[5];
          } else if (parts2[4]) {
            ifacename = parts2[4];
          }
          if (ifacename.indexOf(":") > -1) {
            ifacename = ifacename.split(":")[1].trim();
          }
        }
        if (_darwin || _freebsd || _openbsd || _netbsd || _sunos) {
          let cmd = "";
          if (_linux) {
            cmd = "ip route 2> /dev/null | grep default | awk '{print $5}'";
          }
          if (_darwin) {
            cmd = "route -n get default 2>/dev/null | grep interface: | awk '{print $2}'";
          }
          if (_freebsd || _openbsd || _netbsd || _sunos) {
            cmd = "route get 0.0.0.0 | grep interface:";
          }
          let result2 = execSync(cmd);
          ifacename = result2.toString().split("\n")[0];
          if (ifacename.indexOf(":") > -1) {
            ifacename = ifacename.split(":")[1].trim();
          }
        }
      } catch (e) {
        util2.noop();
      }
      if (ifacename) {
        _default_iface = ifacename;
      }
      return _default_iface;
    }
    __name(getDefaultNetworkInterface, "getDefaultNetworkInterface");
    exports2.getDefaultNetworkInterface = getDefaultNetworkInterface;
    function getMacAddresses() {
      let iface = "";
      let mac = "";
      let result2 = {};
      if (_linux || _freebsd || _openbsd || _netbsd) {
        if (typeof pathToIp === "undefined") {
          try {
            const lines = execSync("which ip", util2.execOptsLinux).toString().split("\n");
            if (lines.length && lines[0].indexOf(":") === -1 && lines[0].indexOf("/") === 0) {
              pathToIp = lines[0];
            } else {
              pathToIp = "";
            }
          } catch (e) {
            pathToIp = "";
          }
        }
        try {
          const cmd = "export LC_ALL=C; " + (pathToIp ? pathToIp + " link show up" : "/sbin/ifconfig") + "; unset LC_ALL";
          let res = execSync(cmd, util2.execOptsLinux);
          const lines = res.toString().split("\n");
          for (let i = 0; i < lines.length; i++) {
            if (lines[i] && lines[i][0] !== " ") {
              if (pathToIp) {
                let nextline = lines[i + 1].trim().split(" ");
                if (nextline[0] === "link/ether") {
                  iface = lines[i].split(" ")[1];
                  iface = iface.slice(0, iface.length - 1);
                  mac = nextline[1];
                }
              } else {
                iface = lines[i].split(" ")[0];
                mac = lines[i].split("HWaddr ")[1];
              }
              if (iface && mac) {
                result2[iface] = mac.trim();
                iface = "";
                mac = "";
              }
            }
          }
        } catch (e) {
          util2.noop();
        }
      }
      if (_darwin) {
        try {
          const cmd = "/sbin/ifconfig";
          let res = execSync(cmd);
          const lines = res.toString().split("\n");
          for (let i = 0; i < lines.length; i++) {
            if (lines[i] && lines[i][0] !== "	" && lines[i].indexOf(":") > 0) {
              iface = lines[i].split(":")[0];
            } else if (lines[i].indexOf("	ether ") === 0) {
              mac = lines[i].split("	ether ")[1];
              if (iface && mac) {
                result2[iface] = mac.trim();
                iface = "";
                mac = "";
              }
            }
          }
        } catch (e) {
          util2.noop();
        }
      }
      return result2;
    }
    __name(getMacAddresses, "getMacAddresses");
    function networkInterfaceDefault(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = getDefaultNetworkInterface();
          if (callback) {
            callback(result2);
          }
          resolve5(result2);
        });
      });
    }
    __name(networkInterfaceDefault, "networkInterfaceDefault");
    exports2.networkInterfaceDefault = networkInterfaceDefault;
    function parseLinesWindowsNics(sections, nconfigsections) {
      let nics = [];
      for (let i in sections) {
        try {
          if ({}.hasOwnProperty.call(sections, i)) {
            if (sections[i].trim() !== "") {
              let lines = sections[i].trim().split("\r\n");
              let linesNicConfig = null;
              try {
                linesNicConfig = nconfigsections && nconfigsections[i] ? nconfigsections[i].trim().split("\r\n") : [];
              } catch (e) {
                util2.noop();
              }
              let netEnabled = util2.getValue(lines, "NetEnabled", ":");
              let adapterType = util2.getValue(lines, "AdapterTypeID", ":") === "9" ? "wireless" : "wired";
              let ifacename = util2.getValue(lines, "Name", ":").replace(/\]/g, ")").replace(/\[/g, "(");
              let iface = util2.getValue(lines, "NetConnectionID", ":").replace(/\]/g, ")").replace(/\[/g, "(");
              if (ifacename.toLowerCase().indexOf("wi-fi") >= 0 || ifacename.toLowerCase().indexOf("wireless") >= 0) {
                adapterType = "wireless";
              }
              if (netEnabled !== "") {
                const speed = parseInt(util2.getValue(lines, "speed", ":").trim(), 10) / 1e6;
                nics.push({
                  mac: util2.getValue(lines, "MACAddress", ":").toLowerCase(),
                  dhcp: util2.getValue(linesNicConfig, "dhcpEnabled", ":").toLowerCase() === "true",
                  name: ifacename,
                  iface,
                  netEnabled: netEnabled === "TRUE",
                  speed: isNaN(speed) ? null : speed,
                  operstate: util2.getValue(lines, "NetConnectionStatus", ":") === "2" ? "up" : "down",
                  type: adapterType
                });
              }
            }
          }
        } catch (e) {
          util2.noop();
        }
      }
      return nics;
    }
    __name(parseLinesWindowsNics, "parseLinesWindowsNics");
    function getWindowsNics() {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let cmd = "Get-CimInstance Win32_NetworkAdapter | fl *; echo '#-#-#-#';";
          cmd += "Get-CimInstance Win32_NetworkAdapterConfiguration | fl DHCPEnabled";
          try {
            util2.powerShell(cmd).then((data) => {
              data = data.split("#-#-#-#");
              const nsections = (data[0] || "").split(/\n\s*\n/);
              const nconfigsections = (data[1] || "").split(/\n\s*\n/);
              resolve5(parseLinesWindowsNics(nsections, nconfigsections));
            });
          } catch (e) {
            resolve5([]);
          }
        });
      });
    }
    __name(getWindowsNics, "getWindowsNics");
    function getWindowsDNSsuffixes() {
      let iface = {};
      let dnsSuffixes = {
        primaryDNS: "",
        exitCode: 0,
        ifaces: []
      };
      try {
        const ipconfig = execSync("ipconfig /all", util2.execOptsWin);
        const ipconfigArray = ipconfig.split("\r\n\r\n");
        ipconfigArray.forEach((element, index) => {
          if (index == 1) {
            const longPrimaryDNS = element.split("\r\n").filter((element2) => {
              return element2.toUpperCase().includes("DNS");
            });
            const primaryDNS = longPrimaryDNS[0].substring(longPrimaryDNS[0].lastIndexOf(":") + 1);
            dnsSuffixes.primaryDNS = primaryDNS.trim();
            if (!dnsSuffixes.primaryDNS) {
              dnsSuffixes.primaryDNS = "Not defined";
            }
          }
          if (index > 1) {
            if (index % 2 == 0) {
              const name = element.substring(element.lastIndexOf(" ") + 1).replace(":", "");
              iface.name = name;
            } else {
              const connectionSpecificDNS = element.split("\r\n").filter((element2) => {
                return element2.toUpperCase().includes("DNS");
              });
              const dnsSuffix = connectionSpecificDNS[0].substring(connectionSpecificDNS[0].lastIndexOf(":") + 1);
              iface.dnsSuffix = dnsSuffix.trim();
              dnsSuffixes.ifaces.push(iface);
              iface = {};
            }
          }
        });
        return dnsSuffixes;
      } catch (error) {
        return {
          primaryDNS: "",
          exitCode: 0,
          ifaces: []
        };
      }
    }
    __name(getWindowsDNSsuffixes, "getWindowsDNSsuffixes");
    function getWindowsIfaceDNSsuffix(ifaces, ifacename) {
      let dnsSuffix = "";
      const interfaceName = ifacename + ".";
      try {
        const connectionDnsSuffix = ifaces.filter((iface) => {
          return interfaceName.includes(iface.name + ".");
        }).map((iface) => iface.dnsSuffix);
        if (connectionDnsSuffix[0]) {
          dnsSuffix = connectionDnsSuffix[0];
        }
        if (!dnsSuffix) {
          dnsSuffix = "";
        }
        return dnsSuffix;
      } catch (error) {
        return "Unknown";
      }
    }
    __name(getWindowsIfaceDNSsuffix, "getWindowsIfaceDNSsuffix");
    function getWindowsWiredProfilesInformation() {
      try {
        const result2 = execSync("netsh lan show profiles", util2.execOptsWin);
        const profileList = result2.split("\r\nProfile on interface");
        return profileList;
      } catch (error) {
        if (error.status === 1 && error.stdout.includes("AutoConfig")) {
          return "Disabled";
        }
        return [];
      }
    }
    __name(getWindowsWiredProfilesInformation, "getWindowsWiredProfilesInformation");
    function getWindowsWirelessIfaceSSID(interfaceName) {
      try {
        const result2 = execSync(`netsh wlan show  interface name="${interfaceName}" | findstr "SSID"`, util2.execOptsWin);
        const SSID = result2.split("\r\n").shift();
        const parseSSID = SSID.split(":").pop().trim();
        return parseSSID;
      } catch (error) {
        return "Unknown";
      }
    }
    __name(getWindowsWirelessIfaceSSID, "getWindowsWirelessIfaceSSID");
    function getWindowsIEEE8021x(connectionType, iface, ifaces) {
      let i8021x = {
        state: "Unknown",
        protocol: "Unknown"
      };
      if (ifaces === "Disabled") {
        i8021x.state = "Disabled";
        i8021x.protocol = "Not defined";
        return i8021x;
      }
      if (connectionType == "wired" && ifaces.length > 0) {
        try {
          const iface8021xInfo = ifaces.find((element) => {
            return element.includes(iface + "\r\n");
          });
          const arrayIface8021xInfo = iface8021xInfo.split("\r\n");
          const state8021x = arrayIface8021xInfo.find((element) => {
            return element.includes("802.1x");
          });
          if (state8021x.includes("Disabled")) {
            i8021x.state = "Disabled";
            i8021x.protocol = "Not defined";
          } else if (state8021x.includes("Enabled")) {
            const protocol8021x = arrayIface8021xInfo.find((element) => {
              return element.includes("EAP");
            });
            i8021x.protocol = protocol8021x.split(":").pop();
            i8021x.state = "Enabled";
          }
        } catch (error) {
          return i8021x;
        }
      } else if (connectionType == "wireless") {
        let i8021xState = "";
        let i8021xProtocol = "";
        try {
          const SSID = getWindowsWirelessIfaceSSID(iface);
          if (SSID !== "Unknown") {
            let ifaceSanitized = "";
            const s = util2.isPrototypePolluted() ? "---" : util2.sanitizeShellString(SSID);
            const l = util2.mathMin(s.length, 32);
            for (let i = 0; i <= l; i++) {
              if (s[i] !== void 0) {
                ifaceSanitized = ifaceSanitized + s[i];
              }
            }
            i8021xState = execSync(`netsh wlan show profiles "${ifaceSanitized}" | findstr "802.1X"`, util2.execOptsWin);
            i8021xProtocol = execSync(`netsh wlan show profiles "${ifaceSanitized}" | findstr "EAP"`, util2.execOptsWin);
          }
          if (i8021xState.includes(":") && i8021xProtocol.includes(":")) {
            i8021x.state = i8021xState.split(":").pop();
            i8021x.protocol = i8021xProtocol.split(":").pop();
          }
        } catch (error) {
          if (error.status === 1 && error.stdout.includes("AutoConfig")) {
            i8021x.state = "Disabled";
            i8021x.protocol = "Not defined";
          }
          return i8021x;
        }
      }
      return i8021x;
    }
    __name(getWindowsIEEE8021x, "getWindowsIEEE8021x");
    function splitSectionsNics(lines) {
      const result2 = [];
      let section = [];
      lines.forEach(function(line) {
        if (!line.startsWith("	") && !line.startsWith(" ")) {
          if (section.length) {
            result2.push(section);
            section = [];
          }
        }
        section.push(line);
      });
      if (section.length) {
        result2.push(section);
      }
      return result2;
    }
    __name(splitSectionsNics, "splitSectionsNics");
    function parseLinesDarwinNics(sections) {
      let nics = [];
      sections.forEach((section) => {
        let nic = {
          iface: "",
          mtu: null,
          mac: "",
          ip6: "",
          ip4: "",
          speed: null,
          type: "",
          operstate: "",
          duplex: "",
          internal: false
        };
        const first = section[0];
        nic.iface = first.split(":")[0].trim();
        let parts2 = first.split("> mtu");
        nic.mtu = parts2.length > 1 ? parseInt(parts2[1], 10) : null;
        if (isNaN(nic.mtu)) {
          nic.mtu = null;
        }
        nic.internal = parts2[0].toLowerCase().indexOf("loopback") > -1;
        section.forEach((line) => {
          if (line.trim().startsWith("ether ")) {
            nic.mac = line.split("ether ")[1].toLowerCase().trim();
          }
          if (line.trim().startsWith("inet6 ") && !nic.ip6) {
            nic.ip6 = line.split("inet6 ")[1].toLowerCase().split("%")[0].split(" ")[0];
          }
          if (line.trim().startsWith("inet ") && !nic.ip4) {
            nic.ip4 = line.split("inet ")[1].toLowerCase().split(" ")[0];
          }
        });
        let speed = util2.getValue(section, "link rate");
        nic.speed = speed ? parseFloat(speed) : null;
        if (nic.speed === null) {
          speed = util2.getValue(section, "uplink rate");
          nic.speed = speed ? parseFloat(speed) : null;
          if (nic.speed !== null && speed.toLowerCase().indexOf("gbps") >= 0) {
            nic.speed = nic.speed * 1e3;
          }
        } else {
          if (speed.toLowerCase().indexOf("gbps") >= 0) {
            nic.speed = nic.speed * 1e3;
          }
        }
        nic.type = util2.getValue(section, "type").toLowerCase().indexOf("wi-fi") > -1 ? "wireless" : "wired";
        const operstate = util2.getValue(section, "status").toLowerCase();
        nic.operstate = operstate === "active" ? "up" : operstate === "inactive" ? "down" : "unknown";
        nic.duplex = util2.getValue(section, "media").toLowerCase().indexOf("half-duplex") > -1 ? "half" : "full";
        if (nic.ip6 || nic.ip4 || nic.mac) {
          nics.push(nic);
        }
      });
      return nics;
    }
    __name(parseLinesDarwinNics, "parseLinesDarwinNics");
    function getDarwinNics() {
      const cmd = "/sbin/ifconfig -v";
      try {
        const lines = execSync(cmd, {
          maxBuffer: 1024 * 2e4
        }).toString().split("\n");
        const nsections = splitSectionsNics(lines);
        return parseLinesDarwinNics(nsections);
      } catch (e) {
        return [];
      }
    }
    __name(getDarwinNics, "getDarwinNics");
    function getLinuxIfaceConnectionName(interfaceName) {
      const cmd = `nmcli device status 2>/dev/null | grep ${interfaceName}`;
      try {
        const result2 = execSync(cmd, util2.execOptsLinux).toString();
        const resultFormat = result2.replace(/\s+/g, " ").trim();
        const connectionNameLines = resultFormat.split(" ").slice(3);
        const connectionName = connectionNameLines.join(" ");
        return connectionName != "--" ? connectionName : "";
      } catch (e) {
        return "";
      }
    }
    __name(getLinuxIfaceConnectionName, "getLinuxIfaceConnectionName");
    function checkLinuxDCHPInterfaces(file) {
      let result2 = [];
      try {
        let cmd = `cat ${file} 2> /dev/null | grep 'iface\\|source'`;
        const lines = execSync(cmd, util2.execOptsLinux).toString().split("\n");
        lines.forEach((line) => {
          const parts2 = line.replace(/\s+/g, " ").trim().split(" ");
          if (parts2.length >= 4) {
            if (line.toLowerCase().indexOf(" inet ") >= 0 && line.toLowerCase().indexOf("dhcp") >= 0) {
              result2.push(parts2[1]);
            }
          }
          if (line.toLowerCase().includes("source")) {
            let file2 = line.split(" ")[1];
            result2 = result2.concat(checkLinuxDCHPInterfaces(file2));
          }
        });
      } catch (e) {
        util2.noop();
      }
      return result2;
    }
    __name(checkLinuxDCHPInterfaces, "checkLinuxDCHPInterfaces");
    function getLinuxDHCPNics() {
      let cmd = "ip a 2> /dev/null";
      let result2 = [];
      try {
        const lines = execSync(cmd, util2.execOptsLinux).toString().split("\n");
        const nsections = splitSectionsNics(lines);
        result2 = parseLinuxDHCPNics(nsections);
      } catch (e) {
        util2.noop();
      }
      try {
        result2 = checkLinuxDCHPInterfaces("/etc/network/interfaces");
      } catch (e) {
        util2.noop();
      }
      return result2;
    }
    __name(getLinuxDHCPNics, "getLinuxDHCPNics");
    function parseLinuxDHCPNics(sections) {
      const result2 = [];
      if (sections && sections.length) {
        sections.forEach((lines) => {
          if (lines && lines.length) {
            const parts2 = lines[0].split(":");
            if (parts2.length > 2) {
              for (let line of lines) {
                if (line.indexOf(" inet ") >= 0 && line.indexOf(" dynamic ") >= 0) {
                  const parts22 = line.split(" ");
                  const nic = parts22[parts22.length - 1].trim();
                  result2.push(nic);
                  break;
                }
              }
            }
          }
        });
      }
      return result2;
    }
    __name(parseLinuxDHCPNics, "parseLinuxDHCPNics");
    function getLinuxIfaceDHCPstatus(iface, connectionName, DHCPNics) {
      let result2 = false;
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.method;`;
        try {
          const lines = execSync(cmd, util2.execOptsLinux).toString();
          const resultFormat = lines.replace(/\s+/g, " ").trim();
          let dhcStatus = resultFormat.split(" ").slice(1).toString();
          switch (dhcStatus) {
            case "auto":
              result2 = true;
              break;
            default:
              result2 = false;
              break;
          }
          return result2;
        } catch (e) {
          return DHCPNics.indexOf(iface) >= 0;
        }
      } else {
        return DHCPNics.indexOf(iface) >= 0;
      }
    }
    __name(getLinuxIfaceDHCPstatus, "getLinuxIfaceDHCPstatus");
    function getDarwinIfaceDHCPstatus(iface) {
      let result2 = false;
      const cmd = `ipconfig getpacket "${iface}" 2>/dev/null | grep lease_time;`;
      try {
        const lines = execSync(cmd).toString().split("\n");
        if (lines.length && lines[0].startsWith("lease_time")) {
          result2 = true;
        }
      } catch (e) {
        util2.noop();
      }
      return result2;
    }
    __name(getDarwinIfaceDHCPstatus, "getDarwinIfaceDHCPstatus");
    function getLinuxIfaceDNSsuffix(connectionName) {
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep ipv4.dns-search;`;
        try {
          const result2 = execSync(cmd, util2.execOptsLinux).toString();
          const resultFormat = result2.replace(/\s+/g, " ").trim();
          const dnsSuffix = resultFormat.split(" ").slice(1).toString();
          return dnsSuffix == "--" ? "Not defined" : dnsSuffix;
        } catch (e) {
          return "Unknown";
        }
      } else {
        return "Unknown";
      }
    }
    __name(getLinuxIfaceDNSsuffix, "getLinuxIfaceDNSsuffix");
    function getLinuxIfaceIEEE8021xAuth(connectionName) {
      if (connectionName) {
        const cmd = `nmcli connection show "${connectionName}" 2>/dev/null | grep 802-1x.eap;`;
        try {
          const result2 = execSync(cmd, util2.execOptsLinux).toString();
          const resultFormat = result2.replace(/\s+/g, " ").trim();
          const authenticationProtocol = resultFormat.split(" ").slice(1).toString();
          return authenticationProtocol == "--" ? "" : authenticationProtocol;
        } catch (e) {
          return "Not defined";
        }
      } else {
        return "Not defined";
      }
    }
    __name(getLinuxIfaceIEEE8021xAuth, "getLinuxIfaceIEEE8021xAuth");
    function getLinuxIfaceIEEE8021xState(authenticationProtocol) {
      if (authenticationProtocol) {
        if (authenticationProtocol == "Not defined") {
          return "Disabled";
        }
        return "Enabled";
      } else {
        return "Unknown";
      }
    }
    __name(getLinuxIfaceIEEE8021xState, "getLinuxIfaceIEEE8021xState");
    function testVirtualNic(iface, ifaceName, mac) {
      const virtualMacs = [
        "00:00:00:00:00:00",
        "00:03:FF",
        "00:05:69",
        "00:0C:29",
        "00:0F:4B",
        "00:13:07",
        "00:13:BE",
        "00:15:5d",
        "00:16:3E",
        "00:1C:42",
        "00:21:F6",
        "00:24:0B",
        "00:50:56",
        "00:A0:B1",
        "00:E0:C8",
        "08:00:27",
        "0A:00:27",
        "18:92:2C",
        "16:DF:49",
        "3C:F3:92",
        "54:52:00",
        "FC:15:97"
      ];
      if (mac) {
        return virtualMacs.filter((item) => {
          return mac.toUpperCase().toUpperCase().startsWith(item.substring(0, mac.length));
        }).length > 0 || iface.toLowerCase().indexOf(" virtual ") > -1 || ifaceName.toLowerCase().indexOf(" virtual ") > -1 || iface.toLowerCase().indexOf("vethernet ") > -1 || ifaceName.toLowerCase().indexOf("vethernet ") > -1 || iface.toLowerCase().startsWith("veth") || ifaceName.toLowerCase().startsWith("veth") || iface.toLowerCase().startsWith("vboxnet") || ifaceName.toLowerCase().startsWith("vboxnet");
      } else {
        return false;
      }
    }
    __name(testVirtualNic, "testVirtualNic");
    function networkInterfaces(callback, rescan, defaultString) {
      if (typeof callback === "string") {
        defaultString = callback;
        rescan = true;
        callback = null;
      }
      if (typeof callback === "boolean") {
        rescan = callback;
        callback = null;
        defaultString = "";
      }
      if (typeof rescan === "undefined") {
        rescan = true;
      }
      defaultString = defaultString || "";
      defaultString = "" + defaultString;
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let ifaces = os.networkInterfaces();
          let result2 = [];
          let nics = [];
          let dnsSuffixes = [];
          let nics8021xInfo = [];
          if (_darwin || _freebsd || _openbsd || _netbsd) {
            if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
              result2 = _networkInterfaces;
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            } else {
              const defaultInterface = getDefaultNetworkInterface();
              _ifaces = JSON.parse(JSON.stringify(ifaces));
              nics = getDarwinNics();
              nics.forEach((nic) => {
                if ({}.hasOwnProperty.call(ifaces, nic.iface)) {
                  ifaces[nic.iface].forEach(function(details) {
                    if (details.family === "IPv4" || details.family === 4) {
                      nic.ip4subnet = details.netmask;
                    }
                    if (details.family === "IPv6" || details.family === 6) {
                      nic.ip6subnet = details.netmask;
                    }
                  });
                }
                let ifaceSanitized = "";
                const s = util2.isPrototypePolluted() ? "---" : util2.sanitizeShellString(nic.iface);
                const l = util2.mathMin(s.length, 2e3);
                for (let i = 0; i <= l; i++) {
                  if (s[i] !== void 0) {
                    ifaceSanitized = ifaceSanitized + s[i];
                  }
                }
                result2.push({
                  iface: nic.iface,
                  ifaceName: nic.iface,
                  default: nic.iface === defaultInterface,
                  ip4: nic.ip4,
                  ip4subnet: nic.ip4subnet || "",
                  ip6: nic.ip6,
                  ip6subnet: nic.ip6subnet || "",
                  mac: nic.mac,
                  internal: nic.internal,
                  virtual: nic.internal ? false : testVirtualNic(nic.iface, nic.iface, nic.mac),
                  operstate: nic.operstate,
                  type: nic.type,
                  duplex: nic.duplex,
                  mtu: nic.mtu,
                  speed: nic.speed,
                  dhcp: getDarwinIfaceDHCPstatus(ifaceSanitized),
                  dnsSuffix: "",
                  ieee8021xAuth: "",
                  ieee8021xState: "",
                  carrierChanges: 0
                });
              });
              _networkInterfaces = result2;
              if (defaultString.toLowerCase().indexOf("default") >= 0) {
                result2 = result2.filter((item) => item.default);
                if (result2.length > 0) {
                  result2 = result2[0];
                } else {
                  result2 = [];
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_linux) {
            if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
              result2 = _networkInterfaces;
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            } else {
              _ifaces = JSON.parse(JSON.stringify(ifaces));
              _dhcpNics = getLinuxDHCPNics();
              const defaultInterface = getDefaultNetworkInterface();
              for (let dev in ifaces) {
                let ip4 = "";
                let ip4subnet = "";
                let ip6 = "";
                let ip6subnet = "";
                let mac = "";
                let duplex = "";
                let mtu = "";
                let speed = null;
                let carrierChanges = 0;
                let dhcp = false;
                let dnsSuffix = "";
                let ieee8021xAuth = "";
                let ieee8021xState = "";
                let type = "";
                if ({}.hasOwnProperty.call(ifaces, dev)) {
                  let ifaceName = dev;
                  ifaces[dev].forEach(function(details) {
                    if (details.family === "IPv4" || details.family === 4) {
                      ip4 = details.address;
                      ip4subnet = details.netmask;
                    }
                    if (details.family === "IPv6" || details.family === 6) {
                      if (!ip6 || ip6.match(/^fe80::/i)) {
                        ip6 = details.address;
                        ip6subnet = details.netmask;
                      }
                    }
                    mac = details.mac;
                    const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                    if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                      if (Object.keys(_mac).length === 0) {
                        _mac = getMacAddresses();
                      }
                      mac = _mac[dev] || "";
                    }
                  });
                  let iface = dev.split(":")[0].trim().toLowerCase();
                  let ifaceSanitized = "";
                  const s = util2.isPrototypePolluted() ? "---" : util2.sanitizeShellString(iface);
                  const l = util2.mathMin(s.length, 2e3);
                  for (let i = 0; i <= l; i++) {
                    if (s[i] !== void 0) {
                      ifaceSanitized = ifaceSanitized + s[i];
                    }
                  }
                  const cmd = `echo -n "addr_assign_type: "; cat /sys/class/net/${ifaceSanitized}/addr_assign_type 2>/dev/null; echo;
            echo -n "address: "; cat /sys/class/net/${ifaceSanitized}/address 2>/dev/null; echo;
            echo -n "addr_len: "; cat /sys/class/net/${ifaceSanitized}/addr_len 2>/dev/null; echo;
            echo -n "broadcast: "; cat /sys/class/net/${ifaceSanitized}/broadcast 2>/dev/null; echo;
            echo -n "carrier: "; cat /sys/class/net/${ifaceSanitized}/carrier 2>/dev/null; echo;
            echo -n "carrier_changes: "; cat /sys/class/net/${ifaceSanitized}/carrier_changes 2>/dev/null; echo;
            echo -n "dev_id: "; cat /sys/class/net/${ifaceSanitized}/dev_id 2>/dev/null; echo;
            echo -n "dev_port: "; cat /sys/class/net/${ifaceSanitized}/dev_port 2>/dev/null; echo;
            echo -n "dormant: "; cat /sys/class/net/${ifaceSanitized}/dormant 2>/dev/null; echo;
            echo -n "duplex: "; cat /sys/class/net/${ifaceSanitized}/duplex 2>/dev/null; echo;
            echo -n "flags: "; cat /sys/class/net/${ifaceSanitized}/flags 2>/dev/null; echo;
            echo -n "gro_flush_timeout: "; cat /sys/class/net/${ifaceSanitized}/gro_flush_timeout 2>/dev/null; echo;
            echo -n "ifalias: "; cat /sys/class/net/${ifaceSanitized}/ifalias 2>/dev/null; echo;
            echo -n "ifindex: "; cat /sys/class/net/${ifaceSanitized}/ifindex 2>/dev/null; echo;
            echo -n "iflink: "; cat /sys/class/net/${ifaceSanitized}/iflink 2>/dev/null; echo;
            echo -n "link_mode: "; cat /sys/class/net/${ifaceSanitized}/link_mode 2>/dev/null; echo;
            echo -n "mtu: "; cat /sys/class/net/${ifaceSanitized}/mtu 2>/dev/null; echo;
            echo -n "netdev_group: "; cat /sys/class/net/${ifaceSanitized}/netdev_group 2>/dev/null; echo;
            echo -n "operstate: "; cat /sys/class/net/${ifaceSanitized}/operstate 2>/dev/null; echo;
            echo -n "proto_down: "; cat /sys/class/net/${ifaceSanitized}/proto_down 2>/dev/null; echo;
            echo -n "speed: "; cat /sys/class/net/${ifaceSanitized}/speed 2>/dev/null; echo;
            echo -n "tx_queue_len: "; cat /sys/class/net/${ifaceSanitized}/tx_queue_len 2>/dev/null; echo;
            echo -n "type: "; cat /sys/class/net/${ifaceSanitized}/type 2>/dev/null; echo;
            echo -n "wireless: "; cat /proc/net/wireless 2>/dev/null | grep ${ifaceSanitized}; echo;
            echo -n "wirelessspeed: "; iw dev ${ifaceSanitized} link 2>&1 | grep bitrate; echo;`;
                  let lines = [];
                  try {
                    lines = execSync(cmd, util2.execOptsLinux).toString().split("\n");
                    const connectionName = getLinuxIfaceConnectionName(ifaceSanitized);
                    dhcp = getLinuxIfaceDHCPstatus(ifaceSanitized, connectionName, _dhcpNics);
                    dnsSuffix = getLinuxIfaceDNSsuffix(connectionName);
                    ieee8021xAuth = getLinuxIfaceIEEE8021xAuth(connectionName);
                    ieee8021xState = getLinuxIfaceIEEE8021xState(ieee8021xAuth);
                  } catch (e) {
                    util2.noop();
                  }
                  duplex = util2.getValue(lines, "duplex");
                  duplex = duplex.startsWith("cat") ? "" : duplex;
                  mtu = parseInt(util2.getValue(lines, "mtu"), 10);
                  let myspeed = parseInt(util2.getValue(lines, "speed"), 10);
                  speed = isNaN(myspeed) ? null : myspeed;
                  let wirelessspeed = util2.getValue(lines, "wirelessspeed").split("tx bitrate: ");
                  if (speed === null && wirelessspeed.length === 2) {
                    myspeed = parseFloat(wirelessspeed[1]);
                    speed = isNaN(myspeed) ? null : myspeed;
                  }
                  carrierChanges = parseInt(util2.getValue(lines, "carrier_changes"), 10);
                  const operstate = util2.getValue(lines, "operstate");
                  type = operstate === "up" ? util2.getValue(lines, "wireless").trim() ? "wireless" : "wired" : "unknown";
                  if (ifaceSanitized === "lo" || ifaceSanitized.startsWith("bond")) {
                    type = "virtual";
                  }
                  let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                  if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                    internal = true;
                  }
                  const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                  result2.push({
                    iface: ifaceSanitized,
                    ifaceName,
                    default: iface === defaultInterface,
                    ip4,
                    ip4subnet,
                    ip6,
                    ip6subnet,
                    mac,
                    internal,
                    virtual,
                    operstate,
                    type,
                    duplex,
                    mtu,
                    speed,
                    dhcp,
                    dnsSuffix,
                    ieee8021xAuth,
                    ieee8021xState,
                    carrierChanges
                  });
                }
              }
              _networkInterfaces = result2;
              if (defaultString.toLowerCase().indexOf("default") >= 0) {
                result2 = result2.filter((item) => item.default);
                if (result2.length > 0) {
                  result2 = result2[0];
                } else {
                  result2 = [];
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_windows) {
            if (JSON.stringify(ifaces) === JSON.stringify(_ifaces) && !rescan) {
              result2 = _networkInterfaces;
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            } else {
              _ifaces = JSON.parse(JSON.stringify(ifaces));
              const defaultInterface = getDefaultNetworkInterface();
              getWindowsNics().then(function(nics2) {
                nics2.forEach((nic) => {
                  let found = false;
                  Object.keys(ifaces).forEach((key) => {
                    if (!found) {
                      ifaces[key].forEach((value2) => {
                        if (Object.keys(value2).indexOf("mac") >= 0) {
                          found = value2["mac"] === nic.mac;
                        }
                      });
                    }
                  });
                  if (!found) {
                    ifaces[nic.name] = [
                      {
                        mac: nic.mac
                      }
                    ];
                  }
                });
                nics8021xInfo = getWindowsWiredProfilesInformation();
                dnsSuffixes = getWindowsDNSsuffixes();
                for (let dev in ifaces) {
                  let ifaceSanitized = "";
                  const s = util2.isPrototypePolluted() ? "---" : util2.sanitizeShellString(dev);
                  const l = util2.mathMin(s.length, 2e3);
                  for (let i = 0; i <= l; i++) {
                    if (s[i] !== void 0) {
                      ifaceSanitized = ifaceSanitized + s[i];
                    }
                  }
                  let iface = dev;
                  let ip4 = "";
                  let ip4subnet = "";
                  let ip6 = "";
                  let ip6subnet = "";
                  let mac = "";
                  let duplex = "";
                  let mtu = "";
                  let speed = null;
                  let carrierChanges = 0;
                  let operstate = "down";
                  let dhcp = false;
                  let dnsSuffix = "";
                  let ieee8021xAuth = "";
                  let ieee8021xState = "";
                  let type = "";
                  if ({}.hasOwnProperty.call(ifaces, dev)) {
                    let ifaceName = dev;
                    ifaces[dev].forEach(function(details) {
                      if (details.family === "IPv4" || details.family === 4) {
                        ip4 = details.address;
                        ip4subnet = details.netmask;
                      }
                      if (details.family === "IPv6" || details.family === 6) {
                        if (!ip6 || ip6.match(/^fe80::/i)) {
                          ip6 = details.address;
                          ip6subnet = details.netmask;
                        }
                      }
                      mac = details.mac;
                      const nodeMainVersion = parseInt(process.versions.node.split("."), 10);
                      if (mac.indexOf("00:00:0") > -1 && (_linux || _darwin) && !details.internal && nodeMainVersion >= 8 && nodeMainVersion <= 11) {
                        if (Object.keys(_mac).length === 0) {
                          _mac = getMacAddresses();
                        }
                        mac = _mac[dev] || "";
                      }
                    });
                    dnsSuffix = getWindowsIfaceDNSsuffix(dnsSuffixes.ifaces, ifaceSanitized);
                    let foundFirst = false;
                    nics2.forEach((detail) => {
                      if (detail.mac === mac && !foundFirst) {
                        iface = detail.iface || iface;
                        ifaceName = detail.name;
                        dhcp = detail.dhcp;
                        operstate = detail.operstate;
                        speed = operstate === "up" ? detail.speed : 0;
                        type = detail.type;
                        foundFirst = true;
                      }
                    });
                    if (dev.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("wlan") >= 0 || ifaceName.toLowerCase().indexOf("802.11n") >= 0 || ifaceName.toLowerCase().indexOf("wireless") >= 0 || ifaceName.toLowerCase().indexOf("wi-fi") >= 0 || ifaceName.toLowerCase().indexOf("wifi") >= 0) {
                      type = "wireless";
                    }
                    const IEEE8021x = getWindowsIEEE8021x(type, ifaceSanitized, nics8021xInfo);
                    ieee8021xAuth = IEEE8021x.protocol;
                    ieee8021xState = IEEE8021x.state;
                    let internal = ifaces[dev] && ifaces[dev][0] ? ifaces[dev][0].internal : false;
                    if (dev.toLowerCase().indexOf("loopback") > -1 || ifaceName.toLowerCase().indexOf("loopback") > -1) {
                      internal = true;
                    }
                    const virtual = internal ? false : testVirtualNic(dev, ifaceName, mac);
                    result2.push({
                      iface,
                      ifaceName,
                      default: iface === defaultInterface,
                      ip4,
                      ip4subnet,
                      ip6,
                      ip6subnet,
                      mac,
                      internal,
                      virtual,
                      operstate,
                      type,
                      duplex,
                      mtu,
                      speed,
                      dhcp,
                      dnsSuffix,
                      ieee8021xAuth,
                      ieee8021xState,
                      carrierChanges
                    });
                  }
                }
                _networkInterfaces = result2;
                if (defaultString.toLowerCase().indexOf("default") >= 0) {
                  result2 = result2.filter((item) => item.default);
                  if (result2.length > 0) {
                    result2 = result2[0];
                  } else {
                    result2 = [];
                  }
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            }
          }
        });
      });
    }
    __name(networkInterfaces, "networkInterfaces");
    exports2.networkInterfaces = networkInterfaces;
    function calcNetworkSpeed(iface, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors) {
      let result2 = {
        iface,
        operstate,
        rx_bytes,
        rx_dropped,
        rx_errors,
        tx_bytes,
        tx_dropped,
        tx_errors,
        rx_sec: null,
        tx_sec: null,
        ms: 0
      };
      if (_network[iface] && _network[iface].ms) {
        result2.ms = Date.now() - _network[iface].ms;
        result2.rx_sec = rx_bytes - _network[iface].rx_bytes >= 0 ? (rx_bytes - _network[iface].rx_bytes) / (result2.ms / 1e3) : 0;
        result2.tx_sec = tx_bytes - _network[iface].tx_bytes >= 0 ? (tx_bytes - _network[iface].tx_bytes) / (result2.ms / 1e3) : 0;
        _network[iface].rx_bytes = rx_bytes;
        _network[iface].tx_bytes = tx_bytes;
        _network[iface].rx_sec = result2.rx_sec;
        _network[iface].tx_sec = result2.tx_sec;
        _network[iface].ms = Date.now();
        _network[iface].last_ms = result2.ms;
        _network[iface].operstate = operstate;
      } else {
        if (!_network[iface]) {
          _network[iface] = {};
        }
        _network[iface].rx_bytes = rx_bytes;
        _network[iface].tx_bytes = tx_bytes;
        _network[iface].rx_sec = null;
        _network[iface].tx_sec = null;
        _network[iface].ms = Date.now();
        _network[iface].last_ms = 0;
        _network[iface].operstate = operstate;
      }
      return result2;
    }
    __name(calcNetworkSpeed, "calcNetworkSpeed");
    function networkStats(ifaces, callback) {
      let ifacesArray = [];
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (util2.isFunction(ifaces) && !callback) {
            callback = ifaces;
            ifacesArray = [
              getDefaultNetworkInterface()
            ];
          } else {
            if (typeof ifaces !== "string" && ifaces !== void 0) {
              if (callback) {
                callback([]);
              }
              return resolve5([]);
            }
            ifaces = ifaces || getDefaultNetworkInterface();
            try {
              ifaces.__proto__.toLowerCase = util2.stringToLower;
              ifaces.__proto__.replace = util2.stringReplace;
              ifaces.__proto__.toString = util2.stringToString;
              ifaces.__proto__.substr = util2.stringSubstr;
              ifaces.__proto__.substring = util2.stringSubstring;
              ifaces.__proto__.trim = util2.stringTrim;
              ifaces.__proto__.startsWith = util2.stringStartWith;
            } catch (e) {
              Object.setPrototypeOf(ifaces, util2.stringObj);
            }
            ifaces = ifaces.trim().toLowerCase().replace(/,+/g, "|");
            ifacesArray = ifaces.split("|");
          }
          const result2 = [];
          const workload = [];
          if (ifacesArray.length && ifacesArray[0].trim() === "*") {
            ifacesArray = [];
            networkInterfaces(false).then((allIFaces) => {
              for (let iface of allIFaces) {
                ifacesArray.push(iface.iface);
              }
              networkStats(ifacesArray.join(",")).then((result3) => {
                if (callback) {
                  callback(result3);
                }
                resolve5(result3);
              });
            });
          } else {
            for (let iface of ifacesArray) {
              workload.push(networkStatsSingle(iface.trim()));
            }
            if (workload.length) {
              Promise.all(workload).then((data) => {
                if (callback) {
                  callback(data);
                }
                resolve5(data);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(networkStats, "networkStats");
    function networkStatsSingle(iface) {
      function parseLinesWindowsPerfData(sections) {
        let perfData = [];
        for (let i in sections) {
          if ({}.hasOwnProperty.call(sections, i)) {
            if (sections[i].trim() !== "") {
              let lines = sections[i].trim().split("\r\n");
              perfData.push({
                name: util2.getValue(lines, "Name", ":").replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase(),
                rx_bytes: parseInt(util2.getValue(lines, "BytesReceivedPersec", ":"), 10),
                rx_errors: parseInt(util2.getValue(lines, "PacketsReceivedErrors", ":"), 10),
                rx_dropped: parseInt(util2.getValue(lines, "PacketsReceivedDiscarded", ":"), 10),
                tx_bytes: parseInt(util2.getValue(lines, "BytesSentPersec", ":"), 10),
                tx_errors: parseInt(util2.getValue(lines, "PacketsOutboundErrors", ":"), 10),
                tx_dropped: parseInt(util2.getValue(lines, "PacketsOutboundDiscarded", ":"), 10)
              });
            }
          }
        }
        return perfData;
      }
      __name(parseLinesWindowsPerfData, "parseLinesWindowsPerfData");
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let ifaceSanitized = "";
          const s = util2.isPrototypePolluted() ? "---" : util2.sanitizeShellString(iface);
          const l = util2.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (s[i] !== void 0) {
              ifaceSanitized = ifaceSanitized + s[i];
            }
          }
          let result2 = {
            iface: ifaceSanitized,
            operstate: "unknown",
            rx_bytes: 0,
            rx_dropped: 0,
            rx_errors: 0,
            tx_bytes: 0,
            tx_dropped: 0,
            tx_errors: 0,
            rx_sec: null,
            tx_sec: null,
            ms: 0
          };
          let operstate = "unknown";
          let rx_bytes = 0;
          let tx_bytes = 0;
          let rx_dropped = 0;
          let rx_errors = 0;
          let tx_dropped = 0;
          let tx_errors = 0;
          let cmd, lines, stats;
          if (!_network[ifaceSanitized] || _network[ifaceSanitized] && !_network[ifaceSanitized].ms || _network[ifaceSanitized] && _network[ifaceSanitized].ms && Date.now() - _network[ifaceSanitized].ms >= 500) {
            if (_linux) {
              if (fs.existsSync("/sys/class/net/" + ifaceSanitized)) {
                cmd = "cat /sys/class/net/" + ifaceSanitized + "/operstate; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_bytes; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_bytes; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_dropped; cat /sys/class/net/" + ifaceSanitized + "/statistics/rx_errors; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_dropped; cat /sys/class/net/" + ifaceSanitized + "/statistics/tx_errors; ";
                exec(cmd, function(error, stdout) {
                  if (!error) {
                    lines = stdout.toString().split("\n");
                    operstate = lines[0].trim();
                    rx_bytes = parseInt(lines[1], 10);
                    tx_bytes = parseInt(lines[2], 10);
                    rx_dropped = parseInt(lines[3], 10);
                    rx_errors = parseInt(lines[4], 10);
                    tx_dropped = parseInt(lines[5], 10);
                    tx_errors = parseInt(lines[6], 10);
                    result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                  }
                  resolve5(result2);
                });
              } else {
                resolve5(result2);
              }
            }
            if (_freebsd || _openbsd || _netbsd) {
              cmd = "netstat -ibndI " + ifaceSanitized;
              exec(cmd, function(error, stdout) {
                if (!error) {
                  lines = stdout.toString().split("\n");
                  for (let i = 1; i < lines.length; i++) {
                    const line = lines[i].replace(/ +/g, " ").split(" ");
                    if (line && line[0] && line[7] && line[10]) {
                      rx_bytes = rx_bytes + parseInt(line[7]);
                      if (line[6].trim() !== "-") {
                        rx_dropped = rx_dropped + parseInt(line[6]);
                      }
                      if (line[5].trim() !== "-") {
                        rx_errors = rx_errors + parseInt(line[5]);
                      }
                      tx_bytes = tx_bytes + parseInt(line[10]);
                      if (line[12].trim() !== "-") {
                        tx_dropped = tx_dropped + parseInt(line[12]);
                      }
                      if (line[9].trim() !== "-") {
                        tx_errors = tx_errors + parseInt(line[9]);
                      }
                      operstate = "up";
                    }
                  }
                  result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                }
                resolve5(result2);
              });
            }
            if (_darwin) {
              cmd = "ifconfig " + ifaceSanitized + ' | grep "status"';
              exec(cmd, function(error, stdout) {
                result2.operstate = (stdout.toString().split(":")[1] || "").trim();
                result2.operstate = (result2.operstate || "").toLowerCase();
                result2.operstate = result2.operstate === "active" ? "up" : result2.operstate === "inactive" ? "down" : "unknown";
                cmd = "netstat -bdI " + ifaceSanitized;
                exec(cmd, function(error2, stdout2) {
                  if (!error2) {
                    lines = stdout2.toString().split("\n");
                    if (lines.length > 1 && lines[1].trim() !== "") {
                      stats = lines[1].replace(/ +/g, " ").split(" ");
                      const offset = stats.length > 11 ? 1 : 0;
                      rx_bytes = parseInt(stats[offset + 5]);
                      rx_dropped = parseInt(stats[offset + 10]);
                      rx_errors = parseInt(stats[offset + 4]);
                      tx_bytes = parseInt(stats[offset + 8]);
                      tx_dropped = parseInt(stats[offset + 10]);
                      tx_errors = parseInt(stats[offset + 7]);
                      result2 = calcNetworkSpeed(ifaceSanitized, rx_bytes, tx_bytes, result2.operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                    }
                  }
                  resolve5(result2);
                });
              });
            }
            if (_windows) {
              let perfData = [];
              let ifaceName = ifaceSanitized;
              util2.powerShell("Get-CimInstance Win32_PerfRawData_Tcpip_NetworkInterface | select Name,BytesReceivedPersec,PacketsReceivedErrors,PacketsReceivedDiscarded,BytesSentPersec,PacketsOutboundErrors,PacketsOutboundDiscarded | fl").then((stdout, error) => {
                if (!error) {
                  const psections = stdout.toString().split(/\n\s*\n/);
                  perfData = parseLinesWindowsPerfData(psections);
                }
                networkInterfaces(false).then((interfaces) => {
                  rx_bytes = 0;
                  tx_bytes = 0;
                  perfData.forEach((detail) => {
                    interfaces.forEach((det) => {
                      if ((det.iface.toLowerCase() === ifaceSanitized.toLowerCase() || det.mac.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip4.toLowerCase() === ifaceSanitized.toLowerCase() || det.ip6.toLowerCase() === ifaceSanitized.toLowerCase() || det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === ifaceSanitized.replace(/[()[\] ]+/g, "").replace("#", "_").toLowerCase()) && det.ifaceName.replace(/[()[\] ]+/g, "").replace(/#|\//g, "_").toLowerCase() === detail.name) {
                        ifaceName = det.iface;
                        rx_bytes = detail.rx_bytes;
                        rx_dropped = detail.rx_dropped;
                        rx_errors = detail.rx_errors;
                        tx_bytes = detail.tx_bytes;
                        tx_dropped = detail.tx_dropped;
                        tx_errors = detail.tx_errors;
                        operstate = det.operstate;
                      }
                    });
                  });
                  if (rx_bytes && tx_bytes) {
                    result2 = calcNetworkSpeed(ifaceName, parseInt(rx_bytes), parseInt(tx_bytes), operstate, rx_dropped, rx_errors, tx_dropped, tx_errors);
                  }
                  resolve5(result2);
                });
              });
            }
          } else {
            result2.rx_bytes = _network[ifaceSanitized].rx_bytes;
            result2.tx_bytes = _network[ifaceSanitized].tx_bytes;
            result2.rx_sec = _network[ifaceSanitized].rx_sec;
            result2.tx_sec = _network[ifaceSanitized].tx_sec;
            result2.ms = _network[ifaceSanitized].last_ms;
            result2.operstate = _network[ifaceSanitized].operstate;
            resolve5(result2);
          }
        });
      });
    }
    __name(networkStatsSingle, "networkStatsSingle");
    exports2.networkStats = networkStats;
    function getProcessName(processes, pid) {
      let cmd = "";
      processes.forEach((line) => {
        const parts2 = line.split(" ");
        const id = parseInt(parts2[0], 10) || -1;
        if (id === pid) {
          parts2.shift();
          cmd = parts2.join(" ").split(":")[0];
        }
      });
      cmd = cmd.split(" -")[0];
      cmd = cmd.split(" /")[0];
      return cmd;
    }
    __name(getProcessName, "getProcessName");
    function networkConnections(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = 'export LC_ALL=C; netstat -tunap | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
            if (_freebsd || _openbsd || _netbsd) {
              cmd = 'export LC_ALL=C; netstat -na | grep "ESTABLISHED\\|SYN_SENT\\|SYN_RECV\\|FIN_WAIT1\\|FIN_WAIT2\\|TIME_WAIT\\|CLOSE\\|CLOSE_WAIT\\|LAST_ACK\\|LISTEN\\|CLOSING\\|UNKNOWN"; unset LC_ALL';
            }
            exec(cmd, {
              maxBuffer: 1024 * 2e4
            }, function(error, stdout) {
              let lines = stdout.toString().split("\n");
              if (!error && (lines.length > 1 || lines[0] != "")) {
                lines.forEach(function(line) {
                  line = line.replace(/ +/g, " ").split(" ");
                  if (line.length >= 7) {
                    let localip = line[3];
                    let localport = "";
                    let localaddress = line[3].split(":");
                    if (localaddress.length > 1) {
                      localport = localaddress[localaddress.length - 1];
                      localaddress.pop();
                      localip = localaddress.join(":");
                    }
                    let peerip = line[4];
                    let peerport = "";
                    let peeraddress = line[4].split(":");
                    if (peeraddress.length > 1) {
                      peerport = peeraddress[peeraddress.length - 1];
                      peeraddress.pop();
                      peerip = peeraddress.join(":");
                    }
                    let connstate = line[5];
                    let proc = line[6].split("/");
                    if (connstate) {
                      result2.push({
                        protocol: line[0],
                        localAddress: localip,
                        localPort: localport,
                        peerAddress: peerip,
                        peerPort: peerport,
                        state: connstate,
                        pid: proc[0] && proc[0] !== "-" ? parseInt(proc[0], 10) : null,
                        process: proc[1] ? proc[1].split(" ")[0].split(":")[0] : ""
                      });
                    }
                  }
                });
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              } else {
                cmd = 'ss -tunap | grep "ESTAB\\|SYN-SENT\\|SYN-RECV\\|FIN-WAIT1\\|FIN-WAIT2\\|TIME-WAIT\\|CLOSE\\|CLOSE-WAIT\\|LAST-ACK\\|LISTEN\\|CLOSING"';
                exec(cmd, {
                  maxBuffer: 1024 * 2e4
                }, function(error2, stdout2) {
                  if (!error2) {
                    let lines2 = stdout2.toString().split("\n");
                    lines2.forEach(function(line) {
                      line = line.replace(/ +/g, " ").split(" ");
                      if (line.length >= 6) {
                        let localip = line[4];
                        let localport = "";
                        let localaddress = line[4].split(":");
                        if (localaddress.length > 1) {
                          localport = localaddress[localaddress.length - 1];
                          localaddress.pop();
                          localip = localaddress.join(":");
                        }
                        let peerip = line[5];
                        let peerport = "";
                        let peeraddress = line[5].split(":");
                        if (peeraddress.length > 1) {
                          peerport = peeraddress[peeraddress.length - 1];
                          peeraddress.pop();
                          peerip = peeraddress.join(":");
                        }
                        let connstate = line[1];
                        if (connstate === "ESTAB") {
                          connstate = "ESTABLISHED";
                        }
                        if (connstate === "TIME-WAIT") {
                          connstate = "TIME_WAIT";
                        }
                        let pid = null;
                        let process1 = "";
                        if (line.length >= 7 && line[6].indexOf("users:") > -1) {
                          let proc = line[6].replace('users:(("', "").replace(/"/g, "").split(",");
                          if (proc.length > 2) {
                            process1 = proc[0].split(" ")[0].split(":")[0];
                            pid = parseInt(proc[1], 10);
                          }
                        }
                        if (connstate) {
                          result2.push({
                            protocol: line[0],
                            localAddress: localip,
                            localPort: localport,
                            peerAddress: peerip,
                            peerPort: peerport,
                            state: connstate,
                            pid,
                            process: process1
                          });
                        }
                      }
                    });
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                });
              }
            });
          }
          if (_darwin) {
            let cmd = 'netstat -natvln | head -n2; netstat -natvln | grep "tcp4\\|tcp6\\|udp4\\|udp6"';
            const states = "ESTABLISHED|SYN_SENT|SYN_RECV|FIN_WAIT1|FIN_WAIT_1|FIN_WAIT2|FIN_WAIT_2|TIME_WAIT|CLOSE|CLOSE_WAIT|LAST_ACK|LISTEN|CLOSING|UNKNOWN".split("|");
            exec(cmd, {
              maxBuffer: 1024 * 2e4
            }, function(error, stdout) {
              if (!error) {
                exec("ps -axo pid,command", {
                  maxBuffer: 1024 * 2e4
                }, function(err2, stdout2) {
                  let processes = stdout2.toString().split("\n");
                  processes = processes.map((line) => {
                    return line.trim().replace(/ +/g, " ");
                  });
                  let lines = stdout.toString().split("\n");
                  lines.shift();
                  let pidPos = 8;
                  if (lines.length > 1 && lines[0].indexOf("pid") > 0) {
                    const header = (lines.shift() || "").replace(/ Address/g, "_Address").replace(/ +/g, " ").split(" ");
                    pidPos = header.indexOf("pid");
                  }
                  lines.forEach(function(line) {
                    line = line.replace(/ +/g, " ").split(" ");
                    if (line.length >= 8) {
                      let localip = line[3];
                      let localport = "";
                      let localaddress = line[3].split(".");
                      if (localaddress.length > 1) {
                        localport = localaddress[localaddress.length - 1];
                        localaddress.pop();
                        localip = localaddress.join(".");
                      }
                      let peerip = line[4];
                      let peerport = "";
                      let peeraddress = line[4].split(".");
                      if (peeraddress.length > 1) {
                        peerport = peeraddress[peeraddress.length - 1];
                        peeraddress.pop();
                        peerip = peeraddress.join(".");
                      }
                      const hasState = states.indexOf(line[5]) >= 0;
                      let connstate = hasState ? line[5] : "UNKNOWN";
                      let pid = parseInt(line[pidPos + (hasState ? 0 : -1)], 10);
                      if (connstate) {
                        result2.push({
                          protocol: line[0],
                          localAddress: localip,
                          localPort: localport,
                          peerAddress: peerip,
                          peerPort: peerport,
                          state: connstate,
                          pid,
                          process: getProcessName(processes, pid)
                        });
                      }
                    }
                  });
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                });
              }
            });
          }
          if (_windows) {
            let cmd = "netstat -nao";
            try {
              exec(cmd, util2.execOptsWin, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\r\n");
                  lines.forEach(function(line) {
                    line = line.trim().replace(/ +/g, " ").split(" ");
                    if (line.length >= 4) {
                      let localip = line[1];
                      let localport = "";
                      let localaddress = line[1].split(":");
                      if (localaddress.length > 1) {
                        localport = localaddress[localaddress.length - 1];
                        localaddress.pop();
                        localip = localaddress.join(":");
                      }
                      localip = localip.replace(/\[/g, "").replace(/\]/g, "");
                      let peerip = line[2];
                      let peerport = "";
                      let peeraddress = line[2].split(":");
                      if (peeraddress.length > 1) {
                        peerport = peeraddress[peeraddress.length - 1];
                        peeraddress.pop();
                        peerip = peeraddress.join(":");
                      }
                      peerip = peerip.replace(/\[/g, "").replace(/\]/g, "");
                      let pid = util2.toInt(line[4]);
                      let connstate = line[3];
                      if (connstate === "HERGESTELLT") {
                        connstate = "ESTABLISHED";
                      }
                      if (connstate.startsWith("ABH")) {
                        connstate = "LISTEN";
                      }
                      if (connstate === "SCHLIESSEN_WARTEN") {
                        connstate = "CLOSE_WAIT";
                      }
                      if (connstate === "WARTEND") {
                        connstate = "TIME_WAIT";
                      }
                      if (connstate === "SYN_GESENDET") {
                        connstate = "SYN_SENT";
                      }
                      if (connstate === "LISTENING") {
                        connstate = "LISTEN";
                      }
                      if (connstate === "SYN_RECEIVED") {
                        connstate = "SYN_RECV";
                      }
                      if (connstate === "FIN_WAIT_1") {
                        connstate = "FIN_WAIT1";
                      }
                      if (connstate === "FIN_WAIT_2") {
                        connstate = "FIN_WAIT2";
                      }
                      if (line[0].toLowerCase() !== "udp" && connstate) {
                        result2.push({
                          protocol: line[0].toLowerCase(),
                          localAddress: localip,
                          localPort: localport,
                          peerAddress: peerip,
                          peerPort: peerport,
                          state: connstate,
                          pid,
                          process: ""
                        });
                      } else if (line[0].toLowerCase() === "udp") {
                        result2.push({
                          protocol: line[0].toLowerCase(),
                          localAddress: localip,
                          localPort: localport,
                          peerAddress: peerip,
                          peerPort: peerport,
                          state: "",
                          pid: parseInt(line[3], 10),
                          process: ""
                        });
                      }
                    }
                  });
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(networkConnections, "networkConnections");
    exports2.networkConnections = networkConnections;
    function networkGatewayDefault(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = "";
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = "ip route get 1";
            try {
              exec(cmd, {
                maxBuffer: 1024 * 2e4
              }, function(error, stdout) {
                if (!error) {
                  let lines = stdout.toString().split("\n");
                  const line = lines && lines[0] ? lines[0] : "";
                  let parts2 = line.split(" via ");
                  if (parts2 && parts2[1]) {
                    parts2 = parts2[1].split(" ");
                    result2 = parts2[0];
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_darwin) {
            let cmd = "route -n get default";
            try {
              exec(cmd, {
                maxBuffer: 1024 * 2e4
              }, function(error, stdout) {
                if (!error) {
                  const lines = stdout.toString().split("\n").map((line) => line.trim());
                  result2 = util2.getValue(lines, "gateway");
                }
                if (!result2) {
                  cmd = "netstat -rn | awk '/default/ {print $2}'";
                  exec(cmd, {
                    maxBuffer: 1024 * 2e4
                  }, function(error2, stdout2) {
                    const lines = stdout2.toString().split("\n").map((line) => line.trim());
                    result2 = lines.find((line) => /^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/.test(line));
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
          if (_windows) {
            try {
              exec("netstat -r", util2.execOptsWin, function(error, stdout) {
                const lines = stdout.toString().split(os.EOL);
                lines.forEach((line) => {
                  line = line.replace(/\s+/g, " ").trim();
                  if (line.indexOf("0.0.0.0 0.0.0.0") > -1 && !/[a-zA-Z]/.test(line)) {
                    const parts2 = line.split(" ");
                    if (parts2.length >= 5 && parts2[parts2.length - 3].indexOf(".") > -1) {
                      result2 = parts2[parts2.length - 3];
                    }
                  }
                });
                if (!result2) {
                  util2.powerShell("Get-CimInstance -ClassName Win32_IP4RouteTable | Where-Object { $_.Destination -eq '0.0.0.0' -and $_.Mask -eq '0.0.0.0' }").then((data) => {
                    let lines2 = data.toString().split("\r\n");
                    if (lines2.length > 1 && !result2) {
                      result2 = util2.getValue(lines2, "NextHop");
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    }
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(networkGatewayDefault, "networkGatewayDefault");
    exports2.networkGatewayDefault = networkGatewayDefault;
  }
});

// node_modules/systeminformation/lib/wifi.js
var require_wifi = __commonJS({
  "node_modules/systeminformation/lib/wifi.js"(exports2) {
    "use strict";
    var os = require("os");
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    function wifiDBFromQuality(quality) {
      const qual = parseFloat(quality);
      if (qual < 0) {
        return 0;
      }
      if (qual >= 100) {
        return -50;
      }
      return qual / 2 - 100;
    }
    __name(wifiDBFromQuality, "wifiDBFromQuality");
    function wifiQualityFromDB(db) {
      const result2 = 2 * (parseFloat(db) + 100);
      return result2 <= 100 ? result2 : 100;
    }
    __name(wifiQualityFromDB, "wifiQualityFromDB");
    var _wifi_frequencies = {
      1: 2412,
      2: 2417,
      3: 2422,
      4: 2427,
      5: 2432,
      6: 2437,
      7: 2442,
      8: 2447,
      9: 2452,
      10: 2457,
      11: 2462,
      12: 2467,
      13: 2472,
      14: 2484,
      32: 5160,
      34: 5170,
      36: 5180,
      38: 5190,
      40: 5200,
      42: 5210,
      44: 5220,
      46: 5230,
      48: 5240,
      50: 5250,
      52: 5260,
      54: 5270,
      56: 5280,
      58: 5290,
      60: 5300,
      62: 5310,
      64: 5320,
      68: 5340,
      96: 5480,
      100: 5500,
      102: 5510,
      104: 5520,
      106: 5530,
      108: 5540,
      110: 5550,
      112: 5560,
      114: 5570,
      116: 5580,
      118: 5590,
      120: 5600,
      122: 5610,
      124: 5620,
      126: 5630,
      128: 5640,
      132: 5660,
      134: 5670,
      136: 5680,
      138: 5690,
      140: 5700,
      142: 5710,
      144: 5720,
      149: 5745,
      151: 5755,
      153: 5765,
      155: 5775,
      157: 5785,
      159: 5795,
      161: 5805,
      165: 5825,
      169: 5845,
      173: 5865,
      183: 4915,
      184: 4920,
      185: 4925,
      187: 4935,
      188: 4940,
      189: 4945,
      192: 4960,
      196: 4980
    };
    function wifiFrequencyFromChannel(channel) {
      return {}.hasOwnProperty.call(_wifi_frequencies, channel) ? _wifi_frequencies[channel] : null;
    }
    __name(wifiFrequencyFromChannel, "wifiFrequencyFromChannel");
    function wifiChannelFromFrequencs(frequency) {
      let channel = 0;
      for (let key in _wifi_frequencies) {
        if ({}.hasOwnProperty.call(_wifi_frequencies, key)) {
          if (_wifi_frequencies[key] === frequency) {
            channel = util2.toInt(key);
          }
        }
      }
      return channel;
    }
    __name(wifiChannelFromFrequencs, "wifiChannelFromFrequencs");
    function ifaceListLinux() {
      const result2 = [];
      const cmd = "iw dev 2>/dev/null";
      try {
        const all = execSync(cmd, util2.execOptsLinux).toString().split("\n").map((line) => line.trim()).join("\n");
        const parts2 = all.split("\nInterface ");
        parts2.shift();
        parts2.forEach((ifaceDetails) => {
          const lines = ifaceDetails.split("\n");
          const iface = lines[0];
          const id = util2.toInt(util2.getValue(lines, "ifindex", " "));
          const mac = util2.getValue(lines, "addr", " ");
          const channel = util2.toInt(util2.getValue(lines, "channel", " "));
          result2.push({
            id,
            iface,
            mac,
            channel
          });
        });
        return result2;
      } catch (e) {
        try {
          const all = execSync("nmcli -t -f general,wifi-properties,wired-properties,interface-flags,capabilities,nsp device show 2>/dev/null", util2.execOptsLinux).toString();
          const parts2 = all.split("\n\n");
          let i = 1;
          parts2.forEach((ifaceDetails) => {
            const lines = ifaceDetails.split("\n");
            const iface = util2.getValue(lines, "GENERAL.DEVICE");
            const type = util2.getValue(lines, "GENERAL.TYPE");
            const id = i++;
            const mac = util2.getValue(lines, "GENERAL.HWADDR");
            const channel = "";
            if (type.toLowerCase() === "wifi") {
              result2.push({
                id,
                iface,
                mac,
                channel
              });
            }
          });
          return result2;
        } catch (e2) {
          return [];
        }
      }
    }
    __name(ifaceListLinux, "ifaceListLinux");
    function nmiDeviceLinux(iface) {
      const cmd = `nmcli -t -f general,wifi-properties,capabilities,ip4,ip6 device show ${iface} 2> /dev/null`;
      try {
        const lines = execSync(cmd, util2.execOptsLinux).toString().split("\n");
        const ssid = util2.getValue(lines, "GENERAL.CONNECTION");
        return {
          iface,
          type: util2.getValue(lines, "GENERAL.TYPE"),
          vendor: util2.getValue(lines, "GENERAL.VENDOR"),
          product: util2.getValue(lines, "GENERAL.PRODUCT"),
          mac: util2.getValue(lines, "GENERAL.HWADDR").toLowerCase(),
          ssid: ssid !== "--" ? ssid : null
        };
      } catch (e) {
        return {};
      }
    }
    __name(nmiDeviceLinux, "nmiDeviceLinux");
    function nmiConnectionLinux(ssid) {
      const cmd = `nmcli -t --show-secrets connection show ${ssid} 2>/dev/null`;
      try {
        const lines = execSync(cmd, util2.execOptsLinux).toString().split("\n");
        const bssid = util2.getValue(lines, "802-11-wireless.seen-bssids").toLowerCase();
        return {
          ssid: ssid !== "--" ? ssid : null,
          uuid: util2.getValue(lines, "connection.uuid"),
          type: util2.getValue(lines, "connection.type"),
          autoconnect: util2.getValue(lines, "connection.autoconnect") === "yes",
          security: util2.getValue(lines, "802-11-wireless-security.key-mgmt"),
          bssid: bssid !== "--" ? bssid : null
        };
      } catch (e) {
        return {};
      }
    }
    __name(nmiConnectionLinux, "nmiConnectionLinux");
    function wpaConnectionLinux(iface) {
      if (!iface) {
        return {};
      }
      const cmd = `wpa_cli -i ${iface} status 2>&1`;
      try {
        const lines = execSync(cmd, util2.execOptsLinux).toString().split("\n");
        const freq = util2.toInt(util2.getValue(lines, "freq", "="));
        return {
          ssid: util2.getValue(lines, "ssid", "="),
          uuid: util2.getValue(lines, "uuid", "="),
          security: util2.getValue(lines, "key_mgmt", "="),
          freq,
          channel: wifiChannelFromFrequencs(freq),
          bssid: util2.getValue(lines, "bssid", "=").toLowerCase()
        };
      } catch (e) {
        return {};
      }
    }
    __name(wpaConnectionLinux, "wpaConnectionLinux");
    function getWifiNetworkListNmi() {
      const result2 = [];
      const cmd = "nmcli -t -m multiline --fields active,ssid,bssid,mode,chan,freq,signal,security,wpa-flags,rsn-flags device wifi list 2>/dev/null";
      try {
        const stdout = execSync(cmd, util2.execOptsLinux);
        const parts2 = stdout.toString().split("ACTIVE:");
        parts2.shift();
        parts2.forEach((part) => {
          part = "ACTIVE:" + part;
          const lines = part.split(os.EOL);
          const channel = util2.getValue(lines, "CHAN");
          const frequency = util2.getValue(lines, "FREQ").toLowerCase().replace("mhz", "").trim();
          const security = util2.getValue(lines, "SECURITY").replace("(", "").replace(")", "");
          const wpaFlags = util2.getValue(lines, "WPA-FLAGS").replace("(", "").replace(")", "");
          const rsnFlags = util2.getValue(lines, "RSN-FLAGS").replace("(", "").replace(")", "");
          const quality = util2.getValue(lines, "SIGNAL");
          result2.push({
            ssid: util2.getValue(lines, "SSID"),
            bssid: util2.getValue(lines, "BSSID").toLowerCase(),
            mode: util2.getValue(lines, "MODE"),
            channel: channel ? parseInt(channel, 10) : null,
            frequency: frequency ? parseInt(frequency, 10) : null,
            signalLevel: wifiDBFromQuality(quality),
            quality: quality ? parseInt(quality, 10) : null,
            security: security && security !== "none" ? security.split(" ") : [],
            wpaFlags: wpaFlags && wpaFlags !== "none" ? wpaFlags.split(" ") : [],
            rsnFlags: rsnFlags && rsnFlags !== "none" ? rsnFlags.split(" ") : []
          });
        });
        return result2;
      } catch (e) {
        return [];
      }
    }
    __name(getWifiNetworkListNmi, "getWifiNetworkListNmi");
    function getWifiNetworkListIw(iface) {
      const result2 = [];
      try {
        let iwlistParts = execSync(`export LC_ALL=C; iwlist ${iface} scan 2>&1; unset LC_ALL`, util2.execOptsLinux).toString().split("        Cell ");
        if (iwlistParts[0].indexOf("resource busy") >= 0) {
          return -1;
        }
        if (iwlistParts.length > 1) {
          iwlistParts.shift();
          iwlistParts.forEach((element) => {
            const lines = element.split("\n");
            const channel = util2.getValue(lines, "channel", ":", true);
            const address = lines && lines.length && lines[0].indexOf("Address:") >= 0 ? lines[0].split("Address:")[1].trim().toLowerCase() : "";
            const mode = util2.getValue(lines, "mode", ":", true);
            const frequency = util2.getValue(lines, "frequency", ":", true);
            const qualityString = util2.getValue(lines, "Quality", "=", true);
            const dbParts = qualityString.toLowerCase().split("signal level=");
            const db = dbParts.length > 1 ? util2.toInt(dbParts[1]) : 0;
            const quality = db ? wifiQualityFromDB(db) : 0;
            const ssid = util2.getValue(lines, "essid", ":", true);
            const isWpa = element.indexOf(" WPA ") >= 0;
            const isWpa2 = element.indexOf("WPA2 ") >= 0;
            const security = [];
            if (isWpa) {
              security.push("WPA");
            }
            if (isWpa2) {
              security.push("WPA2");
            }
            const wpaFlags = [];
            let wpaFlag = "";
            lines.forEach(function(line) {
              const l = line.trim().toLowerCase();
              if (l.indexOf("group cipher") >= 0) {
                if (wpaFlag) {
                  wpaFlags.push(wpaFlag);
                }
                const parts2 = l.split(":");
                if (parts2.length > 1) {
                  wpaFlag = parts2[1].trim().toUpperCase();
                }
              }
              if (l.indexOf("pairwise cipher") >= 0) {
                const parts2 = l.split(":");
                if (parts2.length > 1) {
                  if (parts2[1].indexOf("tkip")) {
                    wpaFlag = wpaFlag ? "TKIP/" + wpaFlag : "TKIP";
                  } else if (parts2[1].indexOf("ccmp")) {
                    wpaFlag = wpaFlag ? "CCMP/" + wpaFlag : "CCMP";
                  } else if (parts2[1].indexOf("proprietary")) {
                    wpaFlag = wpaFlag ? "PROP/" + wpaFlag : "PROP";
                  }
                }
              }
              if (l.indexOf("authentication suites") >= 0) {
                const parts2 = l.split(":");
                if (parts2.length > 1) {
                  if (parts2[1].indexOf("802.1x")) {
                    wpaFlag = wpaFlag ? "802.1x/" + wpaFlag : "802.1x";
                  } else if (parts2[1].indexOf("psk")) {
                    wpaFlag = wpaFlag ? "PSK/" + wpaFlag : "PSK";
                  }
                }
              }
            });
            if (wpaFlag) {
              wpaFlags.push(wpaFlag);
            }
            result2.push({
              ssid,
              bssid: address,
              mode,
              channel: channel ? util2.toInt(channel) : null,
              frequency: frequency ? util2.toInt(frequency.replace(".", "")) : null,
              signalLevel: db,
              quality,
              security,
              wpaFlags,
              rsnFlags: []
            });
          });
        }
        return result2;
      } catch (e) {
        return -1;
      }
    }
    __name(getWifiNetworkListIw, "getWifiNetworkListIw");
    function parseWifiDarwin(wifiStr) {
      const result2 = [];
      try {
        let wifiObj = JSON.parse(wifiStr);
        wifiObj = wifiObj.SPAirPortDataType[0].spairport_airport_interfaces[0].spairport_airport_other_local_wireless_networks;
        wifiObj.forEach(function(wifiItem) {
          let security = [];
          const sm = wifiItem.spairport_security_mode;
          if (sm === "spairport_security_mode_wep") {
            security.push("WEP");
          } else if (sm === "spairport_security_mode_wpa2_personal") {
            security.push("WPA2");
          } else if (sm.startsWith("spairport_security_mode_wpa2_enterprise")) {
            security.push("WPA2 EAP");
          } else if (sm.startsWith("pairport_security_mode_wpa3_transition")) {
            security.push("WPA2/WPA3");
          } else if (sm.startsWith("pairport_security_mode_wpa3")) {
            security.push("WPA3");
          }
          const channel = parseInt(("" + wifiItem.spairport_network_channel).split(" ")[0]) || 0;
          const signalLevel = wifiItem.spairport_signal_noise || null;
          result2.push({
            ssid: wifiItem._name || "",
            bssid: wifiItem.spairport_network_bssid || null,
            mode: wifiItem.spairport_network_phymode,
            channel,
            frequency: wifiFrequencyFromChannel(channel),
            signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,
            quality: wifiQualityFromDB(signalLevel),
            security,
            wpaFlags: [],
            rsnFlags: []
          });
        });
        return result2;
      } catch (e) {
        return result2;
      }
    }
    __name(parseWifiDarwin, "parseWifiDarwin");
    function wifiNetworks(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = [];
          if (_linux) {
            result2 = getWifiNetworkListNmi();
            if (result2.length === 0) {
              try {
                const iwconfigParts = execSync("export LC_ALL=C; iwconfig 2>/dev/null; unset LC_ALL", util2.execOptsLinux).toString().split("\n\n");
                let iface = "";
                iwconfigParts.forEach((element) => {
                  if (element.indexOf("no wireless") === -1 && element.trim() !== "") {
                    iface = element.split(" ")[0];
                  }
                });
                if (iface) {
                  let ifaceSanitized = "";
                  const s = util2.isPrototypePolluted() ? "---" : util2.sanitizeShellString(iface, true);
                  const l = util2.mathMin(s.length, 2e3);
                  for (let i = 0; i <= l; i++) {
                    if (s[i] !== void 0) {
                      ifaceSanitized = ifaceSanitized + s[i];
                    }
                  }
                  const res = getWifiNetworkListIw(ifaceSanitized);
                  if (res === -1) {
                    setTimeout(function(iface2) {
                      const res2 = getWifiNetworkListIw(iface2);
                      if (res2 != -1) {
                        result2 = res2;
                      }
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    }, 4e3);
                  } else {
                    result2 = res;
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  }
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              } catch (e) {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            } else {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          } else if (_darwin) {
            let cmd = "system_profiler SPAirPortDataType -json 2>/dev/null";
            exec(cmd, {
              maxBuffer: 1024 * 4e4
            }, function(error, stdout) {
              result2 = parseWifiDarwin(stdout.toString());
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          } else if (_windows) {
            let cmd = "netsh wlan show networks mode=Bssid";
            util2.powerShell(cmd).then((stdout) => {
              const ssidParts = stdout.toString("utf8").split(os.EOL + os.EOL + "SSID ");
              ssidParts.shift();
              ssidParts.forEach((ssidPart) => {
                const ssidLines = ssidPart.split(os.EOL);
                if (ssidLines && ssidLines.length >= 8 && ssidLines[0].indexOf(":") >= 0) {
                  const bssidsParts = ssidPart.split(" BSSID");
                  bssidsParts.shift();
                  bssidsParts.forEach((bssidPart) => {
                    const bssidLines = bssidPart.split(os.EOL);
                    const bssidLine = bssidLines[0].split(":");
                    bssidLine.shift();
                    const bssid = bssidLine.join(":").trim().toLowerCase();
                    const channel = bssidLines[3].split(":").pop().trim();
                    const quality = bssidLines[1].split(":").pop().trim();
                    result2.push({
                      ssid: ssidLines[0].split(":").pop().trim(),
                      bssid,
                      mode: "",
                      channel: channel ? parseInt(channel, 10) : null,
                      frequency: wifiFrequencyFromChannel(channel),
                      signalLevel: wifiDBFromQuality(quality),
                      quality: quality ? parseInt(quality, 10) : null,
                      security: [
                        ssidLines[2].split(":").pop().trim()
                      ],
                      wpaFlags: [
                        ssidLines[3].split(":").pop().trim()
                      ],
                      rsnFlags: []
                    });
                  });
                }
              });
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(wifiNetworks, "wifiNetworks");
    exports2.wifiNetworks = wifiNetworks;
    function getVendor(model) {
      model = model.toLowerCase();
      let result2 = "";
      if (model.indexOf("intel") >= 0) {
        result2 = "Intel";
      } else if (model.indexOf("realtek") >= 0) {
        result2 = "Realtek";
      } else if (model.indexOf("qualcom") >= 0) {
        result2 = "Qualcom";
      } else if (model.indexOf("broadcom") >= 0) {
        result2 = "Broadcom";
      } else if (model.indexOf("cavium") >= 0) {
        result2 = "Cavium";
      } else if (model.indexOf("cisco") >= 0) {
        result2 = "Cisco";
      } else if (model.indexOf("marvel") >= 0) {
        result2 = "Marvel";
      } else if (model.indexOf("zyxel") >= 0) {
        result2 = "Zyxel";
      } else if (model.indexOf("melanox") >= 0) {
        result2 = "Melanox";
      } else if (model.indexOf("d-link") >= 0) {
        result2 = "D-Link";
      } else if (model.indexOf("tp-link") >= 0) {
        result2 = "TP-Link";
      } else if (model.indexOf("asus") >= 0) {
        result2 = "Asus";
      } else if (model.indexOf("linksys") >= 0) {
        result2 = "Linksys";
      }
      return result2;
    }
    __name(getVendor, "getVendor");
    function wifiConnections(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          const result2 = [];
          if (_linux) {
            const ifaces = ifaceListLinux();
            const networkList = getWifiNetworkListNmi();
            ifaces.forEach((ifaceDetail) => {
              let ifaceSanitized = "";
              const s = util2.isPrototypePolluted() ? "---" : util2.sanitizeShellString(ifaceDetail.iface, true);
              const ll = util2.mathMin(s.length, 2e3);
              for (let i = 0; i <= ll; i++) {
                if (s[i] !== void 0) {
                  ifaceSanitized = ifaceSanitized + s[i];
                }
              }
              const nmiDetails = nmiDeviceLinux(ifaceSanitized);
              const wpaDetails = wpaConnectionLinux(ifaceSanitized);
              const ssid = nmiDetails.ssid || wpaDetails.ssid;
              const network = networkList.filter((nw) => nw.ssid === ssid);
              let ssidSanitized = "";
              const t = util2.isPrototypePolluted() ? "---" : util2.sanitizeShellString(ssid, true);
              const l = util2.mathMin(t.length, 32);
              for (let i = 0; i <= l; i++) {
                if (t[i] !== void 0) {
                  ssidSanitized = ssidSanitized + t[i];
                }
              }
              const nmiConnection = nmiConnectionLinux(ssidSanitized);
              const channel = network && network.length && network[0].channel ? network[0].channel : wpaDetails.channel ? wpaDetails.channel : null;
              const bssid = network && network.length && network[0].bssid ? network[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null;
              const signalLevel = network && network.length && network[0].signalLevel ? network[0].signalLevel : null;
              if (ssid && bssid) {
                result2.push({
                  id: ifaceDetail.id,
                  iface: ifaceDetail.iface,
                  model: nmiDetails.product,
                  ssid,
                  bssid: network && network.length && network[0].bssid ? network[0].bssid : wpaDetails.bssid ? wpaDetails.bssid : null,
                  channel,
                  frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                  type: nmiConnection.type ? nmiConnection.type : "802.11",
                  security: nmiConnection.security ? nmiConnection.security : wpaDetails.security ? wpaDetails.security : null,
                  signalLevel,
                  quality: wifiQualityFromDB(signalLevel),
                  txRate: null
                });
              }
            });
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          } else if (_darwin) {
            let cmd = 'system_profiler SPNetworkDataType SPAirPortDataType -xml 2>/dev/null; echo "######" ; ioreg -n AppleBCMWLANSkywalkInterface -r 2>/dev/null';
            exec(cmd, function(error, stdout) {
              try {
                const parts2 = stdout.toString().split("######");
                const profilerObj = util2.plistParser(parts2[0]);
                const networkObj = profilerObj[0]._SPCommandLineArguments.indexOf("SPNetworkDataType") >= 0 ? profilerObj[0]._items : profilerObj[1]._items;
                const airportObj = profilerObj[0]._SPCommandLineArguments.indexOf("SPAirPortDataType") >= 0 ? profilerObj[0]._items[0].spairport_airport_interfaces : profilerObj[1]._items[0].spairport_airport_interfaces;
                let lines3 = [];
                if (parts2[1].indexOf("  | {") > 0 && parts2[1].indexOf("  | }") > parts2[1].indexOf("  | {")) {
                  lines3 = parts2[1].split("  | {")[1].split("  | }")[0].replace(/ \| /g, "").replace(/"/g, "").split("\n");
                }
                const networkWifiObj = networkObj.find((item) => {
                  return item._name === "Wi-Fi";
                });
                const airportWifiObj = airportObj[0].spairport_current_network_information;
                const channel = parseInt(("" + airportWifiObj.spairport_network_channel).split(" ")[0]) || 0;
                const signalLevel = airportWifiObj.spairport_signal_noise || null;
                let security = [];
                const sm = airportWifiObj.spairport_security_mode;
                if (sm === "spairport_security_mode_wep") {
                  security.push("WEP");
                } else if (sm === "spairport_security_mode_wpa2_personal") {
                  security.push("WPA2");
                } else if (sm.startsWith("spairport_security_mode_wpa2_enterprise")) {
                  security.push("WPA2 EAP");
                } else if (sm.startsWith("pairport_security_mode_wpa3_transition")) {
                  security.push("WPA2/WPA3");
                } else if (sm.startsWith("pairport_security_mode_wpa3")) {
                  security.push("WPA3");
                }
                result2.push({
                  id: networkWifiObj._name || "Wi-Fi",
                  iface: networkWifiObj.interface || "",
                  model: networkWifiObj.hardware || "",
                  ssid: airportWifiObj._name || "",
                  bssid: airportWifiObj.spairport_network_bssid || "",
                  channel,
                  frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                  type: airportWifiObj.spairport_network_phymode || "802.11",
                  security,
                  signalLevel: signalLevel ? parseInt(signalLevel, 10) : null,
                  quality: wifiQualityFromDB(signalLevel),
                  txRate: airportWifiObj.spairport_network_rate || null
                });
              } catch (e) {
                util2.noop();
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          } else if (_windows) {
            let cmd = "netsh wlan show interfaces";
            util2.powerShell(cmd).then(function(stdout) {
              const allLines = stdout.toString().split("\r\n");
              for (let i = 0; i < allLines.length; i++) {
                allLines[i] = allLines[i].trim();
              }
              const parts2 = allLines.join("\r\n").split(":\r\n\r\n");
              parts2.shift();
              parts2.forEach((part) => {
                const lines = part.split("\r\n");
                if (lines.length >= 5) {
                  const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
                  const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
                  const id = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
                  const ssid = util2.getValue(lines, "SSID", ":", true);
                  const bssid = util2.getValue(lines, "BSSID", ":", true) || util2.getValue(lines, "AP BSSID", ":", true);
                  const quality = util2.getValue(lines, "Signal", ":", true);
                  const signalLevel = wifiDBFromQuality(quality);
                  const type = util2.getValue(lines, "Radio type", ":", true) || util2.getValue(lines, "Type de radio", ":", true) || util2.getValue(lines, "Funktyp", ":", true) || null;
                  const security = util2.getValue(lines, "authentication", ":", true) || util2.getValue(lines, "Authentification", ":", true) || util2.getValue(lines, "Authentifizierung", ":", true) || null;
                  const channel = util2.getValue(lines, "Channel", ":", true) || util2.getValue(lines, "Canal", ":", true) || util2.getValue(lines, "Kanal", ":", true) || null;
                  const txRate = util2.getValue(lines, "Transmit rate (mbps)", ":", true) || util2.getValue(lines, "Transmission (mbit/s)", ":", true) || util2.getValue(lines, "Empfangsrate (MBit/s)", ":", true) || null;
                  if (model && id && ssid && bssid) {
                    result2.push({
                      id,
                      iface,
                      model,
                      ssid,
                      bssid,
                      channel: util2.toInt(channel),
                      frequency: channel ? wifiFrequencyFromChannel(channel) : null,
                      type,
                      security,
                      signalLevel,
                      quality: quality ? parseInt(quality, 10) : null,
                      txRate: util2.toInt(txRate) || null
                    });
                  }
                }
              });
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(wifiConnections, "wifiConnections");
    exports2.wifiConnections = wifiConnections;
    function wifiInterfaces(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          const result2 = [];
          if (_linux) {
            const ifaces = ifaceListLinux();
            ifaces.forEach((ifaceDetail) => {
              const nmiDetails = nmiDeviceLinux(ifaceDetail.iface);
              result2.push({
                id: ifaceDetail.id,
                iface: ifaceDetail.iface,
                model: nmiDetails.product ? nmiDetails.product : null,
                vendor: nmiDetails.vendor ? nmiDetails.vendor : null,
                mac: ifaceDetail.mac
              });
            });
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          } else if (_darwin) {
            let cmd = "system_profiler SPNetworkDataType";
            exec(cmd, function(error, stdout) {
              const parts1 = stdout.toString().split("\n\n    Wi-Fi:\n\n");
              if (parts1.length > 1) {
                const lines = parts1[1].split("\n\n")[0].split("\n");
                const iface = util2.getValue(lines, "BSD Device Name", ":", true);
                const mac = util2.getValue(lines, "MAC Address", ":", true);
                const model = util2.getValue(lines, "hardware", ":", true);
                result2.push({
                  id: "Wi-Fi",
                  iface,
                  model,
                  vendor: "",
                  mac
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          } else if (_windows) {
            let cmd = "netsh wlan show interfaces";
            util2.powerShell(cmd).then(function(stdout) {
              const allLines = stdout.toString().split("\r\n");
              for (let i = 0; i < allLines.length; i++) {
                allLines[i] = allLines[i].trim();
              }
              const parts2 = allLines.join("\r\n").split(":\r\n\r\n");
              parts2.shift();
              parts2.forEach((part) => {
                const lines = part.split("\r\n");
                if (lines.length >= 5) {
                  const iface = lines[0].indexOf(":") >= 0 ? lines[0].split(":")[1].trim() : "";
                  const model = lines[1].indexOf(":") >= 0 ? lines[1].split(":")[1].trim() : "";
                  const id = lines[2].indexOf(":") >= 0 ? lines[2].split(":")[1].trim() : "";
                  const macParts = lines[3].indexOf(":") >= 0 ? lines[3].split(":") : [];
                  macParts.shift();
                  const mac = macParts.join(":").trim();
                  const vendor = getVendor(model);
                  if (iface && model && id && mac) {
                    result2.push({
                      id,
                      iface,
                      model,
                      vendor,
                      mac
                    });
                  }
                }
              });
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(wifiInterfaces, "wifiInterfaces");
    exports2.wifiInterfaces = wifiInterfaces;
  }
});

// node_modules/systeminformation/lib/processes.js
var require_processes = __commonJS({
  "node_modules/systeminformation/lib/processes.js"(exports2) {
    "use strict";
    var os = require("os");
    var fs = require("fs");
    var path = require("path");
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var _processes_cpu = {
      all: 0,
      all_utime: 0,
      all_stime: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _services_cpu = {
      all: 0,
      all_utime: 0,
      all_stime: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _process_cpu = {
      all: 0,
      all_utime: 0,
      all_stime: 0,
      list: {},
      ms: 0,
      result: {}
    };
    var _winStatusValues = {
      "0": "unknown",
      "1": "other",
      "2": "ready",
      "3": "running",
      "4": "blocked",
      "5": "suspended blocked",
      "6": "suspended ready",
      "7": "terminated",
      "8": "stopped",
      "9": "growing"
    };
    function parseTimeUnix(time) {
      let result2 = time;
      let parts2 = time.replace(/ +/g, " ").split(" ");
      if (parts2.length === 5) {
        result2 = parts2[4] + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(parts2[1].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + parts2[2]).slice(-2) + " " + parts2[3];
      }
      return result2;
    }
    __name(parseTimeUnix, "parseTimeUnix");
    function parseElapsedTime(etime) {
      let current = /* @__PURE__ */ new Date();
      current = new Date(current.getTime() - current.getTimezoneOffset() * 6e4);
      const elapsed = etime.split("-");
      const timeIndex = elapsed.length - 1;
      const days = timeIndex > 0 ? parseInt(elapsed[timeIndex - 1]) : 0;
      const timeStr = elapsed[timeIndex].split(":");
      const hours = timeStr.length === 3 ? parseInt(timeStr[0] || 0) : 0;
      const mins = parseInt(timeStr[timeStr.length === 3 ? 1 : 0] || 0);
      const secs = parseInt(timeStr[timeStr.length === 3 ? 2 : 1] || 0);
      const ms = (((days * 24 + hours) * 60 + mins) * 60 + secs) * 1e3;
      let res = new Date(current.getTime());
      let result2 = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
      try {
        res = new Date(current.getTime() - ms);
        result2 = res.toISOString().substring(0, 10) + " " + res.toISOString().substring(11, 19);
      } catch (e) {
        util2.noop();
      }
      return result2;
    }
    __name(parseElapsedTime, "parseElapsedTime");
    function services(srv, callback) {
      if (util2.isFunction(srv) && !callback) {
        callback = srv;
        srv = "";
      }
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (typeof srv !== "string") {
            if (callback) {
              callback([]);
            }
            return resolve5([]);
          }
          if (srv) {
            let srvString = "";
            try {
              srvString.__proto__.toLowerCase = util2.stringToLower;
              srvString.__proto__.replace = util2.stringReplace;
              srvString.__proto__.toString = util2.stringToString;
              srvString.__proto__.substr = util2.stringSubstr;
              srvString.__proto__.substring = util2.stringSubstring;
              srvString.__proto__.trim = util2.stringTrim;
              srvString.__proto__.startsWith = util2.stringStartWith;
            } catch (e) {
              Object.setPrototypeOf(srvString, util2.stringObj);
            }
            const s = util2.sanitizeShellString(srv);
            const l = util2.mathMin(s.length, 2e3);
            for (let i = 0; i <= l; i++) {
              if (s[i] !== void 0) {
                srvString = srvString + s[i];
              }
            }
            srvString = srvString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
            if (srvString === "") {
              srvString = "*";
            }
            if (util2.isPrototypePolluted() && srvString !== "*") {
              srvString = "------";
            }
            let srvs = srvString.split("|");
            let result2 = [];
            let dataSrv = [];
            if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
              if ((_linux || _freebsd || _openbsd || _netbsd) && srvString === "*") {
                try {
                  const tmpsrv = execSync("systemctl --all --type=service --no-legend 2> /dev/null", util2.execOptsLinux).toString().split("\n");
                  srvs = [];
                  for (const s2 of tmpsrv) {
                    const name = s2.split(".service")[0];
                    if (name && s2.indexOf(" not-found ") === -1) {
                      srvs.push(name.trim());
                    }
                  }
                  srvString = srvs.join("|");
                } catch (d) {
                  try {
                    srvString = "";
                    const tmpsrv = execSync("service --status-all 2> /dev/null", util2.execOptsLinux).toString().split("\n");
                    for (const s2 of tmpsrv) {
                      const parts2 = s2.split("]");
                      if (parts2.length === 2) {
                        srvString += (srvString !== "" ? "|" : "") + parts2[1].trim();
                      }
                    }
                    srvs = srvString.split("|");
                  } catch (e) {
                    try {
                      const srvStr = execSync("ls /etc/init.d/ -m 2> /dev/null", util2.execOptsLinux).toString().split("\n").join("");
                      srvString = "";
                      if (srvStr) {
                        const tmpsrv = srvStr.split(",");
                        for (const s2 of tmpsrv) {
                          const name = s2.trim();
                          if (name) {
                            srvString += (srvString !== "" ? "|" : "") + name;
                          }
                        }
                        srvs = srvString.split("|");
                      }
                    } catch (f) {
                      srvString = "";
                      srvs = [];
                    }
                  }
                }
              }
              if (_darwin && srvString === "*") {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
              let args = _darwin ? [
                "-caxo",
                "pcpu,pmem,pid,command"
              ] : [
                "-axo",
                "pcpu,pmem,pid,command"
              ];
              if (srvString !== "" && srvs.length > 0) {
                util2.execSafe("ps", args).then((stdout) => {
                  if (stdout) {
                    let lines = stdout.replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                    srvs.forEach(function(srv2) {
                      let ps;
                      if (_darwin) {
                        ps = lines.filter(function(e) {
                          return e.toLowerCase().indexOf(srv2) !== -1;
                        });
                      } else {
                        ps = lines.filter(function(e) {
                          return e.toLowerCase().indexOf(" " + srv2.toLowerCase() + ":") !== -1 || e.toLowerCase().indexOf("/" + srv2.toLowerCase()) !== -1;
                        });
                      }
                      const pids = [];
                      for (const p of ps) {
                        const pid = p.trim().split(" ")[2];
                        if (pid) {
                          pids.push(parseInt(pid, 10));
                        }
                      }
                      result2.push({
                        name: srv2,
                        running: ps.length > 0,
                        startmode: "",
                        pids,
                        cpu: parseFloat(ps.reduce(function(pv, cv) {
                          return pv + parseFloat(cv.trim().split(" ")[0]);
                        }, 0).toFixed(2)),
                        mem: parseFloat(ps.reduce(function(pv, cv) {
                          return pv + parseFloat(cv.trim().split(" ")[1]);
                        }, 0).toFixed(2))
                      });
                    });
                    if (_linux) {
                      let cmd = 'cat /proc/stat | grep "cpu "';
                      for (let i in result2) {
                        for (let j in result2[i].pids) {
                          cmd += ";cat /proc/" + result2[i].pids[j] + "/stat";
                        }
                      }
                      exec(cmd, {
                        maxBuffer: 1024 * 2e4
                      }, function(error, stdout2) {
                        let curr_processes = stdout2.toString().split("\n");
                        let all = parseProcStat(curr_processes.shift());
                        let list_new = {};
                        let resultProcess = {};
                        curr_processes.forEach((element) => {
                          resultProcess = calcProcStatLinux(element, all, _services_cpu);
                          if (resultProcess.pid) {
                            let listPos = -1;
                            for (let i in result2) {
                              for (let j in result2[i].pids) {
                                if (parseInt(result2[i].pids[j]) === parseInt(resultProcess.pid)) {
                                  listPos = i;
                                }
                              }
                            }
                            if (listPos >= 0) {
                              result2[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                            }
                            list_new[resultProcess.pid] = {
                              cpuu: resultProcess.cpuu,
                              cpus: resultProcess.cpus,
                              utime: resultProcess.utime,
                              stime: resultProcess.stime,
                              cutime: resultProcess.cutime,
                              cstime: resultProcess.cstime
                            };
                          }
                        });
                        _services_cpu.all = all;
                        _services_cpu.list = Object.assign({}, list_new);
                        _services_cpu.ms = Date.now() - _services_cpu.ms;
                        _services_cpu.result = Object.assign({}, result2);
                        if (callback) {
                          callback(result2);
                        }
                        resolve5(result2);
                      });
                    } else {
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    }
                  } else {
                    args = [
                      "-o",
                      "comm"
                    ];
                    util2.execSafe("ps", args).then((stdout2) => {
                      if (stdout2) {
                        let lines = stdout2.replace(/ +/g, " ").replace(/,+/g, ".").split("\n");
                        srvs.forEach(function(srv2) {
                          let ps = lines.filter(function(e) {
                            return e.indexOf(srv2) !== -1;
                          });
                          result2.push({
                            name: srv2,
                            running: ps.length > 0,
                            startmode: "",
                            cpu: 0,
                            mem: 0
                          });
                        });
                        if (callback) {
                          callback(result2);
                        }
                        resolve5(result2);
                      } else {
                        srvs.forEach(function(srv2) {
                          result2.push({
                            name: srv2,
                            running: false,
                            startmode: "",
                            cpu: 0,
                            mem: 0
                          });
                        });
                        if (callback) {
                          callback(result2);
                        }
                        resolve5(result2);
                      }
                    });
                  }
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            }
            if (_windows) {
              try {
                let wincommand = "Get-CimInstance Win32_Service";
                if (srvs[0] !== "*") {
                  wincommand += ' -Filter "';
                  srvs.forEach((srv2) => {
                    wincommand += `Name='${srv2}' or `;
                  });
                  wincommand = `${wincommand.slice(0, -4)}"`;
                }
                wincommand += " | select Name,Caption,Started,StartMode,ProcessId | fl";
                util2.powerShell(wincommand).then((stdout, error) => {
                  if (!error) {
                    let serviceSections = stdout.split(/\n\s*\n/);
                    serviceSections.forEach((element) => {
                      if (element.trim() !== "") {
                        let lines = element.trim().split("\r\n");
                        let srvName = util2.getValue(lines, "Name", ":", true).toLowerCase();
                        let srvCaption = util2.getValue(lines, "Caption", ":", true).toLowerCase();
                        let started = util2.getValue(lines, "Started", ":", true);
                        let startMode = util2.getValue(lines, "StartMode", ":", true);
                        let pid = util2.getValue(lines, "ProcessId", ":", true);
                        if (srvString === "*" || srvs.indexOf(srvName) >= 0 || srvs.indexOf(srvCaption) >= 0) {
                          result2.push({
                            name: srvName,
                            running: started.toLowerCase() === "true",
                            startmode: startMode,
                            pids: [
                              pid
                            ],
                            cpu: 0,
                            mem: 0
                          });
                          dataSrv.push(srvName);
                          dataSrv.push(srvCaption);
                        }
                      }
                    });
                    if (srvString !== "*") {
                      let srvsMissing = srvs.filter(function(e) {
                        return dataSrv.indexOf(e) === -1;
                      });
                      srvsMissing.forEach(function(srvName) {
                        result2.push({
                          name: srvName,
                          running: false,
                          startmode: "",
                          pids: [],
                          cpu: 0,
                          mem: 0
                        });
                      });
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  } else {
                    srvs.forEach(function(srvName) {
                      result2.push({
                        name: srvName,
                        running: false,
                        startmode: "",
                        cpu: 0,
                        mem: 0
                      });
                    });
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  }
                });
              } catch (e) {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            }
          } else {
            if (callback) {
              callback([]);
            }
            resolve5([]);
          }
        });
      });
    }
    __name(services, "services");
    exports2.services = services;
    function parseProcStat(line) {
      let parts2 = line.replace(/ +/g, " ").split(" ");
      let user = parts2.length >= 2 ? parseInt(parts2[1]) : 0;
      let nice = parts2.length >= 3 ? parseInt(parts2[2]) : 0;
      let system = parts2.length >= 4 ? parseInt(parts2[3]) : 0;
      let idle = parts2.length >= 5 ? parseInt(parts2[4]) : 0;
      let iowait = parts2.length >= 6 ? parseInt(parts2[5]) : 0;
      let irq = parts2.length >= 7 ? parseInt(parts2[6]) : 0;
      let softirq = parts2.length >= 8 ? parseInt(parts2[7]) : 0;
      let steal = parts2.length >= 9 ? parseInt(parts2[8]) : 0;
      let guest = parts2.length >= 10 ? parseInt(parts2[9]) : 0;
      let guest_nice = parts2.length >= 11 ? parseInt(parts2[10]) : 0;
      return user + nice + system + idle + iowait + irq + softirq + steal + guest + guest_nice;
    }
    __name(parseProcStat, "parseProcStat");
    function calcProcStatLinux(line, all, _cpu_old) {
      let statparts = line.replace(/ +/g, " ").split(")");
      if (statparts.length >= 2) {
        let parts2 = statparts[1].split(" ");
        if (parts2.length >= 16) {
          let pid = parseInt(statparts[0].split(" ")[0]);
          let utime = parseInt(parts2[12]);
          let stime = parseInt(parts2[13]);
          let cutime = parseInt(parts2[14]);
          let cstime = parseInt(parts2[15]);
          let cpuu = 0;
          let cpus = 0;
          if (_cpu_old.all > 0 && _cpu_old.list[pid]) {
            cpuu = (utime + cutime - _cpu_old.list[pid].utime - _cpu_old.list[pid].cutime) / (all - _cpu_old.all) * 100;
            cpus = (stime + cstime - _cpu_old.list[pid].stime - _cpu_old.list[pid].cstime) / (all - _cpu_old.all) * 100;
          } else {
            cpuu = (utime + cutime) / all * 100;
            cpus = (stime + cstime) / all * 100;
          }
          return {
            pid,
            utime,
            stime,
            cutime,
            cstime,
            cpuu,
            cpus
          };
        } else {
          return {
            pid: 0,
            utime: 0,
            stime: 0,
            cutime: 0,
            cstime: 0,
            cpuu: 0,
            cpus: 0
          };
        }
      } else {
        return {
          pid: 0,
          utime: 0,
          stime: 0,
          cutime: 0,
          cstime: 0,
          cpuu: 0,
          cpus: 0
        };
      }
    }
    __name(calcProcStatLinux, "calcProcStatLinux");
    function calcProcStatWin(procStat, all, _cpu_old) {
      let cpuu = 0;
      let cpus = 0;
      if (_cpu_old.all > 0 && _cpu_old.list[procStat.pid]) {
        cpuu = (procStat.utime - _cpu_old.list[procStat.pid].utime) / (all - _cpu_old.all) * 100;
        cpus = (procStat.stime - _cpu_old.list[procStat.pid].stime) / (all - _cpu_old.all) * 100;
      } else {
        cpuu = procStat.utime / all * 100;
        cpus = procStat.stime / all * 100;
      }
      return {
        pid: procStat.pid,
        utime: procStat.utime,
        stime: procStat.stime,
        cpuu: cpuu > 0 ? cpuu : 0,
        cpus: cpus > 0 ? cpus : 0
      };
    }
    __name(calcProcStatWin, "calcProcStatWin");
    function processes(callback) {
      let parsedhead = [];
      function getName(command2) {
        command2 = command2 || "";
        let result2 = command2.split(" ")[0];
        if (result2.substr(-1) === ":") {
          result2 = result2.substr(0, result2.length - 1);
        }
        if (result2.substr(0, 1) !== "[") {
          let parts2 = result2.split("/");
          if (isNaN(parseInt(parts2[parts2.length - 1]))) {
            result2 = parts2[parts2.length - 1];
          } else {
            result2 = parts2[0];
          }
        }
        return result2;
      }
      __name(getName, "getName");
      function parseLine(line) {
        let offset = 0;
        let offset2 = 0;
        function checkColumn(i) {
          offset = offset2;
          if (parsedhead[i]) {
            offset2 = line.substring(parsedhead[i].to + offset, 1e4).indexOf(" ");
          } else {
            offset2 = 1e4;
          }
        }
        __name(checkColumn, "checkColumn");
        checkColumn(0);
        const pid = parseInt(line.substring(parsedhead[0].from + offset, parsedhead[0].to + offset2));
        checkColumn(1);
        const ppid = parseInt(line.substring(parsedhead[1].from + offset, parsedhead[1].to + offset2));
        checkColumn(2);
        const cpu = parseFloat(line.substring(parsedhead[2].from + offset, parsedhead[2].to + offset2).replace(/,/g, "."));
        checkColumn(3);
        const mem2 = parseFloat(line.substring(parsedhead[3].from + offset, parsedhead[3].to + offset2).replace(/,/g, "."));
        checkColumn(4);
        const priority = parseInt(line.substring(parsedhead[4].from + offset, parsedhead[4].to + offset2));
        checkColumn(5);
        const vsz = parseInt(line.substring(parsedhead[5].from + offset, parsedhead[5].to + offset2));
        checkColumn(6);
        const rss = parseInt(line.substring(parsedhead[6].from + offset, parsedhead[6].to + offset2));
        checkColumn(7);
        const nice = parseInt(line.substring(parsedhead[7].from + offset, parsedhead[7].to + offset2)) || 0;
        checkColumn(8);
        const started = !_sunos ? parseElapsedTime(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim()) : parseTimeUnix(line.substring(parsedhead[8].from + offset, parsedhead[8].to + offset2).trim());
        checkColumn(9);
        let state = line.substring(parsedhead[9].from + offset, parsedhead[9].to + offset2).trim();
        state = state[0] === "R" ? "running" : state[0] === "S" ? "sleeping" : state[0] === "T" ? "stopped" : state[0] === "W" ? "paging" : state[0] === "X" ? "dead" : state[0] === "Z" ? "zombie" : state[0] === "D" || state[0] === "U" ? "blocked" : "unknown";
        checkColumn(10);
        let tty = line.substring(parsedhead[10].from + offset, parsedhead[10].to + offset2).trim();
        if (tty === "?" || tty === "??") {
          tty = "";
        }
        checkColumn(11);
        const user = line.substring(parsedhead[11].from + offset, parsedhead[11].to + offset2).trim();
        checkColumn(12);
        let cmdPath = "";
        let command2 = "";
        let params2 = "";
        let fullcommand = line.substring(parsedhead[12].from + offset, parsedhead[12].to + offset2).trim();
        if (fullcommand.substr(fullcommand.length - 1) === "]") {
          fullcommand = fullcommand.slice(0, -1);
        }
        if (fullcommand.substr(0, 1) === "[") {
          command2 = fullcommand.substring(1);
        } else {
          const p1 = fullcommand.indexOf("(");
          const p2 = fullcommand.indexOf(")");
          const p3 = fullcommand.indexOf("/");
          const p4 = fullcommand.indexOf(":");
          if (p1 < p2 && p1 < p3 && p3 < p2) {
            command2 = fullcommand.split(" ")[0];
            command2 = command2.replace(/:/g, "");
          } else {
            if (p4 > 0 && (p3 === -1 || p3 > 3)) {
              command2 = fullcommand.split(" ")[0];
              command2 = command2.replace(/:/g, "");
            } else {
              let firstParamPos = fullcommand.indexOf(" -");
              let firstParamPathPos = fullcommand.indexOf(" /");
              firstParamPos = firstParamPos >= 0 ? firstParamPos : 1e4;
              firstParamPathPos = firstParamPathPos >= 0 ? firstParamPathPos : 1e4;
              const firstPos = Math.min(firstParamPos, firstParamPathPos);
              let tmpCommand = fullcommand.substr(0, firstPos);
              const tmpParams = fullcommand.substr(firstPos);
              const lastSlashPos = tmpCommand.lastIndexOf("/");
              if (lastSlashPos >= 0) {
                cmdPath = tmpCommand.substr(0, lastSlashPos);
                tmpCommand = tmpCommand.substr(lastSlashPos + 1);
              }
              if (firstPos === 1e4 && tmpCommand.indexOf(" ") > -1) {
                const parts2 = tmpCommand.split(" ");
                if (fs.existsSync(path.join(cmdPath, parts2[0]))) {
                  command2 = parts2.shift();
                  params2 = (parts2.join(" ") + " " + tmpParams).trim();
                } else {
                  command2 = tmpCommand.trim();
                  params2 = tmpParams.trim();
                }
              } else {
                command2 = tmpCommand.trim();
                params2 = tmpParams.trim();
              }
            }
          }
        }
        return {
          pid,
          parentPid: ppid,
          name: _linux ? getName(command2) : command2,
          cpu,
          cpuu: 0,
          cpus: 0,
          mem: mem2,
          priority,
          memVsz: vsz,
          memRss: rss,
          nice,
          started,
          state,
          tty,
          user,
          command: command2,
          params: params2,
          path: cmdPath
        };
      }
      __name(parseLine, "parseLine");
      function parseProcesses(lines) {
        let result2 = [];
        if (lines.length > 1) {
          let head = lines[0];
          parsedhead = util2.parseHead(head, 8);
          lines.shift();
          lines.forEach(function(line) {
            if (line.trim() !== "") {
              result2.push(parseLine(line));
            }
          });
        }
        return result2;
      }
      __name(parseProcesses, "parseProcesses");
      function parseProcesses2(lines) {
        function formatDateTime(time) {
          const month = ("0" + (time.getMonth() + 1).toString()).slice(-2);
          const year = time.getFullYear().toString();
          const day = ("0" + time.getDate().toString()).slice(-2);
          const hours = ("0" + time.getHours().toString()).slice(-2);
          const mins = ("0" + time.getMinutes().toString()).slice(-2);
          const secs = ("0" + time.getSeconds().toString()).slice(-2);
          return year + "-" + month + "-" + day + " " + hours + ":" + mins + ":" + secs;
        }
        __name(formatDateTime, "formatDateTime");
        function parseElapsed(etime) {
          let started = "";
          if (etime.indexOf("d") >= 0) {
            const elapsed_parts = etime.split("d");
            started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 24 + elapsed_parts[1] * 1) * 60 * 60 * 1e3));
          } else if (etime.indexOf("h") >= 0) {
            const elapsed_parts = etime.split("h");
            started = formatDateTime(new Date(Date.now() - (elapsed_parts[0] * 60 + elapsed_parts[1] * 1) * 60 * 1e3));
          } else if (etime.indexOf(":") >= 0) {
            const elapsed_parts = etime.split(":");
            started = formatDateTime(new Date(Date.now() - (elapsed_parts.length > 1 ? (elapsed_parts[0] * 60 + elapsed_parts[1]) * 1e3 : elapsed_parts[0] * 1e3)));
          }
          return started;
        }
        __name(parseElapsed, "parseElapsed");
        let result2 = [];
        lines.forEach(function(line) {
          if (line.trim() !== "") {
            line = line.trim().replace(/ +/g, " ").replace(/,+/g, ".");
            const parts2 = line.split(" ");
            const command2 = parts2.slice(9).join(" ");
            const pmem = parseFloat((1 * parseInt(parts2[3]) * 1024 / os.totalmem()).toFixed(1));
            const started = parseElapsed(parts2[5]);
            result2.push({
              pid: parseInt(parts2[0]),
              parentPid: parseInt(parts2[1]),
              name: getName(command2),
              cpu: 0,
              cpuu: 0,
              cpus: 0,
              mem: pmem,
              priority: 0,
              memVsz: parseInt(parts2[2]),
              memRss: parseInt(parts2[3]),
              nice: parseInt(parts2[4]),
              started,
              state: parts2[6] === "R" ? "running" : parts2[6] === "S" ? "sleeping" : parts2[6] === "T" ? "stopped" : parts2[6] === "W" ? "paging" : parts2[6] === "X" ? "dead" : parts2[6] === "Z" ? "zombie" : parts2[6] === "D" || parts2[6] === "U" ? "blocked" : "unknown",
              tty: parts2[7],
              user: parts2[8],
              command: command2
            });
          }
        });
        return result2;
      }
      __name(parseProcesses2, "parseProcesses2");
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            all: 0,
            running: 0,
            blocked: 0,
            sleeping: 0,
            unknown: 0,
            list: []
          };
          let cmd = "";
          if (_processes_cpu.ms && Date.now() - _processes_cpu.ms >= 500 || _processes_cpu.ms === 0) {
            if (_linux || _freebsd || _openbsd || _netbsd || _darwin || _sunos) {
              if (_linux) {
                cmd = "export LC_ALL=C; ps -axo pid:11,ppid:11,pcpu:6,pmem:6,pri:5,vsz:11,rss:11,ni:5,etime:30,state:5,tty:15,user:20,command; unset LC_ALL";
              }
              if (_freebsd || _openbsd || _netbsd) {
                cmd = "export LC_ALL=C; ps -axo pid,ppid,pcpu,pmem,pri,vsz,rss,ni,etime,state,tty,user,command; unset LC_ALL";
              }
              if (_darwin) {
                cmd = "ps -axo pid,ppid,pcpu,pmem,pri,vsz=temp_title_1,rss=temp_title_2,nice,etime=temp_title_3,state,tty,user,command -r";
              }
              if (_sunos) {
                cmd = "ps -Ao pid,ppid,pcpu,pmem,pri,vsz,rss,nice,stime,s,tty,user,comm";
              }
              exec(cmd, {
                maxBuffer: 1024 * 2e4
              }, function(error, stdout) {
                if (!error && stdout.toString().trim()) {
                  result2.list = parseProcesses(stdout.toString().split("\n")).slice();
                  result2.all = result2.list.length;
                  result2.running = result2.list.filter(function(e) {
                    return e.state === "running";
                  }).length;
                  result2.blocked = result2.list.filter(function(e) {
                    return e.state === "blocked";
                  }).length;
                  result2.sleeping = result2.list.filter(function(e) {
                    return e.state === "sleeping";
                  }).length;
                  if (_linux) {
                    cmd = 'cat /proc/stat | grep "cpu "';
                    result2.list.forEach((element) => {
                      cmd += ";cat /proc/" + element.pid + "/stat";
                    });
                    exec(cmd, {
                      maxBuffer: 1024 * 2e4
                    }, function(error2, stdout2) {
                      let curr_processes = stdout2.toString().split("\n");
                      let all = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      curr_processes.forEach((element) => {
                        resultProcess = calcProcStatLinux(element, all, _processes_cpu);
                        if (resultProcess.pid) {
                          let listPos = result2.list.map(function(e) {
                            return e.pid;
                          }).indexOf(resultProcess.pid);
                          if (listPos >= 0) {
                            result2.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                            result2.list[listPos].cpuu = resultProcess.cpuu;
                            result2.list[listPos].cpus = resultProcess.cpus;
                          }
                          list_new[resultProcess.pid] = {
                            cpuu: resultProcess.cpuu,
                            cpus: resultProcess.cpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      });
                      _processes_cpu.all = all;
                      _processes_cpu.list = Object.assign({}, list_new);
                      _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                      _processes_cpu.result = Object.assign({}, result2);
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    });
                  } else {
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  }
                } else {
                  cmd = "ps -o pid,ppid,vsz,rss,nice,etime,stat,tty,user,comm";
                  if (_sunos) {
                    cmd = "ps -o pid,ppid,vsz,rss,nice,etime,s,tty,user,comm";
                  }
                  exec(cmd, {
                    maxBuffer: 1024 * 2e4
                  }, function(error2, stdout2) {
                    if (!error2) {
                      let lines = stdout2.toString().split("\n");
                      lines.shift();
                      result2.list = parseProcesses2(lines).slice();
                      result2.all = result2.list.length;
                      result2.running = result2.list.filter(function(e) {
                        return e.state === "running";
                      }).length;
                      result2.blocked = result2.list.filter(function(e) {
                        return e.state === "blocked";
                      }).length;
                      result2.sleeping = result2.list.filter(function(e) {
                        return e.state === "sleeping";
                      }).length;
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    } else {
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    }
                  });
                }
              });
            } else if (_windows) {
              try {
                util2.powerShell('Get-CimInstance Win32_Process | select-Object ProcessId,ParentProcessId,ExecutionState,Caption,CommandLine,ExecutablePath,UserModeTime,KernelModeTime,WorkingSetSize,Priority,PageFileUsage, @{n="CreationDate";e={$_.CreationDate.ToString("yyyy-MM-dd HH:mm:ss")}} | fl').then((stdout, error) => {
                  if (!error) {
                    let processSections = stdout.split(/\n\s*\n/);
                    let procs = [];
                    let procStats = [];
                    let list_new = {};
                    let allcpuu = 0;
                    let allcpus = 0;
                    processSections.forEach((element) => {
                      if (element.trim() !== "") {
                        let lines = element.trim().split("\r\n");
                        let pid = parseInt(util2.getValue(lines, "ProcessId", ":", true), 10);
                        let parentPid = parseInt(util2.getValue(lines, "ParentProcessId", ":", true), 10);
                        let statusValue = util2.getValue(lines, "ExecutionState", ":");
                        let name = util2.getValue(lines, "Caption", ":", true);
                        let commandLine = util2.getValue(lines, "CommandLine", ":", true);
                        let additionalCommand = false;
                        lines.forEach((line) => {
                          if (additionalCommand && line.toLowerCase().startsWith(" ")) {
                            commandLine += " " + line.trim();
                          } else {
                            additionalCommand = false;
                          }
                          if (line.toLowerCase().startsWith("commandline")) {
                            additionalCommand = true;
                          }
                        });
                        let commandPath = util2.getValue(lines, "ExecutablePath", ":", true);
                        let utime = parseInt(util2.getValue(lines, "UserModeTime", ":", true), 10);
                        let stime = parseInt(util2.getValue(lines, "KernelModeTime", ":", true), 10);
                        let memw = parseInt(util2.getValue(lines, "WorkingSetSize", ":", true), 10);
                        allcpuu = allcpuu + utime;
                        allcpus = allcpus + stime;
                        result2.all++;
                        if (!statusValue) {
                          result2.unknown++;
                        }
                        if (statusValue === "3") {
                          result2.running++;
                        }
                        if (statusValue === "4" || statusValue === "5") {
                          result2.blocked++;
                        }
                        procStats.push({
                          pid,
                          utime,
                          stime,
                          cpu: 0,
                          cpuu: 0,
                          cpus: 0
                        });
                        procs.push({
                          pid,
                          parentPid,
                          name,
                          cpu: 0,
                          cpuu: 0,
                          cpus: 0,
                          mem: memw / os.totalmem() * 100,
                          priority: parseInt(util2.getValue(lines, "Priority", ":", true), 10),
                          memVsz: parseInt(util2.getValue(lines, "PageFileUsage", ":", true), 10),
                          memRss: Math.floor(parseInt(util2.getValue(lines, "WorkingSetSize", ":", true), 10) / 1024),
                          nice: 0,
                          started: util2.getValue(lines, "CreationDate", ":", true),
                          state: !statusValue ? _winStatusValues[0] : _winStatusValues[statusValue],
                          tty: "",
                          user: "",
                          command: commandLine || name,
                          path: commandPath,
                          params: ""
                        });
                      }
                    });
                    result2.sleeping = result2.all - result2.running - result2.blocked - result2.unknown;
                    result2.list = procs;
                    procStats.forEach((element) => {
                      let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _processes_cpu);
                      let listPos = result2.list.map(function(e) {
                        return e.pid;
                      }).indexOf(resultProcess.pid);
                      if (listPos >= 0) {
                        result2.list[listPos].cpu = resultProcess.cpuu + resultProcess.cpus;
                        result2.list[listPos].cpuu = resultProcess.cpuu;
                        result2.list[listPos].cpus = resultProcess.cpus;
                      }
                      list_new[resultProcess.pid] = {
                        cpuu: resultProcess.cpuu,
                        cpus: resultProcess.cpus,
                        utime: resultProcess.utime,
                        stime: resultProcess.stime
                      };
                    });
                    _processes_cpu.all = allcpuu + allcpus;
                    _processes_cpu.all_utime = allcpuu;
                    _processes_cpu.all_stime = allcpus;
                    _processes_cpu.list = Object.assign({}, list_new);
                    _processes_cpu.ms = Date.now() - _processes_cpu.ms;
                    _processes_cpu.result = Object.assign({}, result2);
                  }
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                });
              } catch (e) {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            } else {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          } else {
            if (callback) {
              callback(_processes_cpu.result);
            }
            resolve5(_processes_cpu.result);
          }
        });
      });
    }
    __name(processes, "processes");
    exports2.processes = processes;
    function processLoad(proc, callback) {
      if (util2.isFunction(proc) && !callback) {
        callback = proc;
        proc = "";
      }
      return new Promise((resolve5) => {
        process.nextTick(() => {
          proc = proc || "";
          if (typeof proc !== "string") {
            if (callback) {
              callback([]);
            }
            return resolve5([]);
          }
          let processesString = "";
          try {
            processesString.__proto__.toLowerCase = util2.stringToLower;
            processesString.__proto__.replace = util2.stringReplace;
            processesString.__proto__.toString = util2.stringToString;
            processesString.__proto__.substr = util2.stringSubstr;
            processesString.__proto__.substring = util2.stringSubstring;
            processesString.__proto__.trim = util2.stringTrim;
            processesString.__proto__.startsWith = util2.stringStartWith;
          } catch (e) {
            Object.setPrototypeOf(processesString, util2.stringObj);
          }
          const s = util2.sanitizeShellString(proc);
          const l = util2.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (s[i] !== void 0) {
              processesString = processesString + s[i];
            }
          }
          processesString = processesString.trim().toLowerCase().replace(/, /g, "|").replace(/,+/g, "|");
          if (processesString === "") {
            processesString = "*";
          }
          if (util2.isPrototypePolluted() && processesString !== "*") {
            processesString = "------";
          }
          let processes2 = processesString.split("|");
          let result2 = [];
          const procSanitized = util2.isPrototypePolluted() ? "" : util2.sanitizeShellString(proc) || "*";
          if (procSanitized && processes2.length && processes2[0] !== "------") {
            if (_windows) {
              try {
                util2.powerShell("Get-CimInstance Win32_Process | select ProcessId,Caption,UserModeTime,KernelModeTime,WorkingSetSize | fl").then((stdout, error) => {
                  if (!error) {
                    let processSections = stdout.split(/\n\s*\n/);
                    let procStats = [];
                    let list_new = {};
                    let allcpuu = 0;
                    let allcpus = 0;
                    processSections.forEach((element) => {
                      if (element.trim() !== "") {
                        let lines = element.trim().split("\r\n");
                        let pid = parseInt(util2.getValue(lines, "ProcessId", ":", true), 10);
                        let name = util2.getValue(lines, "Caption", ":", true);
                        let utime = parseInt(util2.getValue(lines, "UserModeTime", ":", true), 10);
                        let stime = parseInt(util2.getValue(lines, "KernelModeTime", ":", true), 10);
                        let mem2 = parseInt(util2.getValue(lines, "WorkingSetSize", ":", true), 10);
                        allcpuu = allcpuu + utime;
                        allcpus = allcpus + stime;
                        procStats.push({
                          pid,
                          name,
                          utime,
                          stime,
                          cpu: 0,
                          cpuu: 0,
                          cpus: 0,
                          mem: mem2
                        });
                        let pname = "";
                        let inList = false;
                        processes2.forEach(function(proc2) {
                          if (name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                            inList = true;
                            pname = proc2;
                          }
                        });
                        if (processesString === "*" || inList) {
                          let processFound = false;
                          result2.forEach(function(item) {
                            if (item.proc.toLowerCase() === pname.toLowerCase()) {
                              item.pids.push(pid);
                              item.mem += mem2 / os.totalmem() * 100;
                              processFound = true;
                            }
                          });
                          if (!processFound) {
                            result2.push({
                              proc: pname,
                              pid,
                              pids: [
                                pid
                              ],
                              cpu: 0,
                              mem: mem2 / os.totalmem() * 100
                            });
                          }
                        }
                      }
                    });
                    if (processesString !== "*") {
                      let processesMissing = processes2.filter(function(name) {
                        return procStats.filter(function(item) {
                          return item.name.toLowerCase().indexOf(name) >= 0;
                        }).length === 0;
                      });
                      processesMissing.forEach(function(procName) {
                        result2.push({
                          proc: procName,
                          pid: null,
                          pids: [],
                          cpu: 0,
                          mem: 0
                        });
                      });
                    }
                    procStats.forEach((element) => {
                      let resultProcess = calcProcStatWin(element, allcpuu + allcpus, _process_cpu);
                      let listPos = -1;
                      for (let j = 0; j < result2.length; j++) {
                        if (result2[j].pid === resultProcess.pid || result2[j].pids.indexOf(resultProcess.pid) >= 0) {
                          listPos = j;
                        }
                      }
                      if (listPos >= 0) {
                        result2[listPos].cpu += resultProcess.cpuu + resultProcess.cpus;
                      }
                      list_new[resultProcess.pid] = {
                        cpuu: resultProcess.cpuu,
                        cpus: resultProcess.cpus,
                        utime: resultProcess.utime,
                        stime: resultProcess.stime
                      };
                    });
                    _process_cpu.all = allcpuu + allcpus;
                    _process_cpu.all_utime = allcpuu;
                    _process_cpu.all_stime = allcpus;
                    _process_cpu.list = Object.assign({}, list_new);
                    _process_cpu.ms = Date.now() - _process_cpu.ms;
                    _process_cpu.result = JSON.parse(JSON.stringify(result2));
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  }
                });
              } catch (e) {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            }
            if (_darwin || _linux || _freebsd || _openbsd || _netbsd) {
              const params2 = [
                "-axo",
                "pid,ppid,pcpu,pmem,comm"
              ];
              util2.execSafe("ps", params2).then((stdout) => {
                if (stdout) {
                  let procStats = [];
                  let lines = stdout.toString().split("\n").filter(function(line) {
                    if (processesString === "*") {
                      return true;
                    }
                    if (line.toLowerCase().indexOf("grep") !== -1) {
                      return false;
                    }
                    let found = false;
                    processes2.forEach(function(item) {
                      found = found || line.toLowerCase().indexOf(item.toLowerCase()) >= 0;
                    });
                    return found;
                  });
                  lines.shift();
                  lines.forEach(function(line) {
                    let data = line.trim().replace(/ +/g, " ").split(" ");
                    if (data.length > 4) {
                      const linuxName = data[4].indexOf("/") >= 0 ? data[4].substring(0, data[4].indexOf("/")) : data[4];
                      const name = _linux ? linuxName : data[4].substring(data[4].lastIndexOf("/") + 1);
                      procStats.push({
                        name,
                        pid: parseInt(data[0]) || 0,
                        ppid: parseInt(data[1]) || 0,
                        cpu: parseFloat(data[2].replace(",", ".")),
                        mem: parseFloat(data[3].replace(",", "."))
                      });
                    }
                  });
                  procStats.forEach(function(item) {
                    let listPos = -1;
                    let inList = false;
                    let name = item.name;
                    for (let j = 0; j < result2.length; j++) {
                      if (item.name.toLowerCase().indexOf(result2[j].proc.toLowerCase()) >= 0) {
                        listPos = j;
                      }
                    }
                    processes2.forEach(function(proc2) {
                      if (item.name.toLowerCase().indexOf(proc2.toLowerCase()) >= 0 && !inList) {
                        inList = true;
                        name = proc2;
                      }
                    });
                    if (processesString === "*" || inList) {
                      if (listPos < 0) {
                        if (name) {
                          result2.push({
                            proc: name,
                            pid: item.pid,
                            pids: [
                              item.pid
                            ],
                            cpu: item.cpu,
                            mem: item.mem
                          });
                        }
                      } else {
                        if (item.ppid < 10) {
                          result2[listPos].pid = item.pid;
                        }
                        result2[listPos].pids.push(item.pid);
                        result2[listPos].cpu += item.cpu;
                        result2[listPos].mem += item.mem;
                      }
                    }
                  });
                  if (processesString !== "*") {
                    let processesMissing = processes2.filter(function(name) {
                      return procStats.filter(function(item) {
                        return item.name.toLowerCase().indexOf(name) >= 0;
                      }).length === 0;
                    });
                    processesMissing.forEach(function(procName) {
                      result2.push({
                        proc: procName,
                        pid: null,
                        pids: [],
                        cpu: 0,
                        mem: 0
                      });
                    });
                  }
                  if (_linux) {
                    result2.forEach(function(item) {
                      item.cpu = 0;
                    });
                    let cmd = 'cat /proc/stat | grep "cpu "';
                    for (let i in result2) {
                      for (let j in result2[i].pids) {
                        cmd += ";cat /proc/" + result2[i].pids[j] + "/stat";
                      }
                    }
                    exec(cmd, {
                      maxBuffer: 1024 * 2e4
                    }, function(error, stdout2) {
                      let curr_processes = stdout2.toString().split("\n");
                      let all = parseProcStat(curr_processes.shift());
                      let list_new = {};
                      let resultProcess = {};
                      curr_processes.forEach((element) => {
                        resultProcess = calcProcStatLinux(element, all, _process_cpu);
                        if (resultProcess.pid) {
                          let resultItemId = -1;
                          for (let i in result2) {
                            if (result2[i].pids.indexOf(resultProcess.pid) >= 0) {
                              resultItemId = i;
                            }
                          }
                          if (resultItemId >= 0) {
                            result2[resultItemId].cpu += resultProcess.cpuu + resultProcess.cpus;
                          }
                          list_new[resultProcess.pid] = {
                            cpuu: resultProcess.cpuu,
                            cpus: resultProcess.cpus,
                            utime: resultProcess.utime,
                            stime: resultProcess.stime,
                            cutime: resultProcess.cutime,
                            cstime: resultProcess.cstime
                          };
                        }
                      });
                      result2.forEach(function(item) {
                        item.cpu = Math.round(item.cpu * 100) / 100;
                      });
                      _process_cpu.all = all;
                      _process_cpu.list = Object.assign({}, list_new);
                      _process_cpu.ms = Date.now() - _process_cpu.ms;
                      _process_cpu.result = Object.assign({}, result2);
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    });
                  } else {
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  }
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              });
            }
          }
        });
      });
    }
    __name(processLoad, "processLoad");
    exports2.processLoad = processLoad;
  }
});

// node_modules/systeminformation/lib/users.js
var require_users = __commonJS({
  "node_modules/systeminformation/lib/users.js"(exports2) {
    "use strict";
    var exec = require("child_process").exec;
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function parseUsersLinux(lines, phase) {
      let result2 = [];
      let result_who = [];
      let result_w = {};
      let w_first = true;
      let w_header = [];
      let w_pos = [];
      let who_line = {};
      let is_whopart = true;
      lines.forEach(function(line) {
        if (line === "---") {
          is_whopart = false;
        } else {
          let l = line.replace(/ +/g, " ").split(" ");
          if (is_whopart) {
            result_who.push({
              user: l[0],
              tty: l[1],
              date: l[2],
              time: l[3],
              ip: l && l.length > 4 ? l[4].replace(/\(/g, "").replace(/\)/g, "") : ""
            });
          } else {
            if (w_first) {
              w_header = l;
              w_header.forEach(function(item) {
                w_pos.push(line.indexOf(item));
              });
              w_first = false;
            } else {
              result_w.user = line.substring(w_pos[0], w_pos[1] - 1).trim();
              result_w.tty = line.substring(w_pos[1], w_pos[2] - 1).trim();
              result_w.ip = line.substring(w_pos[2], w_pos[3] - 1).replace(/\(/g, "").replace(/\)/g, "").trim();
              result_w.command = line.substring(w_pos[7], 1e3).trim();
              who_line = result_who.filter(function(obj) {
                return obj.user.substring(0, 8).trim() === result_w.user && obj.tty === result_w.tty;
              });
              if (who_line.length === 1) {
                result2.push({
                  user: who_line[0].user,
                  tty: who_line[0].tty,
                  date: who_line[0].date,
                  time: who_line[0].time,
                  ip: who_line[0].ip,
                  command: result_w.command
                });
              }
            }
          }
        }
      });
      if (result2.length === 0 && phase === 2) {
        return result_who;
      } else {
        return result2;
      }
    }
    __name(parseUsersLinux, "parseUsersLinux");
    function parseUsersDarwin(lines) {
      let result2 = [];
      let result_who = [];
      let result_w = {};
      let who_line = {};
      let is_whopart = true;
      lines.forEach(function(line) {
        if (line === "---") {
          is_whopart = false;
        } else {
          let l = line.replace(/ +/g, " ").split(" ");
          if (is_whopart) {
            let dt = "" + (/* @__PURE__ */ new Date()).getFullYear() + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + l[3]).slice(-2);
            try {
              if (new Date(dt) > /* @__PURE__ */ new Date()) {
                dt = "" + ((/* @__PURE__ */ new Date()).getFullYear() - 1) + "-" + ("0" + ("JANFEBMARAPRMAYJUNJULAUGSEPOCTNOVDEC".indexOf(l[2].toUpperCase()) / 3 + 1)).slice(-2) + "-" + ("0" + l[3]).slice(-2);
              }
            } catch {
              util2.noop();
            }
            result_who.push({
              user: l[0],
              tty: l[1],
              date: dt,
              time: l[4]
            });
          } else {
            result_w.user = l[0];
            result_w.tty = l[1];
            result_w.ip = l[2] !== "-" ? l[2] : "";
            result_w.command = l.slice(5, 1e3).join(" ");
            who_line = result_who.filter(function(obj) {
              return obj.user.substring(0, 10) === result_w.user.substring(0, 10) && (obj.tty.substring(3, 1e3) === result_w.tty || obj.tty === result_w.tty);
            });
            if (who_line.length === 1) {
              result2.push({
                user: who_line[0].user,
                tty: who_line[0].tty,
                date: who_line[0].date,
                time: who_line[0].time,
                ip: result_w.ip,
                command: result_w.command
              });
            }
          }
        }
      });
      return result2;
    }
    __name(parseUsersDarwin, "parseUsersDarwin");
    function users(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = [];
          if (_linux) {
            exec('export LC_ALL=C; who --ips; echo "---"; w; unset LC_ALL | tail -n +2', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result2 = parseUsersLinux(lines, 1);
                if (result2.length === 0) {
                  exec('who; echo "---"; w | tail -n +2', function(error2, stdout2) {
                    if (!error2) {
                      lines = stdout2.toString().split("\n");
                      result2 = parseUsersLinux(lines, 2);
                    }
                    if (callback) {
                      callback(result2);
                    }
                    resolve5(result2);
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            });
          }
          if (_freebsd || _openbsd || _netbsd) {
            exec('who; echo "---"; w -ih', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result2 = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            exec('who; echo "---"; w -h', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result2 = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            exec('export LC_ALL=C; who; echo "---"; w -ih; unset LC_ALL', function(error, stdout) {
              if (!error) {
                let lines = stdout.toString().split("\n");
                result2 = parseUsersDarwin(lines);
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_windows) {
            try {
              let cmd = `Get-CimInstance Win32_LogonSession | select LogonId,@{n="StartTime";e={$_.StartTime.ToString("yyyy-MM-dd HH:mm:ss")}} | fl; echo '#-#-#-#';`;
              cmd += "Get-CimInstance Win32_LoggedOnUser | select antecedent,dependent | fl ; echo '#-#-#-#';";
              cmd += `$process = (Get-CimInstance Win32_Process -Filter "name = 'explorer.exe'"); Invoke-CimMethod -InputObject $process[0] -MethodName GetOwner | select user, domain | fl; get-process -name explorer | select-object sessionid | fl; echo '#-#-#-#';`;
              cmd += "query user";
              util2.powerShell(cmd).then((data) => {
                if (data) {
                  data = data.split("#-#-#-#");
                  let sessions = parseWinSessions((data[0] || "").split(/\n\s*\n/));
                  let loggedons = parseWinLoggedOn((data[1] || "").split(/\n\s*\n/));
                  let queryUser = parseWinUsersQuery((data[3] || "").split("\r\n"));
                  let users2 = parseWinUsers((data[2] || "").split(/\n\s*\n/), queryUser);
                  for (let id in loggedons) {
                    if ({}.hasOwnProperty.call(loggedons, id)) {
                      loggedons[id].dateTime = {}.hasOwnProperty.call(sessions, id) ? sessions[id] : "";
                    }
                  }
                  users2.forEach((user) => {
                    let dateTime = "";
                    for (let id in loggedons) {
                      if ({}.hasOwnProperty.call(loggedons, id)) {
                        if (loggedons[id].user === user.user && (!dateTime || dateTime < loggedons[id].dateTime)) {
                          dateTime = loggedons[id].dateTime;
                        }
                      }
                    }
                    result2.push({
                      user: user.user,
                      tty: user.tty,
                      date: `${dateTime.substring(0, 10)}`,
                      time: `${dateTime.substring(11, 19)}`,
                      ip: "",
                      command: ""
                    });
                  });
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(users, "users");
    function parseWinSessions(sessionParts) {
      const sessions = {};
      sessionParts.forEach((session) => {
        const lines = session.split("\r\n");
        const id = util2.getValue(lines, "LogonId");
        const starttime = util2.getValue(lines, "starttime");
        if (id) {
          sessions[id] = starttime;
        }
      });
      return sessions;
    }
    __name(parseWinSessions, "parseWinSessions");
    function fuzzyMatch(name1, name2) {
      name1 = name1.toLowerCase();
      name2 = name2.toLowerCase();
      let eq = 0;
      let len = name1.length;
      if (name2.length > len) {
        len = name2.length;
      }
      for (let i = 0; i < len; i++) {
        const c1 = name1[i] || "";
        const c2 = name2[i] || "";
        if (c1 === c2) {
          eq++;
        }
      }
      return len > 10 ? eq / len > 0.9 : len > 0 ? eq / len > 0.8 : false;
    }
    __name(fuzzyMatch, "fuzzyMatch");
    function parseWinUsers(userParts, userQuery) {
      const users2 = [];
      userParts.forEach((user) => {
        const lines = user.split("\r\n");
        const domain = util2.getValue(lines, "domain", ":", true);
        const username = util2.getValue(lines, "user", ":", true);
        const sessionid = util2.getValue(lines, "sessionid", ":", true);
        if (username) {
          const quser = userQuery.filter((item) => fuzzyMatch(item.user, username));
          users2.push({
            domain,
            user: username,
            tty: quser && quser[0] && quser[0].tty ? quser[0].tty : sessionid
          });
        }
      });
      return users2;
    }
    __name(parseWinUsers, "parseWinUsers");
    function parseWinLoggedOn(loggedonParts) {
      const loggedons = {};
      loggedonParts.forEach((loggedon) => {
        const lines = loggedon.split("\r\n");
        const antecendent = util2.getValue(lines, "antecedent", ":", true);
        let parts2 = antecendent.split("=");
        const name = parts2.length > 2 ? parts2[1].split(",")[0].replace(/"/g, "").trim() : "";
        const domain = parts2.length > 2 ? parts2[2].replace(/"/g, "").replace(/\)/g, "").trim() : "";
        const dependent = util2.getValue(lines, "dependent", ":", true);
        parts2 = dependent.split("=");
        const id = parts2.length > 1 ? parts2[1].replace(/"/g, "").replace(/\)/g, "").trim() : "";
        if (id) {
          loggedons[id] = {
            domain,
            user: name
          };
        }
      });
      return loggedons;
    }
    __name(parseWinLoggedOn, "parseWinLoggedOn");
    function parseWinUsersQuery(lines) {
      lines = lines.filter((item) => item);
      let result2 = [];
      const header = lines[0];
      const headerDelimiter = [];
      if (header) {
        const start = header[0] === " " ? 1 : 0;
        headerDelimiter.push(start - 1);
        let nextSpace = 0;
        for (let i = start + 1; i < header.length; i++) {
          if (header[i] === " " && (header[i - 1] === " " || header[i - 1] === ".")) {
            nextSpace = i;
          } else {
            if (nextSpace) {
              headerDelimiter.push(nextSpace);
              nextSpace = 0;
            }
          }
        }
        for (let i = 1; i < lines.length; i++) {
          if (lines[i].trim()) {
            const user = lines[i].substring(headerDelimiter[0] + 1, headerDelimiter[1]).trim() || "";
            const tty = lines[i].substring(headerDelimiter[1] + 1, headerDelimiter[2] - 2).trim() || "";
            result2.push({
              user,
              tty
            });
          }
        }
      }
      return result2;
    }
    __name(parseWinUsersQuery, "parseWinUsersQuery");
    exports2.users = users;
  }
});

// node_modules/systeminformation/lib/internet.js
var require_internet = __commonJS({
  "node_modules/systeminformation/lib/internet.js"(exports2) {
    "use strict";
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function inetChecksite(url2, callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = {
            url: url2,
            ok: false,
            status: 404,
            ms: null
          };
          if (typeof url2 !== "string") {
            if (callback) {
              callback(result2);
            }
            return resolve5(result2);
          }
          let urlSanitized = "";
          const s = util2.sanitizeShellString(url2, true);
          const l = util2.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (s[i] !== void 0) {
              try {
                s[i].__proto__.toLowerCase = util2.stringToLower;
              } catch (e) {
                Object.setPrototypeOf(s[i], util2.stringObj);
              }
              const sl = s[i].toLowerCase();
              if (sl && sl[0] && !sl[1] && sl[0].length === 1) {
                urlSanitized = urlSanitized + sl[0];
              }
            }
          }
          result2.url = urlSanitized;
          try {
            if (urlSanitized && !util2.isPrototypePolluted()) {
              try {
                urlSanitized.__proto__.startsWith = util2.stringStartWith;
              } catch (e) {
                Object.setPrototypeOf(urlSanitized, util2.stringObj);
              }
              if (urlSanitized.startsWith("file:") || urlSanitized.startsWith("gopher:") || urlSanitized.startsWith("telnet:") || urlSanitized.startsWith("mailto:") || urlSanitized.startsWith("news:") || urlSanitized.startsWith("nntp:")) {
                if (callback) {
                  callback(result2);
                }
                return resolve5(result2);
              }
              util2.checkWebsite(urlSanitized).then((res) => {
                result2.status = res.statusCode;
                result2.ok = res.statusCode >= 200 && res.statusCode <= 399;
                ;
                result2.ms = result2.ok ? res.time : null;
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          } catch (err) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(inetChecksite, "inetChecksite");
    exports2.inetChecksite = inetChecksite;
    function inetLatency(host, callback) {
      if (util2.isFunction(host) && !callback) {
        callback = host;
        host = "";
      }
      host = host || "8.8.8.8";
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (typeof host !== "string") {
            if (callback) {
              callback(null);
            }
            return resolve5(null);
          }
          let hostSanitized = "";
          const s = (util2.isPrototypePolluted() ? "8.8.8.8" : util2.sanitizeShellString(host, true)).trim();
          const l = util2.mathMin(s.length, 2e3);
          for (let i = 0; i <= l; i++) {
            if (!(s[i] === void 0)) {
              try {
                s[i].__proto__.toLowerCase = util2.stringToLower;
              } catch (e) {
                Object.setPrototypeOf(s[i], util2.stringObj);
              }
              const sl = s[i].toLowerCase();
              if (sl && sl[0] && !sl[1]) {
                hostSanitized = hostSanitized + sl[0];
              }
            }
          }
          try {
            hostSanitized.__proto__.startsWith = util2.stringStartWith;
          } catch (e) {
            Object.setPrototypeOf(hostSanitized, util2.stringObj);
          }
          if (hostSanitized.startsWith("file:") || hostSanitized.startsWith("gopher:") || hostSanitized.startsWith("telnet:") || hostSanitized.startsWith("mailto:") || hostSanitized.startsWith("news:") || hostSanitized.startsWith("nntp:")) {
            if (callback) {
              callback(null);
            }
            return resolve5(null);
          }
          let params2;
          if (_linux || _freebsd || _openbsd || _netbsd || _darwin) {
            if (_linux) {
              params2 = [
                "-c",
                "2",
                "-w",
                "3",
                hostSanitized
              ];
            }
            if (_freebsd || _openbsd || _netbsd) {
              params2 = [
                "-c",
                "2",
                "-t",
                "3",
                hostSanitized
              ];
            }
            if (_darwin) {
              params2 = [
                "-c2",
                "-t3",
                hostSanitized
              ];
            }
            util2.execSafe("ping", params2).then((stdout) => {
              let result2 = null;
              if (stdout) {
                const lines = stdout.split("\n").filter((line2) => line2.indexOf("rtt") >= 0 || line2.indexOf("round-trip") >= 0 || line2.indexOf("avg") >= 0).join("\n");
                const line = lines.split("=");
                if (line.length > 1) {
                  const parts2 = line[1].split("/");
                  if (parts2.length > 1) {
                    result2 = parseFloat(parts2[1]);
                  }
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            const params3 = [
              "-s",
              "-a",
              hostSanitized,
              "56",
              "2"
            ];
            const filt = "avg";
            util2.execSafe("ping", params3, {
              timeout: 3e3
            }).then((stdout) => {
              let result2 = null;
              if (stdout) {
                const lines = stdout.split("\n").filter((line2) => line2.indexOf(filt) >= 0).join("\n");
                const line = lines.split("=");
                if (line.length > 1) {
                  const parts2 = line[1].split("/");
                  if (parts2.length > 1) {
                    result2 = parseFloat(parts2[1].replace(",", "."));
                  }
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_windows) {
            let result2 = null;
            try {
              const params3 = [
                hostSanitized,
                "-n",
                "1"
              ];
              util2.execSafe("ping", params3, util2.execOptsWin).then((stdout) => {
                if (stdout) {
                  let lines = stdout.split("\r\n");
                  lines.shift();
                  lines.forEach(function(line) {
                    if ((line.toLowerCase().match(/ms/g) || []).length === 3) {
                      let l2 = line.replace(/ +/g, " ").split(" ");
                      if (l2.length > 6) {
                        result2 = parseFloat(l2[l2.length - 1]);
                      }
                    }
                  });
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              });
            } catch (e) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(inetLatency, "inetLatency");
    exports2.inetLatency = inetLatency;
  }
});

// node_modules/systeminformation/lib/dockerSocket.js
var require_dockerSocket = __commonJS({
  "node_modules/systeminformation/lib/dockerSocket.js"(exports2, module2) {
    "use strict";
    var net = require("net");
    var isWin = require("os").type() === "Windows_NT";
    var socketPath = isWin ? "//./pipe/docker_engine" : "/var/run/docker.sock";
    var DockerSocket = class DockerSocket {
      static {
        __name(this, "DockerSocket");
      }
      getInfo(callback) {
        try {
          let socket = net.createConnection({
            path: socketPath
          });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/info HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
      listImages(all, callback) {
        try {
          let socket = net.createConnection({
            path: socketPath
          });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/images/json" + (all ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
      inspectImage(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({
              path: socketPath
            });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/images/" + id + "/json?stream=0 HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      listContainers(all, callback) {
        try {
          let socket = net.createConnection({
            path: socketPath
          });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/containers/json" + (all ? "?all=1" : "") + " HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
      getStats(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({
              path: socketPath
            });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/stats?stream=0 HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      getInspect(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({
              path: socketPath
            });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/json?stream=0 HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      getProcesses(id, callback) {
        id = id || "";
        if (id) {
          try {
            let socket = net.createConnection({
              path: socketPath
            });
            let alldata = "";
            let data;
            socket.on("connect", () => {
              socket.write("GET http:/containers/" + id + "/top?ps_args=-opid,ppid,pgid,vsz,time,etime,nice,ruser,user,rgroup,group,stat,rss,args HTTP/1.0\r\n\r\n");
            });
            socket.on("data", (data2) => {
              alldata = alldata + data2.toString();
            });
            socket.on("error", () => {
              socket = false;
              callback({});
            });
            socket.on("end", () => {
              let startbody = alldata.indexOf("\r\n\r\n");
              alldata = alldata.substring(startbody + 4);
              socket = false;
              try {
                data = JSON.parse(alldata);
                callback(data);
              } catch (err) {
                callback({});
              }
            });
          } catch (err) {
            callback({});
          }
        } else {
          callback({});
        }
      }
      listVolumes(callback) {
        try {
          let socket = net.createConnection({
            path: socketPath
          });
          let alldata = "";
          let data;
          socket.on("connect", () => {
            socket.write("GET http:/volumes HTTP/1.0\r\n\r\n");
          });
          socket.on("data", (data2) => {
            alldata = alldata + data2.toString();
          });
          socket.on("error", () => {
            socket = false;
            callback({});
          });
          socket.on("end", () => {
            let startbody = alldata.indexOf("\r\n\r\n");
            alldata = alldata.substring(startbody + 4);
            socket = false;
            try {
              data = JSON.parse(alldata);
              callback(data);
            } catch (err) {
              callback({});
            }
          });
        } catch (err) {
          callback({});
        }
      }
    };
    module2.exports = DockerSocket;
  }
});

// node_modules/systeminformation/lib/docker.js
var require_docker = __commonJS({
  "node_modules/systeminformation/lib/docker.js"(exports2) {
    "use strict";
    var util2 = require_util();
    var DockerSocket = require_dockerSocket();
    var _platform = process.platform;
    var _windows = _platform === "win32";
    var _docker_container_stats = {};
    var _docker_socket;
    var _docker_last_read = 0;
    function dockerInfo(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          const result2 = {};
          _docker_socket.getInfo((data) => {
            result2.id = data.ID;
            result2.containers = data.Containers;
            result2.containersRunning = data.ContainersRunning;
            result2.containersPaused = data.ContainersPaused;
            result2.containersStopped = data.ContainersStopped;
            result2.images = data.Images;
            result2.driver = data.Driver;
            result2.memoryLimit = data.MemoryLimit;
            result2.swapLimit = data.SwapLimit;
            result2.kernelMemory = data.KernelMemory;
            result2.cpuCfsPeriod = data.CpuCfsPeriod;
            result2.cpuCfsQuota = data.CpuCfsQuota;
            result2.cpuShares = data.CPUShares;
            result2.cpuSet = data.CPUSet;
            result2.ipv4Forwarding = data.IPv4Forwarding;
            result2.bridgeNfIptables = data.BridgeNfIptables;
            result2.bridgeNfIp6tables = data.BridgeNfIp6tables;
            result2.debug = data.Debug;
            result2.nfd = data.NFd;
            result2.oomKillDisable = data.OomKillDisable;
            result2.ngoroutines = data.NGoroutines;
            result2.systemTime = data.SystemTime;
            result2.loggingDriver = data.LoggingDriver;
            result2.cgroupDriver = data.CgroupDriver;
            result2.nEventsListener = data.NEventsListener;
            result2.kernelVersion = data.KernelVersion;
            result2.operatingSystem = data.OperatingSystem;
            result2.osType = data.OSType;
            result2.architecture = data.Architecture;
            result2.ncpu = data.NCPU;
            result2.memTotal = data.MemTotal;
            result2.dockerRootDir = data.DockerRootDir;
            result2.httpProxy = data.HttpProxy;
            result2.httpsProxy = data.HttpsProxy;
            result2.noProxy = data.NoProxy;
            result2.name = data.Name;
            result2.labels = data.Labels;
            result2.experimentalBuild = data.ExperimentalBuild;
            result2.serverVersion = data.ServerVersion;
            result2.clusterStore = data.ClusterStore;
            result2.clusterAdvertise = data.ClusterAdvertise;
            result2.defaultRuntime = data.DefaultRuntime;
            result2.liveRestoreEnabled = data.LiveRestoreEnabled;
            result2.isolation = data.Isolation;
            result2.initBinary = data.InitBinary;
            result2.productLicense = data.ProductLicense;
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          });
        });
      });
    }
    __name(dockerInfo, "dockerInfo");
    exports2.dockerInfo = dockerInfo;
    function dockerImages(all, callback) {
      if (util2.isFunction(all) && !callback) {
        callback = all;
        all = false;
      }
      if (typeof all === "string" && all === "true") {
        all = true;
      }
      if (typeof all !== "boolean" && all !== void 0) {
        all = false;
      }
      all = all || false;
      let result2 = [];
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          const workload = [];
          _docker_socket.listImages(all, (data) => {
            let dockerImages2 = {};
            try {
              dockerImages2 = data;
              if (dockerImages2 && Object.prototype.toString.call(dockerImages2) === "[object Array]" && dockerImages2.length > 0) {
                dockerImages2.forEach(function(element) {
                  if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                    element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                  }
                  workload.push(dockerImagesInspect(element.Id.trim(), element));
                });
                if (workload.length) {
                  Promise.all(workload).then((data2) => {
                    if (callback) {
                      callback(data2);
                    }
                    resolve5(data2);
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            } catch (err) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          });
        });
      });
    }
    __name(dockerImages, "dockerImages");
    function dockerImagesInspect(imageID, payload) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          imageID = imageID || "";
          if (typeof imageID !== "string") {
            return resolve5();
          }
          const imageIDSanitized = (util2.isPrototypePolluted() ? "" : util2.sanitizeShellString(imageID, true)).trim();
          if (imageIDSanitized) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.inspectImage(imageIDSanitized.trim(), (data) => {
              try {
                resolve5({
                  id: payload.Id,
                  container: data.Container,
                  comment: data.Comment,
                  os: data.Os,
                  architecture: data.Architecture,
                  parent: data.Parent,
                  dockerVersion: data.DockerVersion,
                  size: data.Size,
                  sharedSize: payload.SharedSize,
                  virtualSize: data.VirtualSize,
                  author: data.Author,
                  created: data.Created ? Math.round(new Date(data.Created).getTime() / 1e3) : 0,
                  containerConfig: data.ContainerConfig ? data.ContainerConfig : {},
                  graphDriver: data.GraphDriver ? data.GraphDriver : {},
                  repoDigests: data.RepoDigests ? data.RepoDigests : {},
                  repoTags: data.RepoTags ? data.RepoTags : {},
                  config: data.Config ? data.Config : {},
                  rootFS: data.RootFS ? data.RootFS : {}
                });
              } catch (err) {
                resolve5();
              }
            });
          } else {
            resolve5();
          }
        });
      });
    }
    __name(dockerImagesInspect, "dockerImagesInspect");
    exports2.dockerImages = dockerImages;
    function dockerContainers(all, callback) {
      function inContainers(containers, id) {
        let filtered = containers.filter((obj) => {
          return obj.Id && obj.Id === id;
        });
        return filtered.length > 0;
      }
      __name(inContainers, "inContainers");
      if (util2.isFunction(all) && !callback) {
        callback = all;
        all = false;
      }
      if (typeof all === "string" && all === "true") {
        all = true;
      }
      if (typeof all !== "boolean" && all !== void 0) {
        all = false;
      }
      all = all || false;
      let result2 = [];
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          const workload = [];
          _docker_socket.listContainers(all, (data) => {
            let docker_containers = {};
            try {
              docker_containers = data;
              if (docker_containers && Object.prototype.toString.call(docker_containers) === "[object Array]" && docker_containers.length > 0) {
                for (let key in _docker_container_stats) {
                  if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                    if (!inContainers(docker_containers, key)) {
                      delete _docker_container_stats[key];
                    }
                  }
                }
                docker_containers.forEach(function(element) {
                  if (element.Names && Object.prototype.toString.call(element.Names) === "[object Array]" && element.Names.length > 0) {
                    element.Name = element.Names[0].replace(/^\/|\/$/g, "");
                  }
                  workload.push(dockerContainerInspect(element.Id.trim(), element));
                });
                if (workload.length) {
                  Promise.all(workload).then((data2) => {
                    if (callback) {
                      callback(data2);
                    }
                    resolve5(data2);
                  });
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            } catch (err) {
              for (let key in _docker_container_stats) {
                if ({}.hasOwnProperty.call(_docker_container_stats, key)) {
                  if (!inContainers(docker_containers, key)) {
                    delete _docker_container_stats[key];
                  }
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          });
        });
      });
    }
    __name(dockerContainers, "dockerContainers");
    function dockerContainerInspect(containerID, payload) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          containerID = containerID || "";
          if (typeof containerID !== "string") {
            return resolve5();
          }
          const containerIdSanitized = (util2.isPrototypePolluted() ? "" : util2.sanitizeShellString(containerID, true)).trim();
          if (containerIdSanitized) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getInspect(containerIdSanitized.trim(), (data) => {
              try {
                resolve5({
                  id: payload.Id,
                  name: payload.Name,
                  image: payload.Image,
                  imageID: payload.ImageID,
                  command: payload.Command,
                  created: payload.Created,
                  started: data.State && data.State.StartedAt ? Math.round(new Date(data.State.StartedAt).getTime() / 1e3) : 0,
                  finished: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? Math.round(new Date(data.State.FinishedAt).getTime() / 1e3) : 0,
                  createdAt: data.Created ? data.Created : "",
                  startedAt: data.State && data.State.StartedAt ? data.State.StartedAt : "",
                  finishedAt: data.State && data.State.FinishedAt && !data.State.FinishedAt.startsWith("0001-01-01") ? data.State.FinishedAt : "",
                  state: payload.State,
                  restartCount: data.RestartCount || 0,
                  platform: data.Platform || "",
                  driver: data.Driver || "",
                  ports: payload.Ports,
                  mounts: payload.Mounts
                });
              } catch (err) {
                resolve5();
              }
            });
          } else {
            resolve5();
          }
        });
      });
    }
    __name(dockerContainerInspect, "dockerContainerInspect");
    exports2.dockerContainers = dockerContainers;
    function docker_calcCPUPercent(cpu_stats, precpu_stats) {
      if (!_windows) {
        let cpuPercent = 0;
        let cpuDelta = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
        let systemDelta = cpu_stats.system_cpu_usage - precpu_stats.system_cpu_usage;
        if (systemDelta > 0 && cpuDelta > 0) {
          if (precpu_stats.online_cpus) {
            cpuPercent = cpuDelta / systemDelta * precpu_stats.online_cpus * 100;
          } else {
            cpuPercent = cpuDelta / systemDelta * cpu_stats.cpu_usage.percpu_usage.length * 100;
          }
        }
        return cpuPercent;
      } else {
        let nanoSecNow = util2.nanoSeconds();
        let cpuPercent = 0;
        if (_docker_last_read > 0) {
          let possIntervals = nanoSecNow - _docker_last_read;
          let intervalsUsed = cpu_stats.cpu_usage.total_usage - precpu_stats.cpu_usage.total_usage;
          if (possIntervals > 0) {
            cpuPercent = 100 * intervalsUsed / possIntervals;
          }
        }
        _docker_last_read = nanoSecNow;
        return cpuPercent;
      }
    }
    __name(docker_calcCPUPercent, "docker_calcCPUPercent");
    function docker_calcNetworkIO(networks) {
      let rx;
      let wx;
      for (let key in networks) {
        if (!{}.hasOwnProperty.call(networks, key)) {
          continue;
        }
        let obj = networks[key];
        rx = +obj.rx_bytes;
        wx = +obj.tx_bytes;
      }
      return {
        rx,
        wx
      };
    }
    __name(docker_calcNetworkIO, "docker_calcNetworkIO");
    function docker_calcBlockIO(blkio_stats) {
      let result2 = {
        r: 0,
        w: 0
      };
      if (blkio_stats && blkio_stats.io_service_bytes_recursive && Object.prototype.toString.call(blkio_stats.io_service_bytes_recursive) === "[object Array]" && blkio_stats.io_service_bytes_recursive.length > 0) {
        blkio_stats.io_service_bytes_recursive.forEach(function(element) {
          if (element.op && element.op.toLowerCase() === "read" && element.value) {
            result2.r += element.value;
          }
          if (element.op && element.op.toLowerCase() === "write" && element.value) {
            result2.w += element.value;
          }
        });
      }
      return result2;
    }
    __name(docker_calcBlockIO, "docker_calcBlockIO");
    function dockerContainerStats(containerIDs, callback) {
      let containerArray = [];
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (util2.isFunction(containerIDs) && !callback) {
            callback = containerIDs;
            containerArray = [
              "*"
            ];
          } else {
            containerIDs = containerIDs || "*";
            if (typeof containerIDs !== "string") {
              if (callback) {
                callback([]);
              }
              return resolve5([]);
            }
            let containerIDsSanitized = "";
            try {
              containerIDsSanitized.__proto__.toLowerCase = util2.stringToLower;
              containerIDsSanitized.__proto__.replace = util2.stringReplace;
              containerIDsSanitized.__proto__.toString = util2.stringToString;
              containerIDsSanitized.__proto__.substr = util2.stringSubstr;
              containerIDsSanitized.__proto__.substring = util2.stringSubstring;
              containerIDsSanitized.__proto__.trim = util2.stringTrim;
              containerIDsSanitized.__proto__.startsWith = util2.stringStartWith;
            } catch (e) {
              Object.setPrototypeOf(containerIDsSanitized, util2.stringObj);
            }
            containerIDsSanitized = containerIDs;
            containerIDsSanitized = containerIDsSanitized.trim();
            if (containerIDsSanitized !== "*") {
              containerIDsSanitized = "";
              const s = (util2.isPrototypePolluted() ? "" : util2.sanitizeShellString(containerIDs, true)).trim();
              const l = util2.mathMin(s.length, 2e3);
              for (let i = 0; i <= l; i++) {
                if (s[i] !== void 0) {
                  s[i].__proto__.toLowerCase = util2.stringToLower;
                  const sl = s[i].toLowerCase();
                  if (sl && sl[0] && !sl[1]) {
                    containerIDsSanitized = containerIDsSanitized + sl[0];
                  }
                }
              }
            }
            containerIDsSanitized = containerIDsSanitized.trim().toLowerCase().replace(/,+/g, "|");
            containerArray = containerIDsSanitized.split("|");
          }
          const result2 = [];
          const workload = [];
          if (containerArray.length && containerArray[0].trim() === "*") {
            containerArray = [];
            dockerContainers().then((allContainers) => {
              for (let container of allContainers) {
                containerArray.push(container.id.substring(0, 12));
              }
              if (containerArray.length) {
                dockerContainerStats(containerArray.join(",")).then((result3) => {
                  if (callback) {
                    callback(result3);
                  }
                  resolve5(result3);
                });
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            });
          } else {
            for (let containerID of containerArray) {
              workload.push(dockerContainerStatsSingle(containerID.trim()));
            }
            if (workload.length) {
              Promise.all(workload).then((data) => {
                if (callback) {
                  callback(data);
                }
                resolve5(data);
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          }
        });
      });
    }
    __name(dockerContainerStats, "dockerContainerStats");
    function dockerContainerStatsSingle(containerID) {
      containerID = containerID || "";
      let result2 = {
        id: containerID,
        memUsage: 0,
        memLimit: 0,
        memPercent: 0,
        cpuPercent: 0,
        pids: 0,
        netIO: {
          rx: 0,
          wx: 0
        },
        blockIO: {
          r: 0,
          w: 0
        },
        restartCount: 0,
        cpuStats: {},
        precpuStats: {},
        memoryStats: {},
        networks: {}
      };
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (containerID) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getInspect(containerID, (dataInspect) => {
              try {
                _docker_socket.getStats(containerID, (data) => {
                  try {
                    let stats = data;
                    if (!stats.message) {
                      if (data.id) {
                        result2.id = data.id;
                      }
                      result2.memUsage = stats.memory_stats && stats.memory_stats.usage ? stats.memory_stats.usage : 0;
                      result2.memLimit = stats.memory_stats && stats.memory_stats.limit ? stats.memory_stats.limit : 0;
                      result2.memPercent = stats.memory_stats && stats.memory_stats.usage && stats.memory_stats.limit ? stats.memory_stats.usage / stats.memory_stats.limit * 100 : 0;
                      result2.cpuPercent = stats.cpu_stats && stats.precpu_stats ? docker_calcCPUPercent(stats.cpu_stats, stats.precpu_stats) : 0;
                      result2.pids = stats.pids_stats && stats.pids_stats.current ? stats.pids_stats.current : 0;
                      result2.restartCount = dataInspect.RestartCount ? dataInspect.RestartCount : 0;
                      if (stats.networks) {
                        result2.netIO = docker_calcNetworkIO(stats.networks);
                      }
                      if (stats.blkio_stats) {
                        result2.blockIO = docker_calcBlockIO(stats.blkio_stats);
                      }
                      result2.cpuStats = stats.cpu_stats ? stats.cpu_stats : {};
                      result2.precpuStats = stats.precpu_stats ? stats.precpu_stats : {};
                      result2.memoryStats = stats.memory_stats ? stats.memory_stats : {};
                      result2.networks = stats.networks ? stats.networks : {};
                    }
                  } catch (err) {
                    util2.noop();
                  }
                  resolve5(result2);
                });
              } catch (err) {
                util2.noop();
              }
            });
          } else {
            resolve5(result2);
          }
        });
      });
    }
    __name(dockerContainerStatsSingle, "dockerContainerStatsSingle");
    exports2.dockerContainerStats = dockerContainerStats;
    function dockerContainerProcesses(containerID, callback) {
      let result2 = [];
      return new Promise((resolve5) => {
        process.nextTick(() => {
          containerID = containerID || "";
          if (typeof containerID !== "string") {
            return resolve5(result2);
          }
          const containerIdSanitized = (util2.isPrototypePolluted() ? "" : util2.sanitizeShellString(containerID, true)).trim();
          if (containerIdSanitized) {
            if (!_docker_socket) {
              _docker_socket = new DockerSocket();
            }
            _docker_socket.getProcesses(containerIdSanitized, (data) => {
              try {
                if (data && data.Titles && data.Processes) {
                  let titles = data.Titles.map(function(value2) {
                    return value2.toUpperCase();
                  });
                  let pos_pid = titles.indexOf("PID");
                  let pos_ppid = titles.indexOf("PPID");
                  let pos_pgid = titles.indexOf("PGID");
                  let pos_vsz = titles.indexOf("VSZ");
                  let pos_time = titles.indexOf("TIME");
                  let pos_elapsed = titles.indexOf("ELAPSED");
                  let pos_ni = titles.indexOf("NI");
                  let pos_ruser = titles.indexOf("RUSER");
                  let pos_user = titles.indexOf("USER");
                  let pos_rgroup = titles.indexOf("RGROUP");
                  let pos_group = titles.indexOf("GROUP");
                  let pos_stat = titles.indexOf("STAT");
                  let pos_rss = titles.indexOf("RSS");
                  let pos_command = titles.indexOf("COMMAND");
                  data.Processes.forEach((process1) => {
                    result2.push({
                      pidHost: pos_pid >= 0 ? process1[pos_pid] : "",
                      ppid: pos_ppid >= 0 ? process1[pos_ppid] : "",
                      pgid: pos_pgid >= 0 ? process1[pos_pgid] : "",
                      user: pos_user >= 0 ? process1[pos_user] : "",
                      ruser: pos_ruser >= 0 ? process1[pos_ruser] : "",
                      group: pos_group >= 0 ? process1[pos_group] : "",
                      rgroup: pos_rgroup >= 0 ? process1[pos_rgroup] : "",
                      stat: pos_stat >= 0 ? process1[pos_stat] : "",
                      time: pos_time >= 0 ? process1[pos_time] : "",
                      elapsed: pos_elapsed >= 0 ? process1[pos_elapsed] : "",
                      nice: pos_ni >= 0 ? process1[pos_ni] : "",
                      rss: pos_rss >= 0 ? process1[pos_rss] : "",
                      vsz: pos_vsz >= 0 ? process1[pos_vsz] : "",
                      command: pos_command >= 0 ? process1[pos_command] : ""
                    });
                  });
                }
              } catch (err) {
                util2.noop();
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          } else {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(dockerContainerProcesses, "dockerContainerProcesses");
    exports2.dockerContainerProcesses = dockerContainerProcesses;
    function dockerVolumes(callback) {
      let result2 = [];
      return new Promise((resolve5) => {
        process.nextTick(() => {
          if (!_docker_socket) {
            _docker_socket = new DockerSocket();
          }
          _docker_socket.listVolumes((data) => {
            let dockerVolumes2 = {};
            try {
              dockerVolumes2 = data;
              if (dockerVolumes2 && dockerVolumes2.Volumes && Object.prototype.toString.call(dockerVolumes2.Volumes) === "[object Array]" && dockerVolumes2.Volumes.length > 0) {
                dockerVolumes2.Volumes.forEach(function(element) {
                  result2.push({
                    name: element.Name,
                    driver: element.Driver,
                    labels: element.Labels,
                    mountpoint: element.Mountpoint,
                    options: element.Options,
                    scope: element.Scope,
                    created: element.CreatedAt ? Math.round(new Date(element.CreatedAt).getTime() / 1e3) : 0
                  });
                });
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            } catch (err) {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          });
        });
      });
    }
    __name(dockerVolumes, "dockerVolumes");
    exports2.dockerVolumes = dockerVolumes;
    function dockerAll(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          dockerContainers(true).then((result2) => {
            if (result2 && Object.prototype.toString.call(result2) === "[object Array]" && result2.length > 0) {
              let l = result2.length;
              result2.forEach(function(element) {
                dockerContainerStats(element.id).then((res) => {
                  element.memUsage = res[0].memUsage;
                  element.memLimit = res[0].memLimit;
                  element.memPercent = res[0].memPercent;
                  element.cpuPercent = res[0].cpuPercent;
                  element.pids = res[0].pids;
                  element.netIO = res[0].netIO;
                  element.blockIO = res[0].blockIO;
                  element.cpuStats = res[0].cpuStats;
                  element.precpuStats = res[0].precpuStats;
                  element.memoryStats = res[0].memoryStats;
                  element.networks = res[0].networks;
                  dockerContainerProcesses(element.id).then((processes) => {
                    element.processes = processes;
                    l -= 1;
                    if (l === 0) {
                      if (callback) {
                        callback(result2);
                      }
                      resolve5(result2);
                    }
                  });
                });
              });
            } else {
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            }
          });
        });
      });
    }
    __name(dockerAll, "dockerAll");
    exports2.dockerAll = dockerAll;
  }
});

// node_modules/systeminformation/lib/virtualbox.js
var require_virtualbox = __commonJS({
  "node_modules/systeminformation/lib/virtualbox.js"(exports2) {
    "use strict";
    var os = require("os");
    var exec = require("child_process").exec;
    var util2 = require_util();
    function vboxInfo(callback) {
      let result2 = [];
      return new Promise((resolve5) => {
        process.nextTick(() => {
          try {
            exec(util2.getVboxmanage() + " list vms --long", function(error, stdout) {
              let parts2 = (os.EOL + stdout.toString()).split(os.EOL + "Name:");
              parts2.shift();
              parts2.forEach((part) => {
                const lines = ("Name:" + part).split(os.EOL);
                const state = util2.getValue(lines, "State");
                const running = state.startsWith("running");
                const runningSinceString = running ? state.replace("running (since ", "").replace(")", "").trim() : "";
                let runningSince = 0;
                try {
                  if (running) {
                    const sinceDateObj = new Date(runningSinceString);
                    const offset = sinceDateObj.getTimezoneOffset();
                    runningSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1e3) + offset * 60;
                  }
                } catch (e) {
                  util2.noop();
                }
                const stoppedSinceString = !running ? state.replace("powered off (since", "").replace(")", "").trim() : "";
                let stoppedSince = 0;
                try {
                  if (!running) {
                    const sinceDateObj = new Date(stoppedSinceString);
                    const offset = sinceDateObj.getTimezoneOffset();
                    stoppedSince = Math.round((Date.now() - Date.parse(sinceDateObj)) / 1e3) + offset * 60;
                  }
                } catch (e) {
                  util2.noop();
                }
                result2.push({
                  id: util2.getValue(lines, "UUID"),
                  name: util2.getValue(lines, "Name"),
                  running,
                  started: runningSinceString,
                  runningSince,
                  stopped: stoppedSinceString,
                  stoppedSince,
                  guestOS: util2.getValue(lines, "Guest OS"),
                  hardwareUUID: util2.getValue(lines, "Hardware UUID"),
                  memory: parseInt(util2.getValue(lines, "Memory size", "     "), 10),
                  vram: parseInt(util2.getValue(lines, "VRAM size"), 10),
                  cpus: parseInt(util2.getValue(lines, "Number of CPUs"), 10),
                  cpuExepCap: util2.getValue(lines, "CPU exec cap"),
                  cpuProfile: util2.getValue(lines, "CPUProfile"),
                  chipset: util2.getValue(lines, "Chipset"),
                  firmware: util2.getValue(lines, "Firmware"),
                  pageFusion: util2.getValue(lines, "Page Fusion") === "enabled",
                  configFile: util2.getValue(lines, "Config file"),
                  snapshotFolder: util2.getValue(lines, "Snapshot folder"),
                  logFolder: util2.getValue(lines, "Log folder"),
                  hpet: util2.getValue(lines, "HPET") === "enabled",
                  pae: util2.getValue(lines, "PAE") === "enabled",
                  longMode: util2.getValue(lines, "Long Mode") === "enabled",
                  tripleFaultReset: util2.getValue(lines, "Triple Fault Reset") === "enabled",
                  apic: util2.getValue(lines, "APIC") === "enabled",
                  x2Apic: util2.getValue(lines, "X2APIC") === "enabled",
                  acpi: util2.getValue(lines, "ACPI") === "enabled",
                  ioApic: util2.getValue(lines, "IOAPIC") === "enabled",
                  biosApicMode: util2.getValue(lines, "BIOS APIC mode"),
                  bootMenuMode: util2.getValue(lines, "Boot menu mode"),
                  bootDevice1: util2.getValue(lines, "Boot Device 1"),
                  bootDevice2: util2.getValue(lines, "Boot Device 2"),
                  bootDevice3: util2.getValue(lines, "Boot Device 3"),
                  bootDevice4: util2.getValue(lines, "Boot Device 4"),
                  timeOffset: util2.getValue(lines, "Time offset"),
                  rtc: util2.getValue(lines, "RTC")
                });
              });
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          } catch (e) {
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
        });
      });
    }
    __name(vboxInfo, "vboxInfo");
    exports2.vboxInfo = vboxInfo;
  }
});

// node_modules/systeminformation/lib/printer.js
var require_printer = __commonJS({
  "node_modules/systeminformation/lib/printer.js"(exports2) {
    "use strict";
    var exec = require("child_process").exec;
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    var winPrinterStatus = {
      1: "Other",
      2: "Unknown",
      3: "Idle",
      4: "Printing",
      5: "Warmup",
      6: "Stopped Printing",
      7: "Offline"
    };
    function parseLinuxCupsHeader(lines) {
      const result2 = {};
      if (lines && lines.length) {
        if (lines[0].indexOf(" CUPS v") > 0) {
          const parts2 = lines[0].split(" CUPS v");
          result2.cupsVersion = parts2[1];
        }
      }
      return result2;
    }
    __name(parseLinuxCupsHeader, "parseLinuxCupsHeader");
    function parseLinuxCupsPrinter(lines) {
      const result2 = {};
      const printerId = util2.getValue(lines, "PrinterId", " ");
      result2.id = printerId ? parseInt(printerId, 10) : null;
      result2.name = util2.getValue(lines, "Info", " ");
      result2.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
      result2.uri = util2.getValue(lines, "DeviceURI", " ");
      result2.uuid = util2.getValue(lines, "UUID", " ");
      result2.status = util2.getValue(lines, "State", " ");
      result2.local = util2.getValue(lines, "Location", " ").toLowerCase().startsWith("local");
      result2.default = null;
      result2.shared = util2.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
      return result2;
    }
    __name(parseLinuxCupsPrinter, "parseLinuxCupsPrinter");
    function parseLinuxLpstatPrinter(lines, id) {
      const result2 = {};
      result2.id = id;
      result2.name = util2.getValue(lines, "Description", ":", true);
      result2.model = lines.length > 0 && lines[0] ? lines[0].split(" ")[0] : "";
      result2.uri = null;
      result2.uuid = null;
      result2.status = lines.length > 0 && lines[0] ? lines[0].indexOf(" idle") > 0 ? "idle" : lines[0].indexOf(" printing") > 0 ? "printing" : "unknown" : null;
      result2.local = util2.getValue(lines, "Location", ":", true).toLowerCase().startsWith("local");
      result2.default = null;
      result2.shared = util2.getValue(lines, "Shared", " ").toLowerCase().startsWith("yes");
      return result2;
    }
    __name(parseLinuxLpstatPrinter, "parseLinuxLpstatPrinter");
    function parseDarwinPrinters(printerObject, id) {
      const result2 = {};
      const uriParts = printerObject.uri.split("/");
      result2.id = id;
      result2.name = printerObject._name;
      result2.model = uriParts.length ? uriParts[uriParts.length - 1] : "";
      result2.uri = printerObject.uri;
      result2.uuid = null;
      result2.status = printerObject.status;
      result2.local = printerObject.printserver === "local";
      result2.default = printerObject.default === "yes";
      result2.shared = printerObject.shared === "yes";
      return result2;
    }
    __name(parseDarwinPrinters, "parseDarwinPrinters");
    function parseWindowsPrinters(lines, id) {
      const result2 = {};
      const status = parseInt(util2.getValue(lines, "PrinterStatus", ":"), 10);
      result2.id = id;
      result2.name = util2.getValue(lines, "name", ":");
      result2.model = util2.getValue(lines, "DriverName", ":");
      result2.uri = null;
      result2.uuid = null;
      result2.status = winPrinterStatus[status] ? winPrinterStatus[status] : null;
      result2.local = util2.getValue(lines, "Local", ":").toUpperCase() === "TRUE";
      result2.default = util2.getValue(lines, "Default", ":").toUpperCase() === "TRUE";
      result2.shared = util2.getValue(lines, "Shared", ":").toUpperCase() === "TRUE";
      return result2;
    }
    __name(parseWindowsPrinters, "parseWindowsPrinters");
    function printer(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = "cat /etc/cups/printers.conf 2>/dev/null";
            exec(cmd, function(error, stdout) {
              if (!error) {
                const parts2 = stdout.toString().split("<Printer ");
                const printerHeader = parseLinuxCupsHeader(parts2[0]);
                for (let i = 1; i < parts2.length; i++) {
                  const printers = parseLinuxCupsPrinter(parts2[i].split("\n"));
                  if (printers.name) {
                    printers.engine = "CUPS";
                    printers.engineVersion = printerHeader.cupsVersion;
                    result2.push(printers);
                  }
                }
              }
              if (result2.length === 0) {
                if (_linux) {
                  cmd = "export LC_ALL=C; lpstat -lp 2>/dev/null; unset LC_ALL";
                  exec(cmd, function(error2, stdout2) {
                    const parts2 = ("\n" + stdout2.toString()).split("\nprinter ");
                    for (let i = 1; i < parts2.length; i++) {
                      const printers = parseLinuxLpstatPrinter(parts2[i].split("\n"), i);
                      result2.push(printers);
                    }
                  });
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                } else {
                  if (callback) {
                    callback(result2);
                  }
                  resolve5(result2);
                }
              } else {
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
            });
          }
          if (_darwin) {
            let cmd = "system_profiler SPPrintersDataType -json";
            exec(cmd, function(error, stdout) {
              if (!error) {
                try {
                  const outObj = JSON.parse(stdout.toString());
                  if (outObj.SPPrintersDataType && outObj.SPPrintersDataType.length) {
                    for (let i = 0; i < outObj.SPPrintersDataType.length; i++) {
                      const printer2 = parseDarwinPrinters(outObj.SPPrintersDataType[i], i);
                      result2.push(printer2);
                    }
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_windows) {
            util2.powerShell("Get-CimInstance Win32_Printer | select PrinterStatus,Name,DriverName,Local,Default,Shared | fl").then((stdout, error) => {
              if (!error) {
                const parts2 = stdout.toString().split(/\n\s*\n/);
                for (let i = 0; i < parts2.length; i++) {
                  const printer2 = parseWindowsPrinters(parts2[i].split("\n"), i);
                  if (printer2.name || printer2.model) {
                    result2.push(printer2);
                  }
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            resolve5(null);
          }
        });
      });
    }
    __name(printer, "printer");
    exports2.printer = printer;
  }
});

// node_modules/systeminformation/lib/usb.js
var require_usb = __commonJS({
  "node_modules/systeminformation/lib/usb.js"(exports2) {
    "use strict";
    var exec = require("child_process").exec;
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function getLinuxUsbType(type, name) {
      let result2 = type;
      const str = (name + " " + type).toLowerCase();
      if (str.indexOf("camera") >= 0) {
        result2 = "Camera";
      } else if (str.indexOf("hub") >= 0) {
        result2 = "Hub";
      } else if (str.indexOf("keybrd") >= 0) {
        result2 = "Keyboard";
      } else if (str.indexOf("keyboard") >= 0) {
        result2 = "Keyboard";
      } else if (str.indexOf("mouse") >= 0) {
        result2 = "Mouse";
      } else if (str.indexOf("stora") >= 0) {
        result2 = "Storage";
      } else if (str.indexOf("microp") >= 0) {
        result2 = "Microphone";
      } else if (str.indexOf("headset") >= 0) {
        result2 = "Audio";
      } else if (str.indexOf("audio") >= 0) {
        result2 = "Audio";
      }
      return result2;
    }
    __name(getLinuxUsbType, "getLinuxUsbType");
    function parseLinuxUsb(usb2) {
      const result2 = {};
      const lines = usb2.split("\n");
      if (lines && lines.length && lines[0].indexOf("Device") >= 0) {
        const parts2 = lines[0].split(" ");
        result2.bus = parseInt(parts2[0], 10);
        if (parts2[2]) {
          result2.deviceId = parseInt(parts2[2], 10);
        } else {
          result2.deviceId = null;
        }
      } else {
        result2.bus = null;
        result2.deviceId = null;
      }
      const idVendor = util2.getValue(lines, "idVendor", " ", true).trim();
      let vendorParts = idVendor.split(" ");
      vendorParts.shift();
      const vendor = vendorParts.join(" ");
      const idProduct = util2.getValue(lines, "idProduct", " ", true).trim();
      let productParts = idProduct.split(" ");
      productParts.shift();
      const product = productParts.join(" ");
      const interfaceClass = util2.getValue(lines, "bInterfaceClass", " ", true).trim();
      let interfaceClassParts = interfaceClass.split(" ");
      interfaceClassParts.shift();
      const usbType = interfaceClassParts.join(" ");
      const iManufacturer = util2.getValue(lines, "iManufacturer", " ", true).trim();
      let iManufacturerParts = iManufacturer.split(" ");
      iManufacturerParts.shift();
      const manufacturer = iManufacturerParts.join(" ");
      const iSerial = util2.getValue(lines, "iSerial", " ", true).trim();
      let iSerialParts = iSerial.split(" ");
      iSerialParts.shift();
      const serial = iSerialParts.join(" ");
      result2.id = (idVendor.startsWith("0x") ? idVendor.split(" ")[0].substr(2, 10) : "") + ":" + (idProduct.startsWith("0x") ? idProduct.split(" ")[0].substr(2, 10) : "");
      result2.name = product;
      result2.type = getLinuxUsbType(usbType, product);
      result2.removable = null;
      result2.vendor = vendor;
      result2.manufacturer = manufacturer;
      result2.maxPower = util2.getValue(lines, "MaxPower", " ", true);
      result2.serialNumber = serial;
      return result2;
    }
    __name(parseLinuxUsb, "parseLinuxUsb");
    function getDarwinUsbType(name) {
      let result2 = "";
      if (name.indexOf("camera") >= 0) {
        result2 = "Camera";
      } else if (name.indexOf("touch bar") >= 0) {
        result2 = "Touch Bar";
      } else if (name.indexOf("controller") >= 0) {
        result2 = "Controller";
      } else if (name.indexOf("headset") >= 0) {
        result2 = "Audio";
      } else if (name.indexOf("keyboard") >= 0) {
        result2 = "Keyboard";
      } else if (name.indexOf("trackpad") >= 0) {
        result2 = "Trackpad";
      } else if (name.indexOf("sensor") >= 0) {
        result2 = "Sensor";
      } else if (name.indexOf("bthusb") >= 0) {
        result2 = "Bluetooth";
      } else if (name.indexOf("bth") >= 0) {
        result2 = "Bluetooth";
      } else if (name.indexOf("rfcomm") >= 0) {
        result2 = "Bluetooth";
      } else if (name.indexOf("usbhub") >= 0) {
        result2 = "Hub";
      } else if (name.indexOf(" hub") >= 0) {
        result2 = "Hub";
      } else if (name.indexOf("mouse") >= 0) {
        result2 = "Mouse";
      } else if (name.indexOf("microp") >= 0) {
        result2 = "Microphone";
      } else if (name.indexOf("removable") >= 0) {
        result2 = "Storage";
      }
      return result2;
    }
    __name(getDarwinUsbType, "getDarwinUsbType");
    function parseDarwinUsb(usb2, id) {
      const result2 = {};
      result2.id = id;
      usb2 = usb2.replace(/ \|/g, "");
      usb2 = usb2.trim();
      let lines = usb2.split("\n");
      lines.shift();
      try {
        for (let i = 0; i < lines.length; i++) {
          lines[i] = lines[i].trim();
          lines[i] = lines[i].replace(/=/g, ":");
          if (lines[i] !== "{" && lines[i] !== "}" && lines[i + 1] && lines[i + 1].trim() !== "}") {
            lines[i] = lines[i] + ",";
          }
          lines[i] = lines[i].replace(":Yes,", ':"Yes",');
          lines[i] = lines[i].replace(": Yes,", ': "Yes",');
          lines[i] = lines[i].replace(": Yes", ': "Yes"');
          lines[i] = lines[i].replace(":No,", ':"No",');
          lines[i] = lines[i].replace(": No,", ': "No",');
          lines[i] = lines[i].replace(": No", ': "No"');
          lines[i] = lines[i].replace("((", "").replace("))", "");
          const match = /<(\w+)>/.exec(lines[i]);
          if (match) {
            const number = match[0];
            lines[i] = lines[i].replace(number, `"${number}"`);
          }
        }
        const usbObj = JSON.parse(lines.join("\n"));
        const removableDrive = (usbObj["Built-In"] ? usbObj["Built-In"].toLowerCase() !== "yes" : true) && (usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() === "no" : true);
        result2.bus = null;
        result2.deviceId = null;
        result2.id = usbObj["USB Address"] || null;
        result2.name = usbObj["kUSBProductString"] || usbObj["USB Product Name"] || null;
        result2.type = getDarwinUsbType((usbObj["kUSBProductString"] || usbObj["USB Product Name"] || "").toLowerCase() + (removableDrive ? " removable" : ""));
        result2.removable = usbObj["non-removable"] ? usbObj["non-removable"].toLowerCase() || false : true;
        result2.vendor = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
        result2.manufacturer = usbObj["kUSBVendorString"] || usbObj["USB Vendor Name"] || null;
        result2.maxPower = null;
        result2.serialNumber = usbObj["kUSBSerialNumberString"] || null;
        if (result2.name) {
          return result2;
        } else {
          return null;
        }
      } catch (e) {
        return null;
      }
    }
    __name(parseDarwinUsb, "parseDarwinUsb");
    function getWindowsUsbTypeCreation(creationclass, name) {
      let result2 = "";
      if (name.indexOf("storage") >= 0) {
        result2 = "Storage";
      } else if (name.indexOf("speicher") >= 0) {
        result2 = "Storage";
      } else if (creationclass.indexOf("usbhub") >= 0) {
        result2 = "Hub";
      } else if (creationclass.indexOf("storage") >= 0) {
        result2 = "Storage";
      } else if (creationclass.indexOf("usbcontroller") >= 0) {
        result2 = "Controller";
      } else if (creationclass.indexOf("keyboard") >= 0) {
        result2 = "Keyboard";
      } else if (creationclass.indexOf("pointing") >= 0) {
        result2 = "Mouse";
      } else if (creationclass.indexOf("microp") >= 0) {
        result2 = "Microphone";
      } else if (creationclass.indexOf("disk") >= 0) {
        result2 = "Storage";
      }
      return result2;
    }
    __name(getWindowsUsbTypeCreation, "getWindowsUsbTypeCreation");
    function parseWindowsUsb(lines, id) {
      const usbType = getWindowsUsbTypeCreation(util2.getValue(lines, "CreationClassName", ":").toLowerCase(), util2.getValue(lines, "name", ":").toLowerCase());
      if (usbType) {
        const result2 = {};
        result2.bus = null;
        result2.deviceId = util2.getValue(lines, "deviceid", ":");
        result2.id = id;
        result2.name = util2.getValue(lines, "name", ":");
        result2.type = usbType;
        result2.removable = null;
        result2.vendor = null;
        result2.manufacturer = util2.getValue(lines, "Manufacturer", ":");
        result2.maxPower = null;
        result2.serialNumber = null;
        return result2;
      } else {
        return null;
      }
    }
    __name(parseWindowsUsb, "parseWindowsUsb");
    function usb(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = [];
          if (_linux) {
            const cmd = "export LC_ALL=C; lsusb -v 2>/dev/null; unset LC_ALL";
            exec(cmd, {
              maxBuffer: 1024 * 1024 * 128
            }, function(error, stdout) {
              if (!error) {
                const parts2 = ("\n\n" + stdout.toString()).split("\n\nBus ");
                for (let i = 1; i < parts2.length; i++) {
                  const usb2 = parseLinuxUsb(parts2[i]);
                  result2.push(usb2);
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            let cmd = "ioreg -p IOUSB -c AppleUSBRootHubDevice -w0 -l";
            exec(cmd, {
              maxBuffer: 1024 * 1024 * 128
            }, function(error, stdout) {
              if (!error) {
                const parts2 = stdout.toString().split(" +-o ");
                for (let i = 1; i < parts2.length; i++) {
                  const usb2 = parseDarwinUsb(parts2[i]);
                  if (usb2) {
                    result2.push(usb2);
                  }
                }
                if (callback) {
                  callback(result2);
                }
                resolve5(result2);
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_windows) {
            util2.powerShell('Get-CimInstance CIM_LogicalDevice | where { $_.Description -match "USB"} | select Name,CreationClassName,DeviceId,Manufacturer | fl').then((stdout, error) => {
              if (!error) {
                const parts2 = stdout.toString().split(/\n\s*\n/);
                for (let i = 0; i < parts2.length; i++) {
                  const usb2 = parseWindowsUsb(parts2[i].split("\n"), i);
                  if (usb2 && result2.filter((x) => x.deviceId === usb2.deviceId).length === 0) {
                    result2.push(usb2);
                  }
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos || _freebsd || _openbsd || _netbsd) {
            resolve5(null);
          }
        });
      });
    }
    __name(usb, "usb");
    exports2.usb = usb;
  }
});

// node_modules/systeminformation/lib/audio.js
var require_audio = __commonJS({
  "node_modules/systeminformation/lib/audio.js"(exports2) {
    "use strict";
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var util2 = require_util();
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function parseAudioType(str, input, output) {
      str = str.toLowerCase();
      let result2 = "";
      if (str.indexOf("input") >= 0) {
        result2 = "Microphone";
      }
      if (str.indexOf("display audio") >= 0) {
        result2 = "Speaker";
      }
      if (str.indexOf("speak") >= 0) {
        result2 = "Speaker";
      }
      if (str.indexOf("laut") >= 0) {
        result2 = "Speaker";
      }
      if (str.indexOf("loud") >= 0) {
        result2 = "Speaker";
      }
      if (str.indexOf("head") >= 0) {
        result2 = "Headset";
      }
      if (str.indexOf("mic") >= 0) {
        result2 = "Microphone";
      }
      if (str.indexOf("mikr") >= 0) {
        result2 = "Microphone";
      }
      if (str.indexOf("phone") >= 0) {
        result2 = "Phone";
      }
      if (str.indexOf("controll") >= 0) {
        result2 = "Controller";
      }
      if (str.indexOf("line o") >= 0) {
        result2 = "Line Out";
      }
      if (str.indexOf("digital o") >= 0) {
        result2 = "Digital Out";
      }
      if (str.indexOf("smart sound technology") >= 0) {
        result2 = "Digital Signal Processor";
      }
      if (str.indexOf("high definition audio") >= 0) {
        result2 = "Sound Driver";
      }
      if (!result2 && output) {
        result2 = "Speaker";
      } else if (!result2 && input) {
        result2 = "Microphone";
      }
      return result2;
    }
    __name(parseAudioType, "parseAudioType");
    function getLinuxAudioPci() {
      let cmd = "lspci -v 2>/dev/null";
      let result2 = [];
      try {
        const parts2 = execSync(cmd, util2.execOptsLinux).toString().split("\n\n");
        parts2.forEach((element) => {
          const lines = element.split("\n");
          if (lines && lines.length && lines[0].toLowerCase().indexOf("audio") >= 0) {
            const audio2 = {};
            audio2.slotId = lines[0].split(" ")[0];
            audio2.driver = util2.getValue(lines, "Kernel driver in use", ":", true) || util2.getValue(lines, "Kernel modules", ":", true);
            result2.push(audio2);
          }
        });
        return result2;
      } catch (e) {
        return result2;
      }
    }
    __name(getLinuxAudioPci, "getLinuxAudioPci");
    function parseLinuxAudioPciMM(lines, audioPCI) {
      const result2 = {};
      const slotId = util2.getValue(lines, "Slot");
      const pciMatch = audioPCI.filter(function(item) {
        return item.slotId === slotId;
      });
      result2.id = slotId;
      result2.name = util2.getValue(lines, "SDevice");
      result2.manufacturer = util2.getValue(lines, "SVendor");
      result2.revision = util2.getValue(lines, "Rev");
      result2.driver = pciMatch && pciMatch.length === 1 && pciMatch[0].driver ? pciMatch[0].driver : "";
      result2.default = null;
      result2.channel = "PCIe";
      result2.type = parseAudioType(result2.name, null, null);
      result2.in = null;
      result2.out = null;
      result2.status = "online";
      return result2;
    }
    __name(parseLinuxAudioPciMM, "parseLinuxAudioPciMM");
    function parseDarwinChannel(str) {
      let result2 = "";
      if (str.indexOf("builtin") >= 0) {
        result2 = "Built-In";
      }
      if (str.indexOf("extern") >= 0) {
        result2 = "Audio-Jack";
      }
      if (str.indexOf("hdmi") >= 0) {
        result2 = "HDMI";
      }
      if (str.indexOf("displayport") >= 0) {
        result2 = "Display-Port";
      }
      if (str.indexOf("usb") >= 0) {
        result2 = "USB";
      }
      if (str.indexOf("pci") >= 0) {
        result2 = "PCIe";
      }
      return result2;
    }
    __name(parseDarwinChannel, "parseDarwinChannel");
    function parseDarwinAudio(audioObject, id) {
      const result2 = {};
      const channelStr = ((audioObject.coreaudio_device_transport || "") + " " + (audioObject._name || "")).toLowerCase();
      result2.id = id;
      result2.name = audioObject._name;
      result2.manufacturer = audioObject.coreaudio_device_manufacturer;
      result2.revision = null;
      result2.driver = null;
      result2.default = !!(audioObject.coreaudio_default_audio_input_device || "") || !!(audioObject.coreaudio_default_audio_output_device || "");
      result2.channel = parseDarwinChannel(channelStr);
      result2.type = parseAudioType(result2.name, !!(audioObject.coreaudio_device_input || ""), !!(audioObject.coreaudio_device_output || ""));
      result2.in = !!(audioObject.coreaudio_device_input || "");
      result2.out = !!(audioObject.coreaudio_device_output || "");
      result2.status = "online";
      return result2;
    }
    __name(parseDarwinAudio, "parseDarwinAudio");
    function parseWindowsAudio(lines) {
      const result2 = {};
      const status = util2.getValue(lines, "StatusInfo", ":");
      result2.id = util2.getValue(lines, "DeviceID", ":");
      result2.name = util2.getValue(lines, "name", ":");
      result2.manufacturer = util2.getValue(lines, "manufacturer", ":");
      result2.revision = null;
      result2.driver = null;
      result2.default = null;
      result2.channel = null;
      result2.type = parseAudioType(result2.name, null, null);
      result2.in = null;
      result2.out = null;
      result2.status = status;
      return result2;
    }
    __name(parseWindowsAudio, "parseWindowsAudio");
    function audio(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = [];
          if (_linux || _freebsd || _openbsd || _netbsd) {
            let cmd = "lspci -vmm 2>/dev/null";
            exec(cmd, function(error, stdout) {
              if (!error) {
                const audioPCI = getLinuxAudioPci();
                const parts2 = stdout.toString().split("\n\n");
                parts2.forEach((element) => {
                  const lines = element.split("\n");
                  if (util2.getValue(lines, "class", ":", true).toLowerCase().indexOf("audio") >= 0) {
                    const audio2 = parseLinuxAudioPciMM(lines, audioPCI);
                    result2.push(audio2);
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_darwin) {
            let cmd = "system_profiler SPAudioDataType -json";
            exec(cmd, function(error, stdout) {
              if (!error) {
                try {
                  const outObj = JSON.parse(stdout.toString());
                  if (outObj.SPAudioDataType && outObj.SPAudioDataType.length && outObj.SPAudioDataType[0] && outObj.SPAudioDataType[0]["_items"] && outObj.SPAudioDataType[0]["_items"].length) {
                    for (let i = 0; i < outObj.SPAudioDataType[0]["_items"].length; i++) {
                      const audio2 = parseDarwinAudio(outObj.SPAudioDataType[0]["_items"][i], i);
                      result2.push(audio2);
                    }
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_windows) {
            util2.powerShell("Get-CimInstance Win32_SoundDevice | select DeviceID,StatusInfo,Name,Manufacturer | fl").then((stdout, error) => {
              if (!error) {
                const parts2 = stdout.toString().split(/\n\s*\n/);
                parts2.forEach((element) => {
                  const lines = element.split("\n");
                  if (util2.getValue(lines, "name", ":")) {
                    result2.push(parseWindowsAudio(lines));
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_sunos) {
            resolve5(null);
          }
        });
      });
    }
    __name(audio, "audio");
    exports2.audio = audio;
  }
});

// node_modules/systeminformation/lib/bluetoothVendors.js
var require_bluetoothVendors = __commonJS({
  "node_modules/systeminformation/lib/bluetoothVendors.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      0: "Ericsson Technology Licensing",
      1: "Nokia Mobile Phones",
      2: "Intel Corp.",
      3: "IBM Corp.",
      4: "Toshiba Corp.",
      5: "3Com",
      6: "Microsoft",
      7: "Lucent",
      8: "Motorola",
      9: "Infineon Technologies AG",
      10: "Cambridge Silicon Radio",
      11: "Silicon Wave",
      12: "Digianswer A/S",
      13: "Texas Instruments Inc.",
      14: "Ceva, Inc. (formerly Parthus Technologies, Inc.)",
      15: "Broadcom Corporation",
      16: "Mitel Semiconductor",
      17: "Widcomm, Inc",
      18: "Zeevo, Inc.",
      19: "Atmel Corporation",
      20: "Mitsubishi Electric Corporation",
      21: "RTX Telecom A/S",
      22: "KC Technology Inc.",
      23: "NewLogic",
      24: "Transilica, Inc.",
      25: "Rohde & Schwarz GmbH & Co. KG",
      26: "TTPCom Limited",
      27: "Signia Technologies, Inc.",
      28: "Conexant Systems Inc.",
      29: "Qualcomm",
      30: "Inventel",
      31: "AVM Berlin",
      32: "BandSpeed, Inc.",
      33: "Mansella Ltd",
      34: "NEC Corporation",
      35: "WavePlus Technology Co., Ltd.",
      36: "Alcatel",
      37: "NXP Semiconductors (formerly Philips Semiconductors)",
      38: "C Technologies",
      39: "Open Interface",
      40: "R F Micro Devices",
      41: "Hitachi Ltd",
      42: "Symbol Technologies, Inc.",
      43: "Tenovis",
      44: "Macronix International Co. Ltd.",
      45: "GCT Semiconductor",
      46: "Norwood Systems",
      47: "MewTel Technology Inc.",
      48: "ST Microelectronics",
      49: "Synopsis",
      50: "Red-M (Communications) Ltd",
      51: "Commil Ltd",
      52: "Computer Access Technology Corporation (CATC)",
      53: "Eclipse (HQ Espana) S.L.",
      54: "Renesas Electronics Corporation",
      55: "Mobilian Corporation",
      56: "Terax",
      57: "Integrated System Solution Corp.",
      58: "Matsushita Electric Industrial Co., Ltd.",
      59: "Gennum Corporation",
      60: "BlackBerry Limited (formerly Research In Motion)",
      61: "IPextreme, Inc.",
      62: "Systems and Chips, Inc.",
      63: "Bluetooth SIG, Inc.",
      64: "Seiko Epson Corporation",
      65: "Integrated Silicon Solution Taiwan, Inc.",
      66: "CONWISE Technology Corporation Ltd",
      67: "PARROT SA",
      68: "Socket Mobile",
      69: "Atheros Communications, Inc.",
      70: "MediaTek, Inc.",
      71: "Bluegiga",
      72: "Marvell Technology Group Ltd.",
      73: "3DSP Corporation",
      74: "Accel Semiconductor Ltd.",
      75: "Continental Automotive Systems",
      76: "Apple, Inc.",
      77: "Staccato Communications, Inc.",
      78: "Avago Technologies",
      79: "APT Licensing Ltd.",
      80: "SiRF Technology",
      81: "Tzero Technologies, Inc.",
      82: "J&M Corporation",
      83: "Free2move AB",
      84: "3DiJoy Corporation",
      85: "Plantronics, Inc.",
      86: "Sony Ericsson Mobile Communications",
      87: "Harman International Industries, Inc.",
      88: "Vizio, Inc.",
      89: "Nordic Semiconductor ASA",
      90: "EM Microelectronic-Marin SA",
      91: "Ralink Technology Corporation",
      92: "Belkin International, Inc.",
      93: "Realtek Semiconductor Corporation",
      94: "Stonestreet One, LLC",
      95: "Wicentric, Inc.",
      96: "RivieraWaves S.A.S",
      97: "RDA Microelectronics",
      98: "Gibson Guitars",
      99: "MiCommand Inc.",
      100: "Band XI International, LLC",
      101: "Hewlett-Packard Company",
      102: "9Solutions Oy",
      103: "GN Netcom A/S",
      104: "General Motors",
      105: "A&D Engineering, Inc.",
      106: "MindTree Ltd.",
      107: "Polar Electro OY",
      108: "Beautiful Enterprise Co., Ltd.",
      109: "BriarTek, Inc.",
      110: "Summit Data Communications, Inc.",
      111: "Sound ID",
      112: "Monster, LLC",
      113: "connectBlue AB",
      114: "ShangHai Super Smart Electronics Co. Ltd.",
      115: "Group Sense Ltd.",
      116: "Zomm, LLC",
      117: "Samsung Electronics Co. Ltd.",
      118: "Creative Technology Ltd.",
      119: "Laird Technologies",
      120: "Nike, Inc.",
      121: "lesswire AG",
      122: "MStar Semiconductor, Inc.",
      123: "Hanlynn Technologies",
      124: "A & R Cambridge",
      125: "Seers Technology Co. Ltd",
      126: "Sports Tracking Technologies Ltd.",
      127: "Autonet Mobile",
      128: "DeLorme Publishing Company, Inc.",
      129: "WuXi Vimicro",
      130: "Sennheiser Communications A/S",
      131: "TimeKeeping Systems, Inc.",
      132: "Ludus Helsinki Ltd.",
      133: "BlueRadios, Inc.",
      134: "equinox AG",
      135: "Garmin International, Inc.",
      136: "Ecotest",
      137: "GN ReSound A/S",
      138: "Jawbone",
      139: "Topcorn Positioning Systems, LLC",
      140: "Gimbal Inc. (formerly Qualcomm Labs, Inc. and Qualcomm Retail Solutions, Inc.)",
      141: "Zscan Software",
      142: "Quintic Corp.",
      143: "Stollman E+V GmbH",
      144: "Funai Electric Co., Ltd.",
      145: "Advanced PANMOBIL Systems GmbH & Co. KG",
      146: "ThinkOptics, Inc.",
      147: "Universal Electronics, Inc.",
      148: "Airoha Technology Corp.",
      149: "NEC Lighting, Ltd.",
      150: "ODM Technology, Inc.",
      151: "ConnecteDevice Ltd.",
      152: "zer01.tv GmbH",
      153: "i.Tech Dynamic Global Distribution Ltd.",
      154: "Alpwise",
      155: "Jiangsu Toppower Automotive Electronics Co., Ltd.",
      156: "Colorfy, Inc.",
      157: "Geoforce Inc.",
      158: "Bose Corporation",
      159: "Suunto Oy",
      160: "Kensington Computer Products Group",
      161: "SR-Medizinelektronik",
      162: "Vertu Corporation Limited",
      163: "Meta Watch Ltd.",
      164: "LINAK A/S",
      165: "OTL Dynamics LLC",
      166: "Panda Ocean Inc.",
      167: "Visteon Corporation",
      168: "ARP Devices Limited",
      169: "Magneti Marelli S.p.A",
      170: "CAEN RFID srl",
      171: "Ingenieur-Systemgruppe Zahn GmbH",
      172: "Green Throttle Games",
      173: "Peter Systemtechnik GmbH",
      174: "Omegawave Oy",
      175: "Cinetix",
      176: "Passif Semiconductor Corp",
      177: "Saris Cycling Group, Inc",
      178: "Bekey A/S",
      179: "Clarinox Technologies Pty. Ltd.",
      180: "BDE Technology Co., Ltd.",
      181: "Swirl Networks",
      182: "Meso international",
      183: "TreLab Ltd",
      184: "Qualcomm Innovation Center, Inc. (QuIC)",
      185: "Johnson Controls, Inc.",
      186: "Starkey Laboratories Inc.",
      187: "S-Power Electronics Limited",
      188: "Ace Sensor Inc",
      189: "Aplix Corporation",
      190: "AAMP of America",
      191: "Stalmart Technology Limited",
      192: "AMICCOM Electronics Corporation",
      193: "Shenzhen Excelsecu Data Technology Co.,Ltd",
      194: "Geneq Inc.",
      195: "adidas AG",
      196: "LG Electronics",
      197: "Onset Computer Corporation",
      198: "Selfly BV",
      199: "Quuppa Oy.",
      200: "GeLo Inc",
      201: "Evluma",
      202: "MC10",
      203: "Binauric SE",
      204: "Beats Electronics",
      205: "Microchip Technology Inc.",
      206: "Elgato Systems GmbH",
      207: "ARCHOS SA",
      208: "Dexcom, Inc.",
      209: "Polar Electro Europe B.V.",
      210: "Dialog Semiconductor B.V.",
      211: "Taixingbang\xA0Technology (HK) Co,. LTD.",
      212: "Kawantech",
      213: "Austco Communication Systems",
      214: "Timex Group USA, Inc.",
      215: "Qualcomm Technologies, Inc.",
      216: "Qualcomm Connected Experiences, Inc.",
      217: "Voyetra Turtle Beach",
      218: "txtr GmbH",
      219: "Biosentronics",
      220: "Procter & Gamble",
      221: "Hosiden Corporation",
      222: "Muzik LLC",
      223: "Misfit Wearables Corp",
      224: "Google",
      225: "Danlers Ltd",
      226: "Semilink Inc",
      227: "inMusic Brands, Inc",
      228: "L.S. Research Inc.",
      229: "Eden Software Consultants Ltd.",
      230: "Freshtemp",
      231: "KS Technologies",
      232: "ACTS Technologies",
      233: "Vtrack Systems",
      234: "Nielsen-Kellerman Company",
      235: "Server Technology, Inc.",
      236: "BioResearch Associates",
      237: "Jolly Logic, LLC",
      238: "Above Average Outcomes, Inc.",
      239: "Bitsplitters GmbH",
      240: "PayPal, Inc.",
      241: "Witron Technology Limited",
      242: "Aether Things\xA0Inc. (formerly Morse Project Inc.)",
      243: "Kent Displays Inc.",
      244: "Nautilus Inc.",
      245: "Smartifier Oy",
      246: "Elcometer Limited",
      247: "VSN Technologies Inc.",
      248: "AceUni Corp., Ltd.",
      249: "StickNFind",
      250: "Crystal Code AB",
      251: "KOUKAAM a.s.",
      252: "Delphi Corporation",
      253: "ValenceTech Limited",
      254: "Reserved",
      255: "Typo Products, LLC",
      256: "TomTom International BV",
      257: "Fugoo, Inc",
      258: "Keiser Corporation",
      259: "Bang & Olufsen A/S",
      260: "PLUS Locations Systems Pty Ltd",
      261: "Ubiquitous Computing Technology Corporation",
      262: "Innovative Yachtter Solutions",
      263: "William Demant Holding A/S",
      264: "Chicony Electronics Co., Ltd.",
      265: "Atus BV",
      266: "Codegate Ltd.",
      267: "ERi, Inc.",
      268: "Transducers Direct, LLC",
      269: "Fujitsu Ten Limited",
      270: "Audi AG",
      271: "HiSilicon Technologies Co., Ltd.",
      272: "Nippon Seiki Co., Ltd.",
      273: "Steelseries ApS",
      274: "vyzybl Inc.",
      275: "Openbrain Technologies, Co., Ltd.",
      276: "Xensr",
      277: "e.solutions",
      278: "1OAK Technologies",
      279: "Wimoto Technologies Inc",
      280: "Radius Networks, Inc.",
      281: "Wize Technology Co., Ltd.",
      282: "Qualcomm Labs, Inc.",
      283: "Aruba Networks",
      284: "Baidu",
      285: "Arendi AG",
      286: "Skoda Auto a.s.",
      287: "Volkswagon AG",
      288: "Porsche AG",
      289: "Sino Wealth Electronic Ltd.",
      290: "AirTurn, Inc.",
      291: "Kinsa, Inc.",
      292: "HID Global",
      293: "SEAT es",
      294: "Promethean Ltd.",
      295: "Salutica Allied Solutions",
      296: "GPSI Group Pty Ltd",
      297: "Nimble Devices Oy",
      298: "Changzhou Yongse Infotech Co., Ltd",
      299: "SportIQ",
      300: "TEMEC Instruments B.V.",
      301: "Sony Corporation",
      302: "ASSA ABLOY",
      303: "Clarion Co., Ltd.",
      304: "Warehouse Innovations",
      305: "Cypress Semiconductor Corporation",
      306: "MADS Inc",
      307: "Blue Maestro Limited",
      308: "Resolution Products, Inc.",
      309: "Airewear LLC",
      310: "Seed Labs, Inc. (formerly ETC sp. z.o.o.)",
      311: "Prestigio Plaza Ltd.",
      312: "NTEO Inc.",
      313: "Focus Systems Corporation",
      314: "Tencent Holdings Limited",
      315: "Allegion",
      316: "Murata Manufacuring Co., Ltd.",
      318: "Nod, Inc.",
      319: "B&B Manufacturing Company",
      320: "Alpine\xA0Electronics\xA0(China)\xA0Co.,\xA0Ltd",
      321: "FedEx Services",
      322: "Grape Systems Inc.",
      323: "Bkon Connect",
      324: "Lintech GmbH",
      325: "Novatel Wireless",
      326: "Ciright",
      327: "Mighty Cast, Inc.",
      328: "Ambimat Electronics",
      329: "Perytons Ltd.",
      330: "Tivoli Audio, LLC",
      331: "Master Lock",
      332: "Mesh-Net Ltd",
      333: "Huizhou Desay SV Automotive CO., LTD.",
      334: "Tangerine, Inc.",
      335: "B&W Group Ltd.",
      336: "Pioneer Corporation",
      337: "OnBeep",
      338: "Vernier Software & Technology",
      339: "ROL Ergo",
      340: "Pebble Technology",
      341: "NETATMO",
      342: "Accumulate AB",
      343: "Anhui Huami Information Technology Co., Ltd.",
      344: "Inmite s.r.o.",
      345: "ChefSteps, Inc.",
      346: "micas AG",
      347: "Biomedical Research Ltd.",
      348: "Pitius Tec S.L.",
      349: "Estimote, Inc.",
      350: "Unikey Technologies, Inc.",
      351: "Timer Cap Co.",
      352: "AwoX",
      353: "yikes",
      354: "MADSGlobal NZ Ltd.",
      355: "PCH International",
      356: "Qingdao Yeelink Information Technology Co., Ltd.",
      357: "Milwaukee Tool (formerly Milwaukee Electric Tools)",
      358: "MISHIK Pte Ltd",
      359: "Bayer HealthCare",
      360: "Spicebox LLC",
      361: "emberlight",
      362: "Cooper-Atkins Corporation",
      363: "Qblinks",
      364: "MYSPHERA",
      365: "LifeScan Inc",
      366: "Volantic AB",
      367: "Podo Labs, Inc",
      368: "Roche Diabetes Care AG",
      369: "Amazon Fulfillment Service",
      370: "Connovate Technology Private Limited",
      371: "Kocomojo, LLC",
      372: "Everykey LLC",
      373: "Dynamic Controls",
      374: "SentriLock",
      375: "I-SYST inc.",
      376: "CASIO COMPUTER CO., LTD.",
      377: "LAPIS Semiconductor Co., Ltd.",
      378: "Telemonitor, Inc.",
      379: "taskit GmbH",
      380: "Daimler AG",
      381: "BatAndCat",
      382: "BluDotz Ltd",
      383: "XTel ApS",
      384: "Gigaset Communications GmbH",
      385: "Gecko Health Innovations, Inc.",
      386: "HOP Ubiquitous",
      387: "To Be Assigned",
      388: "Nectar",
      389: "bel\u2019apps LLC",
      390: "CORE Lighting Ltd",
      391: "Seraphim Sense Ltd",
      392: "Unico RBC",
      393: "Physical Enterprises Inc.",
      394: "Able Trend Technology Limited",
      395: "Konica Minolta, Inc.",
      396: "Wilo SE",
      397: "Extron Design Services",
      398: "Fitbit, Inc.",
      399: "Fireflies Systems",
      400: "Intelletto Technologies Inc.",
      401: "FDK CORPORATION",
      402: "Cloudleaf, Inc",
      403: "Maveric Automation LLC",
      404: "Acoustic Stream Corporation",
      405: "Zuli",
      406: "Paxton Access Ltd",
      407: "WiSilica Inc",
      408: "Vengit Limited",
      409: "SALTO SYSTEMS S.L.",
      410: "TRON Forum (formerly T-Engine Forum)",
      411: "CUBETECH s.r.o.",
      412: "Cokiya Incorporated",
      413: "CVS Health",
      414: "Ceruus",
      415: "Strainstall Ltd",
      416: "Channel Enterprises (HK) Ltd.",
      417: "FIAMM",
      418: "GIGALANE.CO.,LTD",
      419: "EROAD",
      420: "Mine Safety Appliances",
      421: "Icon Health and Fitness",
      422: "Asandoo GmbH",
      423: "ENERGOUS CORPORATION",
      424: "Taobao",
      425: "Canon Inc.",
      426: "Geophysical Technology Inc.",
      427: "Facebook, Inc.",
      428: "Nipro Diagnostics, Inc.",
      429: "FlightSafety International",
      430: "Earlens Corporation",
      431: "Sunrise Micro Devices, Inc.",
      432: "Star Micronics Co., Ltd.",
      433: "Netizens Sp. z o.o.",
      434: "Nymi Inc.",
      435: "Nytec, Inc.",
      436: "Trineo Sp. z o.o.",
      437: "Nest Labs Inc.",
      438: "LM Technologies Ltd",
      439: "General Electric Company",
      440: "i+D3 S.L.",
      441: "HANA Micron",
      442: "Stages Cycling LLC",
      443: "Cochlear Bone Anchored Solutions AB",
      444: "SenionLab AB",
      445: "Syszone Co., Ltd",
      446: "Pulsate Mobile Ltd.",
      447: "Hong Kong HunterSun Electronic Limited",
      448: "pironex GmbH",
      449: "BRADATECH Corp.",
      450: "Transenergooil AG",
      451: "Bunch",
      452: "DME Microelectronics",
      453: "Bitcraze AB",
      454: "HASWARE Inc.",
      455: "Abiogenix Inc.",
      456: "Poly-Control ApS",
      457: "Avi-on",
      458: "Laerdal Medical AS",
      459: "Fetch My Pet",
      460: "Sam Labs Ltd.",
      461: "Chengdu Synwing Technology Ltd",
      462: "HOUWA SYSTEM DESIGN, k.k.",
      463: "BSH",
      464: "Primus Inter Pares Ltd",
      465: "August",
      466: "Gill Electronics",
      467: "Sky Wave Design",
      468: "Newlab S.r.l.",
      469: "ELAD srl",
      470: "G-wearables inc.",
      471: "Squadrone Systems Inc.",
      472: "Code Corporation",
      473: "Savant Systems LLC",
      474: "Logitech International SA",
      475: "Innblue Consulting",
      476: "iParking Ltd.",
      477: "Koninklijke Philips Electronics N.V.",
      478: "Minelab Electronics Pty Limited",
      479: "Bison Group Ltd.",
      480: "Widex A/S",
      481: "Jolla Ltd",
      482: "Lectronix, Inc.",
      483: "Caterpillar Inc",
      484: "Freedom Innovations",
      485: "Dynamic Devices Ltd",
      486: "Technology Solutions (UK) Ltd",
      487: "IPS Group Inc.",
      488: "STIR",
      489: "Sano, Inc",
      490: "Advanced Application Design, Inc.",
      491: "AutoMap LLC",
      492: "Spreadtrum Communications Shanghai Ltd",
      493: "CuteCircuit LTD",
      494: "Valeo Service",
      495: "Fullpower Technologies, Inc.",
      496: "KloudNation",
      497: "Zebra Technologies Corporation",
      498: "Itron, Inc.",
      499: "The University of Tokyo",
      500: "UTC Fire and Security",
      501: "Cool Webthings Limited",
      502: "DJO Global",
      503: "Gelliner Limited",
      504: "Anyka (Guangzhou) Microelectronics Technology Co, LTD",
      505: "Medtronic, Inc.",
      506: "Gozio, Inc.",
      507: "Form Lifting, LLC",
      508: "Wahoo Fitness, LLC",
      509: "Kontakt Micro-Location Sp. z o.o.",
      510: "Radio System Corporation",
      511: "Freescale Semiconductor, Inc.",
      512: "Verifone Systems PTe Ltd. Taiwan Branch",
      513: "AR Timing",
      514: "Rigado LLC",
      515: "Kemppi Oy",
      516: "Tapcentive Inc.",
      517: "Smartbotics Inc.",
      518: "Otter Products, LLC",
      519: "STEMP Inc.",
      520: "LumiGeek LLC",
      521: "InvisionHeart Inc.",
      522: "Macnica Inc. ",
      523: "Jaguar Land Rover Limited",
      524: "CoroWare Technologies, Inc",
      525: "Simplo Technology Co., LTD",
      526: "Omron Healthcare Co., LTD",
      527: "Comodule GMBH",
      528: "ikeGPS",
      529: "Telink Semiconductor Co. Ltd",
      530: "Interplan Co., Ltd",
      531: "Wyler AG",
      532: "IK Multimedia Production srl",
      533: "Lukoton Experience Oy",
      534: "MTI Ltd",
      535: "Tech4home, Lda",
      536: "Hiotech AB",
      537: "DOTT Limited",
      538: "Blue Speck Labs, LLC",
      539: "Cisco Systems, Inc",
      540: "Mobicomm Inc",
      541: "Edamic",
      542: "Goodnet, Ltd",
      543: "Luster Leaf Products Inc",
      544: "Manus Machina BV",
      545: "Mobiquity Networks Inc",
      546: "Praxis Dynamics",
      547: "Philip Morris Products S.A.",
      548: "Comarch SA",
      549: "Nestl Nespresso S.A.",
      550: "Merlinia A/S",
      551: "LifeBEAM Technologies",
      552: "Twocanoes Labs, LLC",
      553: "Muoverti Limited",
      554: "Stamer Musikanlagen GMBH",
      555: "Tesla Motors",
      556: "Pharynks Corporation",
      557: "Lupine",
      558: "Siemens AG",
      559: "Huami (Shanghai) Culture Communication CO., LTD",
      560: "Foster Electric Company, Ltd",
      561: "ETA SA",
      562: "x-Senso Solutions Kft",
      563: "Shenzhen SuLong Communication Ltd",
      564: "FengFan (BeiJing) Technology Co, Ltd",
      565: "Qrio Inc",
      566: "Pitpatpet Ltd",
      567: "MSHeli s.r.l.",
      568: "Trakm8 Ltd",
      569: "JIN CO, Ltd",
      570: "Alatech Tehnology",
      571: "Beijing CarePulse Electronic Technology Co, Ltd",
      572: "Awarepoint",
      573: "ViCentra B.V.",
      574: "Raven Industries",
      575: "WaveWare Technologies Inc.",
      576: "Argenox Technologies",
      577: "Bragi GmbH",
      578: "16Lab Inc",
      579: "Masimo Corp",
      580: "Iotera Inc",
      581: "Endress+Hauser",
      582: "ACKme Networks, Inc.",
      583: "FiftyThree Inc.",
      584: "Parker Hannifin Corp",
      585: "Transcranial Ltd",
      586: "Uwatec AG",
      587: "Orlan LLC",
      588: "Blue Clover Devices",
      589: "M-Way Solutions GmbH",
      590: "Microtronics Engineering GmbH",
      591: "Schneider Schreibgerte GmbH",
      592: "Sapphire Circuits LLC",
      593: "Lumo Bodytech Inc.",
      594: "UKC Technosolution",
      595: "Xicato Inc.",
      596: "Playbrush",
      597: "Dai Nippon Printing Co., Ltd.",
      598: "G24 Power Limited",
      599: "AdBabble Local Commerce Inc.",
      600: "Devialet SA",
      601: "ALTYOR",
      602: "University of Applied Sciences Valais/Haute Ecole Valaisanne",
      603: "Five Interactive, LLC dba Zendo",
      604: "NetEaseHangzhouNetwork co.Ltd.",
      605: "Lexmark International Inc.",
      606: "Fluke Corporation",
      607: "Yardarm Technologies",
      608: "SensaRx",
      609: "SECVRE GmbH",
      610: "Glacial Ridge Technologies",
      611: "Identiv, Inc.",
      612: "DDS, Inc.",
      613: "SMK Corporation",
      614: "Schawbel Technologies LLC",
      615: "XMI Systems SA",
      616: "Cerevo",
      617: "Torrox GmbH & Co KG",
      618: "Gemalto",
      619: "DEKA Research & Development Corp.",
      620: "Domster Tadeusz Szydlowski",
      621: "Technogym SPA",
      622: "FLEURBAEY BVBA",
      623: "Aptcode Solutions",
      624: "LSI ADL Technology",
      625: "Animas Corp",
      626: "Alps Electric Co., Ltd.",
      627: "OCEASOFT",
      628: "Motsai Research",
      629: "Geotab",
      630: "E.G.O. Elektro-Gertebau GmbH",
      631: "bewhere inc",
      632: "Johnson Outdoors Inc",
      633: "steute Schaltgerate GmbH & Co. KG",
      634: "Ekomini inc.",
      635: "DEFA AS",
      636: "Aseptika Ltd",
      637: "HUAWEI Technologies Co., Ltd. ( )",
      638: "HabitAware, LLC",
      639: "ruwido austria gmbh",
      640: "ITEC corporation",
      641: "StoneL",
      642: "Sonova AG",
      643: "Maven Machines, Inc.",
      644: "Synapse Electronics",
      645: "Standard Innovation Inc.",
      646: "RF Code, Inc.",
      647: "Wally Ventures S.L.",
      648: "Willowbank Electronics Ltd",
      649: "SK Telecom",
      650: "Jetro AS",
      651: "Code Gears LTD",
      652: "NANOLINK APS",
      653: "IF, LLC",
      654: "RF Digital Corp",
      655: "Church & Dwight Co., Inc",
      656: "Multibit Oy",
      657: "CliniCloud Inc",
      658: "SwiftSensors",
      659: "Blue Bite",
      660: "ELIAS GmbH",
      661: "Sivantos GmbH",
      662: "Petzl",
      663: "storm power ltd",
      664: "EISST Ltd",
      665: "Inexess Technology Simma KG",
      666: "Currant, Inc.",
      667: "C2 Development, Inc.",
      668: "Blue Sky Scientific, LLC",
      669: "ALOTTAZS LABS, LLC",
      670: "Kupson spol. s r.o.",
      671: "Areus Engineering GmbH",
      672: "Impossible Camera GmbH",
      673: "InventureTrack Systems",
      674: "LockedUp",
      675: "Itude",
      676: "Pacific Lock Company",
      677: "Tendyron Corporation ( )",
      678: "Robert Bosch GmbH",
      679: "Illuxtron international B.V.",
      680: "miSport Ltd.",
      681: "Chargelib",
      682: "Doppler Lab",
      683: "BBPOS Limited",
      684: "RTB Elektronik GmbH & Co. KG",
      685: "Rx Networks, Inc.",
      686: "WeatherFlow, Inc.",
      687: "Technicolor USA Inc.",
      688: "Bestechnic(Shanghai),Ltd",
      689: "Raden Inc",
      690: "JouZen Oy",
      691: "CLABER S.P.A.",
      692: "Hyginex, Inc.",
      693: "HANSHIN ELECTRIC RAILWAY CO.,LTD.",
      694: "Schneider Electric",
      695: "Oort Technologies LLC",
      696: "Chrono Therapeutics",
      697: "Rinnai Corporation",
      698: "Swissprime Technologies AG",
      699: "Koha.,Co.Ltd",
      700: "Genevac Ltd",
      701: "Chemtronics",
      702: "Seguro Technology Sp. z o.o.",
      703: "Redbird Flight Simulations",
      704: "Dash Robotics",
      705: "LINE Corporation",
      706: "Guillemot Corporation",
      707: "Techtronic Power Tools Technology Limited",
      708: "Wilson Sporting Goods",
      709: "Lenovo (Singapore) Pte Ltd. ( )",
      710: "Ayatan Sensors",
      711: "Electronics Tomorrow Limited",
      712: "VASCO Data Security International, Inc.",
      713: "PayRange Inc.",
      714: "ABOV Semiconductor",
      715: "AINA-Wireless Inc.",
      716: "Eijkelkamp Soil & Water",
      717: "BMA ergonomics b.v.",
      718: "Teva Branded Pharmaceutical Products R&D, Inc.",
      719: "Anima",
      720: "3M",
      721: "Empatica Srl",
      722: "Afero, Inc.",
      723: "Powercast Corporation",
      724: "Secuyou ApS",
      725: "OMRON Corporation",
      726: "Send Solutions",
      727: "NIPPON SYSTEMWARE CO.,LTD.",
      728: "Neosfar",
      729: "Fliegl Agrartechnik GmbH",
      730: "Gilvader",
      731: "Digi International Inc (R)",
      732: "DeWalch Technologies, Inc.",
      733: "Flint Rehabilitation Devices, LLC",
      734: "Samsung SDS Co., Ltd.",
      735: "Blur Product Development",
      736: "University of Michigan",
      737: "Victron Energy BV",
      738: "NTT docomo",
      739: "Carmanah Technologies Corp.",
      740: "Bytestorm Ltd.",
      741: "Espressif Incorporated ( () )",
      742: "Unwire",
      743: "Connected Yard, Inc.",
      744: "American Music Environments",
      745: "Sensogram Technologies, Inc.",
      746: "Fujitsu Limited",
      747: "Ardic Technology",
      748: "Delta Systems, Inc",
      749: "HTC Corporation",
      750: "Citizen Holdings Co., Ltd.",
      751: "SMART-INNOVATION.inc",
      752: "Blackrat Software",
      753: "The Idea Cave, LLC",
      754: "GoPro, Inc.",
      755: "AuthAir, Inc",
      756: "Vensi, Inc.",
      757: "Indagem Tech LLC",
      758: "Intemo Technologies",
      759: "DreamVisions co., Ltd.",
      760: "Runteq Oy Ltd",
      761: "IMAGINATION TECHNOLOGIES LTD",
      762: "CoSTAR TEchnologies",
      763: "Clarius Mobile Health Corp.",
      764: "Shanghai Frequen Microelectronics Co., Ltd.",
      765: "Uwanna, Inc.",
      766: "Lierda Science & Technology Group Co., Ltd.",
      767: "Silicon Laboratories",
      768: "World Moto Inc.",
      769: "Giatec Scientific Inc.",
      770: "Loop Devices, Inc",
      771: "IACA electronique",
      772: "Martians Inc",
      773: "Swipp ApS",
      774: "Life Laboratory Inc.",
      775: "FUJI INDUSTRIAL CO.,LTD.",
      776: "Surefire, LLC",
      777: "Dolby Labs",
      778: "Ellisys",
      779: "Magnitude Lighting Converters",
      780: "Hilti AG",
      781: "Devdata S.r.l.",
      782: "Deviceworx",
      783: "Shortcut Labs",
      784: "SGL Italia S.r.l.",
      785: "PEEQ DATA",
      786: "Ducere Technologies Pvt Ltd",
      787: "DiveNav, Inc.",
      788: "RIIG AI Sp. z o.o.",
      789: "Thermo Fisher Scientific",
      790: "AG Measurematics Pvt. Ltd.",
      791: "CHUO Electronics CO., LTD.",
      792: "Aspenta International",
      793: "Eugster Frismag AG",
      794: "Amber wireless GmbH",
      795: "HQ Inc",
      796: "Lab Sensor Solutions",
      797: "Enterlab ApS",
      798: "Eyefi, Inc.",
      799: "MetaSystem S.p.A.",
      800: "SONO ELECTRONICS. CO., LTD",
      801: "Jewelbots",
      802: "Compumedics Limited",
      803: "Rotor Bike Components",
      804: "Astro, Inc.",
      805: "Amotus Solutions",
      806: "Healthwear Technologies (Changzhou)Ltd",
      807: "Essex Electronics",
      808: "Grundfos A/S",
      809: "Eargo, Inc.",
      810: "Electronic Design Lab",
      811: "ESYLUX",
      812: "NIPPON SMT.CO.,Ltd",
      813: "BM innovations GmbH",
      814: "indoormap",
      815: "OttoQ Inc",
      816: "North Pole Engineering",
      817: "3flares Technologies Inc.",
      818: "Electrocompaniet A.S.",
      819: "Mul-T-Lock",
      820: "Corentium AS",
      821: "Enlighted Inc",
      822: "GISTIC",
      823: "AJP2 Holdings, LLC",
      824: "COBI GmbH",
      825: "Blue Sky Scientific, LLC",
      826: "Appception, Inc.",
      827: "Courtney Thorne Limited",
      828: "Virtuosys",
      829: "TPV Technology Limited",
      830: "Monitra SA",
      831: "Automation Components, Inc.",
      832: "Letsense s.r.l.",
      833: "Etesian Technologies LLC",
      834: "GERTEC BRASIL LTDA.",
      835: "Drekker Development Pty. Ltd.",
      836: "Whirl Inc",
      837: "Locus Positioning",
      838: "Acuity Brands Lighting, Inc",
      839: "Prevent Biometrics",
      840: "Arioneo",
      841: "VersaMe",
      842: "Vaddio",
      843: "Libratone A/S",
      844: "HM Electronics, Inc.",
      845: "TASER International, Inc.",
      846: "SafeTrust Inc.",
      847: "Heartland Payment Systems",
      848: "Bitstrata Systems Inc.",
      849: "Pieps GmbH",
      850: "iRiding(Xiamen)Technology Co.,Ltd.",
      851: "Alpha Audiotronics, Inc.",
      852: "TOPPAN FORMS CO.,LTD.",
      853: "Sigma Designs, Inc.",
      854: "Spectrum Brands, Inc.",
      855: "Polymap Wireless",
      856: "MagniWare Ltd.",
      857: "Novotec Medical GmbH",
      858: "Medicom Innovation Partner a/s",
      859: "Matrix Inc.",
      860: "Eaton Corporation",
      861: "KYS",
      862: "Naya Health, Inc.",
      863: "Acromag",
      864: "Insulet Corporation",
      865: "Wellinks Inc.",
      866: "ON Semiconductor",
      867: "FREELAP SA",
      868: "Favero Electronics Srl",
      869: "BioMech Sensor LLC",
      870: "BOLTT Sports technologies Private limited",
      871: "Saphe International",
      872: "Metormote AB",
      873: "littleBits",
      874: "SetPoint Medical",
      875: "BRControls Products BV",
      876: "Zipcar",
      877: "AirBolt Pty Ltd",
      878: "KeepTruckin Inc",
      879: "Motiv, Inc.",
      880: "Wazombi Labs O",
      881: "ORBCOMM",
      882: "Nixie Labs, Inc.",
      883: "AppNearMe Ltd",
      884: "Holman Industries",
      885: "Expain AS",
      886: "Electronic Temperature Instruments Ltd",
      887: "Plejd AB",
      888: "Propeller Health",
      889: "Shenzhen iMCO Electronic Technology Co.,Ltd",
      890: "Algoria",
      891: "Apption Labs Inc.",
      892: "Cronologics Corporation",
      893: "MICRODIA Ltd.",
      894: "lulabytes S.L.",
      895: "Nestec S.A.",
      896: "LLC MEGA - F service",
      897: "Sharp Corporation",
      898: "Precision Outcomes Ltd",
      899: "Kronos Incorporated",
      900: "OCOSMOS Co., Ltd.",
      901: "Embedded Electronic Solutions Ltd. dba e2Solutions",
      902: "Aterica Inc.",
      903: "BluStor PMC, Inc.",
      904: "Kapsch TrafficCom AB",
      905: "ActiveBlu Corporation",
      906: "Kohler Mira Limited",
      907: "Noke",
      908: "Appion Inc.",
      909: "Resmed Ltd",
      910: "Crownstone B.V.",
      911: "Xiaomi Inc.",
      912: "INFOTECH s.r.o.",
      913: "Thingsquare AB",
      914: "T&D",
      915: "LAVAZZA S.p.A.",
      916: "Netclearance Systems, Inc.",
      917: "SDATAWAY",
      918: "BLOKS GmbH",
      919: "LEGO System A/S",
      920: "Thetatronics Ltd",
      921: "Nikon Corporation",
      922: "NeST",
      923: "South Silicon Valley Microelectronics",
      924: "ALE International",
      925: "CareView Communications, Inc.",
      926: "SchoolBoard Limited",
      927: "Molex Corporation",
      928: "IVT Wireless Limited",
      929: "Alpine Labs LLC",
      930: "Candura Instruments",
      931: "SmartMovt Technology Co., Ltd",
      932: "Token Zero Ltd",
      933: "ACE CAD Enterprise Co., Ltd. (ACECAD)",
      934: "Medela, Inc",
      935: "AeroScout",
      936: "Esrille Inc.",
      937: "THINKERLY SRL",
      938: "Exon Sp. z o.o.",
      939: "Meizu Technology Co., Ltd.",
      940: "Smablo LTD",
      941: "XiQ",
      942: "Allswell Inc.",
      943: "Comm-N-Sense Corp DBA Verigo",
      944: "VIBRADORM GmbH",
      945: "Otodata Wireless Network Inc.",
      946: "Propagation Systems Limited",
      947: "Midwest Instruments & Controls",
      948: "Alpha Nodus, inc.",
      949: "petPOMM, Inc",
      950: "Mattel",
      951: "Airbly Inc.",
      952: "A-Safe Limited",
      953: "FREDERIQUE CONSTANT SA",
      954: "Maxscend Microelectronics Company Limited",
      955: "Abbott Diabetes Care",
      956: "ASB Bank Ltd",
      957: "amadas",
      958: "Applied Science, Inc.",
      959: "iLumi Solutions Inc.",
      960: "Arch Systems Inc.",
      961: "Ember Technologies, Inc.",
      962: "Snapchat Inc",
      963: "Casambi Technologies Oy",
      964: "Pico Technology Inc.",
      965: "St. Jude Medical, Inc.",
      966: "Intricon",
      967: "Structural Health Systems, Inc.",
      968: "Avvel International",
      969: "Gallagher Group",
      970: "In2things Automation Pvt. Ltd.",
      971: "SYSDEV Srl",
      972: "Vonkil Technologies Ltd",
      973: "Wynd Technologies, Inc.",
      974: "CONTRINEX S.A.",
      975: "MIRA, Inc.",
      976: "Watteam Ltd",
      977: "Density Inc.",
      978: "IOT Pot India Private Limited",
      979: "Sigma Connectivity AB",
      980: "PEG PEREGO SPA",
      981: "Wyzelink Systems Inc.",
      982: "Yota Devices LTD",
      983: "FINSECUR",
      984: "Zen-Me Labs Ltd",
      985: "3IWare Co., Ltd.",
      986: "EnOcean GmbH",
      987: "Instabeat, Inc",
      988: "Nima Labs",
      989: "Andreas Stihl AG & Co. KG",
      990: "Nathan Rhoades LLC",
      991: "Grob Technologies, LLC",
      992: "Actions (Zhuhai) Technology Co., Limited",
      993: "SPD Development Company Ltd",
      994: "Sensoan Oy",
      995: "Qualcomm Life Inc",
      996: "Chip-ing AG",
      997: "ffly4u",
      998: "IoT Instruments Oy",
      999: "TRUE Fitness Technology",
      1e3: "Reiner Kartengeraete GmbH & Co. KG.",
      1001: "SHENZHEN LEMONJOY TECHNOLOGY CO., LTD.",
      1002: "Hello Inc.",
      1003: "Evollve Inc.",
      1004: "Jigowatts Inc.",
      1005: "BASIC MICRO.COM,INC.",
      1006: "CUBE TECHNOLOGIES",
      1007: "foolography GmbH",
      1008: "CLINK",
      1009: "Hestan Smart Cooking Inc.",
      1010: "WindowMaster A/S",
      1011: "Flowscape AB",
      1012: "PAL Technologies Ltd",
      1013: "WHERE, Inc.",
      1014: "Iton Technology Corp.",
      1015: "Owl Labs Inc.",
      1016: "Rockford Corp.",
      1017: "Becon Technologies Co.,Ltd.",
      1018: "Vyassoft Technologies Inc",
      1019: "Nox Medical",
      1020: "Kimberly-Clark",
      1021: "Trimble Navigation Ltd.",
      1022: "Littelfuse",
      1023: "Withings",
      1024: "i-developer IT Beratung UG",
      1026: "Sears Holdings Corporation",
      1027: "Gantner Electronic GmbH",
      1028: "Authomate Inc",
      1029: "Vertex International, Inc.",
      1030: "Airtago",
      1031: "Swiss Audio SA",
      1032: "ToGetHome Inc.",
      1033: "AXIS",
      1034: "Openmatics",
      1035: "Jana Care Inc.",
      1036: "Senix Corporation",
      1037: "NorthStar Battery Company, LLC",
      1038: "SKF (U.K.) Limited",
      1039: "CO-AX Technology, Inc.",
      1040: "Fender Musical Instruments",
      1041: "Luidia Inc",
      1042: "SEFAM",
      1043: "Wireless Cables Inc",
      1044: "Lightning Protection International Pty Ltd",
      1045: "Uber Technologies Inc",
      1046: "SODA GmbH",
      1047: "Fatigue Science",
      1048: "Alpine Electronics Inc.",
      1049: "Novalogy LTD",
      1050: "Friday Labs Limited",
      1051: "OrthoAccel Technologies",
      1052: "WaterGuru, Inc.",
      1053: "Benning Elektrotechnik und Elektronik GmbH & Co. KG",
      1054: "Dell Computer Corporation",
      1055: "Kopin Corporation",
      1056: "TecBakery GmbH",
      1057: "Backbone Labs, Inc.",
      1058: "DELSEY SA",
      1059: "Chargifi Limited",
      1060: "Trainesense Ltd.",
      1061: "Unify Software and Solutions GmbH & Co. KG",
      1062: "Husqvarna AB",
      1063: "Focus fleet and fuel management inc",
      1064: "SmallLoop, LLC",
      1065: "Prolon Inc.",
      1066: "BD Medical",
      1067: "iMicroMed Incorporated",
      1068: "Ticto N.V.",
      1069: "Meshtech AS",
      1070: "MemCachier Inc.",
      1071: "Danfoss A/S",
      1072: "SnapStyk Inc.",
      1073: "Amyway Corporation",
      1074: "Silk Labs, Inc.",
      1075: "Pillsy Inc.",
      1076: "Hatch Baby, Inc.",
      1077: "Blocks Wearables Ltd.",
      1078: "Drayson Technologies (Europe) Limited",
      1079: "eBest IOT Inc.",
      1080: "Helvar Ltd",
      1081: "Radiance Technologies",
      1082: "Nuheara Limited",
      1083: "Appside co., ltd.",
      1084: "DeLaval",
      1085: "Coiler Corporation",
      1086: "Thermomedics, Inc.",
      1087: "Tentacle Sync GmbH",
      1088: "Valencell, Inc.",
      1089: "iProtoXi Oy",
      1090: "SECOM CO., LTD.",
      1091: "Tucker International LLC",
      1092: "Metanate Limited",
      1093: "Kobian Canada Inc.",
      1094: "NETGEAR, Inc.",
      1095: "Fabtronics Australia Pty Ltd",
      1096: "Grand Centrix GmbH",
      1097: "1UP USA.com llc",
      1098: "SHIMANO INC.",
      1099: "Nain Inc.",
      1100: "LifeStyle Lock, LLC",
      1101: "VEGA Grieshaber KG",
      1102: "Xtrava Inc.",
      1103: "TTS Tooltechnic Systems AG & Co. KG",
      1104: "Teenage Engineering AB",
      1105: "Tunstall Nordic AB",
      1106: "Svep Design Center AB",
      1107: "GreenPeak Technologies BV",
      1108: "Sphinx Electronics GmbH & Co KG",
      1109: "Atomation",
      1110: "Nemik Consulting Inc",
      1111: "RF INNOVATION",
      1112: "Mini Solution Co., Ltd.",
      1113: "Lumenetix, Inc",
      1114: "2048450 Ontario Inc",
      1115: "SPACEEK LTD",
      1116: "Delta T Corporation",
      1117: "Boston Scientific Corporation",
      1118: "Nuviz, Inc.",
      1119: "Real Time Automation, Inc.",
      1120: "Kolibree",
      1121: "vhf elektronik GmbH",
      1122: "Bonsai Systems GmbH",
      1123: "Fathom Systems Inc.",
      1124: "Bellman & Symfon",
      1125: "International Forte Group LLC",
      1126: "CycleLabs Solutions inc.",
      1127: "Codenex Oy",
      1128: "Kynesim Ltd",
      1129: "Palago AB",
      1130: "INSIGMA INC.",
      1131: "PMD Solutions",
      1132: "Qingdao Realtime Technology Co., Ltd.",
      1133: "BEGA Gantenbrink-Leuchten KG",
      1134: "Pambor Ltd.",
      65535: "SPECIAL USE/DEFAULT"
    };
  }
});

// node_modules/systeminformation/lib/bluetooth.js
var require_bluetooth = __commonJS({
  "node_modules/systeminformation/lib/bluetooth.js"(exports2) {
    "use strict";
    var exec = require("child_process").exec;
    var execSync = require("child_process").execSync;
    var path = require("path");
    var util2 = require_util();
    var bluetoothVendors = require_bluetoothVendors();
    var fs = require("fs");
    var _platform = process.platform;
    var _linux = _platform === "linux" || _platform === "android";
    var _darwin = _platform === "darwin";
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    function parseBluetoothType(str) {
      let result2 = "";
      if (str.indexOf("keyboard") >= 0) {
        result2 = "Keyboard";
      }
      if (str.indexOf("mouse") >= 0) {
        result2 = "Mouse";
      }
      if (str.indexOf("trackpad") >= 0) {
        result2 = "Trackpad";
      }
      if (str.indexOf("speaker") >= 0) {
        result2 = "Speaker";
      }
      if (str.indexOf("headset") >= 0) {
        result2 = "Headset";
      }
      if (str.indexOf("phone") >= 0) {
        result2 = "Phone";
      }
      if (str.indexOf("macbook") >= 0) {
        result2 = "Computer";
      }
      if (str.indexOf("imac") >= 0) {
        result2 = "Computer";
      }
      if (str.indexOf("ipad") >= 0) {
        result2 = "Tablet";
      }
      if (str.indexOf("watch") >= 0) {
        result2 = "Watch";
      }
      if (str.indexOf("headphone") >= 0) {
        result2 = "Headset";
      }
      return result2;
    }
    __name(parseBluetoothType, "parseBluetoothType");
    function parseBluetoothManufacturer(str) {
      let result2 = str.split(" ")[0];
      str = str.toLowerCase();
      if (str.indexOf("apple") >= 0) {
        result2 = "Apple";
      }
      if (str.indexOf("ipad") >= 0) {
        result2 = "Apple";
      }
      if (str.indexOf("imac") >= 0) {
        result2 = "Apple";
      }
      if (str.indexOf("iphone") >= 0) {
        result2 = "Apple";
      }
      if (str.indexOf("magic mouse") >= 0) {
        result2 = "Apple";
      }
      if (str.indexOf("magic track") >= 0) {
        result2 = "Apple";
      }
      if (str.indexOf("macbook") >= 0) {
        result2 = "Apple";
      }
      return result2;
    }
    __name(parseBluetoothManufacturer, "parseBluetoothManufacturer");
    function parseBluetoothVendor(str) {
      const id = parseInt(str);
      if (!isNaN(id)) return bluetoothVendors[id];
    }
    __name(parseBluetoothVendor, "parseBluetoothVendor");
    function parseLinuxBluetoothInfo(lines, macAddr1, macAddr2) {
      const result2 = {};
      result2.device = null;
      result2.name = util2.getValue(lines, "name", "=");
      result2.manufacturer = null;
      result2.macDevice = macAddr1;
      result2.macHost = macAddr2;
      result2.batteryPercent = null;
      result2.type = parseBluetoothType(result2.name.toLowerCase());
      result2.connected = false;
      return result2;
    }
    __name(parseLinuxBluetoothInfo, "parseLinuxBluetoothInfo");
    function parseDarwinBluetoothDevices(bluetoothObject, macAddr2) {
      const result2 = {};
      const typeStr = ((bluetoothObject.device_minorClassOfDevice_string || bluetoothObject.device_majorClassOfDevice_string || bluetoothObject.device_minorType || "") + (bluetoothObject.device_name || "")).toLowerCase();
      result2.device = bluetoothObject.device_services || "";
      result2.name = bluetoothObject.device_name || "";
      result2.manufacturer = bluetoothObject.device_manufacturer || parseBluetoothVendor(bluetoothObject.device_vendorID) || parseBluetoothManufacturer(bluetoothObject.device_name || "") || "";
      result2.macDevice = (bluetoothObject.device_addr || bluetoothObject.device_address || "").toLowerCase().replace(/-/g, ":");
      result2.macHost = macAddr2;
      result2.batteryPercent = bluetoothObject.device_batteryPercent || null;
      result2.type = parseBluetoothType(typeStr);
      result2.connected = bluetoothObject.device_isconnected === "attrib_Yes" || false;
      return result2;
    }
    __name(parseDarwinBluetoothDevices, "parseDarwinBluetoothDevices");
    function parseWindowsBluetooth(lines) {
      const result2 = {};
      result2.device = null;
      result2.name = util2.getValue(lines, "name", ":");
      result2.manufacturer = util2.getValue(lines, "manufacturer", ":");
      result2.macDevice = null;
      result2.macHost = null;
      result2.batteryPercent = null;
      result2.type = parseBluetoothType(result2.name.toLowerCase());
      result2.connected = null;
      return result2;
    }
    __name(parseWindowsBluetooth, "parseWindowsBluetooth");
    function bluetoothDevices(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let result2 = [];
          if (_linux) {
            const btFiles = util2.getFilesInPath("/var/lib/bluetooth/");
            btFiles.forEach((element) => {
              const filename = path.basename(element);
              const pathParts = element.split("/");
              const macAddr1 = pathParts.length >= 6 ? pathParts[pathParts.length - 2] : null;
              const macAddr2 = pathParts.length >= 7 ? pathParts[pathParts.length - 3] : null;
              if (filename === "info") {
                const infoFile = fs.readFileSync(element, {
                  encoding: "utf8"
                }).split("\n");
                result2.push(parseLinuxBluetoothInfo(infoFile, macAddr1, macAddr2));
              }
            });
            try {
              const hdicon = execSync("hcitool con", util2.execOptsLinux).toString().toLowerCase();
              for (let i = 0; i < result2.length; i++) {
                if (result2[i].macDevice && result2[i].macDevice.length > 10 && hdicon.indexOf(result2[i].macDevice.toLowerCase()) >= 0) {
                  result2[i].connected = true;
                }
              }
            } catch (e) {
              util2.noop();
            }
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          }
          if (_darwin) {
            let cmd = "system_profiler SPBluetoothDataType -json";
            exec(cmd, function(error, stdout) {
              if (!error) {
                try {
                  const outObj = JSON.parse(stdout.toString());
                  if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_title"] && outObj.SPBluetoothDataType[0]["device_title"].length) {
                    let macAddr2 = null;
                    if (outObj.SPBluetoothDataType[0]["local_device_title"] && outObj.SPBluetoothDataType[0].local_device_title.general_address) {
                      macAddr2 = outObj.SPBluetoothDataType[0].local_device_title.general_address.toLowerCase().replace(/-/g, ":");
                    }
                    outObj.SPBluetoothDataType[0]["device_title"].forEach((element) => {
                      const obj = element;
                      const objKey = Object.keys(obj);
                      if (objKey && objKey.length === 1) {
                        const innerObject = obj[objKey[0]];
                        innerObject.device_name = objKey[0];
                        const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                        result2.push(bluetoothDevice);
                      }
                    });
                  }
                  if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_connected"] && outObj.SPBluetoothDataType[0]["device_connected"].length) {
                    const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                    outObj.SPBluetoothDataType[0]["device_connected"].forEach((element) => {
                      const obj = element;
                      const objKey = Object.keys(obj);
                      if (objKey && objKey.length === 1) {
                        const innerObject = obj[objKey[0]];
                        innerObject.device_name = objKey[0];
                        innerObject.device_isconnected = "attrib_Yes";
                        const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                        result2.push(bluetoothDevice);
                      }
                    });
                  }
                  if (outObj.SPBluetoothDataType && outObj.SPBluetoothDataType.length && outObj.SPBluetoothDataType[0] && outObj.SPBluetoothDataType[0]["device_not_connected"] && outObj.SPBluetoothDataType[0]["device_not_connected"].length) {
                    const macAddr2 = outObj.SPBluetoothDataType[0].controller_properties && outObj.SPBluetoothDataType[0].controller_properties.controller_address ? outObj.SPBluetoothDataType[0].controller_properties.controller_address.toLowerCase().replace(/-/g, ":") : null;
                    outObj.SPBluetoothDataType[0]["device_not_connected"].forEach((element) => {
                      const obj = element;
                      const objKey = Object.keys(obj);
                      if (objKey && objKey.length === 1) {
                        const innerObject = obj[objKey[0]];
                        innerObject.device_name = objKey[0];
                        innerObject.device_isconnected = "attrib_No";
                        const bluetoothDevice = parseDarwinBluetoothDevices(innerObject, macAddr2);
                        result2.push(bluetoothDevice);
                      }
                    });
                  }
                } catch (e) {
                  util2.noop();
                }
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_windows) {
            util2.powerShell("Get-CimInstance Win32_PNPEntity | select PNPClass, Name, Manufacturer | fl").then((stdout, error) => {
              if (!error) {
                const parts2 = stdout.toString().split(/\n\s*\n/);
                parts2.forEach((part) => {
                  if (util2.getValue(part.split("\n"), "PNPClass", ":") === "Bluetooth") {
                    result2.push(parseWindowsBluetooth(part.split("\n")));
                  }
                });
              }
              if (callback) {
                callback(result2);
              }
              resolve5(result2);
            });
          }
          if (_freebsd || _netbsd || _openbsd || _sunos) {
            resolve5(null);
          }
        });
      });
    }
    __name(bluetoothDevices, "bluetoothDevices");
    exports2.bluetoothDevices = bluetoothDevices;
  }
});

// node_modules/systeminformation/lib/index.js
var require_lib = __commonJS({
  "node_modules/systeminformation/lib/index.js"(exports2) {
    "use strict";
    var lib_version = require_package2().version;
    var util2 = require_util();
    var system = require_system();
    var osInfo = require_osinfo();
    var cpu = require_cpu();
    var memory = require_memory();
    var battery = require_battery();
    var graphics = require_graphics();
    var filesystem = require_filesystem();
    var network = require_network();
    var wifi = require_wifi();
    var processes = require_processes();
    var users = require_users();
    var internet = require_internet();
    var docker = require_docker();
    var vbox = require_virtualbox();
    var printer = require_printer();
    var usb = require_usb();
    var audio = require_audio();
    var bluetooth = require_bluetooth();
    var _platform = process.platform;
    var _windows = _platform === "win32";
    var _freebsd = _platform === "freebsd";
    var _openbsd = _platform === "openbsd";
    var _netbsd = _platform === "netbsd";
    var _sunos = _platform === "sunos";
    if (_windows) {
      util2.getCodepage();
      util2.getPowershell();
    }
    function version2() {
      return lib_version;
    }
    __name(version2, "version");
    function getStaticData(callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let data = {};
          data.version = version2();
          Promise.all([
            system.system(),
            system.bios(),
            system.baseboard(),
            system.chassis(),
            osInfo.osInfo(),
            osInfo.uuid(),
            osInfo.versions(),
            cpu.cpu(),
            cpu.cpuFlags(),
            graphics.graphics(),
            network.networkInterfaces(),
            memory.memLayout(),
            filesystem.diskLayout()
          ]).then((res) => {
            data.system = res[0];
            data.bios = res[1];
            data.baseboard = res[2];
            data.chassis = res[3];
            data.os = res[4];
            data.uuid = res[5];
            data.versions = res[6];
            data.cpu = res[7];
            data.cpu.flags = res[8];
            data.graphics = res[9];
            data.net = res[10];
            data.memLayout = res[11];
            data.diskLayout = res[12];
            if (callback) {
              callback(data);
            }
            resolve5(data);
          });
        });
      });
    }
    __name(getStaticData, "getStaticData");
    function getDynamicData(srv, iface, callback) {
      if (util2.isFunction(iface)) {
        callback = iface;
        iface = "";
      }
      if (util2.isFunction(srv)) {
        callback = srv;
        srv = "";
      }
      return new Promise((resolve5) => {
        process.nextTick(() => {
          iface = iface || network.getDefaultNetworkInterface();
          srv = srv || "";
          let functionProcessed = function() {
            let totalFunctions = 15;
            if (_windows) {
              totalFunctions = 13;
            }
            if (_freebsd || _openbsd || _netbsd) {
              totalFunctions = 11;
            }
            if (_sunos) {
              totalFunctions = 6;
            }
            return function() {
              if (--totalFunctions === 0) {
                if (callback) {
                  callback(data);
                }
                resolve5(data);
              }
            };
          }();
          let data = {};
          data.time = osInfo.time();
          data.node = process.versions.node;
          data.v8 = process.versions.v8;
          cpu.cpuCurrentSpeed().then((res) => {
            data.cpuCurrentSpeed = res;
            functionProcessed();
          });
          users.users().then((res) => {
            data.users = res;
            functionProcessed();
          });
          processes.processes().then((res) => {
            data.processes = res;
            functionProcessed();
          });
          cpu.currentLoad().then((res) => {
            data.currentLoad = res;
            functionProcessed();
          });
          if (!_sunos) {
            cpu.cpuTemperature().then((res) => {
              data.temp = res;
              functionProcessed();
            });
          }
          if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
            network.networkStats(iface).then((res) => {
              data.networkStats = res;
              functionProcessed();
            });
          }
          if (!_sunos) {
            network.networkConnections().then((res) => {
              data.networkConnections = res;
              functionProcessed();
            });
          }
          memory.mem().then((res) => {
            data.mem = res;
            functionProcessed();
          });
          if (!_sunos) {
            battery().then((res) => {
              data.battery = res;
              functionProcessed();
            });
          }
          if (!_sunos) {
            processes.services(srv).then((res) => {
              data.services = res;
              functionProcessed();
            });
          }
          if (!_sunos) {
            filesystem.fsSize().then((res) => {
              data.fsSize = res;
              functionProcessed();
            });
          }
          if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
            filesystem.fsStats().then((res) => {
              data.fsStats = res;
              functionProcessed();
            });
          }
          if (!_windows && !_openbsd && !_freebsd && !_netbsd && !_sunos) {
            filesystem.disksIO().then((res) => {
              data.disksIO = res;
              functionProcessed();
            });
          }
          if (!_openbsd && !_freebsd && !_netbsd && !_sunos) {
            wifi.wifiNetworks().then((res) => {
              data.wifiNetworks = res;
              functionProcessed();
            });
          }
          internet.inetLatency().then((res) => {
            data.inetLatency = res;
            functionProcessed();
          });
        });
      });
    }
    __name(getDynamicData, "getDynamicData");
    function getAllData2(srv, iface, callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          let data = {};
          if (iface && util2.isFunction(iface) && !callback) {
            callback = iface;
            iface = "";
          }
          if (srv && util2.isFunction(srv) && !iface && !callback) {
            callback = srv;
            srv = "";
            iface = "";
          }
          getStaticData().then((res) => {
            data = res;
            getDynamicData(srv, iface).then((res2) => {
              for (let key in res2) {
                if ({}.hasOwnProperty.call(res2, key)) {
                  data[key] = res2[key];
                }
              }
              if (callback) {
                callback(data);
              }
              resolve5(data);
            });
          });
        });
      });
    }
    __name(getAllData2, "getAllData");
    function get(valueObject, callback) {
      return new Promise((resolve5) => {
        process.nextTick(() => {
          const allPromises = Object.keys(valueObject).filter((func) => ({}).hasOwnProperty.call(exports2, func)).map((func) => {
            const params2 = valueObject[func].substring(valueObject[func].lastIndexOf("(") + 1, valueObject[func].lastIndexOf(")"));
            let funcWithoutParams = func.indexOf(")") >= 0 ? func.split(")")[1].trim() : func;
            funcWithoutParams = func.indexOf("|") >= 0 ? func.split("|")[0].trim() : funcWithoutParams;
            if (params2) {
              return exports2[funcWithoutParams](params2);
            } else {
              return exports2[funcWithoutParams]("");
            }
          });
          Promise.all(allPromises).then((data) => {
            const result2 = {};
            let i = 0;
            for (let key in valueObject) {
              if ({}.hasOwnProperty.call(valueObject, key) && {}.hasOwnProperty.call(exports2, key) && data.length > i) {
                if (valueObject[key] === "*" || valueObject[key] === "all") {
                  result2[key] = data[i];
                } else {
                  let keys = valueObject[key];
                  let filter = "";
                  let filterParts = [];
                  if (keys.indexOf(")") >= 0) {
                    keys = keys.split(")")[1].trim();
                  }
                  if (keys.indexOf("|") >= 0) {
                    filter = keys.split("|")[1].trim();
                    filterParts = filter.split(":");
                    keys = keys.split("|")[0].trim();
                  }
                  keys = keys.replace(/,/g, " ").replace(/ +/g, " ").split(" ");
                  if (data[i]) {
                    if (Array.isArray(data[i])) {
                      const partialArray = [];
                      data[i].forEach((element) => {
                        let partialRes = {};
                        if (keys.length === 1 && (keys[0] === "*" || keys[0] === "all")) {
                          partialRes = element;
                        } else {
                          keys.forEach((k) => {
                            if ({}.hasOwnProperty.call(element, k)) {
                              partialRes[k] = element[k];
                            }
                          });
                        }
                        if (filter && filterParts.length === 2) {
                          if ({}.hasOwnProperty.call(partialRes, filterParts[0].trim())) {
                            const val = partialRes[filterParts[0].trim()];
                            if (typeof val == "number") {
                              if (val === parseFloat(filterParts[1].trim())) {
                                partialArray.push(partialRes);
                              }
                            } else if (typeof val == "string") {
                              if (val.toLowerCase() === filterParts[1].trim().toLowerCase()) {
                                partialArray.push(partialRes);
                              }
                            }
                          }
                        } else {
                          partialArray.push(partialRes);
                        }
                      });
                      result2[key] = partialArray;
                    } else {
                      const partialRes = {};
                      keys.forEach((k) => {
                        if ({}.hasOwnProperty.call(data[i], k)) {
                          partialRes[k] = data[i][k];
                        }
                      });
                      result2[key] = partialRes;
                    }
                  } else {
                    result2[key] = {};
                  }
                }
                i++;
              }
            }
            if (callback) {
              callback(result2);
            }
            resolve5(result2);
          });
        });
      });
    }
    __name(get, "get");
    function observe(valueObject, interval, callback) {
      let _data = null;
      const result2 = setInterval(() => {
        get(valueObject).then((data) => {
          if (JSON.stringify(_data) !== JSON.stringify(data)) {
            _data = Object.assign({}, data);
            callback(data);
          }
        });
      }, interval);
      return result2;
    }
    __name(observe, "observe");
    exports2.version = version2;
    exports2.system = system.system;
    exports2.bios = system.bios;
    exports2.baseboard = system.baseboard;
    exports2.chassis = system.chassis;
    exports2.time = osInfo.time;
    exports2.osInfo = osInfo.osInfo;
    exports2.versions = osInfo.versions;
    exports2.shell = osInfo.shell;
    exports2.uuid = osInfo.uuid;
    exports2.cpu = cpu.cpu;
    exports2.cpuFlags = cpu.cpuFlags;
    exports2.cpuCache = cpu.cpuCache;
    exports2.cpuCurrentSpeed = cpu.cpuCurrentSpeed;
    exports2.cpuTemperature = cpu.cpuTemperature;
    exports2.currentLoad = cpu.currentLoad;
    exports2.fullLoad = cpu.fullLoad;
    exports2.mem = memory.mem;
    exports2.memLayout = memory.memLayout;
    exports2.battery = battery;
    exports2.graphics = graphics.graphics;
    exports2.fsSize = filesystem.fsSize;
    exports2.fsOpenFiles = filesystem.fsOpenFiles;
    exports2.blockDevices = filesystem.blockDevices;
    exports2.fsStats = filesystem.fsStats;
    exports2.disksIO = filesystem.disksIO;
    exports2.diskLayout = filesystem.diskLayout;
    exports2.networkInterfaceDefault = network.networkInterfaceDefault;
    exports2.networkGatewayDefault = network.networkGatewayDefault;
    exports2.networkInterfaces = network.networkInterfaces;
    exports2.networkStats = network.networkStats;
    exports2.networkConnections = network.networkConnections;
    exports2.wifiNetworks = wifi.wifiNetworks;
    exports2.wifiInterfaces = wifi.wifiInterfaces;
    exports2.wifiConnections = wifi.wifiConnections;
    exports2.services = processes.services;
    exports2.processes = processes.processes;
    exports2.processLoad = processes.processLoad;
    exports2.users = users.users;
    exports2.inetChecksite = internet.inetChecksite;
    exports2.inetLatency = internet.inetLatency;
    exports2.dockerInfo = docker.dockerInfo;
    exports2.dockerImages = docker.dockerImages;
    exports2.dockerContainers = docker.dockerContainers;
    exports2.dockerContainerStats = docker.dockerContainerStats;
    exports2.dockerContainerProcesses = docker.dockerContainerProcesses;
    exports2.dockerVolumes = docker.dockerVolumes;
    exports2.dockerAll = docker.dockerAll;
    exports2.vboxInfo = vbox.vboxInfo;
    exports2.printer = printer.printer;
    exports2.usb = usb.usb;
    exports2.audio = audio.audio;
    exports2.bluetoothDevices = bluetooth.bluetoothDevices;
    exports2.getStaticData = getStaticData;
    exports2.getDynamicData = getDynamicData;
    exports2.getAllData = getAllData2;
    exports2.get = get;
    exports2.observe = observe;
    exports2.powerShellStart = util2.powerShellStart;
    exports2.powerShellRelease = util2.powerShellRelease;
  }
});

// node_modules/docker-modem/lib/utils.js
var require_utils = __commonJS({
  "node_modules/docker-modem/lib/utils.js"(exports2, module2) {
    "use strict";
    var arr = [];
    var each = arr.forEach;
    var slice = arr.slice;
    module2.exports.extend = function(obj) {
      each.call(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };
    module2.exports.parseJSON = function(s) {
      try {
        return JSON.parse(s);
      } catch (e) {
        return null;
      }
    };
  }
});

// node_modules/docker-modem/lib/http.js
var require_http2 = __commonJS({
  "node_modules/docker-modem/lib/http.js"(exports2, module2) {
    "use strict";
    var nativeHttps = require("https");
    var nativeHttp = require("http");
    var url2 = require("url");
    var utils = require_utils();
    var maxRedirects = module2.exports.maxRedirects = 5;
    var protocols = {
      https: nativeHttps,
      http: nativeHttp
    };
    for (protocol4 in protocols) {
      h = /* @__PURE__ */ __name(function() {
      }, "h");
      h.prototype = protocols[protocol4];
      h = new h();
      h.request = /* @__PURE__ */ function(h2) {
        return function(options, callback, redirectOptions) {
          redirectOptions = redirectOptions || {};
          var max = typeof options === "object" && "maxRedirects" in options ? options.maxRedirects : exports2.maxRedirects;
          var redirect = utils.extend({
            count: 0,
            max,
            clientRequest: null,
            userCallback: callback
          }, redirectOptions);
          if (redirect.count > redirect.max) {
            var err = new Error("Max redirects exceeded. To allow more redirects, pass options.maxRedirects property.");
            redirect.clientRequest.emit("error", err);
            return redirect.clientRequest;
          }
          redirect.count++;
          var reqUrl;
          if (typeof options === "string") {
            reqUrl = options;
          } else {
            reqUrl = url2.format(utils.extend({
              protocol: protocol4
            }, options));
          }
          var clientRequest = Object.getPrototypeOf(h2).request(options, redirectCallback(reqUrl, redirect));
          if (!redirect.clientRequest) redirect.clientRequest = clientRequest;
          function redirectCallback(reqUrl2, redirect2) {
            return function(res) {
              if (res.statusCode < 300 || res.statusCode > 399) {
                return redirect2.userCallback(res);
              }
              if (!("location" in res.headers)) {
                return redirect2.userCallback(res);
              }
              var redirectUrl = url2.resolve(reqUrl2, res.headers.location);
              var proto = url2.parse(redirectUrl).protocol;
              proto = proto.substr(0, proto.length - 1);
              return module2.exports[proto].get(redirectUrl, redirectCallback(reqUrl2, redirect2), redirect2);
            };
          }
          __name(redirectCallback, "redirectCallback");
          return clientRequest;
        };
      }(h);
      h.get = /* @__PURE__ */ function(h2) {
        return function(options, cb, redirectOptions) {
          var req = h2.request(options, cb, redirectOptions);
          req.end();
          return req;
        };
      }(h);
      module2.exports[protocol4] = h;
    }
    var h;
    var protocol4;
  }
});

// node_modules/asn1/lib/ber/errors.js
var require_errors3 = __commonJS({
  "node_modules/asn1/lib/ber/errors.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      newInvalidAsn1Error: /* @__PURE__ */ __name(function(msg) {
        var e = new Error();
        e.name = "InvalidAsn1Error";
        e.message = msg || "";
        return e;
      }, "newInvalidAsn1Error")
    };
  }
});

// node_modules/asn1/lib/ber/types.js
var require_types = __commonJS({
  "node_modules/asn1/lib/ber/types.js"(exports2, module2) {
    "use strict";
    module2.exports = {
      EOC: 0,
      Boolean: 1,
      Integer: 2,
      BitString: 3,
      OctetString: 4,
      Null: 5,
      OID: 6,
      ObjectDescriptor: 7,
      External: 8,
      Real: 9,
      Enumeration: 10,
      PDV: 11,
      Utf8String: 12,
      RelativeOID: 13,
      Sequence: 16,
      Set: 17,
      NumericString: 18,
      PrintableString: 19,
      T61String: 20,
      VideotexString: 21,
      IA5String: 22,
      UTCTime: 23,
      GeneralizedTime: 24,
      GraphicString: 25,
      VisibleString: 26,
      GeneralString: 28,
      UniversalString: 29,
      CharacterString: 30,
      BMPString: 31,
      Constructor: 32,
      Context: 128
    };
  }
});

// node_modules/safer-buffer/safer.js
var require_safer = __commonJS({
  "node_modules/safer-buffer/safer.js"(exports2, module2) {
    "use strict";
    var buffer = require("buffer");
    var Buffer2 = buffer.Buffer;
    var safer = {};
    var key;
    for (key in buffer) {
      if (!buffer.hasOwnProperty(key)) continue;
      if (key === "SlowBuffer" || key === "Buffer") continue;
      safer[key] = buffer[key];
    }
    var Safer = safer.Buffer = {};
    for (key in Buffer2) {
      if (!Buffer2.hasOwnProperty(key)) continue;
      if (key === "allocUnsafe" || key === "allocUnsafeSlow") continue;
      Safer[key] = Buffer2[key];
    }
    safer.Buffer.prototype = Buffer2.prototype;
    if (!Safer.from || Safer.from === Uint8Array.from) {
      Safer.from = function(value2, encodingOrOffset, length) {
        if (typeof value2 === "number") {
          throw new TypeError('The "value" argument must not be of type number. Received type ' + typeof value2);
        }
        if (value2 && typeof value2.length === "undefined") {
          throw new TypeError("The first argument must be one of type string, Buffer, ArrayBuffer, Array, or Array-like Object. Received type " + typeof value2);
        }
        return Buffer2(value2, encodingOrOffset, length);
      };
    }
    if (!Safer.alloc) {
      Safer.alloc = function(size, fill, encoding) {
        if (typeof size !== "number") {
          throw new TypeError('The "size" argument must be of type number. Received type ' + typeof size);
        }
        if (size < 0 || size >= 2 * (1 << 30)) {
          throw new RangeError('The value "' + size + '" is invalid for option "size"');
        }
        var buf = Buffer2(size);
        if (!fill || fill.length === 0) {
          buf.fill(0);
        } else if (typeof encoding === "string") {
          buf.fill(fill, encoding);
        } else {
          buf.fill(fill);
        }
        return buf;
      };
    }
    if (!safer.kStringMaxLength) {
      try {
        safer.kStringMaxLength = process.binding("buffer").kStringMaxLength;
      } catch (e) {
      }
    }
    if (!safer.constants) {
      safer.constants = {
        MAX_LENGTH: safer.kMaxLength
      };
      if (safer.kStringMaxLength) {
        safer.constants.MAX_STRING_LENGTH = safer.kStringMaxLength;
      }
    }
    module2.exports = safer;
  }
});

// node_modules/asn1/lib/ber/reader.js
var require_reader = __commonJS({
  "node_modules/asn1/lib/ber/reader.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors3();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    function Reader(data) {
      if (!data || !Buffer2.isBuffer(data)) throw new TypeError("data must be a node Buffer");
      this._buf = data;
      this._size = data.length;
      this._len = 0;
      this._offset = 0;
    }
    __name(Reader, "Reader");
    Object.defineProperty(Reader.prototype, "length", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return this._len;
      }, "get")
    });
    Object.defineProperty(Reader.prototype, "offset", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return this._offset;
      }, "get")
    });
    Object.defineProperty(Reader.prototype, "remain", {
      get: /* @__PURE__ */ __name(function() {
        return this._size - this._offset;
      }, "get")
    });
    Object.defineProperty(Reader.prototype, "buffer", {
      get: /* @__PURE__ */ __name(function() {
        return this._buf.slice(this._offset);
      }, "get")
    });
    Reader.prototype.readByte = function(peek) {
      if (this._size - this._offset < 1) return null;
      var b = this._buf[this._offset] & 255;
      if (!peek) this._offset += 1;
      return b;
    };
    Reader.prototype.peek = function() {
      return this.readByte(true);
    };
    Reader.prototype.readLength = function(offset) {
      if (offset === void 0) offset = this._offset;
      if (offset >= this._size) return null;
      var lenB = this._buf[offset++] & 255;
      if (lenB === null) return null;
      if ((lenB & 128) === 128) {
        lenB &= 127;
        if (lenB === 0) throw newInvalidAsn1Error("Indefinite length not supported");
        if (lenB > 4) throw newInvalidAsn1Error("encoding too long");
        if (this._size - offset < lenB) return null;
        this._len = 0;
        for (var i = 0; i < lenB; i++) this._len = (this._len << 8) + (this._buf[offset++] & 255);
      } else {
        this._len = lenB;
      }
      return offset;
    };
    Reader.prototype.readSequence = function(tag) {
      var seq = this.peek();
      if (seq === null) return null;
      if (tag !== void 0 && tag !== seq) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + seq.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null) return null;
      this._offset = o;
      return seq;
    };
    Reader.prototype.readInt = function() {
      return this._readTag(ASN1.Integer);
    };
    Reader.prototype.readBoolean = function() {
      return this._readTag(ASN1.Boolean) === 0 ? false : true;
    };
    Reader.prototype.readEnumeration = function() {
      return this._readTag(ASN1.Enumeration);
    };
    Reader.prototype.readString = function(tag, retbuf) {
      if (!tag) tag = ASN1.OctetString;
      var b = this.peek();
      if (b === null) return null;
      if (b !== tag) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null) return null;
      if (this.length > this._size - o) return null;
      this._offset = o;
      if (this.length === 0) return retbuf ? Buffer2.alloc(0) : "";
      var str = this._buf.slice(this._offset, this._offset + this.length);
      this._offset += this.length;
      return retbuf ? str : str.toString("utf8");
    };
    Reader.prototype.readOID = function(tag) {
      if (!tag) tag = ASN1.OID;
      var b = this.readString(tag, true);
      if (b === null) return null;
      var values = [];
      var value2 = 0;
      for (var i = 0; i < b.length; i++) {
        var byte = b[i] & 255;
        value2 <<= 7;
        value2 += byte & 127;
        if ((byte & 128) === 0) {
          values.push(value2);
          value2 = 0;
        }
      }
      value2 = values.shift();
      values.unshift(value2 % 40);
      values.unshift(value2 / 40 >> 0);
      return values.join(".");
    };
    Reader.prototype._readTag = function(tag) {
      assert.ok(tag !== void 0);
      var b = this.peek();
      if (b === null) return null;
      if (b !== tag) throw newInvalidAsn1Error("Expected 0x" + tag.toString(16) + ": got 0x" + b.toString(16));
      var o = this.readLength(this._offset + 1);
      if (o === null) return null;
      if (this.length > 4) throw newInvalidAsn1Error("Integer too long: " + this.length);
      if (this.length > this._size - o) return null;
      this._offset = o;
      var fb = this._buf[this._offset];
      var value2 = 0;
      for (var i = 0; i < this.length; i++) {
        value2 <<= 8;
        value2 |= this._buf[this._offset++] & 255;
      }
      if ((fb & 128) === 128 && i !== 4) value2 -= 1 << i * 8;
      return value2 >> 0;
    };
    module2.exports = Reader;
  }
});

// node_modules/asn1/lib/ber/writer.js
var require_writer = __commonJS({
  "node_modules/asn1/lib/ber/writer.js"(exports2, module2) {
    "use strict";
    var assert = require("assert");
    var Buffer2 = require_safer().Buffer;
    var ASN1 = require_types();
    var errors = require_errors3();
    var newInvalidAsn1Error = errors.newInvalidAsn1Error;
    var DEFAULT_OPTS = {
      size: 1024,
      growthFactor: 8
    };
    function merge(from, to) {
      assert.ok(from);
      assert.equal(typeof from, "object");
      assert.ok(to);
      assert.equal(typeof to, "object");
      var keys = Object.getOwnPropertyNames(from);
      keys.forEach(function(key) {
        if (to[key]) return;
        var value2 = Object.getOwnPropertyDescriptor(from, key);
        Object.defineProperty(to, key, value2);
      });
      return to;
    }
    __name(merge, "merge");
    function Writer(options) {
      options = merge(DEFAULT_OPTS, options || {});
      this._buf = Buffer2.alloc(options.size || 1024);
      this._size = this._buf.length;
      this._offset = 0;
      this._options = options;
      this._seq = [];
    }
    __name(Writer, "Writer");
    Object.defineProperty(Writer.prototype, "buffer", {
      get: /* @__PURE__ */ __name(function() {
        if (this._seq.length) throw newInvalidAsn1Error(this._seq.length + " unended sequence(s)");
        return this._buf.slice(0, this._offset);
      }, "get")
    });
    Writer.prototype.writeByte = function(b) {
      if (typeof b !== "number") throw new TypeError("argument must be a Number");
      this._ensure(1);
      this._buf[this._offset++] = b;
    };
    Writer.prototype.writeInt = function(i, tag) {
      if (typeof i !== "number") throw new TypeError("argument must be a Number");
      if (typeof tag !== "number") tag = ASN1.Integer;
      var sz = 4;
      while (((i & 4286578688) === 0 || (i & 4286578688) === 4286578688 >> 0) && sz > 1) {
        sz--;
        i <<= 8;
      }
      if (sz > 4) throw newInvalidAsn1Error("BER ints cannot be > 0xffffffff");
      this._ensure(2 + sz);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = sz;
      while (sz-- > 0) {
        this._buf[this._offset++] = (i & 4278190080) >>> 24;
        i <<= 8;
      }
    };
    Writer.prototype.writeNull = function() {
      this.writeByte(ASN1.Null);
      this.writeByte(0);
    };
    Writer.prototype.writeEnumeration = function(i, tag) {
      if (typeof i !== "number") throw new TypeError("argument must be a Number");
      if (typeof tag !== "number") tag = ASN1.Enumeration;
      return this.writeInt(i, tag);
    };
    Writer.prototype.writeBoolean = function(b, tag) {
      if (typeof b !== "boolean") throw new TypeError("argument must be a Boolean");
      if (typeof tag !== "number") tag = ASN1.Boolean;
      this._ensure(3);
      this._buf[this._offset++] = tag;
      this._buf[this._offset++] = 1;
      this._buf[this._offset++] = b ? 255 : 0;
    };
    Writer.prototype.writeString = function(s, tag) {
      if (typeof s !== "string") throw new TypeError("argument must be a string (was: " + typeof s + ")");
      if (typeof tag !== "number") tag = ASN1.OctetString;
      var len = Buffer2.byteLength(s);
      this.writeByte(tag);
      this.writeLength(len);
      if (len) {
        this._ensure(len);
        this._buf.write(s, this._offset);
        this._offset += len;
      }
    };
    Writer.prototype.writeBuffer = function(buf, tag) {
      if (typeof tag !== "number") throw new TypeError("tag must be a number");
      if (!Buffer2.isBuffer(buf)) throw new TypeError("argument must be a buffer");
      this.writeByte(tag);
      this.writeLength(buf.length);
      this._ensure(buf.length);
      buf.copy(this._buf, this._offset, 0, buf.length);
      this._offset += buf.length;
    };
    Writer.prototype.writeStringArray = function(strings) {
      if (!strings instanceof Array) throw new TypeError("argument must be an Array[String]");
      var self2 = this;
      strings.forEach(function(s) {
        self2.writeString(s);
      });
    };
    Writer.prototype.writeOID = function(s, tag) {
      if (typeof s !== "string") throw new TypeError("argument must be a string");
      if (typeof tag !== "number") tag = ASN1.OID;
      if (!/^([0-9]+\.){3,}[0-9]+$/.test(s)) throw new Error("argument is not a valid OID string");
      function encodeOctet(bytes2, octet) {
        if (octet < 128) {
          bytes2.push(octet);
        } else if (octet < 16384) {
          bytes2.push(octet >>> 7 | 128);
          bytes2.push(octet & 127);
        } else if (octet < 2097152) {
          bytes2.push(octet >>> 14 | 128);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else if (octet < 268435456) {
          bytes2.push(octet >>> 21 | 128);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        } else {
          bytes2.push((octet >>> 28 | 128) & 255);
          bytes2.push((octet >>> 21 | 128) & 255);
          bytes2.push((octet >>> 14 | 128) & 255);
          bytes2.push((octet >>> 7 | 128) & 255);
          bytes2.push(octet & 127);
        }
      }
      __name(encodeOctet, "encodeOctet");
      var tmp = s.split(".");
      var bytes = [];
      bytes.push(parseInt(tmp[0], 10) * 40 + parseInt(tmp[1], 10));
      tmp.slice(2).forEach(function(b) {
        encodeOctet(bytes, parseInt(b, 10));
      });
      var self2 = this;
      this._ensure(2 + bytes.length);
      this.writeByte(tag);
      this.writeLength(bytes.length);
      bytes.forEach(function(b) {
        self2.writeByte(b);
      });
    };
    Writer.prototype.writeLength = function(len) {
      if (typeof len !== "number") throw new TypeError("argument must be a Number");
      this._ensure(4);
      if (len <= 127) {
        this._buf[this._offset++] = len;
      } else if (len <= 255) {
        this._buf[this._offset++] = 129;
        this._buf[this._offset++] = len;
      } else if (len <= 65535) {
        this._buf[this._offset++] = 130;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else if (len <= 16777215) {
        this._buf[this._offset++] = 131;
        this._buf[this._offset++] = len >> 16;
        this._buf[this._offset++] = len >> 8;
        this._buf[this._offset++] = len;
      } else {
        throw newInvalidAsn1Error("Length too long (> 4 bytes)");
      }
    };
    Writer.prototype.startSequence = function(tag) {
      if (typeof tag !== "number") tag = ASN1.Sequence | ASN1.Constructor;
      this.writeByte(tag);
      this._seq.push(this._offset);
      this._ensure(3);
      this._offset += 3;
    };
    Writer.prototype.endSequence = function() {
      var seq = this._seq.pop();
      var start = seq + 3;
      var len = this._offset - start;
      if (len <= 127) {
        this._shift(start, len, -2);
        this._buf[seq] = len;
      } else if (len <= 255) {
        this._shift(start, len, -1);
        this._buf[seq] = 129;
        this._buf[seq + 1] = len;
      } else if (len <= 65535) {
        this._buf[seq] = 130;
        this._buf[seq + 1] = len >> 8;
        this._buf[seq + 2] = len;
      } else if (len <= 16777215) {
        this._shift(start, len, 1);
        this._buf[seq] = 131;
        this._buf[seq + 1] = len >> 16;
        this._buf[seq + 2] = len >> 8;
        this._buf[seq + 3] = len;
      } else {
        throw newInvalidAsn1Error("Sequence too long");
      }
    };
    Writer.prototype._shift = function(start, len, shift) {
      assert.ok(start !== void 0);
      assert.ok(len !== void 0);
      assert.ok(shift);
      this._buf.copy(this._buf, start + shift, start, start + len);
      this._offset += shift;
    };
    Writer.prototype._ensure = function(len) {
      assert.ok(len);
      if (this._size - this._offset < len) {
        var sz = this._size * this._options.growthFactor;
        if (sz - this._offset < len) sz += len;
        var buf = Buffer2.alloc(sz);
        this._buf.copy(buf, 0, 0, this._offset);
        this._buf = buf;
        this._size = sz;
      }
    };
    module2.exports = Writer;
  }
});

// node_modules/asn1/lib/ber/index.js
var require_ber = __commonJS({
  "node_modules/asn1/lib/ber/index.js"(exports2, module2) {
    "use strict";
    var errors = require_errors3();
    var types = require_types();
    var Reader = require_reader();
    var Writer = require_writer();
    module2.exports = {
      Reader,
      Writer
    };
    for (t in types) {
      if (types.hasOwnProperty(t)) module2.exports[t] = types[t];
    }
    var t;
    for (e in errors) {
      if (errors.hasOwnProperty(e)) module2.exports[e] = errors[e];
    }
    var e;
  }
});

// node_modules/asn1/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/asn1/lib/index.js"(exports2, module2) {
    "use strict";
    var Ber = require_ber();
    module2.exports = {
      Ber,
      BerReader: Ber.Reader,
      BerWriter: Ber.Writer
    };
  }
});

// node_modules/tweetnacl/nacl-fast.js
var require_nacl_fast = __commonJS({
  "node_modules/tweetnacl/nacl-fast.js"(exports2, module2) {
    "use strict";
    (function(nacl) {
      "use strict";
      var gf = /* @__PURE__ */ __name(function(init) {
        var i, r = new Float64Array(16);
        if (init) for (i = 0; i < init.length; i++) r[i] = init[i];
        return r;
      }, "gf");
      var randombytes = /* @__PURE__ */ __name(function() {
        throw new Error("no PRNG");
      }, "randombytes");
      var _0 = new Uint8Array(16);
      var _9 = new Uint8Array(32);
      _9[0] = 9;
      var gf0 = gf(), gf1 = gf([
        1
      ]), _121665 = gf([
        56129,
        1
      ]), D = gf([
        30883,
        4953,
        19914,
        30187,
        55467,
        16705,
        2637,
        112,
        59544,
        30585,
        16505,
        36039,
        65139,
        11119,
        27886,
        20995
      ]), D2 = gf([
        61785,
        9906,
        39828,
        60374,
        45398,
        33411,
        5274,
        224,
        53552,
        61171,
        33010,
        6542,
        64743,
        22239,
        55772,
        9222
      ]), X = gf([
        54554,
        36645,
        11616,
        51542,
        42930,
        38181,
        51040,
        26924,
        56412,
        64982,
        57905,
        49316,
        21502,
        52590,
        14035,
        8553
      ]), Y = gf([
        26200,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214,
        26214
      ]), I = gf([
        41136,
        18958,
        6951,
        50414,
        58488,
        44335,
        6150,
        12099,
        55207,
        15867,
        153,
        11085,
        57099,
        20417,
        9344,
        11139
      ]);
      function ts64(x, i, h, l) {
        x[i] = h >> 24 & 255;
        x[i + 1] = h >> 16 & 255;
        x[i + 2] = h >> 8 & 255;
        x[i + 3] = h & 255;
        x[i + 4] = l >> 24 & 255;
        x[i + 5] = l >> 16 & 255;
        x[i + 6] = l >> 8 & 255;
        x[i + 7] = l & 255;
      }
      __name(ts64, "ts64");
      function vn(x, xi, y, yi, n) {
        var i, d = 0;
        for (i = 0; i < n; i++) d |= x[xi + i] ^ y[yi + i];
        return (1 & d - 1 >>> 8) - 1;
      }
      __name(vn, "vn");
      function crypto_verify_16(x, xi, y, yi) {
        return vn(x, xi, y, yi, 16);
      }
      __name(crypto_verify_16, "crypto_verify_16");
      function crypto_verify_32(x, xi, y, yi) {
        return vn(x, xi, y, yi, 32);
      }
      __name(crypto_verify_32, "crypto_verify_32");
      function core_salsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        x0 = x0 + j0 | 0;
        x1 = x1 + j1 | 0;
        x2 = x2 + j2 | 0;
        x3 = x3 + j3 | 0;
        x4 = x4 + j4 | 0;
        x5 = x5 + j5 | 0;
        x6 = x6 + j6 | 0;
        x7 = x7 + j7 | 0;
        x8 = x8 + j8 | 0;
        x9 = x9 + j9 | 0;
        x10 = x10 + j10 | 0;
        x11 = x11 + j11 | 0;
        x12 = x12 + j12 | 0;
        x13 = x13 + j13 | 0;
        x14 = x14 + j14 | 0;
        x15 = x15 + j15 | 0;
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x1 >>> 0 & 255;
        o[5] = x1 >>> 8 & 255;
        o[6] = x1 >>> 16 & 255;
        o[7] = x1 >>> 24 & 255;
        o[8] = x2 >>> 0 & 255;
        o[9] = x2 >>> 8 & 255;
        o[10] = x2 >>> 16 & 255;
        o[11] = x2 >>> 24 & 255;
        o[12] = x3 >>> 0 & 255;
        o[13] = x3 >>> 8 & 255;
        o[14] = x3 >>> 16 & 255;
        o[15] = x3 >>> 24 & 255;
        o[16] = x4 >>> 0 & 255;
        o[17] = x4 >>> 8 & 255;
        o[18] = x4 >>> 16 & 255;
        o[19] = x4 >>> 24 & 255;
        o[20] = x5 >>> 0 & 255;
        o[21] = x5 >>> 8 & 255;
        o[22] = x5 >>> 16 & 255;
        o[23] = x5 >>> 24 & 255;
        o[24] = x6 >>> 0 & 255;
        o[25] = x6 >>> 8 & 255;
        o[26] = x6 >>> 16 & 255;
        o[27] = x6 >>> 24 & 255;
        o[28] = x7 >>> 0 & 255;
        o[29] = x7 >>> 8 & 255;
        o[30] = x7 >>> 16 & 255;
        o[31] = x7 >>> 24 & 255;
        o[32] = x8 >>> 0 & 255;
        o[33] = x8 >>> 8 & 255;
        o[34] = x8 >>> 16 & 255;
        o[35] = x8 >>> 24 & 255;
        o[36] = x9 >>> 0 & 255;
        o[37] = x9 >>> 8 & 255;
        o[38] = x9 >>> 16 & 255;
        o[39] = x9 >>> 24 & 255;
        o[40] = x10 >>> 0 & 255;
        o[41] = x10 >>> 8 & 255;
        o[42] = x10 >>> 16 & 255;
        o[43] = x10 >>> 24 & 255;
        o[44] = x11 >>> 0 & 255;
        o[45] = x11 >>> 8 & 255;
        o[46] = x11 >>> 16 & 255;
        o[47] = x11 >>> 24 & 255;
        o[48] = x12 >>> 0 & 255;
        o[49] = x12 >>> 8 & 255;
        o[50] = x12 >>> 16 & 255;
        o[51] = x12 >>> 24 & 255;
        o[52] = x13 >>> 0 & 255;
        o[53] = x13 >>> 8 & 255;
        o[54] = x13 >>> 16 & 255;
        o[55] = x13 >>> 24 & 255;
        o[56] = x14 >>> 0 & 255;
        o[57] = x14 >>> 8 & 255;
        o[58] = x14 >>> 16 & 255;
        o[59] = x14 >>> 24 & 255;
        o[60] = x15 >>> 0 & 255;
        o[61] = x15 >>> 8 & 255;
        o[62] = x15 >>> 16 & 255;
        o[63] = x15 >>> 24 & 255;
      }
      __name(core_salsa20, "core_salsa20");
      function core_hsalsa20(o, p, k, c) {
        var j0 = c[0] & 255 | (c[1] & 255) << 8 | (c[2] & 255) << 16 | (c[3] & 255) << 24, j1 = k[0] & 255 | (k[1] & 255) << 8 | (k[2] & 255) << 16 | (k[3] & 255) << 24, j2 = k[4] & 255 | (k[5] & 255) << 8 | (k[6] & 255) << 16 | (k[7] & 255) << 24, j3 = k[8] & 255 | (k[9] & 255) << 8 | (k[10] & 255) << 16 | (k[11] & 255) << 24, j4 = k[12] & 255 | (k[13] & 255) << 8 | (k[14] & 255) << 16 | (k[15] & 255) << 24, j5 = c[4] & 255 | (c[5] & 255) << 8 | (c[6] & 255) << 16 | (c[7] & 255) << 24, j6 = p[0] & 255 | (p[1] & 255) << 8 | (p[2] & 255) << 16 | (p[3] & 255) << 24, j7 = p[4] & 255 | (p[5] & 255) << 8 | (p[6] & 255) << 16 | (p[7] & 255) << 24, j8 = p[8] & 255 | (p[9] & 255) << 8 | (p[10] & 255) << 16 | (p[11] & 255) << 24, j9 = p[12] & 255 | (p[13] & 255) << 8 | (p[14] & 255) << 16 | (p[15] & 255) << 24, j10 = c[8] & 255 | (c[9] & 255) << 8 | (c[10] & 255) << 16 | (c[11] & 255) << 24, j11 = k[16] & 255 | (k[17] & 255) << 8 | (k[18] & 255) << 16 | (k[19] & 255) << 24, j12 = k[20] & 255 | (k[21] & 255) << 8 | (k[22] & 255) << 16 | (k[23] & 255) << 24, j13 = k[24] & 255 | (k[25] & 255) << 8 | (k[26] & 255) << 16 | (k[27] & 255) << 24, j14 = k[28] & 255 | (k[29] & 255) << 8 | (k[30] & 255) << 16 | (k[31] & 255) << 24, j15 = c[12] & 255 | (c[13] & 255) << 8 | (c[14] & 255) << 16 | (c[15] & 255) << 24;
        var x0 = j0, x1 = j1, x2 = j2, x3 = j3, x4 = j4, x5 = j5, x6 = j6, x7 = j7, x8 = j8, x9 = j9, x10 = j10, x11 = j11, x12 = j12, x13 = j13, x14 = j14, x15 = j15, u;
        for (var i = 0; i < 20; i += 2) {
          u = x0 + x12 | 0;
          x4 ^= u << 7 | u >>> 32 - 7;
          u = x4 + x0 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x4 | 0;
          x12 ^= u << 13 | u >>> 32 - 13;
          u = x12 + x8 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x1 | 0;
          x9 ^= u << 7 | u >>> 32 - 7;
          u = x9 + x5 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x9 | 0;
          x1 ^= u << 13 | u >>> 32 - 13;
          u = x1 + x13 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x6 | 0;
          x14 ^= u << 7 | u >>> 32 - 7;
          u = x14 + x10 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x14 | 0;
          x6 ^= u << 13 | u >>> 32 - 13;
          u = x6 + x2 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x11 | 0;
          x3 ^= u << 7 | u >>> 32 - 7;
          u = x3 + x15 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x3 | 0;
          x11 ^= u << 13 | u >>> 32 - 13;
          u = x11 + x7 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
          u = x0 + x3 | 0;
          x1 ^= u << 7 | u >>> 32 - 7;
          u = x1 + x0 | 0;
          x2 ^= u << 9 | u >>> 32 - 9;
          u = x2 + x1 | 0;
          x3 ^= u << 13 | u >>> 32 - 13;
          u = x3 + x2 | 0;
          x0 ^= u << 18 | u >>> 32 - 18;
          u = x5 + x4 | 0;
          x6 ^= u << 7 | u >>> 32 - 7;
          u = x6 + x5 | 0;
          x7 ^= u << 9 | u >>> 32 - 9;
          u = x7 + x6 | 0;
          x4 ^= u << 13 | u >>> 32 - 13;
          u = x4 + x7 | 0;
          x5 ^= u << 18 | u >>> 32 - 18;
          u = x10 + x9 | 0;
          x11 ^= u << 7 | u >>> 32 - 7;
          u = x11 + x10 | 0;
          x8 ^= u << 9 | u >>> 32 - 9;
          u = x8 + x11 | 0;
          x9 ^= u << 13 | u >>> 32 - 13;
          u = x9 + x8 | 0;
          x10 ^= u << 18 | u >>> 32 - 18;
          u = x15 + x14 | 0;
          x12 ^= u << 7 | u >>> 32 - 7;
          u = x12 + x15 | 0;
          x13 ^= u << 9 | u >>> 32 - 9;
          u = x13 + x12 | 0;
          x14 ^= u << 13 | u >>> 32 - 13;
          u = x14 + x13 | 0;
          x15 ^= u << 18 | u >>> 32 - 18;
        }
        o[0] = x0 >>> 0 & 255;
        o[1] = x0 >>> 8 & 255;
        o[2] = x0 >>> 16 & 255;
        o[3] = x0 >>> 24 & 255;
        o[4] = x5 >>> 0 & 255;
        o[5] = x5 >>> 8 & 255;
        o[6] = x5 >>> 16 & 255;
        o[7] = x5 >>> 24 & 255;
        o[8] = x10 >>> 0 & 255;
        o[9] = x10 >>> 8 & 255;
        o[10] = x10 >>> 16 & 255;
        o[11] = x10 >>> 24 & 255;
        o[12] = x15 >>> 0 & 255;
        o[13] = x15 >>> 8 & 255;
        o[14] = x15 >>> 16 & 255;
        o[15] = x15 >>> 24 & 255;
        o[16] = x6 >>> 0 & 255;
        o[17] = x6 >>> 8 & 255;
        o[18] = x6 >>> 16 & 255;
        o[19] = x6 >>> 24 & 255;
        o[20] = x7 >>> 0 & 255;
        o[21] = x7 >>> 8 & 255;
        o[22] = x7 >>> 16 & 255;
        o[23] = x7 >>> 24 & 255;
        o[24] = x8 >>> 0 & 255;
        o[25] = x8 >>> 8 & 255;
        o[26] = x8 >>> 16 & 255;
        o[27] = x8 >>> 24 & 255;
        o[28] = x9 >>> 0 & 255;
        o[29] = x9 >>> 8 & 255;
        o[30] = x9 >>> 16 & 255;
        o[31] = x9 >>> 24 & 255;
      }
      __name(core_hsalsa20, "core_hsalsa20");
      function crypto_core_salsa20(out, inp, k, c) {
        core_salsa20(out, inp, k, c);
      }
      __name(crypto_core_salsa20, "crypto_core_salsa20");
      function crypto_core_hsalsa20(out, inp, k, c) {
        core_hsalsa20(out, inp, k, c);
      }
      __name(crypto_core_hsalsa20, "crypto_core_hsalsa20");
      var sigma = new Uint8Array([
        101,
        120,
        112,
        97,
        110,
        100,
        32,
        51,
        50,
        45,
        98,
        121,
        116,
        101,
        32,
        107
      ]);
      function crypto_stream_salsa20_xor(c, cpos, m, mpos, b, n, k) {
        var z2 = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z2[i] = 0;
        for (i = 0; i < 8; i++) z2[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z2, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = m[mpos + i] ^ x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z2[i] & 255) | 0;
            z2[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
          mpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z2, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = m[mpos + i] ^ x[i];
        }
        return 0;
      }
      __name(crypto_stream_salsa20_xor, "crypto_stream_salsa20_xor");
      function crypto_stream_salsa20(c, cpos, b, n, k) {
        var z2 = new Uint8Array(16), x = new Uint8Array(64);
        var u, i;
        for (i = 0; i < 16; i++) z2[i] = 0;
        for (i = 0; i < 8; i++) z2[i] = n[i];
        while (b >= 64) {
          crypto_core_salsa20(x, z2, k, sigma);
          for (i = 0; i < 64; i++) c[cpos + i] = x[i];
          u = 1;
          for (i = 8; i < 16; i++) {
            u = u + (z2[i] & 255) | 0;
            z2[i] = u & 255;
            u >>>= 8;
          }
          b -= 64;
          cpos += 64;
        }
        if (b > 0) {
          crypto_core_salsa20(x, z2, k, sigma);
          for (i = 0; i < b; i++) c[cpos + i] = x[i];
        }
        return 0;
      }
      __name(crypto_stream_salsa20, "crypto_stream_salsa20");
      function crypto_stream(c, cpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20(c, cpos, d, sn, s);
      }
      __name(crypto_stream, "crypto_stream");
      function crypto_stream_xor(c, cpos, m, mpos, d, n, k) {
        var s = new Uint8Array(32);
        crypto_core_hsalsa20(s, n, k, sigma);
        var sn = new Uint8Array(8);
        for (var i = 0; i < 8; i++) sn[i] = n[i + 16];
        return crypto_stream_salsa20_xor(c, cpos, m, mpos, d, sn, s);
      }
      __name(crypto_stream_xor, "crypto_stream_xor");
      var poly1305 = /* @__PURE__ */ __name(function(key) {
        this.buffer = new Uint8Array(16);
        this.r = new Uint16Array(10);
        this.h = new Uint16Array(10);
        this.pad = new Uint16Array(8);
        this.leftover = 0;
        this.fin = 0;
        var t0, t1, t2, t3, t4, t5, t6, t7;
        t0 = key[0] & 255 | (key[1] & 255) << 8;
        this.r[0] = t0 & 8191;
        t1 = key[2] & 255 | (key[3] & 255) << 8;
        this.r[1] = (t0 >>> 13 | t1 << 3) & 8191;
        t2 = key[4] & 255 | (key[5] & 255) << 8;
        this.r[2] = (t1 >>> 10 | t2 << 6) & 7939;
        t3 = key[6] & 255 | (key[7] & 255) << 8;
        this.r[3] = (t2 >>> 7 | t3 << 9) & 8191;
        t4 = key[8] & 255 | (key[9] & 255) << 8;
        this.r[4] = (t3 >>> 4 | t4 << 12) & 255;
        this.r[5] = t4 >>> 1 & 8190;
        t5 = key[10] & 255 | (key[11] & 255) << 8;
        this.r[6] = (t4 >>> 14 | t5 << 2) & 8191;
        t6 = key[12] & 255 | (key[13] & 255) << 8;
        this.r[7] = (t5 >>> 11 | t6 << 5) & 8065;
        t7 = key[14] & 255 | (key[15] & 255) << 8;
        this.r[8] = (t6 >>> 8 | t7 << 8) & 8191;
        this.r[9] = t7 >>> 5 & 127;
        this.pad[0] = key[16] & 255 | (key[17] & 255) << 8;
        this.pad[1] = key[18] & 255 | (key[19] & 255) << 8;
        this.pad[2] = key[20] & 255 | (key[21] & 255) << 8;
        this.pad[3] = key[22] & 255 | (key[23] & 255) << 8;
        this.pad[4] = key[24] & 255 | (key[25] & 255) << 8;
        this.pad[5] = key[26] & 255 | (key[27] & 255) << 8;
        this.pad[6] = key[28] & 255 | (key[29] & 255) << 8;
        this.pad[7] = key[30] & 255 | (key[31] & 255) << 8;
      }, "poly1305");
      poly1305.prototype.blocks = function(m, mpos, bytes) {
        var hibit = this.fin ? 0 : 1 << 11;
        var t0, t1, t2, t3, t4, t5, t6, t7, c;
        var d0, d1, d2, d3, d4, d5, d6, d7, d8, d9;
        var h0 = this.h[0], h1 = this.h[1], h2 = this.h[2], h3 = this.h[3], h4 = this.h[4], h5 = this.h[5], h6 = this.h[6], h7 = this.h[7], h8 = this.h[8], h9 = this.h[9];
        var r0 = this.r[0], r1 = this.r[1], r2 = this.r[2], r3 = this.r[3], r4 = this.r[4], r5 = this.r[5], r6 = this.r[6], r7 = this.r[7], r8 = this.r[8], r9 = this.r[9];
        while (bytes >= 16) {
          t0 = m[mpos + 0] & 255 | (m[mpos + 1] & 255) << 8;
          h0 += t0 & 8191;
          t1 = m[mpos + 2] & 255 | (m[mpos + 3] & 255) << 8;
          h1 += (t0 >>> 13 | t1 << 3) & 8191;
          t2 = m[mpos + 4] & 255 | (m[mpos + 5] & 255) << 8;
          h2 += (t1 >>> 10 | t2 << 6) & 8191;
          t3 = m[mpos + 6] & 255 | (m[mpos + 7] & 255) << 8;
          h3 += (t2 >>> 7 | t3 << 9) & 8191;
          t4 = m[mpos + 8] & 255 | (m[mpos + 9] & 255) << 8;
          h4 += (t3 >>> 4 | t4 << 12) & 8191;
          h5 += t4 >>> 1 & 8191;
          t5 = m[mpos + 10] & 255 | (m[mpos + 11] & 255) << 8;
          h6 += (t4 >>> 14 | t5 << 2) & 8191;
          t6 = m[mpos + 12] & 255 | (m[mpos + 13] & 255) << 8;
          h7 += (t5 >>> 11 | t6 << 5) & 8191;
          t7 = m[mpos + 14] & 255 | (m[mpos + 15] & 255) << 8;
          h8 += (t6 >>> 8 | t7 << 8) & 8191;
          h9 += t7 >>> 5 | hibit;
          c = 0;
          d0 = c;
          d0 += h0 * r0;
          d0 += h1 * (5 * r9);
          d0 += h2 * (5 * r8);
          d0 += h3 * (5 * r7);
          d0 += h4 * (5 * r6);
          c = d0 >>> 13;
          d0 &= 8191;
          d0 += h5 * (5 * r5);
          d0 += h6 * (5 * r4);
          d0 += h7 * (5 * r3);
          d0 += h8 * (5 * r2);
          d0 += h9 * (5 * r1);
          c += d0 >>> 13;
          d0 &= 8191;
          d1 = c;
          d1 += h0 * r1;
          d1 += h1 * r0;
          d1 += h2 * (5 * r9);
          d1 += h3 * (5 * r8);
          d1 += h4 * (5 * r7);
          c = d1 >>> 13;
          d1 &= 8191;
          d1 += h5 * (5 * r6);
          d1 += h6 * (5 * r5);
          d1 += h7 * (5 * r4);
          d1 += h8 * (5 * r3);
          d1 += h9 * (5 * r2);
          c += d1 >>> 13;
          d1 &= 8191;
          d2 = c;
          d2 += h0 * r2;
          d2 += h1 * r1;
          d2 += h2 * r0;
          d2 += h3 * (5 * r9);
          d2 += h4 * (5 * r8);
          c = d2 >>> 13;
          d2 &= 8191;
          d2 += h5 * (5 * r7);
          d2 += h6 * (5 * r6);
          d2 += h7 * (5 * r5);
          d2 += h8 * (5 * r4);
          d2 += h9 * (5 * r3);
          c += d2 >>> 13;
          d2 &= 8191;
          d3 = c;
          d3 += h0 * r3;
          d3 += h1 * r2;
          d3 += h2 * r1;
          d3 += h3 * r0;
          d3 += h4 * (5 * r9);
          c = d3 >>> 13;
          d3 &= 8191;
          d3 += h5 * (5 * r8);
          d3 += h6 * (5 * r7);
          d3 += h7 * (5 * r6);
          d3 += h8 * (5 * r5);
          d3 += h9 * (5 * r4);
          c += d3 >>> 13;
          d3 &= 8191;
          d4 = c;
          d4 += h0 * r4;
          d4 += h1 * r3;
          d4 += h2 * r2;
          d4 += h3 * r1;
          d4 += h4 * r0;
          c = d4 >>> 13;
          d4 &= 8191;
          d4 += h5 * (5 * r9);
          d4 += h6 * (5 * r8);
          d4 += h7 * (5 * r7);
          d4 += h8 * (5 * r6);
          d4 += h9 * (5 * r5);
          c += d4 >>> 13;
          d4 &= 8191;
          d5 = c;
          d5 += h0 * r5;
          d5 += h1 * r4;
          d5 += h2 * r3;
          d5 += h3 * r2;
          d5 += h4 * r1;
          c = d5 >>> 13;
          d5 &= 8191;
          d5 += h5 * r0;
          d5 += h6 * (5 * r9);
          d5 += h7 * (5 * r8);
          d5 += h8 * (5 * r7);
          d5 += h9 * (5 * r6);
          c += d5 >>> 13;
          d5 &= 8191;
          d6 = c;
          d6 += h0 * r6;
          d6 += h1 * r5;
          d6 += h2 * r4;
          d6 += h3 * r3;
          d6 += h4 * r2;
          c = d6 >>> 13;
          d6 &= 8191;
          d6 += h5 * r1;
          d6 += h6 * r0;
          d6 += h7 * (5 * r9);
          d6 += h8 * (5 * r8);
          d6 += h9 * (5 * r7);
          c += d6 >>> 13;
          d6 &= 8191;
          d7 = c;
          d7 += h0 * r7;
          d7 += h1 * r6;
          d7 += h2 * r5;
          d7 += h3 * r4;
          d7 += h4 * r3;
          c = d7 >>> 13;
          d7 &= 8191;
          d7 += h5 * r2;
          d7 += h6 * r1;
          d7 += h7 * r0;
          d7 += h8 * (5 * r9);
          d7 += h9 * (5 * r8);
          c += d7 >>> 13;
          d7 &= 8191;
          d8 = c;
          d8 += h0 * r8;
          d8 += h1 * r7;
          d8 += h2 * r6;
          d8 += h3 * r5;
          d8 += h4 * r4;
          c = d8 >>> 13;
          d8 &= 8191;
          d8 += h5 * r3;
          d8 += h6 * r2;
          d8 += h7 * r1;
          d8 += h8 * r0;
          d8 += h9 * (5 * r9);
          c += d8 >>> 13;
          d8 &= 8191;
          d9 = c;
          d9 += h0 * r9;
          d9 += h1 * r8;
          d9 += h2 * r7;
          d9 += h3 * r6;
          d9 += h4 * r5;
          c = d9 >>> 13;
          d9 &= 8191;
          d9 += h5 * r4;
          d9 += h6 * r3;
          d9 += h7 * r2;
          d9 += h8 * r1;
          d9 += h9 * r0;
          c += d9 >>> 13;
          d9 &= 8191;
          c = (c << 2) + c | 0;
          c = c + d0 | 0;
          d0 = c & 8191;
          c = c >>> 13;
          d1 += c;
          h0 = d0;
          h1 = d1;
          h2 = d2;
          h3 = d3;
          h4 = d4;
          h5 = d5;
          h6 = d6;
          h7 = d7;
          h8 = d8;
          h9 = d9;
          mpos += 16;
          bytes -= 16;
        }
        this.h[0] = h0;
        this.h[1] = h1;
        this.h[2] = h2;
        this.h[3] = h3;
        this.h[4] = h4;
        this.h[5] = h5;
        this.h[6] = h6;
        this.h[7] = h7;
        this.h[8] = h8;
        this.h[9] = h9;
      };
      poly1305.prototype.finish = function(mac, macpos) {
        var g = new Uint16Array(10);
        var c, mask, f, i;
        if (this.leftover) {
          i = this.leftover;
          this.buffer[i++] = 1;
          for (; i < 16; i++) this.buffer[i] = 0;
          this.fin = 1;
          this.blocks(this.buffer, 0, 16);
        }
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        for (i = 2; i < 10; i++) {
          this.h[i] += c;
          c = this.h[i] >>> 13;
          this.h[i] &= 8191;
        }
        this.h[0] += c * 5;
        c = this.h[0] >>> 13;
        this.h[0] &= 8191;
        this.h[1] += c;
        c = this.h[1] >>> 13;
        this.h[1] &= 8191;
        this.h[2] += c;
        g[0] = this.h[0] + 5;
        c = g[0] >>> 13;
        g[0] &= 8191;
        for (i = 1; i < 10; i++) {
          g[i] = this.h[i] + c;
          c = g[i] >>> 13;
          g[i] &= 8191;
        }
        g[9] -= 1 << 13;
        mask = (c ^ 1) - 1;
        for (i = 0; i < 10; i++) g[i] &= mask;
        mask = ~mask;
        for (i = 0; i < 10; i++) this.h[i] = this.h[i] & mask | g[i];
        this.h[0] = (this.h[0] | this.h[1] << 13) & 65535;
        this.h[1] = (this.h[1] >>> 3 | this.h[2] << 10) & 65535;
        this.h[2] = (this.h[2] >>> 6 | this.h[3] << 7) & 65535;
        this.h[3] = (this.h[3] >>> 9 | this.h[4] << 4) & 65535;
        this.h[4] = (this.h[4] >>> 12 | this.h[5] << 1 | this.h[6] << 14) & 65535;
        this.h[5] = (this.h[6] >>> 2 | this.h[7] << 11) & 65535;
        this.h[6] = (this.h[7] >>> 5 | this.h[8] << 8) & 65535;
        this.h[7] = (this.h[8] >>> 8 | this.h[9] << 5) & 65535;
        f = this.h[0] + this.pad[0];
        this.h[0] = f & 65535;
        for (i = 1; i < 8; i++) {
          f = (this.h[i] + this.pad[i] | 0) + (f >>> 16) | 0;
          this.h[i] = f & 65535;
        }
        mac[macpos + 0] = this.h[0] >>> 0 & 255;
        mac[macpos + 1] = this.h[0] >>> 8 & 255;
        mac[macpos + 2] = this.h[1] >>> 0 & 255;
        mac[macpos + 3] = this.h[1] >>> 8 & 255;
        mac[macpos + 4] = this.h[2] >>> 0 & 255;
        mac[macpos + 5] = this.h[2] >>> 8 & 255;
        mac[macpos + 6] = this.h[3] >>> 0 & 255;
        mac[macpos + 7] = this.h[3] >>> 8 & 255;
        mac[macpos + 8] = this.h[4] >>> 0 & 255;
        mac[macpos + 9] = this.h[4] >>> 8 & 255;
        mac[macpos + 10] = this.h[5] >>> 0 & 255;
        mac[macpos + 11] = this.h[5] >>> 8 & 255;
        mac[macpos + 12] = this.h[6] >>> 0 & 255;
        mac[macpos + 13] = this.h[6] >>> 8 & 255;
        mac[macpos + 14] = this.h[7] >>> 0 & 255;
        mac[macpos + 15] = this.h[7] >>> 8 & 255;
      };
      poly1305.prototype.update = function(m, mpos, bytes) {
        var i, want;
        if (this.leftover) {
          want = 16 - this.leftover;
          if (want > bytes) want = bytes;
          for (i = 0; i < want; i++) this.buffer[this.leftover + i] = m[mpos + i];
          bytes -= want;
          mpos += want;
          this.leftover += want;
          if (this.leftover < 16) return;
          this.blocks(this.buffer, 0, 16);
          this.leftover = 0;
        }
        if (bytes >= 16) {
          want = bytes - bytes % 16;
          this.blocks(m, mpos, want);
          mpos += want;
          bytes -= want;
        }
        if (bytes) {
          for (i = 0; i < bytes; i++) this.buffer[this.leftover + i] = m[mpos + i];
          this.leftover += bytes;
        }
      };
      function crypto_onetimeauth(out, outpos, m, mpos, n, k) {
        var s = new poly1305(k);
        s.update(m, mpos, n);
        s.finish(out, outpos);
        return 0;
      }
      __name(crypto_onetimeauth, "crypto_onetimeauth");
      function crypto_onetimeauth_verify(h, hpos, m, mpos, n, k) {
        var x = new Uint8Array(16);
        crypto_onetimeauth(x, 0, m, mpos, n, k);
        return crypto_verify_16(h, hpos, x, 0);
      }
      __name(crypto_onetimeauth_verify, "crypto_onetimeauth_verify");
      function crypto_secretbox(c, m, d, n, k) {
        var i;
        if (d < 32) return -1;
        crypto_stream_xor(c, 0, m, 0, d, n, k);
        crypto_onetimeauth(c, 16, c, 32, d - 32, c);
        for (i = 0; i < 16; i++) c[i] = 0;
        return 0;
      }
      __name(crypto_secretbox, "crypto_secretbox");
      function crypto_secretbox_open(m, c, d, n, k) {
        var i;
        var x = new Uint8Array(32);
        if (d < 32) return -1;
        crypto_stream(x, 0, 32, n, k);
        if (crypto_onetimeauth_verify(c, 16, c, 32, d - 32, x) !== 0) return -1;
        crypto_stream_xor(m, 0, c, 0, d, n, k);
        for (i = 0; i < 32; i++) m[i] = 0;
        return 0;
      }
      __name(crypto_secretbox_open, "crypto_secretbox_open");
      function set25519(r, a) {
        var i;
        for (i = 0; i < 16; i++) r[i] = a[i] | 0;
      }
      __name(set25519, "set25519");
      function car25519(o) {
        var i, v, c = 1;
        for (i = 0; i < 16; i++) {
          v = o[i] + c + 65535;
          c = Math.floor(v / 65536);
          o[i] = v - c * 65536;
        }
        o[0] += c - 1 + 37 * (c - 1);
      }
      __name(car25519, "car25519");
      function sel25519(p, q, b) {
        var t, c = ~(b - 1);
        for (var i = 0; i < 16; i++) {
          t = c & (p[i] ^ q[i]);
          p[i] ^= t;
          q[i] ^= t;
        }
      }
      __name(sel25519, "sel25519");
      function pack25519(o, n) {
        var i, j, b;
        var m = gf(), t = gf();
        for (i = 0; i < 16; i++) t[i] = n[i];
        car25519(t);
        car25519(t);
        car25519(t);
        for (j = 0; j < 2; j++) {
          m[0] = t[0] - 65517;
          for (i = 1; i < 15; i++) {
            m[i] = t[i] - 65535 - (m[i - 1] >> 16 & 1);
            m[i - 1] &= 65535;
          }
          m[15] = t[15] - 32767 - (m[14] >> 16 & 1);
          b = m[15] >> 16 & 1;
          m[14] &= 65535;
          sel25519(t, m, 1 - b);
        }
        for (i = 0; i < 16; i++) {
          o[2 * i] = t[i] & 255;
          o[2 * i + 1] = t[i] >> 8;
        }
      }
      __name(pack25519, "pack25519");
      function neq25519(a, b) {
        var c = new Uint8Array(32), d = new Uint8Array(32);
        pack25519(c, a);
        pack25519(d, b);
        return crypto_verify_32(c, 0, d, 0);
      }
      __name(neq25519, "neq25519");
      function par25519(a) {
        var d = new Uint8Array(32);
        pack25519(d, a);
        return d[0] & 1;
      }
      __name(par25519, "par25519");
      function unpack25519(o, n) {
        var i;
        for (i = 0; i < 16; i++) o[i] = n[2 * i] + (n[2 * i + 1] << 8);
        o[15] &= 32767;
      }
      __name(unpack25519, "unpack25519");
      function A(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] + b[i];
      }
      __name(A, "A");
      function Z(o, a, b) {
        for (var i = 0; i < 16; i++) o[i] = a[i] - b[i];
      }
      __name(Z, "Z");
      function M(o, a, b) {
        var v, c, t0 = 0, t1 = 0, t2 = 0, t3 = 0, t4 = 0, t5 = 0, t6 = 0, t7 = 0, t8 = 0, t9 = 0, t10 = 0, t11 = 0, t12 = 0, t13 = 0, t14 = 0, t15 = 0, t16 = 0, t17 = 0, t18 = 0, t19 = 0, t20 = 0, t21 = 0, t22 = 0, t23 = 0, t24 = 0, t25 = 0, t26 = 0, t27 = 0, t28 = 0, t29 = 0, t30 = 0, b0 = b[0], b1 = b[1], b2 = b[2], b3 = b[3], b4 = b[4], b5 = b[5], b6 = b[6], b7 = b[7], b8 = b[8], b9 = b[9], b10 = b[10], b11 = b[11], b12 = b[12], b13 = b[13], b14 = b[14], b15 = b[15];
        v = a[0];
        t0 += v * b0;
        t1 += v * b1;
        t2 += v * b2;
        t3 += v * b3;
        t4 += v * b4;
        t5 += v * b5;
        t6 += v * b6;
        t7 += v * b7;
        t8 += v * b8;
        t9 += v * b9;
        t10 += v * b10;
        t11 += v * b11;
        t12 += v * b12;
        t13 += v * b13;
        t14 += v * b14;
        t15 += v * b15;
        v = a[1];
        t1 += v * b0;
        t2 += v * b1;
        t3 += v * b2;
        t4 += v * b3;
        t5 += v * b4;
        t6 += v * b5;
        t7 += v * b6;
        t8 += v * b7;
        t9 += v * b8;
        t10 += v * b9;
        t11 += v * b10;
        t12 += v * b11;
        t13 += v * b12;
        t14 += v * b13;
        t15 += v * b14;
        t16 += v * b15;
        v = a[2];
        t2 += v * b0;
        t3 += v * b1;
        t4 += v * b2;
        t5 += v * b3;
        t6 += v * b4;
        t7 += v * b5;
        t8 += v * b6;
        t9 += v * b7;
        t10 += v * b8;
        t11 += v * b9;
        t12 += v * b10;
        t13 += v * b11;
        t14 += v * b12;
        t15 += v * b13;
        t16 += v * b14;
        t17 += v * b15;
        v = a[3];
        t3 += v * b0;
        t4 += v * b1;
        t5 += v * b2;
        t6 += v * b3;
        t7 += v * b4;
        t8 += v * b5;
        t9 += v * b6;
        t10 += v * b7;
        t11 += v * b8;
        t12 += v * b9;
        t13 += v * b10;
        t14 += v * b11;
        t15 += v * b12;
        t16 += v * b13;
        t17 += v * b14;
        t18 += v * b15;
        v = a[4];
        t4 += v * b0;
        t5 += v * b1;
        t6 += v * b2;
        t7 += v * b3;
        t8 += v * b4;
        t9 += v * b5;
        t10 += v * b6;
        t11 += v * b7;
        t12 += v * b8;
        t13 += v * b9;
        t14 += v * b10;
        t15 += v * b11;
        t16 += v * b12;
        t17 += v * b13;
        t18 += v * b14;
        t19 += v * b15;
        v = a[5];
        t5 += v * b0;
        t6 += v * b1;
        t7 += v * b2;
        t8 += v * b3;
        t9 += v * b4;
        t10 += v * b5;
        t11 += v * b6;
        t12 += v * b7;
        t13 += v * b8;
        t14 += v * b9;
        t15 += v * b10;
        t16 += v * b11;
        t17 += v * b12;
        t18 += v * b13;
        t19 += v * b14;
        t20 += v * b15;
        v = a[6];
        t6 += v * b0;
        t7 += v * b1;
        t8 += v * b2;
        t9 += v * b3;
        t10 += v * b4;
        t11 += v * b5;
        t12 += v * b6;
        t13 += v * b7;
        t14 += v * b8;
        t15 += v * b9;
        t16 += v * b10;
        t17 += v * b11;
        t18 += v * b12;
        t19 += v * b13;
        t20 += v * b14;
        t21 += v * b15;
        v = a[7];
        t7 += v * b0;
        t8 += v * b1;
        t9 += v * b2;
        t10 += v * b3;
        t11 += v * b4;
        t12 += v * b5;
        t13 += v * b6;
        t14 += v * b7;
        t15 += v * b8;
        t16 += v * b9;
        t17 += v * b10;
        t18 += v * b11;
        t19 += v * b12;
        t20 += v * b13;
        t21 += v * b14;
        t22 += v * b15;
        v = a[8];
        t8 += v * b0;
        t9 += v * b1;
        t10 += v * b2;
        t11 += v * b3;
        t12 += v * b4;
        t13 += v * b5;
        t14 += v * b6;
        t15 += v * b7;
        t16 += v * b8;
        t17 += v * b9;
        t18 += v * b10;
        t19 += v * b11;
        t20 += v * b12;
        t21 += v * b13;
        t22 += v * b14;
        t23 += v * b15;
        v = a[9];
        t9 += v * b0;
        t10 += v * b1;
        t11 += v * b2;
        t12 += v * b3;
        t13 += v * b4;
        t14 += v * b5;
        t15 += v * b6;
        t16 += v * b7;
        t17 += v * b8;
        t18 += v * b9;
        t19 += v * b10;
        t20 += v * b11;
        t21 += v * b12;
        t22 += v * b13;
        t23 += v * b14;
        t24 += v * b15;
        v = a[10];
        t10 += v * b0;
        t11 += v * b1;
        t12 += v * b2;
        t13 += v * b3;
        t14 += v * b4;
        t15 += v * b5;
        t16 += v * b6;
        t17 += v * b7;
        t18 += v * b8;
        t19 += v * b9;
        t20 += v * b10;
        t21 += v * b11;
        t22 += v * b12;
        t23 += v * b13;
        t24 += v * b14;
        t25 += v * b15;
        v = a[11];
        t11 += v * b0;
        t12 += v * b1;
        t13 += v * b2;
        t14 += v * b3;
        t15 += v * b4;
        t16 += v * b5;
        t17 += v * b6;
        t18 += v * b7;
        t19 += v * b8;
        t20 += v * b9;
        t21 += v * b10;
        t22 += v * b11;
        t23 += v * b12;
        t24 += v * b13;
        t25 += v * b14;
        t26 += v * b15;
        v = a[12];
        t12 += v * b0;
        t13 += v * b1;
        t14 += v * b2;
        t15 += v * b3;
        t16 += v * b4;
        t17 += v * b5;
        t18 += v * b6;
        t19 += v * b7;
        t20 += v * b8;
        t21 += v * b9;
        t22 += v * b10;
        t23 += v * b11;
        t24 += v * b12;
        t25 += v * b13;
        t26 += v * b14;
        t27 += v * b15;
        v = a[13];
        t13 += v * b0;
        t14 += v * b1;
        t15 += v * b2;
        t16 += v * b3;
        t17 += v * b4;
        t18 += v * b5;
        t19 += v * b6;
        t20 += v * b7;
        t21 += v * b8;
        t22 += v * b9;
        t23 += v * b10;
        t24 += v * b11;
        t25 += v * b12;
        t26 += v * b13;
        t27 += v * b14;
        t28 += v * b15;
        v = a[14];
        t14 += v * b0;
        t15 += v * b1;
        t16 += v * b2;
        t17 += v * b3;
        t18 += v * b4;
        t19 += v * b5;
        t20 += v * b6;
        t21 += v * b7;
        t22 += v * b8;
        t23 += v * b9;
        t24 += v * b10;
        t25 += v * b11;
        t26 += v * b12;
        t27 += v * b13;
        t28 += v * b14;
        t29 += v * b15;
        v = a[15];
        t15 += v * b0;
        t16 += v * b1;
        t17 += v * b2;
        t18 += v * b3;
        t19 += v * b4;
        t20 += v * b5;
        t21 += v * b6;
        t22 += v * b7;
        t23 += v * b8;
        t24 += v * b9;
        t25 += v * b10;
        t26 += v * b11;
        t27 += v * b12;
        t28 += v * b13;
        t29 += v * b14;
        t30 += v * b15;
        t0 += 38 * t16;
        t1 += 38 * t17;
        t2 += 38 * t18;
        t3 += 38 * t19;
        t4 += 38 * t20;
        t5 += 38 * t21;
        t6 += 38 * t22;
        t7 += 38 * t23;
        t8 += 38 * t24;
        t9 += 38 * t25;
        t10 += 38 * t26;
        t11 += 38 * t27;
        t12 += 38 * t28;
        t13 += 38 * t29;
        t14 += 38 * t30;
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        c = 1;
        v = t0 + c + 65535;
        c = Math.floor(v / 65536);
        t0 = v - c * 65536;
        v = t1 + c + 65535;
        c = Math.floor(v / 65536);
        t1 = v - c * 65536;
        v = t2 + c + 65535;
        c = Math.floor(v / 65536);
        t2 = v - c * 65536;
        v = t3 + c + 65535;
        c = Math.floor(v / 65536);
        t3 = v - c * 65536;
        v = t4 + c + 65535;
        c = Math.floor(v / 65536);
        t4 = v - c * 65536;
        v = t5 + c + 65535;
        c = Math.floor(v / 65536);
        t5 = v - c * 65536;
        v = t6 + c + 65535;
        c = Math.floor(v / 65536);
        t6 = v - c * 65536;
        v = t7 + c + 65535;
        c = Math.floor(v / 65536);
        t7 = v - c * 65536;
        v = t8 + c + 65535;
        c = Math.floor(v / 65536);
        t8 = v - c * 65536;
        v = t9 + c + 65535;
        c = Math.floor(v / 65536);
        t9 = v - c * 65536;
        v = t10 + c + 65535;
        c = Math.floor(v / 65536);
        t10 = v - c * 65536;
        v = t11 + c + 65535;
        c = Math.floor(v / 65536);
        t11 = v - c * 65536;
        v = t12 + c + 65535;
        c = Math.floor(v / 65536);
        t12 = v - c * 65536;
        v = t13 + c + 65535;
        c = Math.floor(v / 65536);
        t13 = v - c * 65536;
        v = t14 + c + 65535;
        c = Math.floor(v / 65536);
        t14 = v - c * 65536;
        v = t15 + c + 65535;
        c = Math.floor(v / 65536);
        t15 = v - c * 65536;
        t0 += c - 1 + 37 * (c - 1);
        o[0] = t0;
        o[1] = t1;
        o[2] = t2;
        o[3] = t3;
        o[4] = t4;
        o[5] = t5;
        o[6] = t6;
        o[7] = t7;
        o[8] = t8;
        o[9] = t9;
        o[10] = t10;
        o[11] = t11;
        o[12] = t12;
        o[13] = t13;
        o[14] = t14;
        o[15] = t15;
      }
      __name(M, "M");
      function S(o, a) {
        M(o, a, a);
      }
      __name(S, "S");
      function inv25519(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 253; a >= 0; a--) {
          S(c, c);
          if (a !== 2 && a !== 4) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      __name(inv25519, "inv25519");
      function pow2523(o, i) {
        var c = gf();
        var a;
        for (a = 0; a < 16; a++) c[a] = i[a];
        for (a = 250; a >= 0; a--) {
          S(c, c);
          if (a !== 1) M(c, c, i);
        }
        for (a = 0; a < 16; a++) o[a] = c[a];
      }
      __name(pow2523, "pow2523");
      function crypto_scalarmult(q, n, p) {
        var z2 = new Uint8Array(32);
        var x = new Float64Array(80), r, i;
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf();
        for (i = 0; i < 31; i++) z2[i] = n[i];
        z2[31] = n[31] & 127 | 64;
        z2[0] &= 248;
        unpack25519(x, p);
        for (i = 0; i < 16; i++) {
          b[i] = x[i];
          d[i] = a[i] = c[i] = 0;
        }
        a[0] = d[0] = 1;
        for (i = 254; i >= 0; --i) {
          r = z2[i >>> 3] >>> (i & 7) & 1;
          sel25519(a, b, r);
          sel25519(c, d, r);
          A(e, a, c);
          Z(a, a, c);
          A(c, b, d);
          Z(b, b, d);
          S(d, e);
          S(f, a);
          M(a, c, a);
          M(c, b, e);
          A(e, a, c);
          Z(a, a, c);
          S(b, a);
          Z(c, d, f);
          M(a, c, _121665);
          A(a, a, d);
          M(c, c, a);
          M(a, d, f);
          M(d, b, x);
          S(b, e);
          sel25519(a, b, r);
          sel25519(c, d, r);
        }
        for (i = 0; i < 16; i++) {
          x[i + 16] = a[i];
          x[i + 32] = c[i];
          x[i + 48] = b[i];
          x[i + 64] = d[i];
        }
        var x32 = x.subarray(32);
        var x16 = x.subarray(16);
        inv25519(x32, x32);
        M(x16, x16, x32);
        pack25519(q, x16);
        return 0;
      }
      __name(crypto_scalarmult, "crypto_scalarmult");
      function crypto_scalarmult_base(q, n) {
        return crypto_scalarmult(q, n, _9);
      }
      __name(crypto_scalarmult_base, "crypto_scalarmult_base");
      function crypto_box_keypair(y, x) {
        randombytes(x, 32);
        return crypto_scalarmult_base(y, x);
      }
      __name(crypto_box_keypair, "crypto_box_keypair");
      function crypto_box_beforenm(k, y, x) {
        var s = new Uint8Array(32);
        crypto_scalarmult(s, x, y);
        return crypto_core_hsalsa20(k, _0, s, sigma);
      }
      __name(crypto_box_beforenm, "crypto_box_beforenm");
      var crypto_box_afternm = crypto_secretbox;
      var crypto_box_open_afternm = crypto_secretbox_open;
      function crypto_box(c, m, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_afternm(c, m, d, n, k);
      }
      __name(crypto_box, "crypto_box");
      function crypto_box_open(m, c, d, n, y, x) {
        var k = new Uint8Array(32);
        crypto_box_beforenm(k, y, x);
        return crypto_box_open_afternm(m, c, d, n, k);
      }
      __name(crypto_box_open, "crypto_box_open");
      var K = [
        1116352408,
        3609767458,
        1899447441,
        602891725,
        3049323471,
        3964484399,
        3921009573,
        2173295548,
        961987163,
        4081628472,
        1508970993,
        3053834265,
        2453635748,
        2937671579,
        2870763221,
        3664609560,
        3624381080,
        2734883394,
        310598401,
        1164996542,
        607225278,
        1323610764,
        1426881987,
        3590304994,
        1925078388,
        4068182383,
        2162078206,
        991336113,
        2614888103,
        633803317,
        3248222580,
        3479774868,
        3835390401,
        2666613458,
        4022224774,
        944711139,
        264347078,
        2341262773,
        604807628,
        2007800933,
        770255983,
        1495990901,
        1249150122,
        1856431235,
        1555081692,
        3175218132,
        1996064986,
        2198950837,
        2554220882,
        3999719339,
        2821834349,
        766784016,
        2952996808,
        2566594879,
        3210313671,
        3203337956,
        3336571891,
        1034457026,
        3584528711,
        2466948901,
        113926993,
        3758326383,
        338241895,
        168717936,
        666307205,
        1188179964,
        773529912,
        1546045734,
        1294757372,
        1522805485,
        1396182291,
        2643833823,
        1695183700,
        2343527390,
        1986661051,
        1014477480,
        2177026350,
        1206759142,
        2456956037,
        344077627,
        2730485921,
        1290863460,
        2820302411,
        3158454273,
        3259730800,
        3505952657,
        3345764771,
        106217008,
        3516065817,
        3606008344,
        3600352804,
        1432725776,
        4094571909,
        1467031594,
        275423344,
        851169720,
        430227734,
        3100823752,
        506948616,
        1363258195,
        659060556,
        3750685593,
        883997877,
        3785050280,
        958139571,
        3318307427,
        1322822218,
        3812723403,
        1537002063,
        2003034995,
        1747873779,
        3602036899,
        1955562222,
        1575990012,
        2024104815,
        1125592928,
        2227730452,
        2716904306,
        2361852424,
        442776044,
        2428436474,
        593698344,
        2756734187,
        3733110249,
        3204031479,
        2999351573,
        3329325298,
        3815920427,
        3391569614,
        3928383900,
        3515267271,
        566280711,
        3940187606,
        3454069534,
        4118630271,
        4000239992,
        116418474,
        1914138554,
        174292421,
        2731055270,
        289380356,
        3203993006,
        460393269,
        320620315,
        685471733,
        587496836,
        852142971,
        1086792851,
        1017036298,
        365543100,
        1126000580,
        2618297676,
        1288033470,
        3409855158,
        1501505948,
        4234509866,
        1607167915,
        987167468,
        1816402316,
        1246189591
      ];
      function crypto_hashblocks_hl(hh, hl, m, n) {
        var wh = new Int32Array(16), wl = new Int32Array(16), bh0, bh1, bh2, bh3, bh4, bh5, bh6, bh7, bl0, bl1, bl2, bl3, bl4, bl5, bl6, bl7, th, tl, i, j, h, l, a, b, c, d;
        var ah0 = hh[0], ah1 = hh[1], ah2 = hh[2], ah3 = hh[3], ah4 = hh[4], ah5 = hh[5], ah6 = hh[6], ah7 = hh[7], al0 = hl[0], al1 = hl[1], al2 = hl[2], al3 = hl[3], al4 = hl[4], al5 = hl[5], al6 = hl[6], al7 = hl[7];
        var pos = 0;
        while (n >= 128) {
          for (i = 0; i < 16; i++) {
            j = 8 * i + pos;
            wh[i] = m[j + 0] << 24 | m[j + 1] << 16 | m[j + 2] << 8 | m[j + 3];
            wl[i] = m[j + 4] << 24 | m[j + 5] << 16 | m[j + 6] << 8 | m[j + 7];
          }
          for (i = 0; i < 80; i++) {
            bh0 = ah0;
            bh1 = ah1;
            bh2 = ah2;
            bh3 = ah3;
            bh4 = ah4;
            bh5 = ah5;
            bh6 = ah6;
            bh7 = ah7;
            bl0 = al0;
            bl1 = al1;
            bl2 = al2;
            bl3 = al3;
            bl4 = al4;
            bl5 = al5;
            bl6 = al6;
            bl7 = al7;
            h = ah7;
            l = al7;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah4 >>> 14 | al4 << 32 - 14) ^ (ah4 >>> 18 | al4 << 32 - 18) ^ (al4 >>> 41 - 32 | ah4 << 32 - (41 - 32));
            l = (al4 >>> 14 | ah4 << 32 - 14) ^ (al4 >>> 18 | ah4 << 32 - 18) ^ (ah4 >>> 41 - 32 | al4 << 32 - (41 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah4 & ah5 ^ ~ah4 & ah6;
            l = al4 & al5 ^ ~al4 & al6;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = K[i * 2];
            l = K[i * 2 + 1];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = wh[i % 16];
            l = wl[i % 16];
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            th = c & 65535 | d << 16;
            tl = a & 65535 | b << 16;
            h = th;
            l = tl;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = (ah0 >>> 28 | al0 << 32 - 28) ^ (al0 >>> 34 - 32 | ah0 << 32 - (34 - 32)) ^ (al0 >>> 39 - 32 | ah0 << 32 - (39 - 32));
            l = (al0 >>> 28 | ah0 << 32 - 28) ^ (ah0 >>> 34 - 32 | al0 << 32 - (34 - 32)) ^ (ah0 >>> 39 - 32 | al0 << 32 - (39 - 32));
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            h = ah0 & ah1 ^ ah0 & ah2 ^ ah1 & ah2;
            l = al0 & al1 ^ al0 & al2 ^ al1 & al2;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh7 = c & 65535 | d << 16;
            bl7 = a & 65535 | b << 16;
            h = bh3;
            l = bl3;
            a = l & 65535;
            b = l >>> 16;
            c = h & 65535;
            d = h >>> 16;
            h = th;
            l = tl;
            a += l & 65535;
            b += l >>> 16;
            c += h & 65535;
            d += h >>> 16;
            b += a >>> 16;
            c += b >>> 16;
            d += c >>> 16;
            bh3 = c & 65535 | d << 16;
            bl3 = a & 65535 | b << 16;
            ah1 = bh0;
            ah2 = bh1;
            ah3 = bh2;
            ah4 = bh3;
            ah5 = bh4;
            ah6 = bh5;
            ah7 = bh6;
            ah0 = bh7;
            al1 = bl0;
            al2 = bl1;
            al3 = bl2;
            al4 = bl3;
            al5 = bl4;
            al6 = bl5;
            al7 = bl6;
            al0 = bl7;
            if (i % 16 === 15) {
              for (j = 0; j < 16; j++) {
                h = wh[j];
                l = wl[j];
                a = l & 65535;
                b = l >>> 16;
                c = h & 65535;
                d = h >>> 16;
                h = wh[(j + 9) % 16];
                l = wl[(j + 9) % 16];
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 1) % 16];
                tl = wl[(j + 1) % 16];
                h = (th >>> 1 | tl << 32 - 1) ^ (th >>> 8 | tl << 32 - 8) ^ th >>> 7;
                l = (tl >>> 1 | th << 32 - 1) ^ (tl >>> 8 | th << 32 - 8) ^ (tl >>> 7 | th << 32 - 7);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                th = wh[(j + 14) % 16];
                tl = wl[(j + 14) % 16];
                h = (th >>> 19 | tl << 32 - 19) ^ (tl >>> 61 - 32 | th << 32 - (61 - 32)) ^ th >>> 6;
                l = (tl >>> 19 | th << 32 - 19) ^ (th >>> 61 - 32 | tl << 32 - (61 - 32)) ^ (tl >>> 6 | th << 32 - 6);
                a += l & 65535;
                b += l >>> 16;
                c += h & 65535;
                d += h >>> 16;
                b += a >>> 16;
                c += b >>> 16;
                d += c >>> 16;
                wh[j] = c & 65535 | d << 16;
                wl[j] = a & 65535 | b << 16;
              }
            }
          }
          h = ah0;
          l = al0;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[0];
          l = hl[0];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[0] = ah0 = c & 65535 | d << 16;
          hl[0] = al0 = a & 65535 | b << 16;
          h = ah1;
          l = al1;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[1];
          l = hl[1];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[1] = ah1 = c & 65535 | d << 16;
          hl[1] = al1 = a & 65535 | b << 16;
          h = ah2;
          l = al2;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[2];
          l = hl[2];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[2] = ah2 = c & 65535 | d << 16;
          hl[2] = al2 = a & 65535 | b << 16;
          h = ah3;
          l = al3;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[3];
          l = hl[3];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[3] = ah3 = c & 65535 | d << 16;
          hl[3] = al3 = a & 65535 | b << 16;
          h = ah4;
          l = al4;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[4];
          l = hl[4];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[4] = ah4 = c & 65535 | d << 16;
          hl[4] = al4 = a & 65535 | b << 16;
          h = ah5;
          l = al5;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[5];
          l = hl[5];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[5] = ah5 = c & 65535 | d << 16;
          hl[5] = al5 = a & 65535 | b << 16;
          h = ah6;
          l = al6;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[6];
          l = hl[6];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[6] = ah6 = c & 65535 | d << 16;
          hl[6] = al6 = a & 65535 | b << 16;
          h = ah7;
          l = al7;
          a = l & 65535;
          b = l >>> 16;
          c = h & 65535;
          d = h >>> 16;
          h = hh[7];
          l = hl[7];
          a += l & 65535;
          b += l >>> 16;
          c += h & 65535;
          d += h >>> 16;
          b += a >>> 16;
          c += b >>> 16;
          d += c >>> 16;
          hh[7] = ah7 = c & 65535 | d << 16;
          hl[7] = al7 = a & 65535 | b << 16;
          pos += 128;
          n -= 128;
        }
        return n;
      }
      __name(crypto_hashblocks_hl, "crypto_hashblocks_hl");
      function crypto_hash(out, m, n) {
        var hh = new Int32Array(8), hl = new Int32Array(8), x = new Uint8Array(256), i, b = n;
        hh[0] = 1779033703;
        hh[1] = 3144134277;
        hh[2] = 1013904242;
        hh[3] = 2773480762;
        hh[4] = 1359893119;
        hh[5] = 2600822924;
        hh[6] = 528734635;
        hh[7] = 1541459225;
        hl[0] = 4089235720;
        hl[1] = 2227873595;
        hl[2] = 4271175723;
        hl[3] = 1595750129;
        hl[4] = 2917565137;
        hl[5] = 725511199;
        hl[6] = 4215389547;
        hl[7] = 327033209;
        crypto_hashblocks_hl(hh, hl, m, n);
        n %= 128;
        for (i = 0; i < n; i++) x[i] = m[b - n + i];
        x[n] = 128;
        n = 256 - 128 * (n < 112 ? 1 : 0);
        x[n - 9] = 0;
        ts64(x, n - 8, b / 536870912 | 0, b << 3);
        crypto_hashblocks_hl(hh, hl, x, n);
        for (i = 0; i < 8; i++) ts64(out, 8 * i, hh[i], hl[i]);
        return 0;
      }
      __name(crypto_hash, "crypto_hash");
      function add(p, q) {
        var a = gf(), b = gf(), c = gf(), d = gf(), e = gf(), f = gf(), g = gf(), h = gf(), t = gf();
        Z(a, p[1], p[0]);
        Z(t, q[1], q[0]);
        M(a, a, t);
        A(b, p[0], p[1]);
        A(t, q[0], q[1]);
        M(b, b, t);
        M(c, p[3], q[3]);
        M(c, c, D2);
        M(d, p[2], q[2]);
        A(d, d, d);
        Z(e, b, a);
        Z(f, d, c);
        A(g, d, c);
        A(h, b, a);
        M(p[0], e, f);
        M(p[1], h, g);
        M(p[2], g, f);
        M(p[3], e, h);
      }
      __name(add, "add");
      function cswap(p, q, b) {
        var i;
        for (i = 0; i < 4; i++) {
          sel25519(p[i], q[i], b);
        }
      }
      __name(cswap, "cswap");
      function pack(r, p) {
        var tx = gf(), ty = gf(), zi = gf();
        inv25519(zi, p[2]);
        M(tx, p[0], zi);
        M(ty, p[1], zi);
        pack25519(r, ty);
        r[31] ^= par25519(tx) << 7;
      }
      __name(pack, "pack");
      function scalarmult(p, q, s) {
        var b, i;
        set25519(p[0], gf0);
        set25519(p[1], gf1);
        set25519(p[2], gf1);
        set25519(p[3], gf0);
        for (i = 255; i >= 0; --i) {
          b = s[i / 8 | 0] >> (i & 7) & 1;
          cswap(p, q, b);
          add(q, p);
          add(p, p);
          cswap(p, q, b);
        }
      }
      __name(scalarmult, "scalarmult");
      function scalarbase(p, s) {
        var q = [
          gf(),
          gf(),
          gf(),
          gf()
        ];
        set25519(q[0], X);
        set25519(q[1], Y);
        set25519(q[2], gf1);
        M(q[3], X, Y);
        scalarmult(p, q, s);
      }
      __name(scalarbase, "scalarbase");
      function crypto_sign_keypair(pk, sk, seeded) {
        var d = new Uint8Array(64);
        var p = [
          gf(),
          gf(),
          gf(),
          gf()
        ];
        var i;
        if (!seeded) randombytes(sk, 32);
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        scalarbase(p, d);
        pack(pk, p);
        for (i = 0; i < 32; i++) sk[i + 32] = pk[i];
        return 0;
      }
      __name(crypto_sign_keypair, "crypto_sign_keypair");
      var L = new Float64Array([
        237,
        211,
        245,
        92,
        26,
        99,
        18,
        88,
        214,
        156,
        247,
        162,
        222,
        249,
        222,
        20,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        16
      ]);
      function modL(r, x) {
        var carry, i, j, k;
        for (i = 63; i >= 32; --i) {
          carry = 0;
          for (j = i - 32, k = i - 12; j < k; ++j) {
            x[j] += carry - 16 * x[i] * L[j - (i - 32)];
            carry = x[j] + 128 >> 8;
            x[j] -= carry * 256;
          }
          x[j] += carry;
          x[i] = 0;
        }
        carry = 0;
        for (j = 0; j < 32; j++) {
          x[j] += carry - (x[31] >> 4) * L[j];
          carry = x[j] >> 8;
          x[j] &= 255;
        }
        for (j = 0; j < 32; j++) x[j] -= carry * L[j];
        for (i = 0; i < 32; i++) {
          x[i + 1] += x[i] >> 8;
          r[i] = x[i] & 255;
        }
      }
      __name(modL, "modL");
      function reduce(r) {
        var x = new Float64Array(64), i;
        for (i = 0; i < 64; i++) x[i] = r[i];
        for (i = 0; i < 64; i++) r[i] = 0;
        modL(r, x);
      }
      __name(reduce, "reduce");
      function crypto_sign(sm, m, n, sk) {
        var d = new Uint8Array(64), h = new Uint8Array(64), r = new Uint8Array(64);
        var i, j, x = new Float64Array(64);
        var p = [
          gf(),
          gf(),
          gf(),
          gf()
        ];
        crypto_hash(d, sk, 32);
        d[0] &= 248;
        d[31] &= 127;
        d[31] |= 64;
        var smlen = n + 64;
        for (i = 0; i < n; i++) sm[64 + i] = m[i];
        for (i = 0; i < 32; i++) sm[32 + i] = d[32 + i];
        crypto_hash(r, sm.subarray(32), n + 32);
        reduce(r);
        scalarbase(p, r);
        pack(sm, p);
        for (i = 32; i < 64; i++) sm[i] = sk[i];
        crypto_hash(h, sm, n + 64);
        reduce(h);
        for (i = 0; i < 64; i++) x[i] = 0;
        for (i = 0; i < 32; i++) x[i] = r[i];
        for (i = 0; i < 32; i++) {
          for (j = 0; j < 32; j++) {
            x[i + j] += h[i] * d[j];
          }
        }
        modL(sm.subarray(32), x);
        return smlen;
      }
      __name(crypto_sign, "crypto_sign");
      function unpackneg(r, p) {
        var t = gf(), chk = gf(), num = gf(), den = gf(), den2 = gf(), den4 = gf(), den6 = gf();
        set25519(r[2], gf1);
        unpack25519(r[1], p);
        S(num, r[1]);
        M(den, num, D);
        Z(num, num, r[2]);
        A(den, r[2], den);
        S(den2, den);
        S(den4, den2);
        M(den6, den4, den2);
        M(t, den6, num);
        M(t, t, den);
        pow2523(t, t);
        M(t, t, num);
        M(t, t, den);
        M(t, t, den);
        M(r[0], t, den);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) M(r[0], r[0], I);
        S(chk, r[0]);
        M(chk, chk, den);
        if (neq25519(chk, num)) return -1;
        if (par25519(r[0]) === p[31] >> 7) Z(r[0], gf0, r[0]);
        M(r[3], r[0], r[1]);
        return 0;
      }
      __name(unpackneg, "unpackneg");
      function crypto_sign_open(m, sm, n, pk) {
        var i, mlen;
        var t = new Uint8Array(32), h = new Uint8Array(64);
        var p = [
          gf(),
          gf(),
          gf(),
          gf()
        ], q = [
          gf(),
          gf(),
          gf(),
          gf()
        ];
        mlen = -1;
        if (n < 64) return -1;
        if (unpackneg(q, pk)) return -1;
        for (i = 0; i < n; i++) m[i] = sm[i];
        for (i = 0; i < 32; i++) m[i + 32] = pk[i];
        crypto_hash(h, m, n);
        reduce(h);
        scalarmult(p, q, h);
        scalarbase(q, sm.subarray(32));
        add(p, q);
        pack(t, p);
        n -= 64;
        if (crypto_verify_32(sm, 0, t, 0)) {
          for (i = 0; i < n; i++) m[i] = 0;
          return -1;
        }
        for (i = 0; i < n; i++) m[i] = sm[i + 64];
        mlen = n;
        return mlen;
      }
      __name(crypto_sign_open, "crypto_sign_open");
      var crypto_secretbox_KEYBYTES = 32, crypto_secretbox_NONCEBYTES = 24, crypto_secretbox_ZEROBYTES = 32, crypto_secretbox_BOXZEROBYTES = 16, crypto_scalarmult_BYTES = 32, crypto_scalarmult_SCALARBYTES = 32, crypto_box_PUBLICKEYBYTES = 32, crypto_box_SECRETKEYBYTES = 32, crypto_box_BEFORENMBYTES = 32, crypto_box_NONCEBYTES = crypto_secretbox_NONCEBYTES, crypto_box_ZEROBYTES = crypto_secretbox_ZEROBYTES, crypto_box_BOXZEROBYTES = crypto_secretbox_BOXZEROBYTES, crypto_sign_BYTES = 64, crypto_sign_PUBLICKEYBYTES = 32, crypto_sign_SECRETKEYBYTES = 64, crypto_sign_SEEDBYTES = 32, crypto_hash_BYTES = 64;
      nacl.lowlevel = {
        crypto_core_hsalsa20,
        crypto_stream_xor,
        crypto_stream,
        crypto_stream_salsa20_xor,
        crypto_stream_salsa20,
        crypto_onetimeauth,
        crypto_onetimeauth_verify,
        crypto_verify_16,
        crypto_verify_32,
        crypto_secretbox,
        crypto_secretbox_open,
        crypto_scalarmult,
        crypto_scalarmult_base,
        crypto_box_beforenm,
        crypto_box_afternm,
        crypto_box,
        crypto_box_open,
        crypto_box_keypair,
        crypto_hash,
        crypto_sign,
        crypto_sign_keypair,
        crypto_sign_open,
        crypto_secretbox_KEYBYTES,
        crypto_secretbox_NONCEBYTES,
        crypto_secretbox_ZEROBYTES,
        crypto_secretbox_BOXZEROBYTES,
        crypto_scalarmult_BYTES,
        crypto_scalarmult_SCALARBYTES,
        crypto_box_PUBLICKEYBYTES,
        crypto_box_SECRETKEYBYTES,
        crypto_box_BEFORENMBYTES,
        crypto_box_NONCEBYTES,
        crypto_box_ZEROBYTES,
        crypto_box_BOXZEROBYTES,
        crypto_sign_BYTES,
        crypto_sign_PUBLICKEYBYTES,
        crypto_sign_SECRETKEYBYTES,
        crypto_sign_SEEDBYTES,
        crypto_hash_BYTES
      };
      function checkLengths(k, n) {
        if (k.length !== crypto_secretbox_KEYBYTES) throw new Error("bad key size");
        if (n.length !== crypto_secretbox_NONCEBYTES) throw new Error("bad nonce size");
      }
      __name(checkLengths, "checkLengths");
      function checkBoxLengths(pk, sk) {
        if (pk.length !== crypto_box_PUBLICKEYBYTES) throw new Error("bad public key size");
        if (sk.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
      }
      __name(checkBoxLengths, "checkBoxLengths");
      function checkArrayTypes() {
        var t, i;
        for (i = 0; i < arguments.length; i++) {
          if ((t = Object.prototype.toString.call(arguments[i])) !== "[object Uint8Array]") throw new TypeError("unexpected type " + t + ", use Uint8Array");
        }
      }
      __name(checkArrayTypes, "checkArrayTypes");
      function cleanup(arr) {
        for (var i = 0; i < arr.length; i++) arr[i] = 0;
      }
      __name(cleanup, "cleanup");
      if (!nacl.util) {
        nacl.util = {};
        nacl.util.decodeUTF8 = nacl.util.encodeUTF8 = nacl.util.encodeBase64 = nacl.util.decodeBase64 = function() {
          throw new Error("nacl.util moved into separate package: https://github.com/dchest/tweetnacl-util-js");
        };
      }
      nacl.randomBytes = function(n) {
        var b = new Uint8Array(n);
        randombytes(b, n);
        return b;
      };
      nacl.secretbox = function(msg, nonce, key) {
        checkArrayTypes(msg, nonce, key);
        checkLengths(key, nonce);
        var m = new Uint8Array(crypto_secretbox_ZEROBYTES + msg.length);
        var c = new Uint8Array(m.length);
        for (var i = 0; i < msg.length; i++) m[i + crypto_secretbox_ZEROBYTES] = msg[i];
        crypto_secretbox(c, m, m.length, nonce, key);
        return c.subarray(crypto_secretbox_BOXZEROBYTES);
      };
      nacl.secretbox.open = function(box, nonce, key) {
        checkArrayTypes(box, nonce, key);
        checkLengths(key, nonce);
        var c = new Uint8Array(crypto_secretbox_BOXZEROBYTES + box.length);
        var m = new Uint8Array(c.length);
        for (var i = 0; i < box.length; i++) c[i + crypto_secretbox_BOXZEROBYTES] = box[i];
        if (c.length < 32) return false;
        if (crypto_secretbox_open(m, c, c.length, nonce, key) !== 0) return false;
        return m.subarray(crypto_secretbox_ZEROBYTES);
      };
      nacl.secretbox.keyLength = crypto_secretbox_KEYBYTES;
      nacl.secretbox.nonceLength = crypto_secretbox_NONCEBYTES;
      nacl.secretbox.overheadLength = crypto_secretbox_BOXZEROBYTES;
      nacl.scalarMult = function(n, p) {
        checkArrayTypes(n, p);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        if (p.length !== crypto_scalarmult_BYTES) throw new Error("bad p size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult(q, n, p);
        return q;
      };
      nacl.scalarMult.base = function(n) {
        checkArrayTypes(n);
        if (n.length !== crypto_scalarmult_SCALARBYTES) throw new Error("bad n size");
        var q = new Uint8Array(crypto_scalarmult_BYTES);
        crypto_scalarmult_base(q, n);
        return q;
      };
      nacl.scalarMult.scalarLength = crypto_scalarmult_SCALARBYTES;
      nacl.scalarMult.groupElementLength = crypto_scalarmult_BYTES;
      nacl.box = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox(msg, nonce, k);
      };
      nacl.box.before = function(publicKey, secretKey) {
        checkArrayTypes(publicKey, secretKey);
        checkBoxLengths(publicKey, secretKey);
        var k = new Uint8Array(crypto_box_BEFORENMBYTES);
        crypto_box_beforenm(k, publicKey, secretKey);
        return k;
      };
      nacl.box.after = nacl.secretbox;
      nacl.box.open = function(msg, nonce, publicKey, secretKey) {
        var k = nacl.box.before(publicKey, secretKey);
        return nacl.secretbox.open(msg, nonce, k);
      };
      nacl.box.open.after = nacl.secretbox.open;
      nacl.box.keyPair = function() {
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_box_SECRETKEYBYTES);
        crypto_box_keypair(pk, sk);
        return {
          publicKey: pk,
          secretKey: sk
        };
      };
      nacl.box.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_box_SECRETKEYBYTES) throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_box_PUBLICKEYBYTES);
        crypto_scalarmult_base(pk, secretKey);
        return {
          publicKey: pk,
          secretKey: new Uint8Array(secretKey)
        };
      };
      nacl.box.publicKeyLength = crypto_box_PUBLICKEYBYTES;
      nacl.box.secretKeyLength = crypto_box_SECRETKEYBYTES;
      nacl.box.sharedKeyLength = crypto_box_BEFORENMBYTES;
      nacl.box.nonceLength = crypto_box_NONCEBYTES;
      nacl.box.overheadLength = nacl.secretbox.overheadLength;
      nacl.sign = function(msg, secretKey) {
        checkArrayTypes(msg, secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
        var signedMsg = new Uint8Array(crypto_sign_BYTES + msg.length);
        crypto_sign(signedMsg, msg, msg.length, secretKey);
        return signedMsg;
      };
      nacl.sign.open = function(signedMsg, publicKey) {
        if (arguments.length !== 2) throw new Error("nacl.sign.open accepts 2 arguments; did you mean to use nacl.sign.detached.verify?");
        checkArrayTypes(signedMsg, publicKey);
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
        var tmp = new Uint8Array(signedMsg.length);
        var mlen = crypto_sign_open(tmp, signedMsg, signedMsg.length, publicKey);
        if (mlen < 0) return null;
        var m = new Uint8Array(mlen);
        for (var i = 0; i < m.length; i++) m[i] = tmp[i];
        return m;
      };
      nacl.sign.detached = function(msg, secretKey) {
        var signedMsg = nacl.sign(msg, secretKey);
        var sig = new Uint8Array(crypto_sign_BYTES);
        for (var i = 0; i < sig.length; i++) sig[i] = signedMsg[i];
        return sig;
      };
      nacl.sign.detached.verify = function(msg, sig, publicKey) {
        checkArrayTypes(msg, sig, publicKey);
        if (sig.length !== crypto_sign_BYTES) throw new Error("bad signature size");
        if (publicKey.length !== crypto_sign_PUBLICKEYBYTES) throw new Error("bad public key size");
        var sm = new Uint8Array(crypto_sign_BYTES + msg.length);
        var m = new Uint8Array(crypto_sign_BYTES + msg.length);
        var i;
        for (i = 0; i < crypto_sign_BYTES; i++) sm[i] = sig[i];
        for (i = 0; i < msg.length; i++) sm[i + crypto_sign_BYTES] = msg[i];
        return crypto_sign_open(m, sm, sm.length, publicKey) >= 0;
      };
      nacl.sign.keyPair = function() {
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        crypto_sign_keypair(pk, sk);
        return {
          publicKey: pk,
          secretKey: sk
        };
      };
      nacl.sign.keyPair.fromSecretKey = function(secretKey) {
        checkArrayTypes(secretKey);
        if (secretKey.length !== crypto_sign_SECRETKEYBYTES) throw new Error("bad secret key size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        for (var i = 0; i < pk.length; i++) pk[i] = secretKey[32 + i];
        return {
          publicKey: pk,
          secretKey: new Uint8Array(secretKey)
        };
      };
      nacl.sign.keyPair.fromSeed = function(seed) {
        checkArrayTypes(seed);
        if (seed.length !== crypto_sign_SEEDBYTES) throw new Error("bad seed size");
        var pk = new Uint8Array(crypto_sign_PUBLICKEYBYTES);
        var sk = new Uint8Array(crypto_sign_SECRETKEYBYTES);
        for (var i = 0; i < 32; i++) sk[i] = seed[i];
        crypto_sign_keypair(pk, sk, true);
        return {
          publicKey: pk,
          secretKey: sk
        };
      };
      nacl.sign.publicKeyLength = crypto_sign_PUBLICKEYBYTES;
      nacl.sign.secretKeyLength = crypto_sign_SECRETKEYBYTES;
      nacl.sign.seedLength = crypto_sign_SEEDBYTES;
      nacl.sign.signatureLength = crypto_sign_BYTES;
      nacl.hash = function(msg) {
        checkArrayTypes(msg);
        var h = new Uint8Array(crypto_hash_BYTES);
        crypto_hash(h, msg, msg.length);
        return h;
      };
      nacl.hash.hashLength = crypto_hash_BYTES;
      nacl.verify = function(x, y) {
        checkArrayTypes(x, y);
        if (x.length === 0 || y.length === 0) return false;
        if (x.length !== y.length) return false;
        return vn(x, 0, y, 0, x.length) === 0 ? true : false;
      };
      nacl.setPRNG = function(fn) {
        randombytes = fn;
      };
      (function() {
        var crypto5 = typeof self !== "undefined" ? self.crypto || self.msCrypto : null;
        if (crypto5 && crypto5.getRandomValues) {
          var QUOTA = 65536;
          nacl.setPRNG(function(x, n) {
            var i, v = new Uint8Array(n);
            for (i = 0; i < n; i += QUOTA) {
              crypto5.getRandomValues(v.subarray(i, i + Math.min(n - i, QUOTA)));
            }
            for (i = 0; i < n; i++) x[i] = v[i];
            cleanup(v);
          });
        } else if (typeof require !== "undefined") {
          crypto5 = require("crypto");
          if (crypto5 && crypto5.randomBytes) {
            nacl.setPRNG(function(x, n) {
              var i, v = crypto5.randomBytes(n);
              for (i = 0; i < n; i++) x[i] = v[i];
              cleanup(v);
            });
          }
        }
      })();
    })(typeof module2 !== "undefined" && module2.exports ? module2.exports : self.nacl = self.nacl || {});
  }
});

// node_modules/bcrypt-pbkdf/index.js
var require_bcrypt_pbkdf = __commonJS({
  "node_modules/bcrypt-pbkdf/index.js"(exports2, module2) {
    "use strict";
    var crypto_hash_sha512 = require_nacl_fast().lowlevel.crypto_hash;
    var BLF_J = 0;
    var Blowfish = /* @__PURE__ */ __name(function() {
      this.S = [
        new Uint32Array([
          3509652390,
          2564797868,
          805139163,
          3491422135,
          3101798381,
          1780907670,
          3128725573,
          4046225305,
          614570311,
          3012652279,
          134345442,
          2240740374,
          1667834072,
          1901547113,
          2757295779,
          4103290238,
          227898511,
          1921955416,
          1904987480,
          2182433518,
          2069144605,
          3260701109,
          2620446009,
          720527379,
          3318853667,
          677414384,
          3393288472,
          3101374703,
          2390351024,
          1614419982,
          1822297739,
          2954791486,
          3608508353,
          3174124327,
          2024746970,
          1432378464,
          3864339955,
          2857741204,
          1464375394,
          1676153920,
          1439316330,
          715854006,
          3033291828,
          289532110,
          2706671279,
          2087905683,
          3018724369,
          1668267050,
          732546397,
          1947742710,
          3462151702,
          2609353502,
          2950085171,
          1814351708,
          2050118529,
          680887927,
          999245976,
          1800124847,
          3300911131,
          1713906067,
          1641548236,
          4213287313,
          1216130144,
          1575780402,
          4018429277,
          3917837745,
          3693486850,
          3949271944,
          596196993,
          3549867205,
          258830323,
          2213823033,
          772490370,
          2760122372,
          1774776394,
          2652871518,
          566650946,
          4142492826,
          1728879713,
          2882767088,
          1783734482,
          3629395816,
          2517608232,
          2874225571,
          1861159788,
          326777828,
          3124490320,
          2130389656,
          2716951837,
          967770486,
          1724537150,
          2185432712,
          2364442137,
          1164943284,
          2105845187,
          998989502,
          3765401048,
          2244026483,
          1075463327,
          1455516326,
          1322494562,
          910128902,
          469688178,
          1117454909,
          936433444,
          3490320968,
          3675253459,
          1240580251,
          122909385,
          2157517691,
          634681816,
          4142456567,
          3825094682,
          3061402683,
          2540495037,
          79693498,
          3249098678,
          1084186820,
          1583128258,
          426386531,
          1761308591,
          1047286709,
          322548459,
          995290223,
          1845252383,
          2603652396,
          3431023940,
          2942221577,
          3202600964,
          3727903485,
          1712269319,
          422464435,
          3234572375,
          1170764815,
          3523960633,
          3117677531,
          1434042557,
          442511882,
          3600875718,
          1076654713,
          1738483198,
          4213154764,
          2393238008,
          3677496056,
          1014306527,
          4251020053,
          793779912,
          2902807211,
          842905082,
          4246964064,
          1395751752,
          1040244610,
          2656851899,
          3396308128,
          445077038,
          3742853595,
          3577915638,
          679411651,
          2892444358,
          2354009459,
          1767581616,
          3150600392,
          3791627101,
          3102740896,
          284835224,
          4246832056,
          1258075500,
          768725851,
          2589189241,
          3069724005,
          3532540348,
          1274779536,
          3789419226,
          2764799539,
          1660621633,
          3471099624,
          4011903706,
          913787905,
          3497959166,
          737222580,
          2514213453,
          2928710040,
          3937242737,
          1804850592,
          3499020752,
          2949064160,
          2386320175,
          2390070455,
          2415321851,
          4061277028,
          2290661394,
          2416832540,
          1336762016,
          1754252060,
          3520065937,
          3014181293,
          791618072,
          3188594551,
          3933548030,
          2332172193,
          3852520463,
          3043980520,
          413987798,
          3465142937,
          3030929376,
          4245938359,
          2093235073,
          3534596313,
          375366246,
          2157278981,
          2479649556,
          555357303,
          3870105701,
          2008414854,
          3344188149,
          4221384143,
          3956125452,
          2067696032,
          3594591187,
          2921233993,
          2428461,
          544322398,
          577241275,
          1471733935,
          610547355,
          4027169054,
          1432588573,
          1507829418,
          2025931657,
          3646575487,
          545086370,
          48609733,
          2200306550,
          1653985193,
          298326376,
          1316178497,
          3007786442,
          2064951626,
          458293330,
          2589141269,
          3591329599,
          3164325604,
          727753846,
          2179363840,
          146436021,
          1461446943,
          4069977195,
          705550613,
          3059967265,
          3887724982,
          4281599278,
          3313849956,
          1404054877,
          2845806497,
          146425753,
          1854211946
        ]),
        new Uint32Array([
          1266315497,
          3048417604,
          3681880366,
          3289982499,
          290971e4,
          1235738493,
          2632868024,
          2414719590,
          3970600049,
          1771706367,
          1449415276,
          3266420449,
          422970021,
          1963543593,
          2690192192,
          3826793022,
          1062508698,
          1531092325,
          1804592342,
          2583117782,
          2714934279,
          4024971509,
          1294809318,
          4028980673,
          1289560198,
          2221992742,
          1669523910,
          35572830,
          157838143,
          1052438473,
          1016535060,
          1802137761,
          1753167236,
          1386275462,
          3080475397,
          2857371447,
          1040679964,
          2145300060,
          2390574316,
          1461121720,
          2956646967,
          4031777805,
          4028374788,
          33600511,
          2920084762,
          1018524850,
          629373528,
          3691585981,
          3515945977,
          2091462646,
          2486323059,
          586499841,
          988145025,
          935516892,
          3367335476,
          2599673255,
          2839830854,
          265290510,
          3972581182,
          2759138881,
          3795373465,
          1005194799,
          847297441,
          406762289,
          1314163512,
          1332590856,
          1866599683,
          4127851711,
          750260880,
          613907577,
          1450815602,
          3165620655,
          3734664991,
          3650291728,
          3012275730,
          3704569646,
          1427272223,
          778793252,
          1343938022,
          2676280711,
          2052605720,
          1946737175,
          3164576444,
          3914038668,
          3967478842,
          3682934266,
          1661551462,
          3294938066,
          4011595847,
          840292616,
          3712170807,
          616741398,
          312560963,
          711312465,
          1351876610,
          322626781,
          1910503582,
          271666773,
          2175563734,
          1594956187,
          70604529,
          3617834859,
          1007753275,
          1495573769,
          4069517037,
          2549218298,
          2663038764,
          504708206,
          2263041392,
          3941167025,
          2249088522,
          1514023603,
          1998579484,
          1312622330,
          694541497,
          2582060303,
          2151582166,
          1382467621,
          776784248,
          2618340202,
          3323268794,
          2497899128,
          2784771155,
          503983604,
          4076293799,
          907881277,
          423175695,
          432175456,
          1378068232,
          4145222326,
          3954048622,
          3938656102,
          3820766613,
          2793130115,
          2977904593,
          26017576,
          3274890735,
          3194772133,
          1700274565,
          1756076034,
          4006520079,
          3677328699,
          720338349,
          1533947780,
          354530856,
          688349552,
          3973924725,
          1637815568,
          332179504,
          3949051286,
          53804574,
          2852348879,
          3044236432,
          1282449977,
          3583942155,
          3416972820,
          4006381244,
          1617046695,
          2628476075,
          3002303598,
          1686838959,
          431878346,
          2686675385,
          1700445008,
          1080580658,
          1009431731,
          832498133,
          3223435511,
          2605976345,
          2271191193,
          2516031870,
          1648197032,
          4164389018,
          2548247927,
          300782431,
          375919233,
          238389289,
          3353747414,
          2531188641,
          2019080857,
          1475708069,
          455242339,
          2609103871,
          448939670,
          3451063019,
          1395535956,
          2413381860,
          1841049896,
          1491858159,
          885456874,
          4264095073,
          4001119347,
          1565136089,
          3898914787,
          1108368660,
          540939232,
          1173283510,
          2745871338,
          3681308437,
          4207628240,
          3343053890,
          4016749493,
          1699691293,
          1103962373,
          3625875870,
          2256883143,
          3830138730,
          1031889488,
          3479347698,
          1535977030,
          4236805024,
          3251091107,
          2132092099,
          1774941330,
          1199868427,
          1452454533,
          157007616,
          2904115357,
          342012276,
          595725824,
          1480756522,
          206960106,
          497939518,
          591360097,
          863170706,
          2375253569,
          3596610801,
          1814182875,
          2094937945,
          3421402208,
          1082520231,
          3463918190,
          2785509508,
          435703966,
          3908032597,
          1641649973,
          2842273706,
          3305899714,
          1510255612,
          2148256476,
          2655287854,
          3276092548,
          4258621189,
          236887753,
          3681803219,
          274041037,
          1734335097,
          3815195456,
          3317970021,
          1899903192,
          1026095262,
          4050517792,
          356393447,
          2410691914,
          3873677099,
          3682840055
        ]),
        new Uint32Array([
          3913112168,
          2491498743,
          4132185628,
          2489919796,
          1091903735,
          1979897079,
          3170134830,
          3567386728,
          3557303409,
          857797738,
          1136121015,
          1342202287,
          507115054,
          2535736646,
          337727348,
          3213592640,
          1301675037,
          2528481711,
          1895095763,
          1721773893,
          3216771564,
          62756741,
          2142006736,
          835421444,
          2531993523,
          1442658625,
          3659876326,
          2882144922,
          676362277,
          1392781812,
          170690266,
          3921047035,
          1759253602,
          3611846912,
          1745797284,
          664899054,
          1329594018,
          3901205900,
          3045908486,
          2062866102,
          2865634940,
          3543621612,
          3464012697,
          1080764994,
          553557557,
          3656615353,
          3996768171,
          991055499,
          499776247,
          1265440854,
          648242737,
          3940784050,
          980351604,
          3713745714,
          1749149687,
          3396870395,
          4211799374,
          3640570775,
          1161844396,
          3125318951,
          1431517754,
          545492359,
          4268468663,
          3499529547,
          1437099964,
          2702547544,
          3433638243,
          2581715763,
          2787789398,
          1060185593,
          1593081372,
          2418618748,
          4260947970,
          69676912,
          2159744348,
          86519011,
          2512459080,
          3838209314,
          1220612927,
          3339683548,
          133810670,
          1090789135,
          1078426020,
          1569222167,
          845107691,
          3583754449,
          4072456591,
          1091646820,
          628848692,
          1613405280,
          3757631651,
          526609435,
          236106946,
          48312990,
          2942717905,
          3402727701,
          1797494240,
          859738849,
          992217954,
          4005476642,
          2243076622,
          3870952857,
          3732016268,
          765654824,
          3490871365,
          2511836413,
          1685915746,
          3888969200,
          1414112111,
          2273134842,
          3281911079,
          4080962846,
          172450625,
          2569994100,
          980381355,
          4109958455,
          2819808352,
          2716589560,
          2568741196,
          3681446669,
          3329971472,
          1835478071,
          660984891,
          3704678404,
          4045999559,
          3422617507,
          3040415634,
          1762651403,
          1719377915,
          3470491036,
          2693910283,
          3642056355,
          3138596744,
          1364962596,
          2073328063,
          1983633131,
          926494387,
          3423689081,
          2150032023,
          4096667949,
          1749200295,
          3328846651,
          309677260,
          2016342300,
          1779581495,
          3079819751,
          111262694,
          1274766160,
          443224088,
          298511866,
          1025883608,
          3806446537,
          1145181785,
          168956806,
          3641502830,
          3584813610,
          1689216846,
          3666258015,
          3200248200,
          1692713982,
          2646376535,
          4042768518,
          1618508792,
          1610833997,
          3523052358,
          4130873264,
          2001055236,
          3610705100,
          2202168115,
          4028541809,
          2961195399,
          1006657119,
          2006996926,
          3186142756,
          1430667929,
          3210227297,
          1314452623,
          4074634658,
          4101304120,
          2273951170,
          1399257539,
          3367210612,
          3027628629,
          1190975929,
          2062231137,
          2333990788,
          2221543033,
          2438960610,
          1181637006,
          548689776,
          2362791313,
          3372408396,
          3104550113,
          3145860560,
          296247880,
          1970579870,
          3078560182,
          3769228297,
          1714227617,
          3291629107,
          3898220290,
          166772364,
          1251581989,
          493813264,
          448347421,
          195405023,
          2709975567,
          677966185,
          3703036547,
          1463355134,
          2715995803,
          1338867538,
          1343315457,
          2802222074,
          2684532164,
          233230375,
          2599980071,
          2000651841,
          3277868038,
          1638401717,
          4028070440,
          3237316320,
          6314154,
          819756386,
          300326615,
          590932579,
          1405279636,
          3267499572,
          3150704214,
          2428286686,
          3959192993,
          3461946742,
          1862657033,
          1266418056,
          963775037,
          2089974820,
          2263052895,
          1917689273,
          448879540,
          3550394620,
          3981727096,
          150775221,
          3627908307,
          1303187396,
          508620638,
          2975983352,
          2726630617,
          1817252668,
          1876281319,
          1457606340,
          908771278,
          3720792119,
          3617206836,
          2455994898,
          1729034894,
          1080033504
        ]),
        new Uint32Array([
          976866871,
          3556439503,
          2881648439,
          1522871579,
          1555064734,
          1336096578,
          3548522304,
          2579274686,
          3574697629,
          3205460757,
          3593280638,
          3338716283,
          3079412587,
          564236357,
          2993598910,
          1781952180,
          1464380207,
          3163844217,
          3332601554,
          1699332808,
          1393555694,
          1183702653,
          3581086237,
          1288719814,
          691649499,
          2847557200,
          2895455976,
          3193889540,
          2717570544,
          1781354906,
          1676643554,
          2592534050,
          3230253752,
          1126444790,
          2770207658,
          2633158820,
          2210423226,
          2615765581,
          2414155088,
          3127139286,
          673620729,
          2805611233,
          1269405062,
          4015350505,
          3341807571,
          4149409754,
          1057255273,
          2012875353,
          2162469141,
          2276492801,
          2601117357,
          993977747,
          3918593370,
          2654263191,
          753973209,
          36408145,
          2530585658,
          25011837,
          3520020182,
          2088578344,
          530523599,
          2918365339,
          1524020338,
          1518925132,
          3760827505,
          3759777254,
          1202760957,
          3985898139,
          3906192525,
          674977740,
          4174734889,
          2031300136,
          2019492241,
          3983892565,
          4153806404,
          3822280332,
          352677332,
          2297720250,
          60907813,
          90501309,
          3286998549,
          1016092578,
          2535922412,
          2839152426,
          457141659,
          509813237,
          4120667899,
          652014361,
          1966332200,
          2975202805,
          55981186,
          2327461051,
          676427537,
          3255491064,
          2882294119,
          3433927263,
          1307055953,
          942726286,
          933058658,
          2468411793,
          3933900994,
          4215176142,
          1361170020,
          2001714738,
          2830558078,
          3274259782,
          1222529897,
          1679025792,
          2729314320,
          3714953764,
          1770335741,
          151462246,
          3013232138,
          1682292957,
          1483529935,
          471910574,
          1539241949,
          458788160,
          3436315007,
          1807016891,
          3718408830,
          978976581,
          1043663428,
          3165965781,
          1927990952,
          4200891579,
          2372276910,
          3208408903,
          3533431907,
          1412390302,
          2931980059,
          4132332400,
          1947078029,
          3881505623,
          4168226417,
          2941484381,
          1077988104,
          1320477388,
          886195818,
          18198404,
          3786409e3,
          2509781533,
          112762804,
          3463356488,
          1866414978,
          891333506,
          18488651,
          661792760,
          1628790961,
          3885187036,
          3141171499,
          876946877,
          2693282273,
          1372485963,
          791857591,
          2686433993,
          3759982718,
          3167212022,
          3472953795,
          2716379847,
          445679433,
          3561995674,
          3504004811,
          3574258232,
          54117162,
          3331405415,
          2381918588,
          3769707343,
          4154350007,
          1140177722,
          4074052095,
          668550556,
          3214352940,
          367459370,
          261225585,
          2610173221,
          4209349473,
          3468074219,
          3265815641,
          314222801,
          3066103646,
          3808782860,
          282218597,
          3406013506,
          3773591054,
          379116347,
          1285071038,
          846784868,
          2669647154,
          3771962079,
          3550491691,
          2305946142,
          453669953,
          1268987020,
          3317592352,
          3279303384,
          3744833421,
          2610507566,
          3859509063,
          266596637,
          3847019092,
          517658769,
          3462560207,
          3443424879,
          370717030,
          4247526661,
          2224018117,
          4143653529,
          4112773975,
          2788324899,
          2477274417,
          1456262402,
          2901442914,
          1517677493,
          1846949527,
          2295493580,
          3734397586,
          2176403920,
          1280348187,
          1908823572,
          3871786941,
          846861322,
          1172426758,
          3287448474,
          3383383037,
          1655181056,
          3139813346,
          901632758,
          1897031941,
          2986607138,
          3066810236,
          3447102507,
          1393639104,
          373351379,
          950779232,
          625454576,
          3124240540,
          4148612726,
          2007998917,
          544563296,
          2244738638,
          2330496472,
          2058025392,
          1291430526,
          424198748,
          50039436,
          29584100,
          3605783033,
          2429876329,
          2791104160,
          1057563949,
          3255363231,
          3075367218,
          3463963227,
          1469046755,
          985887462
        ])
      ];
      this.P = new Uint32Array([
        608135816,
        2242054355,
        320440878,
        57701188,
        2752067618,
        698298832,
        137296536,
        3964562569,
        1160258022,
        953160567,
        3193202383,
        887688300,
        3232508343,
        3380367581,
        1065670069,
        3041331479,
        2450970073,
        2306472731
      ]);
    }, "Blowfish");
    function F(S, x8, i) {
      return (S[0][x8[i + 3]] + S[1][x8[i + 2]] ^ S[2][x8[i + 1]]) + S[3][x8[i]];
    }
    __name(F, "F");
    Blowfish.prototype.encipher = function(x, x8) {
      if (x8 === void 0) {
        x8 = new Uint8Array(x.buffer);
        if (x.byteOffset !== 0) x8 = x8.subarray(x.byteOffset);
      }
      x[0] ^= this.P[0];
      for (var i = 1; i < 16; i += 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i + 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[17];
      x[1] = t;
    };
    Blowfish.prototype.decipher = function(x) {
      var x8 = new Uint8Array(x.buffer);
      if (x.byteOffset !== 0) x8 = x8.subarray(x.byteOffset);
      x[0] ^= this.P[17];
      for (var i = 16; i > 0; i -= 2) {
        x[1] ^= F(this.S, x8, 0) ^ this.P[i];
        x[0] ^= F(this.S, x8, 4) ^ this.P[i - 1];
      }
      var t = x[0];
      x[0] = x[1] ^ this.P[0];
      x[1] = t;
    };
    function stream2word(data, databytes) {
      var i, temp = 0;
      for (i = 0; i < 4; i++, BLF_J++) {
        if (BLF_J >= databytes) BLF_J = 0;
        temp = temp << 8 | data[BLF_J];
      }
      return temp;
    }
    __name(stream2word, "stream2word");
    Blowfish.prototype.expand0state = function(key, keybytes) {
      var d = new Uint32Array(2), i, k;
      var d8 = new Uint8Array(d.buffer);
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      BLF_J = 0;
      for (i = 0; i < 18; i += 2) {
        this.encipher(d, d8);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          this.encipher(d, d8);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
    };
    Blowfish.prototype.expandstate = function(data, databytes, key, keybytes) {
      var d = new Uint32Array(2), i, k;
      for (i = 0, BLF_J = 0; i < 18; i++) {
        this.P[i] ^= stream2word(key, keybytes);
      }
      for (i = 0, BLF_J = 0; i < 18; i += 2) {
        d[0] ^= stream2word(data, databytes);
        d[1] ^= stream2word(data, databytes);
        this.encipher(d);
        this.P[i] = d[0];
        this.P[i + 1] = d[1];
      }
      for (i = 0; i < 4; i++) {
        for (k = 0; k < 256; k += 2) {
          d[0] ^= stream2word(data, databytes);
          d[1] ^= stream2word(data, databytes);
          this.encipher(d);
          this.S[i][k] = d[0];
          this.S[i][k + 1] = d[1];
        }
      }
      BLF_J = 0;
    };
    Blowfish.prototype.enc = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.encipher(data.subarray(i * 2));
      }
    };
    Blowfish.prototype.dec = function(data, blocks) {
      for (var i = 0; i < blocks; i++) {
        this.decipher(data.subarray(i * 2));
      }
    };
    var BCRYPT_BLOCKS = 8;
    var BCRYPT_HASHSIZE = 32;
    function bcrypt_hash(sha2pass, sha2salt, out) {
      var state = new Blowfish(), cdata = new Uint32Array(BCRYPT_BLOCKS), i, ciphertext = new Uint8Array([
        79,
        120,
        121,
        99,
        104,
        114,
        111,
        109,
        97,
        116,
        105,
        99,
        66,
        108,
        111,
        119,
        102,
        105,
        115,
        104,
        83,
        119,
        97,
        116,
        68,
        121,
        110,
        97,
        109,
        105,
        116,
        101
      ]);
      state.expandstate(sha2salt, 64, sha2pass, 64);
      for (i = 0; i < 64; i++) {
        state.expand0state(sha2salt, 64);
        state.expand0state(sha2pass, 64);
      }
      for (i = 0; i < BCRYPT_BLOCKS; i++) cdata[i] = stream2word(ciphertext, ciphertext.byteLength);
      for (i = 0; i < 64; i++) state.enc(cdata, cdata.byteLength / 8);
      for (i = 0; i < BCRYPT_BLOCKS; i++) {
        out[4 * i + 3] = cdata[i] >>> 24;
        out[4 * i + 2] = cdata[i] >>> 16;
        out[4 * i + 1] = cdata[i] >>> 8;
        out[4 * i + 0] = cdata[i];
      }
    }
    __name(bcrypt_hash, "bcrypt_hash");
    function bcrypt_pbkdf(pass, passlen, salt, saltlen, key, keylen, rounds) {
      var sha2pass = new Uint8Array(64), sha2salt = new Uint8Array(64), out = new Uint8Array(BCRYPT_HASHSIZE), tmpout = new Uint8Array(BCRYPT_HASHSIZE), countsalt = new Uint8Array(saltlen + 4), i, j, amt, stride, dest, count, origkeylen = keylen;
      if (rounds < 1) return -1;
      if (passlen === 0 || saltlen === 0 || keylen === 0 || keylen > out.byteLength * out.byteLength || saltlen > 1 << 20) return -1;
      stride = Math.floor((keylen + out.byteLength - 1) / out.byteLength);
      amt = Math.floor((keylen + stride - 1) / stride);
      for (i = 0; i < saltlen; i++) countsalt[i] = salt[i];
      crypto_hash_sha512(sha2pass, pass, passlen);
      for (count = 1; keylen > 0; count++) {
        countsalt[saltlen + 0] = count >>> 24;
        countsalt[saltlen + 1] = count >>> 16;
        countsalt[saltlen + 2] = count >>> 8;
        countsalt[saltlen + 3] = count;
        crypto_hash_sha512(sha2salt, countsalt, saltlen + 4);
        bcrypt_hash(sha2pass, sha2salt, tmpout);
        for (i = out.byteLength; i--; ) out[i] = tmpout[i];
        for (i = 1; i < rounds; i++) {
          crypto_hash_sha512(sha2salt, tmpout, tmpout.byteLength);
          bcrypt_hash(sha2pass, sha2salt, tmpout);
          for (j = 0; j < out.byteLength; j++) out[j] ^= tmpout[j];
        }
        amt = Math.min(amt, keylen);
        for (i = 0; i < amt; i++) {
          dest = i * stride + (count - 1);
          if (dest >= origkeylen) break;
          key[dest] = out[i];
        }
        keylen -= i;
      }
      return 0;
    }
    __name(bcrypt_pbkdf, "bcrypt_pbkdf");
    module2.exports = {
      BLOCKS: BCRYPT_BLOCKS,
      HASHSIZE: BCRYPT_HASHSIZE,
      hash: bcrypt_hash,
      pbkdf: bcrypt_pbkdf
    };
  }
});

// node_modules/cpu-features/build/Release/cpufeatures.node
var cpufeatures_default;
var init_cpufeatures = __esm({
  "node_modules/cpu-features/build/Release/cpufeatures.node"() {
    cpufeatures_default = "./cpufeatures-MBDOXUZM.node";
  }
});

// node-file:/home/luizfelipelaviola/laviola/unipampa/malware-datalab/autodroid-watcher-client/node_modules/cpu-features/build/Release/cpufeatures.node
var require_cpufeatures = __commonJS({
  "node-file:/home/luizfelipelaviola/laviola/unipampa/malware-datalab/autodroid-watcher-client/node_modules/cpu-features/build/Release/cpufeatures.node"(exports2, module2) {
    "use strict";
    init_cpufeatures();
    try {
      module2.exports = require(cpufeatures_default);
    } catch {
    }
  }
});

// node_modules/cpu-features/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/cpu-features/lib/index.js"(exports2, module2) {
    "use strict";
    var binding = require_cpufeatures();
    module2.exports = binding.getCPUInfo;
  }
});

// node_modules/ssh2/lib/protocol/constants.js
var require_constants2 = __commonJS({
  "node_modules/ssh2/lib/protocol/constants.js"(exports2, module2) {
    "use strict";
    var crypto5 = require("crypto");
    var cpuInfo;
    try {
      cpuInfo = require_lib3()();
    } catch {
    }
    var { bindingAvailable, CIPHER_INFO, MAC_INFO } = require_crypto();
    var eddsaSupported = (() => {
      if (typeof crypto5.sign === "function" && typeof crypto5.verify === "function") {
        const key = "-----BEGIN PRIVATE KEY-----\r\nMC4CAQAwBQYDK2VwBCIEIHKj+sVa9WcD/q2DJUJaf43Kptc8xYuUQA4bOFj9vC8T\r\n-----END PRIVATE KEY-----";
        const data = Buffer.from("a");
        let sig;
        let verified;
        try {
          sig = crypto5.sign(null, data, key);
          verified = crypto5.verify(null, data, key, sig);
        } catch {
        }
        return Buffer.isBuffer(sig) && sig.length === 64 && verified === true;
      }
      return false;
    })();
    var curve25519Supported = typeof crypto5.diffieHellman === "function" && typeof crypto5.generateKeyPairSync === "function" && typeof crypto5.createPublicKey === "function";
    var DEFAULT_KEX = [
      // https://tools.ietf.org/html/rfc5656#section-10.1
      "ecdh-sha2-nistp256",
      "ecdh-sha2-nistp384",
      "ecdh-sha2-nistp521",
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha256",
      // https://tools.ietf.org/html/rfc8268
      "diffie-hellman-group14-sha256",
      "diffie-hellman-group15-sha512",
      "diffie-hellman-group16-sha512",
      "diffie-hellman-group17-sha512",
      "diffie-hellman-group18-sha512"
    ];
    if (curve25519Supported) {
      DEFAULT_KEX.unshift("curve25519-sha256");
      DEFAULT_KEX.unshift("curve25519-sha256@libssh.org");
    }
    var SUPPORTED_KEX = DEFAULT_KEX.concat([
      // https://tools.ietf.org/html/rfc4419#section-4
      "diffie-hellman-group-exchange-sha1",
      "diffie-hellman-group14-sha1",
      "diffie-hellman-group1-sha1"
    ]);
    var DEFAULT_SERVER_HOST_KEY = [
      "ecdsa-sha2-nistp256",
      "ecdsa-sha2-nistp384",
      "ecdsa-sha2-nistp521",
      "rsa-sha2-512",
      "rsa-sha2-256",
      "ssh-rsa"
    ];
    if (eddsaSupported) DEFAULT_SERVER_HOST_KEY.unshift("ssh-ed25519");
    var SUPPORTED_SERVER_HOST_KEY = DEFAULT_SERVER_HOST_KEY.concat([
      "ssh-dss"
    ]);
    var canUseCipher = (() => {
      const ciphers = crypto5.getCiphers();
      return (name) => ciphers.includes(CIPHER_INFO[name].sslName);
    })();
    var DEFAULT_CIPHER = [
      // http://tools.ietf.org/html/rfc5647
      "aes128-gcm@openssh.com",
      "aes256-gcm@openssh.com",
      // http://tools.ietf.org/html/rfc4344#section-4
      "aes128-ctr",
      "aes192-ctr",
      "aes256-ctr"
    ];
    if (cpuInfo && cpuInfo.flags && !cpuInfo.flags.aes) {
      if (bindingAvailable) DEFAULT_CIPHER.unshift("chacha20-poly1305@openssh.com");
      else DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    } else if (bindingAvailable && cpuInfo && cpuInfo.arch === "x86") {
      DEFAULT_CIPHER.splice(4, 0, "chacha20-poly1305@openssh.com");
    } else {
      DEFAULT_CIPHER.push("chacha20-poly1305@openssh.com");
    }
    DEFAULT_CIPHER = DEFAULT_CIPHER.filter(canUseCipher);
    var SUPPORTED_CIPHER = DEFAULT_CIPHER.concat([
      "aes256-cbc",
      "aes192-cbc",
      "aes128-cbc",
      "blowfish-cbc",
      "3des-cbc",
      "aes128-gcm",
      "aes256-gcm",
      // http://tools.ietf.org/html/rfc4345#section-4:
      "arcfour256",
      "arcfour128",
      "cast128-cbc",
      "arcfour"
    ].filter(canUseCipher));
    var canUseMAC = (() => {
      const hashes = crypto5.getHashes();
      return (name) => hashes.includes(MAC_INFO[name].sslName);
    })();
    var DEFAULT_MAC = [
      "hmac-sha2-256-etm@openssh.com",
      "hmac-sha2-512-etm@openssh.com",
      "hmac-sha1-etm@openssh.com",
      "hmac-sha2-256",
      "hmac-sha2-512",
      "hmac-sha1"
    ].filter(canUseMAC);
    var SUPPORTED_MAC = DEFAULT_MAC.concat([
      "hmac-md5",
      "hmac-sha2-256-96",
      "hmac-sha2-512-96",
      "hmac-ripemd160",
      "hmac-sha1-96",
      "hmac-md5-96"
    ].filter(canUseMAC));
    var DEFAULT_COMPRESSION = [
      "none",
      "zlib@openssh.com",
      // compression/decompression does not start until after
      // successful user authentication
      "zlib"
    ];
    var SUPPORTED_COMPRESSION = DEFAULT_COMPRESSION.concat([]);
    var COMPAT = {
      BAD_DHGEX: 1 << 0,
      OLD_EXIT: 1 << 1,
      DYN_RPORT_BUG: 1 << 2,
      BUG_DHGEX_LARGE: 1 << 3,
      IMPLY_RSA_SHA2_SIGALGS: 1 << 4
    };
    module2.exports = {
      MESSAGE: {
        // Transport layer protocol -- generic (1-19)
        DISCONNECT: 1,
        IGNORE: 2,
        UNIMPLEMENTED: 3,
        DEBUG: 4,
        SERVICE_REQUEST: 5,
        SERVICE_ACCEPT: 6,
        EXT_INFO: 7,
        // Transport layer protocol -- algorithm negotiation (20-29)
        KEXINIT: 20,
        NEWKEYS: 21,
        // Transport layer protocol -- key exchange method-specific (30-49)
        KEXDH_INIT: 30,
        KEXDH_REPLY: 31,
        KEXDH_GEX_GROUP: 31,
        KEXDH_GEX_INIT: 32,
        KEXDH_GEX_REPLY: 33,
        KEXDH_GEX_REQUEST: 34,
        KEXECDH_INIT: 30,
        KEXECDH_REPLY: 31,
        // User auth protocol -- generic (50-59)
        USERAUTH_REQUEST: 50,
        USERAUTH_FAILURE: 51,
        USERAUTH_SUCCESS: 52,
        USERAUTH_BANNER: 53,
        // User auth protocol -- user auth method-specific (60-79)
        USERAUTH_PASSWD_CHANGEREQ: 60,
        USERAUTH_PK_OK: 60,
        USERAUTH_INFO_REQUEST: 60,
        USERAUTH_INFO_RESPONSE: 61,
        // Connection protocol -- generic (80-89)
        GLOBAL_REQUEST: 80,
        REQUEST_SUCCESS: 81,
        REQUEST_FAILURE: 82,
        // Connection protocol -- channel-related (90-127)
        CHANNEL_OPEN: 90,
        CHANNEL_OPEN_CONFIRMATION: 91,
        CHANNEL_OPEN_FAILURE: 92,
        CHANNEL_WINDOW_ADJUST: 93,
        CHANNEL_DATA: 94,
        CHANNEL_EXTENDED_DATA: 95,
        CHANNEL_EOF: 96,
        CHANNEL_CLOSE: 97,
        CHANNEL_REQUEST: 98,
        CHANNEL_SUCCESS: 99,
        CHANNEL_FAILURE: 100
      },
      DISCONNECT_REASON: {
        HOST_NOT_ALLOWED_TO_CONNECT: 1,
        PROTOCOL_ERROR: 2,
        KEY_EXCHANGE_FAILED: 3,
        RESERVED: 4,
        MAC_ERROR: 5,
        COMPRESSION_ERROR: 6,
        SERVICE_NOT_AVAILABLE: 7,
        PROTOCOL_VERSION_NOT_SUPPORTED: 8,
        HOST_KEY_NOT_VERIFIABLE: 9,
        CONNECTION_LOST: 10,
        BY_APPLICATION: 11,
        TOO_MANY_CONNECTIONS: 12,
        AUTH_CANCELED_BY_USER: 13,
        NO_MORE_AUTH_METHODS_AVAILABLE: 14,
        ILLEGAL_USER_NAME: 15
      },
      DISCONNECT_REASON_STR: void 0,
      CHANNEL_OPEN_FAILURE: {
        ADMINISTRATIVELY_PROHIBITED: 1,
        CONNECT_FAILED: 2,
        UNKNOWN_CHANNEL_TYPE: 3,
        RESOURCE_SHORTAGE: 4
      },
      TERMINAL_MODE: {
        TTY_OP_END: 0,
        VINTR: 1,
        //  other characters.  Not all of these characters are
        //  supported on all systems.
        VQUIT: 2,
        //  systems).
        VERASE: 3,
        VKILL: 4,
        VEOF: 5,
        //  terminal).
        VEOL: 6,
        //  return and/or linefeed.
        VEOL2: 7,
        VSTART: 8,
        VSTOP: 9,
        VSUSP: 10,
        VDSUSP: 11,
        VREPRINT: 12,
        VWERASE: 13,
        VLNEXT: 14,
        //  it is a special character
        VFLUSH: 15,
        VSWTCH: 16,
        VSTATUS: 17,
        //  etc).
        VDISCARD: 18,
        IGNPAR: 30,
        //  if this flag is FALSE, and 1 if it is TRUE.
        PARMRK: 31,
        INPCK: 32,
        ISTRIP: 33,
        INLCR: 34,
        IGNCR: 35,
        ICRNL: 36,
        IUCLC: 37,
        IXON: 38,
        IXANY: 39,
        IXOFF: 40,
        IMAXBEL: 41,
        ISIG: 50,
        ICANON: 51,
        XCASE: 52,
        //  preceding their lowercase equivalents with "\".
        ECHO: 53,
        ECHOE: 54,
        ECHOK: 55,
        ECHONL: 56,
        NOFLSH: 57,
        TOSTOP: 58,
        IEXTEN: 59,
        ECHOCTL: 60,
        ECHOKE: 61,
        PENDIN: 62,
        OPOST: 70,
        OLCUC: 71,
        ONLCR: 72,
        OCRNL: 73,
        ONOCR: 74,
        //  (output).
        ONLRET: 75,
        CS7: 90,
        CS8: 91,
        PARENB: 92,
        PARODD: 93,
        TTY_OP_ISPEED: 128,
        TTY_OP_OSPEED: 129
      },
      CHANNEL_EXTENDED_DATATYPE: {
        STDERR: 1
      },
      SIGNALS: [
        "ABRT",
        "ALRM",
        "FPE",
        "HUP",
        "ILL",
        "INT",
        "QUIT",
        "SEGV",
        "TERM",
        "USR1",
        "USR2",
        "KILL",
        "PIPE"
      ].reduce((cur, val) => ({
        ...cur,
        [val]: 1
      }), {}),
      COMPAT,
      COMPAT_CHECKS: [
        [
          "Cisco-1.25",
          COMPAT.BAD_DHGEX
        ],
        [
          /^Cisco-1[.]/,
          COMPAT.BUG_DHGEX_LARGE
        ],
        [
          /^[0-9.]+$/,
          COMPAT.OLD_EXIT
        ],
        [
          /^OpenSSH_5[.][0-9]+/,
          COMPAT.DYN_RPORT_BUG
        ],
        [
          /^OpenSSH_7[.]4/,
          COMPAT.IMPLY_RSA_SHA2_SIGALGS
        ]
      ],
      // KEX proposal-related
      DEFAULT_KEX,
      SUPPORTED_KEX,
      DEFAULT_SERVER_HOST_KEY,
      SUPPORTED_SERVER_HOST_KEY,
      DEFAULT_CIPHER,
      SUPPORTED_CIPHER,
      DEFAULT_MAC,
      SUPPORTED_MAC,
      DEFAULT_COMPRESSION,
      SUPPORTED_COMPRESSION,
      curve25519Supported,
      eddsaSupported
    };
    module2.exports.DISCONNECT_REASON_BY_VALUE = Array.from(Object.entries(module2.exports.DISCONNECT_REASON)).reduce((obj, [key, value2]) => ({
      ...obj,
      [value2]: key
    }), {});
  }
});

// node_modules/ssh2/lib/protocol/utils.js
var require_utils2 = __commonJS({
  "node_modules/ssh2/lib/protocol/utils.js"(exports2, module2) {
    "use strict";
    var Ber = require_lib2().Ber;
    var DISCONNECT_REASON;
    var FastBuffer = Buffer[Symbol.species];
    var TypedArrayFill = Object.getPrototypeOf(Uint8Array.prototype).fill;
    function readUInt32BE(buf, offset) {
      return buf[offset++] * 16777216 + buf[offset++] * 65536 + buf[offset++] * 256 + buf[offset];
    }
    __name(readUInt32BE, "readUInt32BE");
    function bufferCopy(src, dest, srcStart, srcEnd, destStart) {
      if (!destStart) destStart = 0;
      if (srcEnd > src.length) srcEnd = src.length;
      let nb = srcEnd - srcStart;
      const destLeft = dest.length - destStart;
      if (nb > destLeft) nb = destLeft;
      dest.set(new Uint8Array(src.buffer, src.byteOffset + srcStart, nb), destStart);
      return nb;
    }
    __name(bufferCopy, "bufferCopy");
    function bufferSlice(buf, start, end) {
      if (end === void 0) end = buf.length;
      return new FastBuffer(buf.buffer, buf.byteOffset + start, end - start);
    }
    __name(bufferSlice, "bufferSlice");
    function makeBufferParser() {
      let pos = 0;
      let buffer;
      const self2 = {
        init: /* @__PURE__ */ __name((buf, start) => {
          buffer = buf;
          pos = typeof start === "number" ? start : 0;
        }, "init"),
        pos: /* @__PURE__ */ __name(() => pos, "pos"),
        length: /* @__PURE__ */ __name(() => buffer ? buffer.length : 0, "length"),
        avail: /* @__PURE__ */ __name(() => buffer && pos < buffer.length ? buffer.length - pos : 0, "avail"),
        clear: /* @__PURE__ */ __name(() => {
          buffer = void 0;
        }, "clear"),
        readUInt32BE: /* @__PURE__ */ __name(() => {
          if (!buffer || pos + 3 >= buffer.length) return;
          return buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];
        }, "readUInt32BE"),
        readUInt64BE: /* @__PURE__ */ __name((behavior) => {
          if (!buffer || pos + 7 >= buffer.length) return;
          switch (behavior) {
            case "always":
              return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);
            case "maybe":
              if (buffer[pos] > 31) return BigInt(`0x${buffer.hexSlice(pos, pos += 8)}`);
            // FALLTHROUGH
            default:
              return buffer[pos++] * 72057594037927940 + buffer[pos++] * 281474976710656 + buffer[pos++] * 1099511627776 + buffer[pos++] * 4294967296 + buffer[pos++] * 16777216 + buffer[pos++] * 65536 + buffer[pos++] * 256 + buffer[pos++];
          }
        }, "readUInt64BE"),
        skip: /* @__PURE__ */ __name((n) => {
          if (buffer && n > 0) pos += n;
        }, "skip"),
        skipString: /* @__PURE__ */ __name(() => {
          const len = self2.readUInt32BE();
          if (len === void 0) return;
          pos += len;
          return pos <= buffer.length ? len : void 0;
        }, "skipString"),
        readByte: /* @__PURE__ */ __name(() => {
          if (buffer && pos < buffer.length) return buffer[pos++];
        }, "readByte"),
        readBool: /* @__PURE__ */ __name(() => {
          if (buffer && pos < buffer.length) return !!buffer[pos++];
        }, "readBool"),
        readList: /* @__PURE__ */ __name(() => {
          const list = self2.readString(true);
          if (list === void 0) return;
          return list ? list.split(",") : [];
        }, "readList"),
        readString: /* @__PURE__ */ __name((dest, maxLen) => {
          if (typeof dest === "number") {
            maxLen = dest;
            dest = void 0;
          }
          const len = self2.readUInt32BE();
          if (len === void 0) return;
          if (buffer.length - pos < len || typeof maxLen === "number" && len > maxLen) {
            return;
          }
          if (dest) {
            if (Buffer.isBuffer(dest)) return bufferCopy(buffer, dest, pos, pos += len);
            return buffer.utf8Slice(pos, pos += len);
          }
          return bufferSlice(buffer, pos, pos += len);
        }, "readString"),
        readRaw: /* @__PURE__ */ __name((len) => {
          if (!buffer) return;
          if (typeof len !== "number") return bufferSlice(buffer, pos, pos += buffer.length - pos);
          if (buffer.length - pos >= len) return bufferSlice(buffer, pos, pos += len);
        }, "readRaw")
      };
      return self2;
    }
    __name(makeBufferParser, "makeBufferParser");
    function makeError(msg, level, fatal) {
      const err = new Error(msg);
      if (typeof level === "boolean") {
        fatal = level;
        err.level = "protocol";
      } else {
        err.level = level || "protocol";
      }
      err.fatal = !!fatal;
      return err;
    }
    __name(makeError, "makeError");
    function writeUInt32BE(buf, value2, offset) {
      buf[offset++] = value2 >>> 24;
      buf[offset++] = value2 >>> 16;
      buf[offset++] = value2 >>> 8;
      buf[offset++] = value2;
      return offset;
    }
    __name(writeUInt32BE, "writeUInt32BE");
    var utilBufferParser = makeBufferParser();
    module2.exports = {
      bufferCopy,
      bufferSlice,
      FastBuffer,
      bufferFill: /* @__PURE__ */ __name((buf, value2, start, end) => {
        return TypedArrayFill.call(buf, value2, start, end);
      }, "bufferFill"),
      makeError,
      doFatalError: /* @__PURE__ */ __name((protocol4, msg, level, reason) => {
        let err;
        if (DISCONNECT_REASON === void 0) ({ DISCONNECT_REASON } = require_constants2());
        if (msg instanceof Error) {
          err = msg;
          if (typeof level !== "number") reason = DISCONNECT_REASON.PROTOCOL_ERROR;
          else reason = level;
        } else {
          err = makeError(msg, level, true);
        }
        if (typeof reason !== "number") reason = DISCONNECT_REASON.PROTOCOL_ERROR;
        protocol4.disconnect(reason);
        protocol4._destruct();
        protocol4._onError(err);
        return Infinity;
      }, "doFatalError"),
      readUInt32BE,
      writeUInt32BE,
      writeUInt32LE: /* @__PURE__ */ __name((buf, value2, offset) => {
        buf[offset++] = value2;
        buf[offset++] = value2 >>> 8;
        buf[offset++] = value2 >>> 16;
        buf[offset++] = value2 >>> 24;
        return offset;
      }, "writeUInt32LE"),
      makeBufferParser,
      bufferParser: makeBufferParser(),
      readString: /* @__PURE__ */ __name((buffer, start, dest, maxLen) => {
        if (typeof dest === "number") {
          maxLen = dest;
          dest = void 0;
        }
        if (start === void 0) start = 0;
        const left2 = buffer.length - start;
        if (start < 0 || start >= buffer.length || left2 < 4) return;
        const len = readUInt32BE(buffer, start);
        if (left2 < 4 + len || typeof maxLen === "number" && len > maxLen) return;
        start += 4;
        const end = start + len;
        buffer._pos = end;
        if (dest) {
          if (Buffer.isBuffer(dest)) return bufferCopy(buffer, dest, start, end);
          return buffer.utf8Slice(start, end);
        }
        return bufferSlice(buffer, start, end);
      }, "readString"),
      sigSSHToASN1: /* @__PURE__ */ __name((sig, type) => {
        switch (type) {
          case "ssh-dss": {
            if (sig.length > 40) return sig;
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            let r = sig.slice(0, 20);
            let s = sig.slice(20);
            if (r[0] & 128) {
              const rNew = Buffer.allocUnsafe(21);
              rNew[0] = 0;
              r.copy(rNew, 1);
              r = rNew;
            } else if (r[0] === 0 && !(r[1] & 128)) {
              r = r.slice(1);
            }
            if (s[0] & 128) {
              const sNew = Buffer.allocUnsafe(21);
              sNew[0] = 0;
              s.copy(sNew, 1);
              s = sNew;
            } else if (s[0] === 0 && !(s[1] & 128)) {
              s = s.slice(1);
            }
            asnWriter.writeBuffer(r, Ber.Integer);
            asnWriter.writeBuffer(s, Ber.Integer);
            asnWriter.endSequence();
            return asnWriter.buffer;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            utilBufferParser.init(sig, 0);
            const r = utilBufferParser.readString();
            const s = utilBufferParser.readString();
            utilBufferParser.clear();
            if (r === void 0 || s === void 0) return;
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            asnWriter.writeBuffer(r, Ber.Integer);
            asnWriter.writeBuffer(s, Ber.Integer);
            asnWriter.endSequence();
            return asnWriter.buffer;
          }
          default:
            return sig;
        }
      }, "sigSSHToASN1"),
      convertSignature: /* @__PURE__ */ __name((signature, keyType) => {
        switch (keyType) {
          case "ssh-dss": {
            if (signature.length <= 40) return signature;
            const asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            let r = asnReader.readString(Ber.Integer, true);
            let s = asnReader.readString(Ber.Integer, true);
            let rOffset = 0;
            let sOffset = 0;
            if (r.length < 20) {
              const rNew = Buffer.allocUnsafe(20);
              rNew.set(r, 1);
              r = rNew;
              r[0] = 0;
            }
            if (s.length < 20) {
              const sNew = Buffer.allocUnsafe(20);
              sNew.set(s, 1);
              s = sNew;
              s[0] = 0;
            }
            if (r.length > 20 && r[0] === 0) rOffset = 1;
            if (s.length > 20 && s[0] === 0) sOffset = 1;
            const newSig = Buffer.allocUnsafe(r.length - rOffset + (s.length - sOffset));
            bufferCopy(r, newSig, rOffset, r.length, 0);
            bufferCopy(s, newSig, sOffset, s.length, r.length - rOffset);
            return newSig;
          }
          case "ecdsa-sha2-nistp256":
          case "ecdsa-sha2-nistp384":
          case "ecdsa-sha2-nistp521": {
            if (signature[0] === 0) return signature;
            const asnReader = new Ber.Reader(signature);
            asnReader.readSequence();
            const r = asnReader.readString(Ber.Integer, true);
            const s = asnReader.readString(Ber.Integer, true);
            if (r === null || s === null) return;
            const newSig = Buffer.allocUnsafe(4 + r.length + 4 + s.length);
            writeUInt32BE(newSig, r.length, 0);
            newSig.set(r, 4);
            writeUInt32BE(newSig, s.length, 4 + r.length);
            newSig.set(s, 4 + 4 + r.length);
            return newSig;
          }
        }
        return signature;
      }, "convertSignature"),
      sendPacket: /* @__PURE__ */ __name((proto, packet, bypass) => {
        if (!bypass && proto._kexinit !== void 0) {
          if (proto._queue === void 0) proto._queue = [];
          proto._queue.push(packet);
          proto._debug && proto._debug("Outbound: ... packet queued");
          return false;
        }
        proto._cipher.encrypt(packet);
        return true;
      }, "sendPacket")
    };
  }
});

// node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node
var sshcrypto_default;
var init_sshcrypto = __esm({
  "node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node"() {
    sshcrypto_default = "./sshcrypto-FWLYVZDT.node";
  }
});

// node-file:/home/luizfelipelaviola/laviola/unipampa/malware-datalab/autodroid-watcher-client/node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node
var require_sshcrypto = __commonJS({
  "node-file:/home/luizfelipelaviola/laviola/unipampa/malware-datalab/autodroid-watcher-client/node_modules/ssh2/lib/protocol/crypto/build/Release/sshcrypto.node"(exports2, module2) {
    "use strict";
    init_sshcrypto();
    try {
      module2.exports = require(sshcrypto_default);
    } catch {
    }
  }
});

// node_modules/ssh2/lib/protocol/crypto/poly1305.js
var require_poly1305 = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto/poly1305.js"(exports2, module2) {
    "use strict";
    var createPoly1305 = function() {
      var _scriptDir = typeof document !== "undefined" && document.currentScript ? document.currentScript.src : void 0;
      if (typeof __filename !== "undefined") _scriptDir = _scriptDir || __filename;
      return function(createPoly13052) {
        createPoly13052 = createPoly13052 || {};
        var b;
        b || (b = typeof createPoly13052 !== "undefined" ? createPoly13052 : {});
        var q, r;
        b.ready = new Promise(function(a, c) {
          q = a;
          r = c;
        });
        var u = {}, w;
        for (w in b) b.hasOwnProperty(w) && (u[w] = b[w]);
        var x = "object" === typeof window, y = "function" === typeof importScripts, z2 = "object" === typeof process && "object" === typeof process.versions && "string" === typeof process.versions.node, B = "", C, D, E, F, G;
        if (z2) B = y ? require("path").dirname(B) + "/" : __dirname + "/", C = /* @__PURE__ */ __name(function(a, c) {
          var d = H(a);
          if (d) return c ? d : d.toString();
          F || (F = require("fs"));
          G || (G = require("path"));
          a = G.normalize(a);
          return F.readFileSync(a, c ? null : "utf8");
        }, "C"), E = /* @__PURE__ */ __name(function(a) {
          a = C(a, true);
          a.buffer || (a = new Uint8Array(a));
          assert(a.buffer);
          return a;
        }, "E"), D = /* @__PURE__ */ __name(function(a, c, d) {
          var e = H(a);
          e && c(e);
          F || (F = require("fs"));
          G || (G = require("path"));
          a = G.normalize(a);
          F.readFile(a, function(f, l) {
            f ? d(f) : c(l.buffer);
          });
        }, "D"), 1 < process.argv.length && process.argv[1].replace(/\\/g, "/"), process.argv.slice(2), b.inspect = function() {
          return "[Emscripten Module object]";
        };
        else if (x || y) y ? B = self.location.href : "undefined" !== typeof document && document.currentScript && (B = document.currentScript.src), _scriptDir && (B = _scriptDir), 0 !== B.indexOf("blob:") ? B = B.substr(0, B.lastIndexOf("/") + 1) : B = "", C = /* @__PURE__ */ __name(function(a) {
          try {
            var c = new XMLHttpRequest();
            c.open("GET", a, false);
            c.send(null);
            return c.responseText;
          } catch (f) {
            if (a = H(a)) {
              c = [];
              for (var d = 0; d < a.length; d++) {
                var e = a[d];
                255 < e && (ba && assert(false, "Character code " + e + " (" + String.fromCharCode(e) + ")  at offset " + d + " not in 0x00-0xFF."), e &= 255);
                c.push(String.fromCharCode(e));
              }
              return c.join("");
            }
            throw f;
          }
        }, "C"), y && (E = /* @__PURE__ */ __name(function(a) {
          try {
            var c = new XMLHttpRequest();
            c.open("GET", a, false);
            c.responseType = "arraybuffer";
            c.send(null);
            return new Uint8Array(c.response);
          } catch (d) {
            if (a = H(a)) return a;
            throw d;
          }
        }, "E")), D = /* @__PURE__ */ __name(function(a, c, d) {
          var e = new XMLHttpRequest();
          e.open("GET", a, true);
          e.responseType = "arraybuffer";
          e.onload = function() {
            if (200 == e.status || 0 == e.status && e.response) c(e.response);
            else {
              var f = H(a);
              f ? c(f.buffer) : d();
            }
          };
          e.onerror = d;
          e.send(null);
        }, "D");
        b.print || console.log.bind(console);
        var I = b.printErr || console.warn.bind(console);
        for (w in u) u.hasOwnProperty(w) && (b[w] = u[w]);
        u = null;
        var J;
        b.wasmBinary && (J = b.wasmBinary);
        var noExitRuntime = b.noExitRuntime || true;
        "object" !== typeof WebAssembly && K("no native wasm support detected");
        var L, M = false;
        function assert(a, c) {
          a || K("Assertion failed: " + c);
        }
        __name(assert, "assert");
        function N(a) {
          var c = b["_" + a];
          assert(c, "Cannot call unknown function " + a + ", make sure it is exported");
          return c;
        }
        __name(N, "N");
        function ca(a, c, d, e) {
          var f = {
            string: /* @__PURE__ */ __name(function(g) {
              var p = 0;
              if (null !== g && void 0 !== g && 0 !== g) {
                var n = (g.length << 2) + 1;
                p = O(n);
                var k = p, h = P;
                if (0 < n) {
                  n = k + n - 1;
                  for (var v = 0; v < g.length; ++v) {
                    var m = g.charCodeAt(v);
                    if (55296 <= m && 57343 >= m) {
                      var oa = g.charCodeAt(++v);
                      m = 65536 + ((m & 1023) << 10) | oa & 1023;
                    }
                    if (127 >= m) {
                      if (k >= n) break;
                      h[k++] = m;
                    } else {
                      if (2047 >= m) {
                        if (k + 1 >= n) break;
                        h[k++] = 192 | m >> 6;
                      } else {
                        if (65535 >= m) {
                          if (k + 2 >= n) break;
                          h[k++] = 224 | m >> 12;
                        } else {
                          if (k + 3 >= n) break;
                          h[k++] = 240 | m >> 18;
                          h[k++] = 128 | m >> 12 & 63;
                        }
                        h[k++] = 128 | m >> 6 & 63;
                      }
                      h[k++] = 128 | m & 63;
                    }
                  }
                  h[k] = 0;
                }
              }
              return p;
            }, "string"),
            array: /* @__PURE__ */ __name(function(g) {
              var p = O(g.length);
              Q.set(g, p);
              return p;
            }, "array")
          }, l = N(a), A = [];
          a = 0;
          if (e) for (var t = 0; t < e.length; t++) {
            var aa = f[d[t]];
            aa ? (0 === a && (a = da()), A[t] = aa(e[t])) : A[t] = e[t];
          }
          d = l.apply(null, A);
          d = function(g) {
            if ("string" === c) if (g) {
              for (var p = P, n = g + NaN, k = g; p[k] && !(k >= n); ) ++k;
              if (16 < k - g && p.subarray && ea) g = ea.decode(p.subarray(g, k));
              else {
                for (n = ""; g < k; ) {
                  var h = p[g++];
                  if (h & 128) {
                    var v = p[g++] & 63;
                    if (192 == (h & 224)) n += String.fromCharCode((h & 31) << 6 | v);
                    else {
                      var m = p[g++] & 63;
                      h = 224 == (h & 240) ? (h & 15) << 12 | v << 6 | m : (h & 7) << 18 | v << 12 | m << 6 | p[g++] & 63;
                      65536 > h ? n += String.fromCharCode(h) : (h -= 65536, n += String.fromCharCode(55296 | h >> 10, 56320 | h & 1023));
                    }
                  } else n += String.fromCharCode(h);
                }
                g = n;
              }
            } else g = "";
            else g = "boolean" === c ? !!g : g;
            return g;
          }(d);
          0 !== a && fa(a);
          return d;
        }
        __name(ca, "ca");
        var ea = "undefined" !== typeof TextDecoder ? new TextDecoder("utf8") : void 0, ha, Q, P;
        function ia() {
          var a = L.buffer;
          ha = a;
          b.HEAP8 = Q = new Int8Array(a);
          b.HEAP16 = new Int16Array(a);
          b.HEAP32 = new Int32Array(a);
          b.HEAPU8 = P = new Uint8Array(a);
          b.HEAPU16 = new Uint16Array(a);
          b.HEAPU32 = new Uint32Array(a);
          b.HEAPF32 = new Float32Array(a);
          b.HEAPF64 = new Float64Array(a);
        }
        __name(ia, "ia");
        var R, ja = [], ka = [], la = [];
        function ma() {
          var a = b.preRun.shift();
          ja.unshift(a);
        }
        __name(ma, "ma");
        var S = 0, T = null, U = null;
        b.preloadedImages = {};
        b.preloadedAudios = {};
        function K(a) {
          if (b.onAbort) b.onAbort(a);
          I(a);
          M = true;
          a = new WebAssembly.RuntimeError("abort(" + a + "). Build with -s ASSERTIONS=1 for more info.");
          r(a);
          throw a;
        }
        __name(K, "K");
        var V = "data:application/octet-stream;base64,", W;
        W = "data:application/octet-stream;base64,AGFzbQEAAAABIAZgAX8Bf2ADf39/AGABfwBgAABgAAF/YAZ/f39/f38AAgcBAWEBYQAAAwsKAAEDAQAAAgQFAgQFAXABAQEFBwEBgAKAgAIGCQF/AUGAjMACCwclCQFiAgABYwADAWQACQFlAAgBZgAHAWcABgFoAAUBaQAKAWoBAAqGTQpPAQJ/QYAIKAIAIgEgAEEDakF8cSICaiEAAkAgAkEAIAAgAU0bDQAgAD8AQRB0SwRAIAAQAEUNAQtBgAggADYCACABDwtBhAhBMDYCAEF/C4wFAg5+Cn8gACgCJCEUIAAoAiAhFSAAKAIcIREgACgCGCESIAAoAhQhEyACQRBPBEAgAC0ATEVBGHQhFyAAKAIEIhZBBWytIQ8gACgCCCIYQQVsrSENIAAoAgwiGUEFbK0hCyAAKAIQIhpBBWytIQkgADUCACEIIBqtIRAgGa0hDiAYrSEMIBatIQoDQCASIAEtAAMiEiABLQAEQQh0ciABLQAFQRB0ciABLQAGIhZBGHRyQQJ2Qf///x9xaq0iAyAOfiABLwAAIAEtAAJBEHRyIBNqIBJBGHRBgICAGHFqrSIEIBB+fCARIAEtAAdBCHQgFnIgAS0ACEEQdHIgAS0ACSIRQRh0ckEEdkH///8fcWqtIgUgDH58IAEtAApBCHQgEXIgAS0AC0EQdHIgAS0ADEEYdHJBBnYgFWqtIgYgCn58IBQgF2ogAS8ADSABLQAPQRB0cmqtIgcgCH58IAMgDH4gBCAOfnwgBSAKfnwgBiAIfnwgByAJfnwgAyAKfiAEIAx+fCAFIAh+fCAGIAl+fCAHIAt+fCADIAh+IAQgCn58IAUgCX58IAYgC358IAcgDX58IAMgCX4gBCAIfnwgBSALfnwgBiANfnwgByAPfnwiA0IaiEL/////D4N8IgRCGohC/////w+DfCIFQhqIQv////8Pg3wiBkIaiEL/////D4N8IgdCGoinQQVsIAOnQf///x9xaiITQRp2IASnQf///x9xaiESIAWnQf///x9xIREgBqdB////H3EhFSAHp0H///8fcSEUIBNB////H3EhEyABQRBqIQEgAkEQayICQQ9LDQALCyAAIBQ2AiQgACAVNgIgIAAgETYCHCAAIBI2AhggACATNgIUCwMAAQu2BAEGfwJAIAAoAjgiBARAIABBPGohBQJAIAJBECAEayIDIAIgA0kbIgZFDQAgBkEDcSEHAkAgBkEBa0EDSQRAQQAhAwwBCyAGQXxxIQhBACEDA0AgBSADIARqaiABIANqLQAAOgAAIAUgA0EBciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0ECciIEIAAoAjhqaiABIARqLQAAOgAAIAUgA0EDciIEIAAoAjhqaiABIARqLQAAOgAAIANBBGohAyAAKAI4IQQgCEEEayIIDQALCyAHRQ0AA0AgBSADIARqaiABIANqLQAAOgAAIANBAWohAyAAKAI4IQQgB0EBayIHDQALCyAAIAQgBmoiAzYCOCADQRBJDQEgACAFQRAQAiAAQQA2AjggAiAGayECIAEgBmohAQsgAkEQTwRAIAAgASACQXBxIgMQAiACQQ9xIQIgASADaiEBCyACRQ0AIAJBA3EhBCAAQTxqIQVBACEDIAJBAWtBA08EQCACQXxxIQcDQCAFIAAoAjggA2pqIAEgA2otAAA6AAAgBSADQQFyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQJyIgYgACgCOGpqIAEgBmotAAA6AAAgBSADQQNyIgYgACgCOGpqIAEgBmotAAA6AAAgA0EEaiEDIAdBBGsiBw0ACwsgBARAA0AgBSAAKAI4IANqaiABIANqLQAAOgAAIANBAWohAyAEQQFrIgQNAAsLIAAgACgCOCACajYCOAsLoS0BDH8jAEEQayIMJAACQAJAAkACQAJAAkACQAJAAkACQAJAAkAgAEH0AU0EQEGICCgCACIFQRAgAEELakF4cSAAQQtJGyIIQQN2IgJ2IgFBA3EEQCABQX9zQQFxIAJqIgNBA3QiAUG4CGooAgAiBEEIaiEAAkAgBCgCCCICIAFBsAhqIgFGBEBBiAggBUF+IAN3cTYCAAwBCyACIAE2AgwgASACNgIICyAEIANBA3QiAUEDcjYCBCABIARqIgEgASgCBEEBcjYCBAwNCyAIQZAIKAIAIgpNDQEgAQRAAkBBAiACdCIAQQAgAGtyIAEgAnRxIgBBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2aiIDQQN0IgBBuAhqKAIAIgQoAggiASAAQbAIaiIARgRAQYgIIAVBfiADd3EiBTYCAAwBCyABIAA2AgwgACABNgIICyAEQQhqIQAgBCAIQQNyNgIEIAQgCGoiAiADQQN0IgEgCGsiA0EBcjYCBCABIARqIAM2AgAgCgRAIApBA3YiAUEDdEGwCGohB0GcCCgCACEEAn8gBUEBIAF0IgFxRQRAQYgIIAEgBXI2AgAgBwwBCyAHKAIICyEBIAcgBDYCCCABIAQ2AgwgBCAHNgIMIAQgATYCCAtBnAggAjYCAEGQCCADNgIADA0LQYwIKAIAIgZFDQEgBkEAIAZrcUEBayIAIABBDHZBEHEiAnYiAUEFdkEIcSIAIAJyIAEgAHYiAUECdkEEcSIAciABIAB2IgFBAXZBAnEiAHIgASAAdiIBQQF2QQFxIgByIAEgAHZqQQJ0QbgKaigCACIBKAIEQXhxIAhrIQMgASECA0ACQCACKAIQIgBFBEAgAigCFCIARQ0BCyAAKAIEQXhxIAhrIgIgAyACIANJIgIbIQMgACABIAIbIQEgACECDAELCyABIAhqIgkgAU0NAiABKAIYIQsgASABKAIMIgRHBEAgASgCCCIAQZgIKAIASRogACAENgIMIAQgADYCCAwMCyABQRRqIgIoAgAiAEUEQCABKAIQIgBFDQQgAUEQaiECCwNAIAIhByAAIgRBFGoiAigCACIADQAgBEEQaiECIAQoAhAiAA0ACyAHQQA2AgAMCwtBfyEIIABBv39LDQAgAEELaiIAQXhxIQhBjAgoAgAiCUUNAEEAIAhrIQMCQAJAAkACf0EAIAhBgAJJDQAaQR8gCEH///8HSw0AGiAAQQh2IgAgAEGA/j9qQRB2QQhxIgJ0IgAgAEGA4B9qQRB2QQRxIgF0IgAgAEGAgA9qQRB2QQJxIgB0QQ92IAEgAnIgAHJrIgBBAXQgCCAAQRVqdkEBcXJBHGoLIgVBAnRBuApqKAIAIgJFBEBBACEADAELQQAhACAIQQBBGSAFQQF2ayAFQR9GG3QhAQNAAkAgAigCBEF4cSAIayIHIANPDQAgAiEEIAciAw0AQQAhAyACIQAMAwsgACACKAIUIgcgByACIAFBHXZBBHFqKAIQIgJGGyAAIAcbIQAgAUEBdCEBIAINAAsLIAAgBHJFBEBBACEEQQIgBXQiAEEAIABrciAJcSIARQ0DIABBACAAa3FBAWsiACAAQQx2QRBxIgJ2IgFBBXZBCHEiACACciABIAB2IgFBAnZBBHEiAHIgASAAdiIBQQF2QQJxIgByIAEgAHYiAUEBdkEBcSIAciABIAB2akECdEG4CmooAgAhAAsgAEUNAQsDQCAAKAIEQXhxIAhrIgEgA0khAiABIAMgAhshAyAAIAQgAhshBCAAKAIQIgEEfyABBSAAKAIUCyIADQALCyAERQ0AIANBkAgoAgAgCGtPDQAgBCAIaiIGIARNDQEgBCgCGCEFIAQgBCgCDCIBRwRAIAQoAggiAEGYCCgCAEkaIAAgATYCDCABIAA2AggMCgsgBEEUaiICKAIAIgBFBEAgBCgCECIARQ0EIARBEGohAgsDQCACIQcgACIBQRRqIgIoAgAiAA0AIAFBEGohAiABKAIQIgANAAsgB0EANgIADAkLIAhBkAgoAgAiAk0EQEGcCCgCACEDAkAgAiAIayIBQRBPBEBBkAggATYCAEGcCCADIAhqIgA2AgAgACABQQFyNgIEIAIgA2ogATYCACADIAhBA3I2AgQMAQtBnAhBADYCAEGQCEEANgIAIAMgAkEDcjYCBCACIANqIgAgACgCBEEBcjYCBAsgA0EIaiEADAsLIAhBlAgoAgAiBkkEQEGUCCAGIAhrIgE2AgBBoAhBoAgoAgAiAiAIaiIANgIAIAAgAUEBcjYCBCACIAhBA3I2AgQgAkEIaiEADAsLQQAhACAIQS9qIgkCf0HgCygCAARAQegLKAIADAELQewLQn83AgBB5AtCgKCAgICABDcCAEHgCyAMQQxqQXBxQdiq1aoFczYCAEH0C0EANgIAQcQLQQA2AgBBgCALIgFqIgVBACABayIHcSICIAhNDQpBwAsoAgAiBARAQbgLKAIAIgMgAmoiASADTQ0LIAEgBEsNCwtBxAstAABBBHENBQJAAkBBoAgoAgAiAwRAQcgLIQADQCADIAAoAgAiAU8EQCABIAAoAgRqIANLDQMLIAAoAggiAA0ACwtBABABIgFBf0YNBiACIQVB5AsoAgAiA0EBayIAIAFxBEAgAiABayAAIAFqQQAgA2txaiEFCyAFIAhNDQYgBUH+////B0sNBkHACygCACIEBEBBuAsoAgAiAyAFaiIAIANNDQcgACAESw0HCyAFEAEiACABRw0BDAgLIAUgBmsgB3EiBUH+////B0sNBSAFEAEiASAAKAIAIAAoAgRqRg0EIAEhAAsCQCAAQX9GDQAgCEEwaiAFTQ0AQegLKAIAIgEgCSAFa2pBACABa3EiAUH+////B0sEQCAAIQEMCAsgARABQX9HBEAgASAFaiEFIAAhAQwIC0EAIAVrEAEaDAULIAAiAUF/Rw0GDAQLAAtBACEEDAcLQQAhAQwFCyABQX9HDQILQcQLQcQLKAIAQQRyNgIACyACQf7///8HSw0BIAIQASEBQQAQASEAIAFBf0YNASAAQX9GDQEgACABTQ0BIAAgAWsiBSAIQShqTQ0BC0G4C0G4CygCACAFaiIANgIAQbwLKAIAIABJBEBBvAsgADYCAAsCQAJAAkBBoAgoAgAiBwRAQcgLIQADQCABIAAoAgAiAyAAKAIEIgJqRg0CIAAoAggiAA0ACwwCC0GYCCgCACIAQQAgACABTRtFBEBBmAggATYCAAtBACEAQcwLIAU2AgBByAsgATYCAEGoCEF/NgIAQawIQeALKAIANgIAQdQLQQA2AgADQCAAQQN0IgNBuAhqIANBsAhqIgI2AgAgA0G8CGogAjYCACAAQQFqIgBBIEcNAAtBlAggBUEoayIDQXggAWtBB3FBACABQQhqQQdxGyIAayICNgIAQaAIIAAgAWoiADYCACAAIAJBAXI2AgQgASADakEoNgIEQaQIQfALKAIANgIADAILIAAtAAxBCHENACADIAdLDQAgASAHTQ0AIAAgAiAFajYCBEGgCCAHQXggB2tBB3FBACAHQQhqQQdxGyIAaiICNgIAQZQIQZQIKAIAIAVqIgEgAGsiADYCACACIABBAXI2AgQgASAHakEoNgIEQaQIQfALKAIANgIADAELQZgIKAIAIAFLBEBBmAggATYCAAsgASAFaiECQcgLIQACQAJAAkACQAJAAkADQCACIAAoAgBHBEAgACgCCCIADQEMAgsLIAAtAAxBCHFFDQELQcgLIQADQCAHIAAoAgAiAk8EQCACIAAoAgRqIgQgB0sNAwsgACgCCCEADAALAAsgACABNgIAIAAgACgCBCAFajYCBCABQXggAWtBB3FBACABQQhqQQdxG2oiCSAIQQNyNgIEIAJBeCACa0EHcUEAIAJBCGpBB3EbaiIFIAggCWoiBmshAiAFIAdGBEBBoAggBjYCAEGUCEGUCCgCACACaiIANgIAIAYgAEEBcjYCBAwDCyAFQZwIKAIARgRAQZwIIAY2AgBBkAhBkAgoAgAgAmoiADYCACAGIABBAXI2AgQgACAGaiAANgIADAMLIAUoAgQiAEEDcUEBRgRAIABBeHEhBwJAIABB/wFNBEAgBSgCCCIDIABBA3YiAEEDdEGwCGpGGiADIAUoAgwiAUYEQEGICEGICCgCAEF+IAB3cTYCAAwCCyADIAE2AgwgASADNgIIDAELIAUoAhghCAJAIAUgBSgCDCIBRwRAIAUoAggiACABNgIMIAEgADYCCAwBCwJAIAVBFGoiACgCACIDDQAgBUEQaiIAKAIAIgMNAEEAIQEMAQsDQCAAIQQgAyIBQRRqIgAoAgAiAw0AIAFBEGohACABKAIQIgMNAAsgBEEANgIACyAIRQ0AAkAgBSAFKAIcIgNBAnRBuApqIgAoAgBGBEAgACABNgIAIAENAUGMCEGMCCgCAEF+IAN3cTYCAAwCCyAIQRBBFCAIKAIQIAVGG2ogATYCACABRQ0BCyABIAg2AhggBSgCECIABEAgASAANgIQIAAgATYCGAsgBSgCFCIARQ0AIAEgADYCFCAAIAE2AhgLIAUgB2ohBSACIAdqIQILIAUgBSgCBEF+cTYCBCAGIAJBAXI2AgQgAiAGaiACNgIAIAJB/wFNBEAgAkEDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwDC0EfIQAgAkH///8HTQRAIAJBCHYiACAAQYD+P2pBEHZBCHEiA3QiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASADciAAcmsiAEEBdCACIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQQCQEGMCCgCACIDQQEgAHQiAXFFBEBBjAggASADcjYCACAEIAY2AgAgBiAENgIYDAELIAJBAEEZIABBAXZrIABBH0YbdCEAIAQoAgAhAQNAIAEiAygCBEF4cSACRg0DIABBHXYhASAAQQF0IQAgAyABQQRxaiIEKAIQIgENAAsgBCAGNgIQIAYgAzYCGAsgBiAGNgIMIAYgBjYCCAwCC0GUCCAFQShrIgNBeCABa0EHcUEAIAFBCGpBB3EbIgBrIgI2AgBBoAggACABaiIANgIAIAAgAkEBcjYCBCABIANqQSg2AgRBpAhB8AsoAgA2AgAgByAEQScgBGtBB3FBACAEQSdrQQdxG2pBL2siACAAIAdBEGpJGyICQRs2AgQgAkHQCykCADcCECACQcgLKQIANwIIQdALIAJBCGo2AgBBzAsgBTYCAEHICyABNgIAQdQLQQA2AgAgAkEYaiEAA0AgAEEHNgIEIABBCGohASAAQQRqIQAgASAESQ0ACyACIAdGDQMgAiACKAIEQX5xNgIEIAcgAiAHayIEQQFyNgIEIAIgBDYCACAEQf8BTQRAIARBA3YiAEEDdEGwCGohAgJ/QYgIKAIAIgFBASAAdCIAcUUEQEGICCAAIAFyNgIAIAIMAQsgAigCCAshACACIAc2AgggACAHNgIMIAcgAjYCDCAHIAA2AggMBAtBHyEAIAdCADcCECAEQf///wdNBEAgBEEIdiIAIABBgP4/akEQdkEIcSICdCIAIABBgOAfakEQdkEEcSIBdCIAIABBgIAPakEQdkECcSIAdEEPdiABIAJyIAByayIAQQF0IAQgAEEVanZBAXFyQRxqIQALIAcgADYCHCAAQQJ0QbgKaiEDAkBBjAgoAgAiAkEBIAB0IgFxRQRAQYwIIAEgAnI2AgAgAyAHNgIAIAcgAzYCGAwBCyAEQQBBGSAAQQF2ayAAQR9GG3QhACADKAIAIQEDQCABIgIoAgRBeHEgBEYNBCAAQR12IQEgAEEBdCEAIAIgAUEEcWoiAygCECIBDQALIAMgBzYCECAHIAI2AhgLIAcgBzYCDCAHIAc2AggMAwsgAygCCCIAIAY2AgwgAyAGNgIIIAZBADYCGCAGIAM2AgwgBiAANgIICyAJQQhqIQAMBQsgAigCCCIAIAc2AgwgAiAHNgIIIAdBADYCGCAHIAI2AgwgByAANgIIC0GUCCgCACIAIAhNDQBBlAggACAIayIBNgIAQaAIQaAIKAIAIgIgCGoiADYCACAAIAFBAXI2AgQgAiAIQQNyNgIEIAJBCGohAAwDC0GECEEwNgIAQQAhAAwCCwJAIAVFDQACQCAEKAIcIgJBAnRBuApqIgAoAgAgBEYEQCAAIAE2AgAgAQ0BQYwIIAlBfiACd3EiCTYCAAwCCyAFQRBBFCAFKAIQIARGG2ogATYCACABRQ0BCyABIAU2AhggBCgCECIABEAgASAANgIQIAAgATYCGAsgBCgCFCIARQ0AIAEgADYCFCAAIAE2AhgLAkAgA0EPTQRAIAQgAyAIaiIAQQNyNgIEIAAgBGoiACAAKAIEQQFyNgIEDAELIAQgCEEDcjYCBCAGIANBAXI2AgQgAyAGaiADNgIAIANB/wFNBEAgA0EDdiIAQQN0QbAIaiECAn9BiAgoAgAiAUEBIAB0IgBxRQRAQYgIIAAgAXI2AgAgAgwBCyACKAIICyEAIAIgBjYCCCAAIAY2AgwgBiACNgIMIAYgADYCCAwBC0EfIQAgA0H///8HTQRAIANBCHYiACAAQYD+P2pBEHZBCHEiAnQiACAAQYDgH2pBEHZBBHEiAXQiACAAQYCAD2pBEHZBAnEiAHRBD3YgASACciAAcmsiAEEBdCADIABBFWp2QQFxckEcaiEACyAGIAA2AhwgBkIANwIQIABBAnRBuApqIQICQAJAIAlBASAAdCIBcUUEQEGMCCABIAlyNgIAIAIgBjYCACAGIAI2AhgMAQsgA0EAQRkgAEEBdmsgAEEfRht0IQAgAigCACEIA0AgCCIBKAIEQXhxIANGDQIgAEEddiECIABBAXQhACABIAJBBHFqIgIoAhAiCA0ACyACIAY2AhAgBiABNgIYCyAGIAY2AgwgBiAGNgIIDAELIAEoAggiACAGNgIMIAEgBjYCCCAGQQA2AhggBiABNgIMIAYgADYCCAsgBEEIaiEADAELAkAgC0UNAAJAIAEoAhwiAkECdEG4CmoiACgCACABRgRAIAAgBDYCACAEDQFBjAggBkF+IAJ3cTYCAAwCCyALQRBBFCALKAIQIAFGG2ogBDYCACAERQ0BCyAEIAs2AhggASgCECIABEAgBCAANgIQIAAgBDYCGAsgASgCFCIARQ0AIAQgADYCFCAAIAQ2AhgLAkAgA0EPTQRAIAEgAyAIaiIAQQNyNgIEIAAgAWoiACAAKAIEQQFyNgIEDAELIAEgCEEDcjYCBCAJIANBAXI2AgQgAyAJaiADNgIAIAoEQCAKQQN2IgBBA3RBsAhqIQRBnAgoAgAhAgJ/QQEgAHQiACAFcUUEQEGICCAAIAVyNgIAIAQMAQsgBCgCCAshACAEIAI2AgggACACNgIMIAIgBDYCDCACIAA2AggLQZwIIAk2AgBBkAggAzYCAAsgAUEIaiEACyAMQRBqJAAgAAsQACMAIABrQXBxIgAkACAACwYAIAAkAAsEACMAC4AJAgh/BH4jAEGQAWsiBiQAIAYgBS0AA0EYdEGAgIAYcSAFLwAAIAUtAAJBEHRycjYCACAGIAUoAANBAnZBg/7/H3E2AgQgBiAFKAAGQQR2Qf+B/x9xNgIIIAYgBSgACUEGdkH//8AfcTYCDCAFLwANIQggBS0ADyEJIAZCADcCFCAGQgA3AhwgBkEANgIkIAYgCCAJQRB0QYCAPHFyNgIQIAYgBSgAEDYCKCAGIAUoABQ2AiwgBiAFKAAYNgIwIAUoABwhBSAGQQA6AEwgBkEANgI4IAYgBTYCNCAGIAEgAhAEIAQEQCAGIAMgBBAECyAGKAI4IgEEQCAGQTxqIgIgAWpBAToAACABQQFqQQ9NBEAgASAGakE9aiEEAkBBDyABayIDRQ0AIAMgBGoiAUEBa0EAOgAAIARBADoAACADQQNJDQAgAUECa0EAOgAAIARBADoAASABQQNrQQA6AAAgBEEAOgACIANBB0kNACABQQRrQQA6AAAgBEEAOgADIANBCUkNACAEQQAgBGtBA3EiAWoiBEEANgIAIAQgAyABa0F8cSIBaiIDQQRrQQA2AgAgAUEJSQ0AIARBADYCCCAEQQA2AgQgA0EIa0EANgIAIANBDGtBADYCACABQRlJDQAgBEEANgIYIARBADYCFCAEQQA2AhAgBEEANgIMIANBEGtBADYCACADQRRrQQA2AgAgA0EYa0EANgIAIANBHGtBADYCACABIARBBHFBGHIiAWsiA0EgSQ0AIAEgBGohAQNAIAFCADcDGCABQgA3AxAgAUIANwMIIAFCADcDACABQSBqIQEgA0EgayIDQR9LDQALCwsgBkEBOgBMIAYgAkEQEAILIAY1AjQhECAGNQIwIREgBjUCLCEOIAAgBjUCKCAGKAIkIAYoAiAgBigCHCAGKAIYIgNBGnZqIgJBGnZqIgFBGnZqIgtBgICAYHIgAUH///8fcSINIAJB////H3EiCCAGKAIUIAtBGnZBBWxqIgFB////H3EiCUEFaiIFQRp2IANB////H3EgAUEadmoiA2oiAUEadmoiAkEadmoiBEEadmoiDEEfdSIHIANxIAEgDEEfdkEBayIDQf///x9xIgpxciIBQRp0IAUgCnEgByAJcXJyrXwiDzwAACAAIA9CGIg8AAMgACAPQhCIPAACIAAgD0IIiDwAASAAIA4gByAIcSACIApxciICQRR0IAFBBnZyrXwgD0IgiHwiDjwABCAAIA5CGIg8AAcgACAOQhCIPAAGIAAgDkIIiDwABSAAIBEgByANcSAEIApxciIBQQ50IAJBDHZyrXwgDkIgiHwiDjwACCAAIA5CGIg8AAsgACAOQhCIPAAKIAAgDkIIiDwACSAAIBAgAyAMcSAHIAtxckEIdCABQRJ2cq18IA5CIIh8Ig48AAwgACAOQhiIPAAPIAAgDkIQiDwADiAAIA5CCIg8AA0gBkIANwIwIAZCADcCKCAGQgA3AiAgBkIANwIYIAZCADcCECAGQgA3AgggBkIANwIAIAZBkAFqJAALpwwBB38CQCAARQ0AIABBCGsiAyAAQQRrKAIAIgFBeHEiAGohBQJAIAFBAXENACABQQNxRQ0BIAMgAygCACIBayIDQZgIKAIASQ0BIAAgAWohACADQZwIKAIARwRAIAFB/wFNBEAgAygCCCICIAFBA3YiBEEDdEGwCGpGGiACIAMoAgwiAUYEQEGICEGICCgCAEF+IAR3cTYCAAwDCyACIAE2AgwgASACNgIIDAILIAMoAhghBgJAIAMgAygCDCIBRwRAIAMoAggiAiABNgIMIAEgAjYCCAwBCwJAIANBFGoiAigCACIEDQAgA0EQaiICKAIAIgQNAEEAIQEMAQsDQCACIQcgBCIBQRRqIgIoAgAiBA0AIAFBEGohAiABKAIQIgQNAAsgB0EANgIACyAGRQ0BAkAgAyADKAIcIgJBAnRBuApqIgQoAgBGBEAgBCABNgIAIAENAUGMCEGMCCgCAEF+IAJ3cTYCAAwDCyAGQRBBFCAGKAIQIANGG2ogATYCACABRQ0CCyABIAY2AhggAygCECICBEAgASACNgIQIAIgATYCGAsgAygCFCICRQ0BIAEgAjYCFCACIAE2AhgMAQsgBSgCBCIBQQNxQQNHDQBBkAggADYCACAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAA8LIAMgBU8NACAFKAIEIgFBAXFFDQACQCABQQJxRQRAIAVBoAgoAgBGBEBBoAggAzYCAEGUCEGUCCgCACAAaiIANgIAIAMgAEEBcjYCBCADQZwIKAIARw0DQZAIQQA2AgBBnAhBADYCAA8LIAVBnAgoAgBGBEBBnAggAzYCAEGQCEGQCCgCACAAaiIANgIAIAMgAEEBcjYCBCAAIANqIAA2AgAPCyABQXhxIABqIQACQCABQf8BTQRAIAUoAggiAiABQQN2IgRBA3RBsAhqRhogAiAFKAIMIgFGBEBBiAhBiAgoAgBBfiAEd3E2AgAMAgsgAiABNgIMIAEgAjYCCAwBCyAFKAIYIQYCQCAFIAUoAgwiAUcEQCAFKAIIIgJBmAgoAgBJGiACIAE2AgwgASACNgIIDAELAkAgBUEUaiICKAIAIgQNACAFQRBqIgIoAgAiBA0AQQAhAQwBCwNAIAIhByAEIgFBFGoiAigCACIEDQAgAUEQaiECIAEoAhAiBA0ACyAHQQA2AgALIAZFDQACQCAFIAUoAhwiAkECdEG4CmoiBCgCAEYEQCAEIAE2AgAgAQ0BQYwIQYwIKAIAQX4gAndxNgIADAILIAZBEEEUIAYoAhAgBUYbaiABNgIAIAFFDQELIAEgBjYCGCAFKAIQIgIEQCABIAI2AhAgAiABNgIYCyAFKAIUIgJFDQAgASACNgIUIAIgATYCGAsgAyAAQQFyNgIEIAAgA2ogADYCACADQZwIKAIARw0BQZAIIAA2AgAPCyAFIAFBfnE2AgQgAyAAQQFyNgIEIAAgA2ogADYCAAsgAEH/AU0EQCAAQQN2IgFBA3RBsAhqIQACf0GICCgCACICQQEgAXQiAXFFBEBBiAggASACcjYCACAADAELIAAoAggLIQIgACADNgIIIAIgAzYCDCADIAA2AgwgAyACNgIIDwtBHyECIANCADcCECAAQf///wdNBEAgAEEIdiIBIAFBgP4/akEQdkEIcSIBdCICIAJBgOAfakEQdkEEcSICdCIEIARBgIAPakEQdkECcSIEdEEPdiABIAJyIARyayIBQQF0IAAgAUEVanZBAXFyQRxqIQILIAMgAjYCHCACQQJ0QbgKaiEBAkACQAJAQYwIKAIAIgRBASACdCIHcUUEQEGMCCAEIAdyNgIAIAEgAzYCACADIAE2AhgMAQsgAEEAQRkgAkEBdmsgAkEfRht0IQIgASgCACEBA0AgASIEKAIEQXhxIABGDQIgAkEddiEBIAJBAXQhAiAEIAFBBHFqIgdBEGooAgAiAQ0ACyAHIAM2AhAgAyAENgIYCyADIAM2AgwgAyADNgIIDAELIAQoAggiACADNgIMIAQgAzYCCCADQQA2AhggAyAENgIMIAMgADYCCAtBqAhBqAgoAgBBAWsiAEF/IAAbNgIACwsLCQEAQYEICwIGUA==";
        if (!W.startsWith(V)) {
          var na = W;
          W = b.locateFile ? b.locateFile(na, B) : B + na;
        }
        function pa() {
          var a = W;
          try {
            if (a == W && J) return new Uint8Array(J);
            var c = H(a);
            if (c) return c;
            if (E) return E(a);
            throw "both async and sync fetching of the wasm failed";
          } catch (d) {
            K(d);
          }
        }
        __name(pa, "pa");
        function qa() {
          if (!J && (x || y)) {
            if ("function" === typeof fetch && !W.startsWith("file://")) return fetch(W, {
              credentials: "same-origin"
            }).then(function(a) {
              if (!a.ok) throw "failed to load wasm binary file at '" + W + "'";
              return a.arrayBuffer();
            }).catch(function() {
              return pa();
            });
            if (D) return new Promise(function(a, c) {
              D(W, function(d) {
                a(new Uint8Array(d));
              }, c);
            });
          }
          return Promise.resolve().then(function() {
            return pa();
          });
        }
        __name(qa, "qa");
        function X(a) {
          for (; 0 < a.length; ) {
            var c = a.shift();
            if ("function" == typeof c) c(b);
            else {
              var d = c.m;
              "number" === typeof d ? void 0 === c.l ? R.get(d)() : R.get(d)(c.l) : d(void 0 === c.l ? null : c.l);
            }
          }
        }
        __name(X, "X");
        var ba = false, ra = "function" === typeof atob ? atob : function(a) {
          var c = "", d = 0;
          a = a.replace(/[^A-Za-z0-9\+\/=]/g, "");
          do {
            var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var f = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var l = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            var A = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=".indexOf(a.charAt(d++));
            e = e << 2 | f >> 4;
            f = (f & 15) << 4 | l >> 2;
            var t = (l & 3) << 6 | A;
            c += String.fromCharCode(e);
            64 !== l && (c += String.fromCharCode(f));
            64 !== A && (c += String.fromCharCode(t));
          } while (d < a.length);
          return c;
        };
        function H(a) {
          if (a.startsWith(V)) {
            a = a.slice(V.length);
            if ("boolean" === typeof z2 && z2) {
              var c = Buffer.from(a, "base64");
              c = new Uint8Array(c.buffer, c.byteOffset, c.byteLength);
            } else try {
              var d = ra(a), e = new Uint8Array(d.length);
              for (a = 0; a < d.length; ++a) e[a] = d.charCodeAt(a);
              c = e;
            } catch (f) {
              throw Error("Converting base64 string to bytes failed.");
            }
            return c;
          }
        }
        __name(H, "H");
        var sa = {
          a: /* @__PURE__ */ __name(function(a) {
            var c = P.length;
            a >>>= 0;
            if (2147483648 < a) return false;
            for (var d = 1; 4 >= d; d *= 2) {
              var e = c * (1 + 0.2 / d);
              e = Math.min(e, a + 100663296);
              e = Math.max(a, e);
              0 < e % 65536 && (e += 65536 - e % 65536);
              a: {
                try {
                  L.grow(Math.min(2147483648, e) - ha.byteLength + 65535 >>> 16);
                  ia();
                  var f = 1;
                  break a;
                } catch (l) {
                }
                f = void 0;
              }
              if (f) return true;
            }
            return false;
          }, "a")
        };
        (function() {
          function a(f) {
            b.asm = f.exports;
            L = b.asm.b;
            ia();
            R = b.asm.j;
            ka.unshift(b.asm.c);
            S--;
            b.monitorRunDependencies && b.monitorRunDependencies(S);
            0 == S && (null !== T && (clearInterval(T), T = null), U && (f = U, U = null, f()));
          }
          __name(a, "a");
          function c(f) {
            a(f.instance);
          }
          __name(c, "c");
          function d(f) {
            return qa().then(function(l) {
              return WebAssembly.instantiate(l, e);
            }).then(f, function(l) {
              I("failed to asynchronously prepare wasm: " + l);
              K(l);
            });
          }
          __name(d, "d");
          var e = {
            a: sa
          };
          S++;
          b.monitorRunDependencies && b.monitorRunDependencies(S);
          if (b.instantiateWasm) try {
            return b.instantiateWasm(e, a);
          } catch (f) {
            return I("Module.instantiateWasm callback failed with error: " + f), false;
          }
          (function() {
            return J || "function" !== typeof WebAssembly.instantiateStreaming || W.startsWith(V) || W.startsWith("file://") || "function" !== typeof fetch ? d(c) : fetch(W, {
              credentials: "same-origin"
            }).then(function(f) {
              return WebAssembly.instantiateStreaming(f, e).then(c, function(l) {
                I("wasm streaming compile failed: " + l);
                I("falling back to ArrayBuffer instantiation");
                return d(c);
              });
            });
          })().catch(r);
          return {};
        })();
        b.___wasm_call_ctors = function() {
          return (b.___wasm_call_ctors = b.asm.c).apply(null, arguments);
        };
        b._poly1305_auth = function() {
          return (b._poly1305_auth = b.asm.d).apply(null, arguments);
        };
        var da = b.stackSave = function() {
          return (da = b.stackSave = b.asm.e).apply(null, arguments);
        }, fa = b.stackRestore = function() {
          return (fa = b.stackRestore = b.asm.f).apply(null, arguments);
        }, O = b.stackAlloc = function() {
          return (O = b.stackAlloc = b.asm.g).apply(null, arguments);
        };
        b._malloc = function() {
          return (b._malloc = b.asm.h).apply(null, arguments);
        };
        b._free = function() {
          return (b._free = b.asm.i).apply(null, arguments);
        };
        b.cwrap = function(a, c, d, e) {
          d = d || [];
          var f = d.every(function(l) {
            return "number" === l;
          });
          return "string" !== c && f && !e ? N(a) : function() {
            return ca(a, c, d, arguments);
          };
        };
        var Y;
        U = /* @__PURE__ */ __name(function ta() {
          Y || Z();
          Y || (U = ta);
        }, "ta");
        function Z() {
          function a() {
            if (!Y && (Y = true, b.calledRun = true, !M)) {
              X(ka);
              q(b);
              if (b.onRuntimeInitialized) b.onRuntimeInitialized();
              if (b.postRun) for ("function" == typeof b.postRun && (b.postRun = [
                b.postRun
              ]); b.postRun.length; ) {
                var c = b.postRun.shift();
                la.unshift(c);
              }
              X(la);
            }
          }
          __name(a, "a");
          if (!(0 < S)) {
            if (b.preRun) for ("function" == typeof b.preRun && (b.preRun = [
              b.preRun
            ]); b.preRun.length; ) ma();
            X(ja);
            0 < S || (b.setStatus ? (b.setStatus("Running..."), setTimeout(function() {
              setTimeout(function() {
                b.setStatus("");
              }, 1);
              a();
            }, 1)) : a());
          }
        }
        __name(Z, "Z");
        b.run = Z;
        if (b.preInit) for ("function" == typeof b.preInit && (b.preInit = [
          b.preInit
        ]); 0 < b.preInit.length; ) b.preInit.pop()();
        Z();
        return createPoly13052.ready;
      };
    }();
    if (typeof exports2 === "object" && typeof module2 === "object") module2.exports = createPoly1305;
    else if (typeof define === "function" && define["amd"]) define([], function() {
      return createPoly1305;
    });
    else if (typeof exports2 === "object") exports2["createPoly1305"] = createPoly1305;
  }
});

// node_modules/ssh2/lib/protocol/crypto.js
var require_crypto = __commonJS({
  "node_modules/ssh2/lib/protocol/crypto.js"(exports2, module2) {
    "use strict";
    var { createCipheriv, createDecipheriv, createHmac, randomFillSync, timingSafeEqual } = require("crypto");
    var { readUInt32BE, writeUInt32BE } = require_utils2();
    var FastBuffer = Buffer[Symbol.species];
    var MAX_SEQNO = 2 ** 32 - 1;
    var EMPTY_BUFFER = Buffer.alloc(0);
    var BUF_INT = Buffer.alloc(4);
    var DISCARD_CACHE = /* @__PURE__ */ new Map();
    var MAX_PACKET_SIZE = 35e3;
    var binding;
    var AESGCMCipher;
    var ChaChaPolyCipher;
    var GenericCipher;
    var AESGCMDecipher;
    var ChaChaPolyDecipher;
    var GenericDecipher;
    try {
      binding = require_sshcrypto();
      ({ AESGCMCipher, ChaChaPolyCipher, GenericCipher, AESGCMDecipher, ChaChaPolyDecipher, GenericDecipher } = binding);
    } catch {
    }
    var CIPHER_STREAM = 1 << 0;
    var CIPHER_INFO = (() => {
      function info(sslName, blockLen, keyLen, ivLen, authLen, discardLen, flags) {
        return {
          sslName,
          blockLen,
          keyLen,
          ivLen: ivLen !== 0 || flags & CIPHER_STREAM ? ivLen : blockLen,
          authLen,
          discardLen,
          stream: !!(flags & CIPHER_STREAM)
        };
      }
      __name(info, "info");
      return {
        "chacha20-poly1305@openssh.com": info("chacha20", 8, 64, 0, 16, 0, CIPHER_STREAM),
        "aes128-gcm": info("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm": info("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-gcm@openssh.com": info("aes-128-gcm", 16, 16, 12, 16, 0, CIPHER_STREAM),
        "aes256-gcm@openssh.com": info("aes-256-gcm", 16, 32, 12, 16, 0, CIPHER_STREAM),
        "aes128-cbc": info("aes-128-cbc", 16, 16, 0, 0, 0, 0),
        "aes192-cbc": info("aes-192-cbc", 16, 24, 0, 0, 0, 0),
        "aes256-cbc": info("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "rijndael-cbc@lysator.liu.se": info("aes-256-cbc", 16, 32, 0, 0, 0, 0),
        "3des-cbc": info("des-ede3-cbc", 8, 24, 0, 0, 0, 0),
        "blowfish-cbc": info("bf-cbc", 8, 16, 0, 0, 0, 0),
        "idea-cbc": info("idea-cbc", 8, 16, 0, 0, 0, 0),
        "cast128-cbc": info("cast-cbc", 8, 16, 0, 0, 0, 0),
        "aes128-ctr": info("aes-128-ctr", 16, 16, 16, 0, 0, CIPHER_STREAM),
        "aes192-ctr": info("aes-192-ctr", 16, 24, 16, 0, 0, CIPHER_STREAM),
        "aes256-ctr": info("aes-256-ctr", 16, 32, 16, 0, 0, CIPHER_STREAM),
        "3des-ctr": info("des-ede3", 8, 24, 8, 0, 0, CIPHER_STREAM),
        "blowfish-ctr": info("bf-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        "cast128-ctr": info("cast5-ecb", 8, 16, 8, 0, 0, CIPHER_STREAM),
        /* The "arcfour128" algorithm is the RC4 cipher, as described in
               [SCHNEIER], using a 128-bit key.  The first 1536 bytes of keystream
               generated by the cipher MUST be discarded, and the first byte of the
               first encrypted packet MUST be encrypted using the 1537th byte of
               keystream.
        
               -- http://tools.ietf.org/html/rfc4345#section-4 */
        "arcfour": info("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        "arcfour128": info("rc4", 8, 16, 0, 0, 1536, CIPHER_STREAM),
        "arcfour256": info("rc4", 8, 32, 0, 0, 1536, CIPHER_STREAM),
        "arcfour512": info("rc4", 8, 64, 0, 0, 1536, CIPHER_STREAM)
      };
    })();
    var MAC_INFO = (() => {
      function info(sslName, len, actualLen, isETM) {
        return {
          sslName,
          len,
          actualLen,
          isETM
        };
      }
      __name(info, "info");
      return {
        "hmac-md5": info("md5", 16, 16, false),
        "hmac-md5-96": info("md5", 16, 12, false),
        "hmac-ripemd160": info("ripemd160", 20, 20, false),
        "hmac-sha1": info("sha1", 20, 20, false),
        "hmac-sha1-etm@openssh.com": info("sha1", 20, 20, true),
        "hmac-sha1-96": info("sha1", 20, 12, false),
        "hmac-sha2-256": info("sha256", 32, 32, false),
        "hmac-sha2-256-etm@openssh.com": info("sha256", 32, 32, true),
        "hmac-sha2-256-96": info("sha256", 32, 12, false),
        "hmac-sha2-512": info("sha512", 64, 64, false),
        "hmac-sha2-512-etm@openssh.com": info("sha512", 64, 64, true),
        "hmac-sha2-512-96": info("sha512", 64, 12, false)
      };
    })();
    var NullCipher = class NullCipher {
      static {
        __name(this, "NullCipher");
      }
      constructor(seqno, onWrite) {
        this.outSeqno = seqno;
        this._onWrite = onWrite;
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen & 8 - 1);
        if (padLen < 4) padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead) return;
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var POLY1305_ZEROS = Buffer.alloc(32);
    var POLY1305_OUT_COMPUTE = Buffer.alloc(16);
    var POLY1305_WASM_MODULE;
    var POLY1305_RESULT_MALLOC;
    var poly1305_auth;
    var ChaChaPolyCipherNative = class ChaChaPolyCipherNative {
      static {
        __name(this, "ChaChaPolyCipherNative");
      }
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encKeyMain = enc.cipherKey.slice(0, 32);
        this._encKeyPktLen = enc.cipherKey.slice(32);
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen - 4 & 8 - 1);
        if (padLen < 4) padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead) return;
        POLY1305_OUT_COMPUTE[0] = 0;
        writeUInt32BE(POLY1305_OUT_COMPUTE, this.outSeqno, 12);
        const polyKey = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
        const pktLenEnc = createCipheriv("chacha20", this._encKeyPktLen, POLY1305_OUT_COMPUTE).update(packet.slice(0, 4));
        this._onWrite(pktLenEnc);
        POLY1305_OUT_COMPUTE[0] = 1;
        const payloadEnc = createCipheriv("chacha20", this._encKeyMain, POLY1305_OUT_COMPUTE).update(packet.slice(4));
        this._onWrite(payloadEnc);
        poly1305_auth(POLY1305_RESULT_MALLOC, pktLenEnc, pktLenEnc.length, payloadEnc, payloadEnc.length, polyKey);
        const mac = Buffer.allocUnsafe(16);
        mac.set(new Uint8Array(POLY1305_WASM_MODULE.HEAPU8.buffer, POLY1305_RESULT_MALLOC, 16), 0);
        this._onWrite(mac);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var ChaChaPolyCipherBinding = class ChaChaPolyCipherBinding {
      static {
        __name(this, "ChaChaPolyCipherBinding");
      }
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._instance = new ChaChaPolyCipher(enc.cipherKey);
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 8 - (pktLen - 4 & 8 - 1);
        if (padLen < 4) padLen += 8;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(
          pktLen + 16
          /* MAC */
        );
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead) return;
        this._instance.encrypt(packet, this.outSeqno);
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var AESGCMCipherNative = class AESGCMCipherNative {
      static {
        __name(this, "AESGCMCipherNative");
      }
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encSSLName = enc.cipherInfo.sslName;
        this._encKey = enc.cipherKey;
        this._encIV = enc.cipherIV;
        this._dead = false;
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 16 - (pktLen - 4 & 16 - 1);
        if (padLen < 4) padLen += 16;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead) return;
        const cipher = createCipheriv(this._encSSLName, this._encKey, this._encIV);
        cipher.setAutoPadding(false);
        const lenData = packet.slice(0, 4);
        cipher.setAAD(lenData);
        this._onWrite(lenData);
        const encrypted = cipher.update(packet.slice(4));
        this._onWrite(encrypted);
        const final = cipher.final();
        if (final.length) this._onWrite(final);
        const tag = cipher.getAuthTag();
        this._onWrite(tag);
        ivIncrement(this._encIV);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var AESGCMCipherBinding = class AESGCMCipherBinding {
      static {
        __name(this, "AESGCMCipherBinding");
      }
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._instance = new AESGCMCipher(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV);
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        let pktLen = 4 + 1 + payloadLen;
        let padLen = 16 - (pktLen - 4 & 16 - 1);
        if (padLen < 4) padLen += 16;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(
          pktLen + 16
          /* authTag */
        );
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead) return;
        this._instance.encrypt(packet);
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var GenericCipherNative = class GenericCipherNative {
      static {
        __name(this, "GenericCipherNative");
      }
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encBlockLen = enc.cipherInfo.blockLen;
        this._cipherInstance = createCipheriv(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV);
        this._macSSLName = enc.macInfo.sslName;
        this._macKey = enc.macKey;
        this._macActualLen = enc.macInfo.actualLen;
        this._macETM = enc.macInfo.isETM;
        this._aadLen = this._macETM ? 4 : 0;
        this._dead = false;
        const discardLen = enc.cipherInfo.discardLen;
        if (discardLen) {
          let discard = DISCARD_CACHE.get(discardLen);
          if (discard === void 0) {
            discard = Buffer.alloc(discardLen);
            DISCARD_CACHE.set(discardLen, discard);
          }
          this._cipherInstance.update(discard);
        }
      }
      free() {
        this._dead = true;
      }
      allocPacket(payloadLen) {
        const blockLen = this._encBlockLen;
        let pktLen = 4 + 1 + payloadLen;
        let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        if (padLen < 4) padLen += blockLen;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead) return;
        let mac;
        if (this._macETM) {
          const lenBytes = new Uint8Array(packet.buffer, packet.byteOffset, 4);
          const encrypted = this._cipherInstance.update(new Uint8Array(packet.buffer, packet.byteOffset + 4, packet.length - 4));
          this._onWrite(lenBytes);
          this._onWrite(encrypted);
          mac = createHmac(this._macSSLName, this._macKey);
          writeUInt32BE(BUF_INT, this.outSeqno, 0);
          mac.update(BUF_INT);
          mac.update(lenBytes);
          mac.update(encrypted);
        } else {
          const encrypted = this._cipherInstance.update(packet);
          this._onWrite(encrypted);
          mac = createHmac(this._macSSLName, this._macKey);
          writeUInt32BE(BUF_INT, this.outSeqno, 0);
          mac.update(BUF_INT);
          mac.update(packet);
        }
        let digest = mac.digest();
        if (digest.length > this._macActualLen) digest = digest.slice(0, this._macActualLen);
        this._onWrite(digest);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var GenericCipherBinding = class GenericCipherBinding {
      static {
        __name(this, "GenericCipherBinding");
      }
      constructor(config) {
        const enc = config.outbound;
        this.outSeqno = enc.seqno;
        this._onWrite = enc.onWrite;
        this._encBlockLen = enc.cipherInfo.blockLen;
        this._macLen = enc.macInfo.len;
        this._macActualLen = enc.macInfo.actualLen;
        this._aadLen = enc.macInfo.isETM ? 4 : 0;
        this._instance = new GenericCipher(enc.cipherInfo.sslName, enc.cipherKey, enc.cipherIV, enc.macInfo.sslName, enc.macKey, enc.macInfo.isETM);
        this._dead = false;
      }
      free() {
        this._dead = true;
        this._instance.free();
      }
      allocPacket(payloadLen) {
        const blockLen = this._encBlockLen;
        let pktLen = 4 + 1 + payloadLen;
        let padLen = blockLen - (pktLen - this._aadLen & blockLen - 1);
        if (padLen < 4) padLen += blockLen;
        pktLen += padLen;
        const packet = Buffer.allocUnsafe(pktLen + this._macLen);
        writeUInt32BE(packet, pktLen - 4, 0);
        packet[4] = padLen;
        randomFillSync(packet, 5 + payloadLen, padLen);
        return packet;
      }
      encrypt(packet) {
        if (this._dead) return;
        this._instance.encrypt(packet, this.outSeqno);
        if (this._macActualLen < this._macLen) {
          packet = new FastBuffer(packet.buffer, packet.byteOffset, packet.length - (this._macLen - this._macActualLen));
        }
        this._onWrite(packet);
        this.outSeqno = this.outSeqno + 1 >>> 0;
      }
    };
    var NullDecipher = class NullDecipher {
      static {
        __name(this, "NullDecipher");
      }
      constructor(seqno, onPayload) {
        this.inSeqno = seqno;
        this._onPayload = onPayload;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--) this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4) return;
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (4 + this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
            if (p >= dataLen) return;
          }
          if (this._packetPos < this._len) {
            const nb = Math.min(this._len - this._packetPos, dataLen - p);
            let chunk;
            if (p !== 0 || nb !== dataLen) chunk = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else chunk = data;
            if (nb === this._len) {
              this._packet = chunk;
            } else {
              if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(chunk, this._packetPos);
            }
            p += nb;
            this._packetPos += nb;
            if (this._packetPos < this._len) return;
          }
          const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._packetPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0) return ret === false ? p : ret;
          }
        }
      }
    };
    var ChaChaPolyDecipherNative = class ChaChaPolyDecipherNative {
      static {
        __name(this, "ChaChaPolyDecipherNative");
      }
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decKeyMain = dec.decipherKey.slice(0, 32);
        this._decKeyPktLen = dec.decipherKey.slice(32);
        this._len = 0;
        this._lenBuf = Buffer.alloc(4);
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(16);
        this._calcMac = Buffer.allocUnsafe(16);
        this._macPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            while (nb--) this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4) return;
            POLY1305_OUT_COMPUTE[0] = 0;
            writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
            const decLenBytes = createDecipheriv("chacha20", this._decKeyPktLen, POLY1305_OUT_COMPUTE).update(this._lenBuf);
            this._len = readUInt32BE(decLenBytes, 0);
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen) return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen) return;
          }
          {
            const nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < 16) return;
          }
          POLY1305_OUT_COMPUTE[0] = 0;
          writeUInt32BE(POLY1305_OUT_COMPUTE, this.inSeqno, 12);
          const polyKey = createCipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(POLY1305_ZEROS);
          poly1305_auth(POLY1305_RESULT_MALLOC, this._lenBuf, 4, this._packet, this._packet.length, polyKey);
          this._calcMac.set(new Uint8Array(POLY1305_WASM_MODULE.HEAPU8.buffer, POLY1305_RESULT_MALLOC, 16), 0);
          if (!timingSafeEqual(this._calcMac, this._mac)) throw new Error("Invalid MAC");
          POLY1305_OUT_COMPUTE[0] = 1;
          const packet = createDecipheriv("chacha20", this._decKeyMain, POLY1305_OUT_COMPUTE).update(this._packet);
          const payload = new FastBuffer(packet.buffer, packet.byteOffset + 1, packet.length - packet[0] - 1);
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenPos = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0) return ret === false ? p : ret;
          }
        }
      }
    };
    var ChaChaPolyDecipherBinding = class ChaChaPolyDecipherBinding {
      static {
        __name(this, "ChaChaPolyDecipherBinding");
      }
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new ChaChaPolyDecipher(dec.decipherKey);
        this._len = 0;
        this._lenBuf = Buffer.alloc(4);
        this._lenPos = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(16);
        this._macPos = 0;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenPos < 4) {
            let nb = Math.min(4 - this._lenPos, dataLen - p);
            while (nb--) this._lenBuf[this._lenPos++] = data[p++];
            if (this._lenPos < 4) return;
            this._len = this._instance.decryptLen(this._lenBuf, this.inSeqno);
            if (this._len > MAX_PACKET_SIZE || this._len < 8 || (this._len & 7) !== 0) {
              throw new Error("Bad packet length");
            }
            if (p >= dataLen) return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen) return;
          }
          {
            const nb = Math.min(16 - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < 16) return;
          }
          this._instance.decrypt(this._packet, this._mac, this.inSeqno);
          const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenPos = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0) return ret === false ? p : ret;
          }
        }
      }
    };
    var AESGCMDecipherNative = class AESGCMDecipherNative {
      static {
        __name(this, "AESGCMDecipherNative");
      }
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decipherInstance = null;
        this._decipherSSLName = dec.decipherInfo.sslName;
        this._decipherKey = dec.decipherKey;
        this._decipherIV = dec.decipherIV;
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._tag = Buffer.allocUnsafe(16);
        this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--) this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4) return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
              throw new Error("Bad packet length");
            }
            this._decipherInstance = createDecipheriv(this._decipherSSLName, this._decipherKey, this._decipherIV);
            this._decipherInstance.setAutoPadding(false);
            this._decipherInstance.setAAD(intToBytes(this._len));
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen) return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let decrypted;
            if (p !== 0 || nb !== dataLen) {
              decrypted = this._decipherInstance.update(new Uint8Array(data.buffer, data.byteOffset + p, nb));
            } else {
              decrypted = this._decipherInstance.update(data);
            }
            if (decrypted.length) {
              if (nb === this._len) {
                this._packet = decrypted;
              } else {
                if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(decrypted, this._packetPos);
              }
              this._packetPos += decrypted.length;
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen) return;
          }
          {
            const nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._tag.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._tagPos);
            } else {
              this._tag.set(data, this._tagPos);
            }
            p += nb;
            this._tagPos += nb;
            if (this._tagPos < 16) return;
          }
          {
            this._decipherInstance.setAuthTag(this._tag);
            const decrypted = this._decipherInstance.final();
            if (decrypted.length) {
              if (this._packet) this._packet.set(decrypted, this._packetPos);
              else this._packet = decrypted;
            }
          }
          const payload = !this._packet ? EMPTY_BUFFER : new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);
          this.inSeqno = this.inSeqno + 1 >>> 0;
          ivIncrement(this._decipherIV);
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._packetPos = 0;
          this._pktLen = 0;
          this._tagPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0) return ret === false ? p : ret;
          }
        }
      }
    };
    var AESGCMDecipherBinding = class AESGCMDecipherBinding {
      static {
        __name(this, "AESGCMDecipherBinding");
      }
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new AESGCMDecipher(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV);
        this._len = 0;
        this._lenBytes = 0;
        this._packet = null;
        this._pktLen = 0;
        this._tag = Buffer.allocUnsafe(16);
        this._tagPos = 0;
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._lenBytes < 4) {
            let nb = Math.min(4 - this._lenBytes, dataLen - p);
            this._lenBytes += nb;
            while (nb--) this._len = (this._len << 8) + data[p++];
            if (this._lenBytes < 4) return;
            if (this._len + 20 > MAX_PACKET_SIZE || this._len < 16 || (this._len & 15) !== 0) {
              throw new Error(`Bad packet length: ${this._len}`);
            }
          }
          if (this._pktLen < this._len) {
            if (p >= dataLen) return;
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen) return;
          }
          {
            const nb = Math.min(16 - this._tagPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._tag.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._tagPos);
            } else {
              this._tag.set(data, this._tagPos);
            }
            p += nb;
            this._tagPos += nb;
            if (this._tagPos < 16) return;
          }
          this._instance.decrypt(this._packet, this._len, this._tag);
          const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._len = 0;
          this._lenBytes = 0;
          this._packet = null;
          this._pktLen = 0;
          this._tagPos = 0;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0) return ret === false ? p : ret;
          }
        }
      }
    };
    var GenericDecipherNative = class GenericDecipherNative {
      static {
        __name(this, "GenericDecipherNative");
      }
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._decipherInstance = createDecipheriv(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV);
        this._decipherInstance.setAutoPadding(false);
        this._block = Buffer.allocUnsafe(dec.macInfo.isETM ? 4 : dec.decipherInfo.blockLen);
        this._blockSize = dec.decipherInfo.blockLen;
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._packetPos = 0;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
        this._macPos = 0;
        this._macSSLName = dec.macInfo.sslName;
        this._macKey = dec.macKey;
        this._macActualLen = dec.macInfo.actualLen;
        this._macETM = dec.macInfo.isETM;
        this._macInstance = null;
        const discardLen = dec.decipherInfo.discardLen;
        if (discardLen) {
          let discard = DISCARD_CACHE.get(discardLen);
          if (discard === void 0) {
            discard = Buffer.alloc(discardLen);
            DISCARD_CACHE.set(discardLen, discard);
          }
          this._decipherInstance.update(discard);
        }
      }
      free() {
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._blockPos < this._block.length) {
            const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length) {
              this._block.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._blockPos);
            } else {
              this._block.set(data, this._blockPos);
            }
            p += nb;
            this._blockPos += nb;
            if (this._blockPos < this._block.length) return;
            let decrypted;
            let need;
            if (this._macETM) {
              this._len = need = readUInt32BE(this._block, 0);
            } else {
              decrypted = this._decipherInstance.update(this._block);
              this._len = readUInt32BE(decrypted, 0);
              need = 4 + this._len - this._blockSize;
            }
            if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._blockSize - 1) !== 0) {
              throw new Error("Bad packet length");
            }
            this._macInstance = createHmac(this._macSSLName, this._macKey);
            writeUInt32BE(BUF_INT, this.inSeqno, 0);
            this._macInstance.update(BUF_INT);
            if (this._macETM) {
              this._macInstance.update(this._block);
            } else {
              this._macInstance.update(new Uint8Array(decrypted.buffer, decrypted.byteOffset, 4));
              this._pktLen = decrypted.length - 4;
              this._packetPos = this._pktLen;
              this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(new Uint8Array(decrypted.buffer, decrypted.byteOffset + 4, this._packetPos), 0);
            }
            if (p >= dataLen) return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else encrypted = data;
            if (this._macETM) this._macInstance.update(encrypted);
            const decrypted = this._decipherInstance.update(encrypted);
            if (decrypted.length) {
              if (nb === this._len) {
                this._packet = decrypted;
              } else {
                if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(decrypted, this._packetPos);
              }
              this._packetPos += decrypted.length;
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen) return;
          }
          {
            const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < this._macActualLen) return;
          }
          if (!this._macETM) this._macInstance.update(this._packet);
          let calculated = this._macInstance.digest();
          if (this._macActualLen < calculated.length) {
            calculated = new Uint8Array(calculated.buffer, calculated.byteOffset, this._macActualLen);
          }
          if (!timingSafeEquals(calculated, this._mac)) throw new Error("Invalid MAC");
          const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._blockPos = 0;
          this._len = 0;
          this._packet = null;
          this._packetPos = 0;
          this._pktLen = 0;
          this._macPos = 0;
          this._macInstance = null;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0) return ret === false ? p : ret;
          }
        }
      }
    };
    var GenericDecipherBinding = class GenericDecipherBinding {
      static {
        __name(this, "GenericDecipherBinding");
      }
      constructor(config) {
        const dec = config.inbound;
        this.inSeqno = dec.seqno;
        this._onPayload = dec.onPayload;
        this._instance = new GenericDecipher(dec.decipherInfo.sslName, dec.decipherKey, dec.decipherIV, dec.macInfo.sslName, dec.macKey, dec.macInfo.isETM, dec.macInfo.actualLen);
        this._block = Buffer.allocUnsafe(dec.macInfo.isETM || dec.decipherInfo.stream ? 4 : dec.decipherInfo.blockLen);
        this._blockPos = 0;
        this._len = 0;
        this._packet = null;
        this._pktLen = 0;
        this._mac = Buffer.allocUnsafe(dec.macInfo.actualLen);
        this._macPos = 0;
        this._macActualLen = dec.macInfo.actualLen;
        this._macETM = dec.macInfo.isETM;
      }
      free() {
        this._instance.free();
      }
      decrypt(data, p, dataLen) {
        while (p < dataLen) {
          if (this._blockPos < this._block.length) {
            const nb = Math.min(this._block.length - this._blockPos, dataLen - p);
            if (p !== 0 || nb !== dataLen || nb < data.length) {
              this._block.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._blockPos);
            } else {
              this._block.set(data, this._blockPos);
            }
            p += nb;
            this._blockPos += nb;
            if (this._blockPos < this._block.length) return;
            let need;
            if (this._macETM) {
              this._len = need = readUInt32BE(this._block, 0);
            } else {
              this._instance.decryptBlock(this._block);
              this._len = readUInt32BE(this._block, 0);
              need = 4 + this._len - this._block.length;
            }
            if (this._len > MAX_PACKET_SIZE || this._len < 5 || (need & this._block.length - 1) !== 0) {
              throw new Error("Bad packet length");
            }
            if (!this._macETM) {
              this._pktLen = this._block.length - 4;
              if (this._pktLen) {
                this._packet = Buffer.allocUnsafe(this._len);
                this._packet.set(new Uint8Array(this._block.buffer, this._block.byteOffset + 4, this._pktLen), 0);
              }
            }
            if (p >= dataLen) return;
          }
          if (this._pktLen < this._len) {
            const nb = Math.min(this._len - this._pktLen, dataLen - p);
            let encrypted;
            if (p !== 0 || nb !== dataLen) encrypted = new Uint8Array(data.buffer, data.byteOffset + p, nb);
            else encrypted = data;
            if (nb === this._len) {
              this._packet = encrypted;
            } else {
              if (!this._packet) this._packet = Buffer.allocUnsafe(this._len);
              this._packet.set(encrypted, this._pktLen);
            }
            p += nb;
            this._pktLen += nb;
            if (this._pktLen < this._len || p >= dataLen) return;
          }
          {
            const nb = Math.min(this._macActualLen - this._macPos, dataLen - p);
            if (p !== 0 || nb !== dataLen) {
              this._mac.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._macPos);
            } else {
              this._mac.set(data, this._macPos);
            }
            p += nb;
            this._macPos += nb;
            if (this._macPos < this._macActualLen) return;
          }
          this._instance.decrypt(this._packet, this.inSeqno, this._block, this._mac);
          const payload = new FastBuffer(this._packet.buffer, this._packet.byteOffset + 1, this._packet.length - this._packet[0] - 1);
          this.inSeqno = this.inSeqno + 1 >>> 0;
          this._blockPos = 0;
          this._len = 0;
          this._packet = null;
          this._pktLen = 0;
          this._macPos = 0;
          this._macInstance = null;
          {
            const ret = this._onPayload(payload);
            if (ret !== void 0) return ret === false ? p : ret;
          }
        }
      }
    };
    function ivIncrement(iv) {
      ++iv[11] >>> 8 && ++iv[10] >>> 8 && ++iv[9] >>> 8 && ++iv[8] >>> 8 && ++iv[7] >>> 8 && ++iv[6] >>> 8 && ++iv[5] >>> 8 && ++iv[4] >>> 8;
    }
    __name(ivIncrement, "ivIncrement");
    var intToBytes = (() => {
      const ret = Buffer.alloc(4);
      return (n) => {
        ret[0] = n >>> 24;
        ret[1] = n >>> 16;
        ret[2] = n >>> 8;
        ret[3] = n;
        return ret;
      };
    })();
    function timingSafeEquals(a, b) {
      if (a.length !== b.length) {
        timingSafeEqual(a, a);
        return false;
      }
      return timingSafeEqual(a, b);
    }
    __name(timingSafeEquals, "timingSafeEquals");
    function createCipher(config) {
      if (typeof config !== "object" || config === null) throw new Error("Invalid config");
      if (typeof config.outbound !== "object" || config.outbound === null) throw new Error("Invalid outbound");
      const outbound = config.outbound;
      if (typeof outbound.onWrite !== "function") throw new Error("Invalid outbound.onWrite");
      if (typeof outbound.cipherInfo !== "object" || outbound.cipherInfo === null) throw new Error("Invalid outbound.cipherInfo");
      if (!Buffer.isBuffer(outbound.cipherKey) || outbound.cipherKey.length !== outbound.cipherInfo.keyLen) {
        throw new Error("Invalid outbound.cipherKey");
      }
      if (outbound.cipherInfo.ivLen && (!Buffer.isBuffer(outbound.cipherIV) || outbound.cipherIV.length !== outbound.cipherInfo.ivLen)) {
        throw new Error("Invalid outbound.cipherIV");
      }
      if (typeof outbound.seqno !== "number" || outbound.seqno < 0 || outbound.seqno > MAX_SEQNO) {
        throw new Error("Invalid outbound.seqno");
      }
      const forceNative = !!outbound.forceNative;
      switch (outbound.cipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMCipher && !forceNative ? new AESGCMCipherBinding(config) : new AESGCMCipherNative(config);
        case "chacha20":
          return ChaChaPolyCipher && !forceNative ? new ChaChaPolyCipherBinding(config) : new ChaChaPolyCipherNative(config);
        default: {
          if (typeof outbound.macInfo !== "object" || outbound.macInfo === null) throw new Error("Invalid outbound.macInfo");
          if (!Buffer.isBuffer(outbound.macKey) || outbound.macKey.length !== outbound.macInfo.len) {
            throw new Error("Invalid outbound.macKey");
          }
          return GenericCipher && !forceNative ? new GenericCipherBinding(config) : new GenericCipherNative(config);
        }
      }
    }
    __name(createCipher, "createCipher");
    function createDecipher(config) {
      if (typeof config !== "object" || config === null) throw new Error("Invalid config");
      if (typeof config.inbound !== "object" || config.inbound === null) throw new Error("Invalid inbound");
      const inbound = config.inbound;
      if (typeof inbound.onPayload !== "function") throw new Error("Invalid inbound.onPayload");
      if (typeof inbound.decipherInfo !== "object" || inbound.decipherInfo === null) {
        throw new Error("Invalid inbound.decipherInfo");
      }
      if (!Buffer.isBuffer(inbound.decipherKey) || inbound.decipherKey.length !== inbound.decipherInfo.keyLen) {
        throw new Error("Invalid inbound.decipherKey");
      }
      if (inbound.decipherInfo.ivLen && (!Buffer.isBuffer(inbound.decipherIV) || inbound.decipherIV.length !== inbound.decipherInfo.ivLen)) {
        throw new Error("Invalid inbound.decipherIV");
      }
      if (typeof inbound.seqno !== "number" || inbound.seqno < 0 || inbound.seqno > MAX_SEQNO) {
        throw new Error("Invalid inbound.seqno");
      }
      const forceNative = !!inbound.forceNative;
      switch (inbound.decipherInfo.sslName) {
        case "aes-128-gcm":
        case "aes-256-gcm":
          return AESGCMDecipher && !forceNative ? new AESGCMDecipherBinding(config) : new AESGCMDecipherNative(config);
        case "chacha20":
          return ChaChaPolyDecipher && !forceNative ? new ChaChaPolyDecipherBinding(config) : new ChaChaPolyDecipherNative(config);
        default: {
          if (typeof inbound.macInfo !== "object" || inbound.macInfo === null) throw new Error("Invalid inbound.macInfo");
          if (!Buffer.isBuffer(inbound.macKey) || inbound.macKey.length !== inbound.macInfo.len) {
            throw new Error("Invalid inbound.macKey");
          }
          return GenericDecipher && !forceNative ? new GenericDecipherBinding(config) : new GenericDecipherNative(config);
        }
      }
    }
    __name(createDecipher, "createDecipher");
    module2.exports = {
      CIPHER_INFO,
      MAC_INFO,
      bindingAvailable: !!binding,
      init: (() => {
        return new Promise(async (resolve5, reject) => {
          try {
            POLY1305_WASM_MODULE = await require_poly1305()();
            POLY1305_RESULT_MALLOC = POLY1305_WASM_MODULE._malloc(16);
            poly1305_auth = POLY1305_WASM_MODULE.cwrap("poly1305_auth", null, [
              "number",
              "array",
              "number",
              "array",
              "number",
              "array"
            ]);
          } catch (ex) {
            return reject(ex);
          }
          resolve5();
        });
      })(),
      NullCipher,
      createCipher,
      NullDecipher,
      createDecipher
    };
  }
});

// node_modules/ssh2/lib/protocol/keyParser.js
var require_keyParser = __commonJS({
  "node_modules/ssh2/lib/protocol/keyParser.js"(exports2, module2) {
    "use strict";
    var { createDecipheriv, createECDH, createHash, createHmac, createSign, createVerify, getCiphers, sign: sign_, verify: verify_ } = require("crypto");
    var supportedOpenSSLCiphers = getCiphers();
    var { Ber } = require_lib2();
    var bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf;
    var { CIPHER_INFO } = require_crypto();
    var { eddsaSupported, SUPPORTED_CIPHER } = require_constants2();
    var { bufferSlice, makeBufferParser, readString, readUInt32BE, writeUInt32BE } = require_utils2();
    var SYM_HASH_ALGO = Symbol("Hash Algorithm");
    var SYM_PRIV_PEM = Symbol("Private key PEM");
    var SYM_PUB_PEM = Symbol("Public key PEM");
    var SYM_PUB_SSH = Symbol("Public key SSH");
    var SYM_DECRYPTED = Symbol("Decrypted Key");
    var CIPHER_INFO_OPENSSL = /* @__PURE__ */ Object.create(null);
    {
      const keys = Object.keys(CIPHER_INFO);
      for (let i = 0; i < keys.length; ++i) {
        const cipherName = CIPHER_INFO[keys[i]].sslName;
        if (!cipherName || CIPHER_INFO_OPENSSL[cipherName]) continue;
        CIPHER_INFO_OPENSSL[cipherName] = CIPHER_INFO[keys[i]];
      }
    }
    var binaryKeyParser = makeBufferParser();
    function makePEM(type, data) {
      data = data.base64Slice(0, data.length);
      let formatted = data.replace(/.{64}/g, "$&\n");
      if (data.length & 63) formatted += "\n";
      return `-----BEGIN ${type} KEY-----
${formatted}-----END ${type} KEY-----`;
    }
    __name(makePEM, "makePEM");
    function combineBuffers(buf1, buf2) {
      const result2 = Buffer.allocUnsafe(buf1.length + buf2.length);
      result2.set(buf1, 0);
      result2.set(buf2, buf1.length);
      return result2;
    }
    __name(combineBuffers, "combineBuffers");
    function skipFields(buf, nfields) {
      const bufLen = buf.length;
      let pos = buf._pos || 0;
      for (let i = 0; i < nfields; ++i) {
        const left2 = bufLen - pos;
        if (pos >= bufLen || left2 < 4) return false;
        const len = readUInt32BE(buf, pos);
        if (left2 < 4 + len) return false;
        pos += 4 + len;
      }
      buf._pos = pos;
      return true;
    }
    __name(skipFields, "skipFields");
    function genOpenSSLRSAPub(n, e) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.113549.1.1.1");
      asnWriter.writeNull();
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter.startSequence();
      asnWriter.writeBuffer(n, Ber.Integer);
      asnWriter.writeBuffer(e, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    __name(genOpenSSLRSAPub, "genOpenSSLRSAPub");
    function genOpenSSHRSAPub(n, e) {
      const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + e.length + 4 + n.length);
      writeUInt32BE(publicKey, 7, 0);
      publicKey.utf8Write("ssh-rsa", 4, 7);
      let i = 4 + 7;
      writeUInt32BE(publicKey, e.length, i);
      publicKey.set(e, i += 4);
      writeUInt32BE(publicKey, n.length, i += e.length);
      publicKey.set(n, i + 4);
      return publicKey;
    }
    __name(genOpenSSHRSAPub, "genOpenSSHRSAPub");
    var genOpenSSLRSAPriv = /* @__PURE__ */ (() => {
      function genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp) {
        const asnWriter = new Ber.Writer();
        asnWriter.startSequence();
        asnWriter.writeInt(0, Ber.Integer);
        asnWriter.writeBuffer(n, Ber.Integer);
        asnWriter.writeBuffer(e, Ber.Integer);
        asnWriter.writeBuffer(d, Ber.Integer);
        asnWriter.writeBuffer(p, Ber.Integer);
        asnWriter.writeBuffer(q, Ber.Integer);
        asnWriter.writeBuffer(dmp1, Ber.Integer);
        asnWriter.writeBuffer(dmq1, Ber.Integer);
        asnWriter.writeBuffer(iqmp, Ber.Integer);
        asnWriter.endSequence();
        return asnWriter.buffer;
      }
      __name(genRSAASN1Buf, "genRSAASN1Buf");
      function bigIntFromBuffer(buf) {
        return BigInt(`0x${buf.hexSlice(0, buf.length)}`);
      }
      __name(bigIntFromBuffer, "bigIntFromBuffer");
      function bigIntToBuffer(bn) {
        let hex = bn.toString(16);
        if ((hex.length & 1) !== 0) {
          hex = `0${hex}`;
        } else {
          const sigbit = hex.charCodeAt(0);
          if (sigbit === 56 || sigbit === 57 || sigbit >= 97 && sigbit <= 102) {
            hex = `00${hex}`;
          }
        }
        return Buffer.from(hex, "hex");
      }
      __name(bigIntToBuffer, "bigIntToBuffer");
      return /* @__PURE__ */ __name(function genOpenSSLRSAPriv2(n, e, d, iqmp, p, q) {
        const bn_d = bigIntFromBuffer(d);
        const dmp1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(p) - 1n));
        const dmq1 = bigIntToBuffer(bn_d % (bigIntFromBuffer(q) - 1n));
        return makePEM("RSA PRIVATE", genRSAASN1Buf(n, e, d, p, q, dmp1, dmq1, iqmp));
      }, "genOpenSSLRSAPriv");
    })();
    function genOpenSSLDSAPub(p, q, g, y) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.10040.4.1");
      asnWriter.startSequence();
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    __name(genOpenSSLDSAPub, "genOpenSSLDSAPub");
    function genOpenSSHDSAPub(p, q, g, y) {
      const publicKey = Buffer.allocUnsafe(4 + 7 + 4 + p.length + 4 + q.length + 4 + g.length + 4 + y.length);
      writeUInt32BE(publicKey, 7, 0);
      publicKey.utf8Write("ssh-dss", 4, 7);
      let i = 4 + 7;
      writeUInt32BE(publicKey, p.length, i);
      publicKey.set(p, i += 4);
      writeUInt32BE(publicKey, q.length, i += p.length);
      publicKey.set(q, i += 4);
      writeUInt32BE(publicKey, g.length, i += q.length);
      publicKey.set(g, i += 4);
      writeUInt32BE(publicKey, y.length, i += g.length);
      publicKey.set(y, i + 4);
      return publicKey;
    }
    __name(genOpenSSHDSAPub, "genOpenSSHDSAPub");
    function genOpenSSLDSAPriv(p, q, g, y, x) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(0, Ber.Integer);
      asnWriter.writeBuffer(p, Ber.Integer);
      asnWriter.writeBuffer(q, Ber.Integer);
      asnWriter.writeBuffer(g, Ber.Integer);
      asnWriter.writeBuffer(y, Ber.Integer);
      asnWriter.writeBuffer(x, Ber.Integer);
      asnWriter.endSequence();
      return makePEM("DSA PRIVATE", asnWriter.buffer);
    }
    __name(genOpenSSLDSAPriv, "genOpenSSLDSAPriv");
    function genOpenSSLEdPub(pub) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.3.101.112");
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(pub.length);
      asnWriter._buf.set(pub, asnWriter._offset);
      asnWriter._offset += pub.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    __name(genOpenSSLEdPub, "genOpenSSLEdPub");
    function genOpenSSHEdPub(pub) {
      const publicKey = Buffer.allocUnsafe(4 + 11 + 4 + pub.length);
      writeUInt32BE(publicKey, 11, 0);
      publicKey.utf8Write("ssh-ed25519", 4, 11);
      writeUInt32BE(publicKey, pub.length, 15);
      publicKey.set(pub, 19);
      return publicKey;
    }
    __name(genOpenSSHEdPub, "genOpenSSHEdPub");
    function genOpenSSLEdPriv(priv) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(0, Ber.Integer);
      asnWriter.startSequence();
      asnWriter.writeOID("1.3.101.112");
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.OctetString);
      asnWriter.writeBuffer(priv, Ber.OctetString);
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PRIVATE", asnWriter.buffer);
    }
    __name(genOpenSSLEdPriv, "genOpenSSLEdPriv");
    function genOpenSSLECDSAPub(oid, Q) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.startSequence();
      asnWriter.writeOID("1.2.840.10045.2.1");
      asnWriter.writeOID(oid);
      asnWriter.endSequence();
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(Q.length);
      asnWriter._buf.set(Q, asnWriter._offset);
      asnWriter._offset += Q.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("PUBLIC", asnWriter.buffer);
    }
    __name(genOpenSSLECDSAPub, "genOpenSSLECDSAPub");
    function genOpenSSHECDSAPub(oid, Q) {
      let curveName;
      switch (oid) {
        case "1.2.840.10045.3.1.7":
          curveName = "nistp256";
          break;
        case "1.3.132.0.34":
          curveName = "nistp384";
          break;
        case "1.3.132.0.35":
          curveName = "nistp521";
          break;
        default:
          return;
      }
      const publicKey = Buffer.allocUnsafe(4 + 19 + 4 + 8 + 4 + Q.length);
      writeUInt32BE(publicKey, 19, 0);
      publicKey.utf8Write(`ecdsa-sha2-${curveName}`, 4, 19);
      writeUInt32BE(publicKey, 8, 23);
      publicKey.utf8Write(curveName, 27, 8);
      writeUInt32BE(publicKey, Q.length, 35);
      publicKey.set(Q, 39);
      return publicKey;
    }
    __name(genOpenSSHECDSAPub, "genOpenSSHECDSAPub");
    function genOpenSSLECDSAPriv(oid, pub, priv) {
      const asnWriter = new Ber.Writer();
      asnWriter.startSequence();
      asnWriter.writeInt(1, Ber.Integer);
      asnWriter.writeBuffer(priv, Ber.OctetString);
      asnWriter.startSequence(160);
      asnWriter.writeOID(oid);
      asnWriter.endSequence();
      asnWriter.startSequence(161);
      asnWriter.startSequence(Ber.BitString);
      asnWriter.writeByte(0);
      asnWriter._ensure(pub.length);
      asnWriter._buf.set(pub, asnWriter._offset);
      asnWriter._offset += pub.length;
      asnWriter.endSequence();
      asnWriter.endSequence();
      asnWriter.endSequence();
      return makePEM("EC PRIVATE", asnWriter.buffer);
    }
    __name(genOpenSSLECDSAPriv, "genOpenSSLECDSAPriv");
    function genOpenSSLECDSAPubFromPriv(curveName, priv) {
      const tempECDH = createECDH(curveName);
      tempECDH.setPrivateKey(priv);
      return tempECDH.getPublicKey();
    }
    __name(genOpenSSLECDSAPubFromPriv, "genOpenSSLECDSAPubFromPriv");
    var BaseKey = {
      sign: (() => {
        if (typeof sign_ === "function") {
          return /* @__PURE__ */ __name(function sign(data, algo) {
            const pem = this[SYM_PRIV_PEM];
            if (pem === null) return new Error("No private key available");
            if (!algo || typeof algo !== "string") algo = this[SYM_HASH_ALGO];
            try {
              return sign_(algo, data, pem);
            } catch (ex) {
              return ex;
            }
          }, "sign");
        }
        return /* @__PURE__ */ __name(function sign(data, algo) {
          const pem = this[SYM_PRIV_PEM];
          if (pem === null) return new Error("No private key available");
          if (!algo || typeof algo !== "string") algo = this[SYM_HASH_ALGO];
          const signature = createSign(algo);
          signature.update(data);
          try {
            return signature.sign(pem);
          } catch (ex) {
            return ex;
          }
        }, "sign");
      })(),
      verify: (() => {
        if (typeof verify_ === "function") {
          return /* @__PURE__ */ __name(function verify(data, signature, algo) {
            const pem = this[SYM_PUB_PEM];
            if (pem === null) return new Error("No public key available");
            if (!algo || typeof algo !== "string") algo = this[SYM_HASH_ALGO];
            try {
              return verify_(algo, data, pem, signature);
            } catch (ex) {
              return ex;
            }
          }, "verify");
        }
        return /* @__PURE__ */ __name(function verify(data, signature, algo) {
          const pem = this[SYM_PUB_PEM];
          if (pem === null) return new Error("No public key available");
          if (!algo || typeof algo !== "string") algo = this[SYM_HASH_ALGO];
          const verifier = createVerify(algo);
          verifier.update(data);
          try {
            return verifier.verify(pem, signature);
          } catch (ex) {
            return ex;
          }
        }, "verify");
      })(),
      isPrivateKey: /* @__PURE__ */ __name(function isPrivateKey() {
        return this[SYM_PRIV_PEM] !== null;
      }, "isPrivateKey"),
      getPrivatePEM: /* @__PURE__ */ __name(function getPrivatePEM() {
        return this[SYM_PRIV_PEM];
      }, "getPrivatePEM"),
      getPublicPEM: /* @__PURE__ */ __name(function getPublicPEM() {
        return this[SYM_PUB_PEM];
      }, "getPublicPEM"),
      getPublicSSH: /* @__PURE__ */ __name(function getPublicSSH() {
        return this[SYM_PUB_SSH];
      }, "getPublicSSH"),
      equals: /* @__PURE__ */ __name(function equals(key) {
        const parsed = parseKey(key);
        if (parsed instanceof Error) return false;
        return this.type === parsed.type && this[SYM_PRIV_PEM] === parsed[SYM_PRIV_PEM] && this[SYM_PUB_PEM] === parsed[SYM_PUB_PEM] && this[SYM_PUB_SSH].equals(parsed[SYM_PUB_SSH]);
      }, "equals")
    };
    function OpenSSH_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    __name(OpenSSH_Private, "OpenSSH_Private");
    OpenSSH_Private.prototype = BaseKey;
    {
      let parseOpenSSHPrivKeys = function(data, nkeys, decrypted) {
        const keys = [];
        if (data.length < 8) return new Error("Malformed OpenSSH private key");
        const check1 = readUInt32BE(data, 0);
        const check2 = readUInt32BE(data, 4);
        if (check1 !== check2) {
          if (decrypted) {
            return new Error("OpenSSH key integrity check failed -- bad passphrase?");
          }
          return new Error("OpenSSH key integrity check failed");
        }
        data._pos = 8;
        let i;
        let oid;
        for (i = 0; i < nkeys; ++i) {
          let algo;
          let privPEM;
          let pubPEM;
          let pubSSH;
          const type = readString(data, data._pos, true);
          if (type === void 0) return new Error("Malformed OpenSSH private key");
          switch (type) {
            case "ssh-rsa": {
              const n = readString(data, data._pos);
              if (n === void 0) return new Error("Malformed OpenSSH private key");
              const e = readString(data, data._pos);
              if (e === void 0) return new Error("Malformed OpenSSH private key");
              const d = readString(data, data._pos);
              if (d === void 0) return new Error("Malformed OpenSSH private key");
              const iqmp = readString(data, data._pos);
              if (iqmp === void 0) return new Error("Malformed OpenSSH private key");
              const p = readString(data, data._pos);
              if (p === void 0) return new Error("Malformed OpenSSH private key");
              const q = readString(data, data._pos);
              if (q === void 0) return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLRSAPub(n, e);
              pubSSH = genOpenSSHRSAPub(n, e);
              privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p, q);
              algo = "sha1";
              break;
            }
            case "ssh-dss": {
              const p = readString(data, data._pos);
              if (p === void 0) return new Error("Malformed OpenSSH private key");
              const q = readString(data, data._pos);
              if (q === void 0) return new Error("Malformed OpenSSH private key");
              const g = readString(data, data._pos);
              if (g === void 0) return new Error("Malformed OpenSSH private key");
              const y = readString(data, data._pos);
              if (y === void 0) return new Error("Malformed OpenSSH private key");
              const x = readString(data, data._pos);
              if (x === void 0) return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLDSAPub(p, q, g, y);
              pubSSH = genOpenSSHDSAPub(p, q, g, y);
              privPEM = genOpenSSLDSAPriv(p, q, g, y, x);
              algo = "sha1";
              break;
            }
            case "ssh-ed25519": {
              if (!eddsaSupported) return new Error(`Unsupported OpenSSH private key type: ${type}`);
              const edpub = readString(data, data._pos);
              if (edpub === void 0 || edpub.length !== 32) return new Error("Malformed OpenSSH private key");
              const edpriv = readString(data, data._pos);
              if (edpriv === void 0 || edpriv.length !== 64) return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLEdPub(edpub);
              pubSSH = genOpenSSHEdPub(edpub);
              privPEM = genOpenSSLEdPriv(bufferSlice(edpriv, 0, 32));
              algo = null;
              break;
            }
            case "ecdsa-sha2-nistp256":
              algo = "sha256";
              oid = "1.2.840.10045.3.1.7";
            // FALLTHROUGH
            case "ecdsa-sha2-nistp384":
              if (algo === void 0) {
                algo = "sha384";
                oid = "1.3.132.0.34";
              }
            // FALLTHROUGH
            case "ecdsa-sha2-nistp521": {
              if (algo === void 0) {
                algo = "sha512";
                oid = "1.3.132.0.35";
              }
              if (!skipFields(data, 1)) return new Error("Malformed OpenSSH private key");
              const ecpub = readString(data, data._pos);
              if (ecpub === void 0) return new Error("Malformed OpenSSH private key");
              const ecpriv = readString(data, data._pos);
              if (ecpriv === void 0) return new Error("Malformed OpenSSH private key");
              pubPEM = genOpenSSLECDSAPub(oid, ecpub);
              pubSSH = genOpenSSHECDSAPub(oid, ecpub);
              privPEM = genOpenSSLECDSAPriv(oid, ecpub, ecpriv);
              break;
            }
            default:
              return new Error(`Unsupported OpenSSH private key type: ${type}`);
          }
          const privComment = readString(data, data._pos, true);
          if (privComment === void 0) return new Error("Malformed OpenSSH private key");
          keys.push(new OpenSSH_Private(type, privComment, privPEM, pubPEM, pubSSH, algo, decrypted));
        }
        let cnt = 0;
        for (i = data._pos; i < data.length; ++i) {
          if (data[i] !== ++cnt % 255) return new Error("Malformed OpenSSH private key");
        }
        return keys;
      };
      __name(parseOpenSSHPrivKeys, "parseOpenSSHPrivKeys");
      const regexp = /^-----BEGIN OPENSSH PRIVATE KEY-----(?:\r\n|\n)([\s\S]+)(?:\r\n|\n)-----END OPENSSH PRIVATE KEY-----$/;
      OpenSSH_Private.parse = (str, passphrase) => {
        const m = regexp.exec(str);
        if (m === null) return null;
        let ret;
        const data = Buffer.from(m[1], "base64");
        if (data.length < 31) return new Error("Malformed OpenSSH private key");
        const magic = data.utf8Slice(0, 15);
        if (magic !== "openssh-key-v1\0") return new Error(`Unsupported OpenSSH key magic: ${magic}`);
        const cipherName = readString(data, 15, true);
        if (cipherName === void 0) return new Error("Malformed OpenSSH private key");
        if (cipherName !== "none" && SUPPORTED_CIPHER.indexOf(cipherName) === -1) return new Error(`Unsupported cipher for OpenSSH key: ${cipherName}`);
        const kdfName = readString(data, data._pos, true);
        if (kdfName === void 0) return new Error("Malformed OpenSSH private key");
        if (kdfName !== "none") {
          if (cipherName === "none") return new Error("Malformed OpenSSH private key");
          if (kdfName !== "bcrypt") return new Error(`Unsupported kdf name for OpenSSH key: ${kdfName}`);
          if (!passphrase) {
            return new Error("Encrypted private OpenSSH key detected, but no passphrase given");
          }
        } else if (cipherName !== "none") {
          return new Error("Malformed OpenSSH private key");
        }
        let encInfo;
        let cipherKey;
        let cipherIV;
        if (cipherName !== "none") encInfo = CIPHER_INFO[cipherName];
        const kdfOptions = readString(data, data._pos);
        if (kdfOptions === void 0) return new Error("Malformed OpenSSH private key");
        if (kdfOptions.length) {
          switch (kdfName) {
            case "none":
              return new Error("Malformed OpenSSH private key");
            case "bcrypt": {
              const salt = readString(kdfOptions, 0);
              if (salt === void 0 || kdfOptions._pos + 4 > kdfOptions.length) return new Error("Malformed OpenSSH private key");
              const rounds = readUInt32BE(kdfOptions, kdfOptions._pos);
              const gen = Buffer.allocUnsafe(encInfo.keyLen + encInfo.ivLen);
              const r = bcrypt_pbkdf(passphrase, passphrase.length, salt, salt.length, gen, gen.length, rounds);
              if (r !== 0) return new Error("Failed to generate information to decrypt key");
              cipherKey = bufferSlice(gen, 0, encInfo.keyLen);
              cipherIV = bufferSlice(gen, encInfo.keyLen, gen.length);
              break;
            }
          }
        } else if (kdfName !== "none") {
          return new Error("Malformed OpenSSH private key");
        }
        if (data._pos + 3 >= data.length) return new Error("Malformed OpenSSH private key");
        const keyCount = readUInt32BE(data, data._pos);
        data._pos += 4;
        if (keyCount > 0) {
          for (let i = 0; i < keyCount; ++i) {
            const pubData = readString(data, data._pos);
            if (pubData === void 0) return new Error("Malformed OpenSSH private key");
            const type = readString(pubData, 0, true);
            if (type === void 0) return new Error("Malformed OpenSSH private key");
          }
          let privBlob = readString(data, data._pos);
          if (privBlob === void 0) return new Error("Malformed OpenSSH private key");
          if (cipherKey !== void 0) {
            if (privBlob.length < encInfo.blockLen || privBlob.length % encInfo.blockLen !== 0) {
              return new Error("Malformed OpenSSH private key");
            }
            try {
              const options = {
                authTagLength: encInfo.authLen
              };
              const decipher = createDecipheriv(encInfo.sslName, cipherKey, cipherIV, options);
              decipher.setAutoPadding(false);
              if (encInfo.authLen > 0) {
                if (data.length - data._pos < encInfo.authLen) return new Error("Malformed OpenSSH private key");
                decipher.setAuthTag(bufferSlice(data, data._pos, data._pos += encInfo.authLen));
              }
              privBlob = combineBuffers(decipher.update(privBlob), decipher.final());
            } catch (ex) {
              return ex;
            }
          }
          if (data._pos !== data.length) return new Error("Malformed OpenSSH private key");
          ret = parseOpenSSHPrivKeys(privBlob, keyCount, cipherKey !== void 0);
        } else {
          ret = [];
        }
        if (ret instanceof Error) return ret;
        return ret[0];
      };
    }
    function OpenSSH_Old_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    __name(OpenSSH_Old_Private, "OpenSSH_Old_Private");
    OpenSSH_Old_Private.prototype = BaseKey;
    {
      const regexp = /^-----BEGIN (RSA|DSA|EC) PRIVATE KEY-----(?:\r\n|\n)((?:[^:]+:\s*[\S].*(?:\r\n|\n))*)([\s\S]+)(?:\r\n|\n)-----END (RSA|DSA|EC) PRIVATE KEY-----$/;
      OpenSSH_Old_Private.parse = (str, passphrase) => {
        const m = regexp.exec(str);
        if (m === null) return null;
        let privBlob = Buffer.from(m[3], "base64");
        let headers = m[2];
        let decrypted = false;
        if (headers !== void 0) {
          headers = headers.split(/\r\n|\n/g);
          for (let i = 0; i < headers.length; ++i) {
            const header = headers[i];
            let sepIdx = header.indexOf(":");
            if (header.slice(0, sepIdx) === "DEK-Info") {
              const val = header.slice(sepIdx + 2);
              sepIdx = val.indexOf(",");
              if (sepIdx === -1) continue;
              const cipherName = val.slice(0, sepIdx).toLowerCase();
              if (supportedOpenSSLCiphers.indexOf(cipherName) === -1) {
                return new Error(`Cipher (${cipherName}) not supported for encrypted OpenSSH private key`);
              }
              const encInfo = CIPHER_INFO_OPENSSL[cipherName];
              if (!encInfo) {
                return new Error(`Cipher (${cipherName}) not supported for encrypted OpenSSH private key`);
              }
              const cipherIV = Buffer.from(val.slice(sepIdx + 1), "hex");
              if (cipherIV.length !== encInfo.ivLen) return new Error("Malformed encrypted OpenSSH private key");
              if (!passphrase) {
                return new Error("Encrypted OpenSSH private key detected, but no passphrase given");
              }
              const ivSlice = bufferSlice(cipherIV, 0, 8);
              let cipherKey = createHash("md5").update(passphrase).update(ivSlice).digest();
              while (cipherKey.length < encInfo.keyLen) {
                cipherKey = combineBuffers(cipherKey, createHash("md5").update(cipherKey).update(passphrase).update(ivSlice).digest());
              }
              if (cipherKey.length > encInfo.keyLen) cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);
              try {
                const decipher = createDecipheriv(cipherName, cipherKey, cipherIV);
                decipher.setAutoPadding(false);
                privBlob = combineBuffers(decipher.update(privBlob), decipher.final());
                decrypted = true;
              } catch (ex) {
                return ex;
              }
            }
          }
        }
        let type;
        let privPEM;
        let pubPEM;
        let pubSSH;
        let algo;
        let reader;
        let errMsg = "Malformed OpenSSH private key";
        if (decrypted) errMsg += ". Bad passphrase?";
        switch (m[1]) {
          case "RSA":
            type = "ssh-rsa";
            privPEM = makePEM("RSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              const n = reader.readString(Ber.Integer, true);
              if (n === null) return new Error(errMsg);
              const e = reader.readString(Ber.Integer, true);
              if (e === null) return new Error(errMsg);
              pubPEM = genOpenSSLRSAPub(n, e);
              pubSSH = genOpenSSHRSAPub(n, e);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "DSA":
            type = "ssh-dss";
            privPEM = makePEM("DSA PRIVATE", privBlob);
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              const p = reader.readString(Ber.Integer, true);
              if (p === null) return new Error(errMsg);
              const q = reader.readString(Ber.Integer, true);
              if (q === null) return new Error(errMsg);
              const g = reader.readString(Ber.Integer, true);
              if (g === null) return new Error(errMsg);
              const y = reader.readString(Ber.Integer, true);
              if (y === null) return new Error(errMsg);
              pubPEM = genOpenSSLDSAPub(p, q, g, y);
              pubSSH = genOpenSSHDSAPub(p, q, g, y);
            } catch {
              return new Error(errMsg);
            }
            algo = "sha1";
            break;
          case "EC": {
            let ecSSLName;
            let ecPriv;
            let ecOID;
            try {
              reader = new Ber.Reader(privBlob);
              reader.readSequence();
              reader.readInt();
              ecPriv = reader.readString(Ber.OctetString, true);
              reader.readByte();
              const offset = reader.readLength();
              if (offset !== null) {
                reader._offset = offset;
                ecOID = reader.readOID();
                if (ecOID === null) return new Error(errMsg);
                switch (ecOID) {
                  case "1.2.840.10045.3.1.7":
                    ecSSLName = "prime256v1";
                    type = "ecdsa-sha2-nistp256";
                    algo = "sha256";
                    break;
                  case "1.3.132.0.34":
                    ecSSLName = "secp384r1";
                    type = "ecdsa-sha2-nistp384";
                    algo = "sha384";
                    break;
                  case "1.3.132.0.35":
                    ecSSLName = "secp521r1";
                    type = "ecdsa-sha2-nistp521";
                    algo = "sha512";
                    break;
                  default:
                    return new Error(`Unsupported private key EC OID: ${ecOID}`);
                }
              } else {
                return new Error(errMsg);
              }
            } catch {
              return new Error(errMsg);
            }
            privPEM = makePEM("EC PRIVATE", privBlob);
            const pubBlob = genOpenSSLECDSAPubFromPriv(ecSSLName, ecPriv);
            pubPEM = genOpenSSLECDSAPub(ecOID, pubBlob);
            pubSSH = genOpenSSHECDSAPub(ecOID, pubBlob);
            break;
          }
        }
        return new OpenSSH_Old_Private(type, "", privPEM, pubPEM, pubSSH, algo, decrypted);
      };
    }
    function PPK_Private(type, comment, privPEM, pubPEM, pubSSH, algo, decrypted) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = privPEM;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = decrypted;
    }
    __name(PPK_Private, "PPK_Private");
    PPK_Private.prototype = BaseKey;
    {
      const EMPTY_PASSPHRASE = Buffer.alloc(0);
      const PPK_IV = Buffer.from([
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0,
        0
      ]);
      const PPK_PP1 = Buffer.from([
        0,
        0,
        0,
        0
      ]);
      const PPK_PP2 = Buffer.from([
        0,
        0,
        0,
        1
      ]);
      const regexp = /^PuTTY-User-Key-File-2: (ssh-(?:rsa|dss))\r?\nEncryption: (aes256-cbc|none)\r?\nComment: ([^\r\n]*)\r?\nPublic-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-Lines: \d+\r?\n([\s\S]+?)\r?\nPrivate-MAC: ([^\r\n]+)/;
      PPK_Private.parse = (str, passphrase) => {
        const m = regexp.exec(str);
        if (m === null) return null;
        const cipherName = m[2];
        const encrypted = cipherName !== "none";
        if (encrypted && !passphrase) {
          return new Error("Encrypted PPK private key detected, but no passphrase given");
        }
        let privBlob = Buffer.from(m[5], "base64");
        if (encrypted) {
          const encInfo = CIPHER_INFO[cipherName];
          let cipherKey = combineBuffers(createHash("sha1").update(PPK_PP1).update(passphrase).digest(), createHash("sha1").update(PPK_PP2).update(passphrase).digest());
          if (cipherKey.length > encInfo.keyLen) cipherKey = bufferSlice(cipherKey, 0, encInfo.keyLen);
          try {
            const decipher = createDecipheriv(encInfo.sslName, cipherKey, PPK_IV);
            decipher.setAutoPadding(false);
            privBlob = combineBuffers(decipher.update(privBlob), decipher.final());
          } catch (ex) {
            return ex;
          }
        }
        const type = m[1];
        const comment = m[3];
        const pubBlob = Buffer.from(m[4], "base64");
        const mac = m[6];
        const typeLen = type.length;
        const cipherNameLen = cipherName.length;
        const commentLen = Buffer.byteLength(comment);
        const pubLen = pubBlob.length;
        const privLen = privBlob.length;
        const macData = Buffer.allocUnsafe(4 + typeLen + 4 + cipherNameLen + 4 + commentLen + 4 + pubLen + 4 + privLen);
        let p = 0;
        writeUInt32BE(macData, typeLen, p);
        macData.utf8Write(type, p += 4, typeLen);
        writeUInt32BE(macData, cipherNameLen, p += typeLen);
        macData.utf8Write(cipherName, p += 4, cipherNameLen);
        writeUInt32BE(macData, commentLen, p += cipherNameLen);
        macData.utf8Write(comment, p += 4, commentLen);
        writeUInt32BE(macData, pubLen, p += commentLen);
        macData.set(pubBlob, p += 4);
        writeUInt32BE(macData, privLen, p += pubLen);
        macData.set(privBlob, p + 4);
        if (!passphrase) passphrase = EMPTY_PASSPHRASE;
        const calcMAC = createHmac("sha1", createHash("sha1").update("putty-private-key-file-mac-key").update(passphrase).digest()).update(macData).digest("hex");
        if (calcMAC !== mac) {
          if (encrypted) {
            return new Error("PPK private key integrity check failed -- bad passphrase?");
          }
          return new Error("PPK private key integrity check failed");
        }
        let pubPEM;
        let pubSSH;
        let privPEM;
        pubBlob._pos = 0;
        skipFields(pubBlob, 1);
        switch (type) {
          case "ssh-rsa": {
            const e = readString(pubBlob, pubBlob._pos);
            if (e === void 0) return new Error("Malformed PPK public key");
            const n = readString(pubBlob, pubBlob._pos);
            if (n === void 0) return new Error("Malformed PPK public key");
            const d = readString(privBlob, 0);
            if (d === void 0) return new Error("Malformed PPK private key");
            const p2 = readString(privBlob, privBlob._pos);
            if (p2 === void 0) return new Error("Malformed PPK private key");
            const q = readString(privBlob, privBlob._pos);
            if (q === void 0) return new Error("Malformed PPK private key");
            const iqmp = readString(privBlob, privBlob._pos);
            if (iqmp === void 0) return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLRSAPub(n, e);
            pubSSH = genOpenSSHRSAPub(n, e);
            privPEM = genOpenSSLRSAPriv(n, e, d, iqmp, p2, q);
            break;
          }
          case "ssh-dss": {
            const p2 = readString(pubBlob, pubBlob._pos);
            if (p2 === void 0) return new Error("Malformed PPK public key");
            const q = readString(pubBlob, pubBlob._pos);
            if (q === void 0) return new Error("Malformed PPK public key");
            const g = readString(pubBlob, pubBlob._pos);
            if (g === void 0) return new Error("Malformed PPK public key");
            const y = readString(pubBlob, pubBlob._pos);
            if (y === void 0) return new Error("Malformed PPK public key");
            const x = readString(privBlob, 0);
            if (x === void 0) return new Error("Malformed PPK private key");
            pubPEM = genOpenSSLDSAPub(p2, q, g, y);
            pubSSH = genOpenSSHDSAPub(p2, q, g, y);
            privPEM = genOpenSSLDSAPriv(p2, q, g, y, x);
            break;
          }
        }
        return new PPK_Private(type, comment, privPEM, pubPEM, pubSSH, "sha1", encrypted);
      };
    }
    function OpenSSH_Public(type, comment, pubPEM, pubSSH, algo) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = null;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = false;
    }
    __name(OpenSSH_Public, "OpenSSH_Public");
    OpenSSH_Public.prototype = BaseKey;
    {
      let regexp;
      if (eddsaSupported) regexp = /^(((?:ssh-(?:rsa|dss|ed25519))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
      else regexp = /^(((?:ssh-(?:rsa|dss))|ecdsa-sha2-nistp(?:256|384|521))(?:-cert-v0[01]@openssh.com)?) ([A-Z0-9a-z/+=]+)(?:$|\s+([\S].*)?)$/;
      OpenSSH_Public.parse = (str) => {
        const m = regexp.exec(str);
        if (m === null) return null;
        const fullType = m[1];
        const baseType = m[2];
        const data = Buffer.from(m[3], "base64");
        const comment = m[4] || "";
        const type = readString(data, data._pos, true);
        if (type === void 0 || type.indexOf(baseType) !== 0) return new Error("Malformed OpenSSH public key");
        return parseDER(data, baseType, comment, fullType);
      };
    }
    function RFC4716_Public(type, comment, pubPEM, pubSSH, algo) {
      this.type = type;
      this.comment = comment;
      this[SYM_PRIV_PEM] = null;
      this[SYM_PUB_PEM] = pubPEM;
      this[SYM_PUB_SSH] = pubSSH;
      this[SYM_HASH_ALGO] = algo;
      this[SYM_DECRYPTED] = false;
    }
    __name(RFC4716_Public, "RFC4716_Public");
    RFC4716_Public.prototype = BaseKey;
    {
      const regexp = /^---- BEGIN SSH2 PUBLIC KEY ----(?:\r?\n)((?:.{0,72}\r?\n)+)---- END SSH2 PUBLIC KEY ----$/;
      const RE_DATA = /^[A-Z0-9a-z/+=\r\n]+$/;
      const RE_HEADER = /^([\x21-\x39\x3B-\x7E]{1,64}): ((?:[^\\]*\\\r?\n)*[^\r\n]+)\r?\n/gm;
      const RE_HEADER_ENDS = /\\\r?\n/g;
      RFC4716_Public.parse = (str) => {
        let m = regexp.exec(str);
        if (m === null) return null;
        const body = m[1];
        let dataStart = 0;
        let comment = "";
        while (m = RE_HEADER.exec(body)) {
          const headerName = m[1];
          const headerValue = m[2].replace(RE_HEADER_ENDS, "");
          if (headerValue.length > 1024) {
            RE_HEADER.lastIndex = 0;
            return new Error("Malformed RFC4716 public key");
          }
          dataStart = RE_HEADER.lastIndex;
          if (headerName.toLowerCase() === "comment") {
            comment = headerValue;
            if (comment.length > 1 && comment.charCodeAt(0) === 34 && comment.charCodeAt(comment.length - 1) === 34) {
              comment = comment.slice(1, -1);
            }
          }
        }
        let data = body.slice(dataStart);
        if (!RE_DATA.test(data)) return new Error("Malformed RFC4716 public key");
        data = Buffer.from(data, "base64");
        const type = readString(data, 0, true);
        if (type === void 0) return new Error("Malformed RFC4716 public key");
        let pubPEM = null;
        let pubSSH = null;
        switch (type) {
          case "ssh-rsa": {
            const e = readString(data, data._pos);
            if (e === void 0) return new Error("Malformed RFC4716 public key");
            const n = readString(data, data._pos);
            if (n === void 0) return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLRSAPub(n, e);
            pubSSH = genOpenSSHRSAPub(n, e);
            break;
          }
          case "ssh-dss": {
            const p = readString(data, data._pos);
            if (p === void 0) return new Error("Malformed RFC4716 public key");
            const q = readString(data, data._pos);
            if (q === void 0) return new Error("Malformed RFC4716 public key");
            const g = readString(data, data._pos);
            if (g === void 0) return new Error("Malformed RFC4716 public key");
            const y = readString(data, data._pos);
            if (y === void 0) return new Error("Malformed RFC4716 public key");
            pubPEM = genOpenSSLDSAPub(p, q, g, y);
            pubSSH = genOpenSSHDSAPub(p, q, g, y);
            break;
          }
          default:
            return new Error("Malformed RFC4716 public key");
        }
        return new RFC4716_Public(type, comment, pubPEM, pubSSH, "sha1");
      };
    }
    function parseDER(data, baseType, comment, fullType) {
      if (!isSupportedKeyType(baseType)) return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      let algo;
      let oid;
      let pubPEM = null;
      let pubSSH = null;
      switch (baseType) {
        case "ssh-rsa": {
          const e = readString(data, data._pos || 0);
          if (e === void 0) return new Error("Malformed OpenSSH public key");
          const n = readString(data, data._pos);
          if (n === void 0) return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLRSAPub(n, e);
          pubSSH = genOpenSSHRSAPub(n, e);
          algo = "sha1";
          break;
        }
        case "ssh-dss": {
          const p = readString(data, data._pos || 0);
          if (p === void 0) return new Error("Malformed OpenSSH public key");
          const q = readString(data, data._pos);
          if (q === void 0) return new Error("Malformed OpenSSH public key");
          const g = readString(data, data._pos);
          if (g === void 0) return new Error("Malformed OpenSSH public key");
          const y = readString(data, data._pos);
          if (y === void 0) return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLDSAPub(p, q, g, y);
          pubSSH = genOpenSSHDSAPub(p, q, g, y);
          algo = "sha1";
          break;
        }
        case "ssh-ed25519": {
          const edpub = readString(data, data._pos || 0);
          if (edpub === void 0 || edpub.length !== 32) return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLEdPub(edpub);
          pubSSH = genOpenSSHEdPub(edpub);
          algo = null;
          break;
        }
        case "ecdsa-sha2-nistp256":
          algo = "sha256";
          oid = "1.2.840.10045.3.1.7";
        // FALLTHROUGH
        case "ecdsa-sha2-nistp384":
          if (algo === void 0) {
            algo = "sha384";
            oid = "1.3.132.0.34";
          }
        // FALLTHROUGH
        case "ecdsa-sha2-nistp521": {
          if (algo === void 0) {
            algo = "sha512";
            oid = "1.3.132.0.35";
          }
          if (!skipFields(data, 1)) return new Error("Malformed OpenSSH public key");
          const ecpub = readString(data, data._pos || 0);
          if (ecpub === void 0) return new Error("Malformed OpenSSH public key");
          pubPEM = genOpenSSLECDSAPub(oid, ecpub);
          pubSSH = genOpenSSHECDSAPub(oid, ecpub);
          break;
        }
        default:
          return new Error(`Unsupported OpenSSH public key type: ${baseType}`);
      }
      return new OpenSSH_Public(fullType, comment, pubPEM, pubSSH, algo);
    }
    __name(parseDER, "parseDER");
    function isSupportedKeyType(type) {
      switch (type) {
        case "ssh-rsa":
        case "ssh-dss":
        case "ecdsa-sha2-nistp256":
        case "ecdsa-sha2-nistp384":
        case "ecdsa-sha2-nistp521":
          return true;
        case "ssh-ed25519":
          if (eddsaSupported) return true;
        // FALLTHROUGH
        default:
          return false;
      }
    }
    __name(isSupportedKeyType, "isSupportedKeyType");
    function isParsedKey(val) {
      if (!val) return false;
      return typeof val[SYM_DECRYPTED] === "boolean";
    }
    __name(isParsedKey, "isParsedKey");
    function parseKey(data, passphrase) {
      if (isParsedKey(data)) return data;
      let origBuffer;
      if (Buffer.isBuffer(data)) {
        origBuffer = data;
        data = data.utf8Slice(0, data.length).trim();
      } else if (typeof data === "string") {
        data = data.trim();
      } else {
        return new Error("Key data must be a Buffer or string");
      }
      if (passphrase != void 0) {
        if (typeof passphrase === "string") passphrase = Buffer.from(passphrase);
        else if (!Buffer.isBuffer(passphrase)) return new Error("Passphrase must be a string or Buffer when supplied");
      }
      let ret;
      if ((ret = OpenSSH_Private.parse(data, passphrase)) !== null) return ret;
      if ((ret = OpenSSH_Old_Private.parse(data, passphrase)) !== null) return ret;
      if ((ret = PPK_Private.parse(data, passphrase)) !== null) return ret;
      if ((ret = OpenSSH_Public.parse(data)) !== null) return ret;
      if ((ret = RFC4716_Public.parse(data)) !== null) return ret;
      if (origBuffer) {
        binaryKeyParser.init(origBuffer, 0);
        const type = binaryKeyParser.readString(true);
        if (type !== void 0) {
          data = binaryKeyParser.readRaw();
          if (data !== void 0) {
            ret = parseDER(data, type, "", type);
            if (ret instanceof Error) ret = null;
          }
        }
        binaryKeyParser.clear();
      }
      if (ret) return ret;
      return new Error("Unsupported key format");
    }
    __name(parseKey, "parseKey");
    module2.exports = {
      isParsedKey,
      isSupportedKeyType,
      parseDERKey: /* @__PURE__ */ __name((data, type) => parseDER(data, type, "", type), "parseDERKey"),
      parseKey
    };
  }
});

// node_modules/ssh2/lib/agent.js
var require_agent = __commonJS({
  "node_modules/ssh2/lib/agent.js"(exports2, module2) {
    "use strict";
    var { Socket: Socket3 } = require("net");
    var { Duplex } = require("stream");
    var { resolve: resolve5 } = require("path");
    var { readFile } = require("fs");
    var { execFile, spawn } = require("child_process");
    var { isParsedKey, parseKey } = require_keyParser();
    var { makeBufferParser, readUInt32BE, writeUInt32BE, writeUInt32LE } = require_utils2();
    function once(cb) {
      let called = false;
      return (...args) => {
        if (called) return;
        called = true;
        cb(...args);
      };
    }
    __name(once, "once");
    function concat(buf1, buf2) {
      const combined = Buffer.allocUnsafe(buf1.length + buf2.length);
      buf1.copy(combined, 0);
      buf2.copy(combined, buf1.length);
      return combined;
    }
    __name(concat, "concat");
    function noop() {
    }
    __name(noop, "noop");
    var EMPTY_BUF = Buffer.alloc(0);
    var binaryParser = makeBufferParser();
    var BaseAgent = class BaseAgent {
      static {
        __name(this, "BaseAgent");
      }
      getIdentities(cb) {
        cb(new Error("Missing getIdentities() implementation"));
      }
      sign(pubKey, data, options, cb) {
        if (typeof options === "function") cb = options;
        cb(new Error("Missing sign() implementation"));
      }
    };
    var OpenSSHAgent = class OpenSSHAgent extends BaseAgent {
      static {
        __name(this, "OpenSSHAgent");
      }
      constructor(socketPath) {
        super();
        this.socketPath = socketPath;
      }
      getStream(cb) {
        cb = once(cb);
        const sock = new Socket3();
        sock.on("connect", () => {
          cb(null, sock);
        });
        sock.on("close", onFail).on("end", onFail).on("error", onFail);
        sock.connect(this.socketPath);
        function onFail() {
          try {
            sock.destroy();
          } catch {
          }
          cb(new Error("Failed to connect to agent"));
        }
        __name(onFail, "onFail");
      }
      getIdentities(cb) {
        cb = once(cb);
        this.getStream((err, stream) => {
          function onFail(err2) {
            if (stream) {
              try {
                stream.destroy();
              } catch {
              }
            }
            if (!err2) err2 = new Error("Failed to retrieve identities from agent");
            cb(err2);
          }
          __name(onFail, "onFail");
          if (err) return onFail(err);
          const protocol4 = new AgentProtocol(true);
          protocol4.on("error", onFail);
          protocol4.pipe(stream).pipe(protocol4);
          stream.on("close", onFail).on("end", onFail).on("error", onFail);
          protocol4.getIdentities((err2, keys) => {
            if (err2) return onFail(err2);
            try {
              stream.destroy();
            } catch {
            }
            cb(null, keys);
          });
        });
      }
      sign(pubKey, data, options, cb) {
        if (typeof options === "function") {
          cb = options;
          options = void 0;
        } else if (typeof options !== "object" || options === null) {
          options = void 0;
        }
        cb = once(cb);
        this.getStream((err, stream) => {
          function onFail(err2) {
            if (stream) {
              try {
                stream.destroy();
              } catch {
              }
            }
            if (!err2) err2 = new Error("Failed to sign data with agent");
            cb(err2);
          }
          __name(onFail, "onFail");
          if (err) return onFail(err);
          const protocol4 = new AgentProtocol(true);
          protocol4.on("error", onFail);
          protocol4.pipe(stream).pipe(protocol4);
          stream.on("close", onFail).on("end", onFail).on("error", onFail);
          protocol4.sign(pubKey, data, options, (err2, sig) => {
            if (err2) return onFail(err2);
            try {
              stream.destroy();
            } catch {
            }
            cb(null, sig);
          });
        });
      }
    };
    var PageantAgent = (() => {
      const RET_ERR_BADARGS = 10;
      const RET_ERR_UNAVAILABLE = 11;
      const RET_ERR_NOMAP = 12;
      const RET_ERR_BINSTDIN = 13;
      const RET_ERR_BINSTDOUT = 14;
      const RET_ERR_BADLEN = 15;
      const EXEPATH = resolve5(__dirname, "..", "util/pagent.exe");
      const ERROR = {
        [RET_ERR_BADARGS]: new Error("Invalid pagent.exe arguments"),
        [RET_ERR_UNAVAILABLE]: new Error("Pageant is not running"),
        [RET_ERR_NOMAP]: new Error("pagent.exe could not create an mmap"),
        [RET_ERR_BINSTDIN]: new Error("pagent.exe could not set mode for stdin"),
        [RET_ERR_BINSTDOUT]: new Error("pagent.exe could not set mode for stdout"),
        [RET_ERR_BADLEN]: new Error("pagent.exe did not get expected input payload")
      };
      function destroy(stream) {
        stream.buffer = null;
        if (stream.proc) {
          stream.proc.kill();
          stream.proc = void 0;
        }
      }
      __name(destroy, "destroy");
      let PageantSocket = class PageantSocket extends Duplex {
        static {
          __name(this, "PageantSocket");
        }
        constructor() {
          super();
          this.proc = void 0;
          this.buffer = null;
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this.buffer === null) {
            this.buffer = data;
          } else {
            const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
            this.buffer.copy(newBuffer, 0);
            data.copy(newBuffer, this.buffer.length);
            this.buffer = newBuffer;
          }
          if (this.buffer.length < 4) return cb();
          const len = readUInt32BE(this.buffer, 0);
          if (this.buffer.length - 4 < len) return cb();
          data = this.buffer.slice(0, 4 + len);
          if (this.buffer.length > 4 + len) return cb(new Error("Unexpected multiple agent requests"));
          this.buffer = null;
          let error;
          const proc = this.proc = spawn(EXEPATH, [
            data.length
          ]);
          proc.stdout.on("data", (data2) => {
            this.push(data2);
          });
          proc.on("error", (err) => {
            error = err;
            cb(error);
          });
          proc.on("close", (code) => {
            this.proc = void 0;
            if (!error) {
              if (error = ERROR[code]) return cb(error);
              cb();
            }
          });
          proc.stdin.end(data);
        }
        _final(cb) {
          destroy(this);
          cb();
        }
        _destroy(err, cb) {
          destroy(this);
          cb();
        }
      };
      return class PageantAgent extends OpenSSHAgent {
        static {
          __name(this, "PageantAgent");
        }
        getStream(cb) {
          cb(null, new PageantSocket());
        }
      };
    })();
    var CygwinAgent = /* @__PURE__ */ (() => {
      const RE_CYGWIN_SOCK = /^!<socket >(\d+) s ([A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8}-[A-Z0-9]{8})/;
      return class CygwinAgent extends OpenSSHAgent {
        static {
          __name(this, "CygwinAgent");
        }
        getStream(cb) {
          cb = once(cb);
          let socketPath = this.socketPath;
          let triedCygpath = false;
          readFile(socketPath, /* @__PURE__ */ __name(function readCygsocket(err, data) {
            if (err) {
              if (triedCygpath) return cb(new Error("Invalid cygwin unix socket path"));
              execFile("cygpath", [
                "-w",
                socketPath
              ], (err2, stdout, stderr) => {
                if (err2 || stdout.length === 0) return cb(new Error("Invalid cygwin unix socket path"));
                triedCygpath = true;
                socketPath = stdout.toString().replace(/[\r\n]/g, "");
                readFile(socketPath, readCygsocket);
              });
              return;
            }
            const m = RE_CYGWIN_SOCK.exec(data.toString("ascii"));
            if (!m) return cb(new Error("Malformed cygwin unix socket file"));
            let state;
            let bc = 0;
            let isRetrying = false;
            const inBuf = [];
            let sock;
            let credsBuf = Buffer.alloc(12);
            const port = parseInt(m[1], 10);
            const secret = m[2].replace(/-/g, "");
            const secretBuf = Buffer.allocUnsafe(16);
            for (let i = 0, j = 0; j < 32; ++i, j += 2) secretBuf[i] = parseInt(secret.substring(j, j + 2), 16);
            for (let i = 0; i < 16; i += 4) writeUInt32LE(secretBuf, readUInt32BE(secretBuf, i), i);
            tryConnect();
            function _onconnect() {
              bc = 0;
              state = "secret";
              sock.write(secretBuf);
            }
            __name(_onconnect, "_onconnect");
            function _ondata(data2) {
              bc += data2.length;
              if (state === "secret") {
                if (bc === 16) {
                  bc = 0;
                  state = "creds";
                  sock.write(credsBuf);
                }
                return;
              }
              if (state === "creds") {
                if (!isRetrying) inBuf.push(data2);
                if (bc === 12) {
                  sock.removeListener("connect", _onconnect);
                  sock.removeListener("data", _ondata);
                  sock.removeListener("error", onFail);
                  sock.removeListener("end", onFail);
                  sock.removeListener("close", onFail);
                  if (isRetrying) return cb(null, sock);
                  isRetrying = true;
                  credsBuf = Buffer.concat(inBuf);
                  writeUInt32LE(credsBuf, process.pid, 0);
                  sock.on("error", () => {
                  });
                  sock.destroy();
                  tryConnect();
                }
              }
            }
            __name(_ondata, "_ondata");
            function onFail() {
              cb(new Error("Problem negotiating cygwin unix socket security"));
            }
            __name(onFail, "onFail");
            function tryConnect() {
              sock = new Socket3();
              sock.on("connect", _onconnect);
              sock.on("data", _ondata);
              sock.on("error", onFail);
              sock.on("end", onFail);
              sock.on("close", onFail);
              sock.connect(port);
            }
            __name(tryConnect, "tryConnect");
          }, "readCygsocket"));
        }
      };
    })();
    var WINDOWS_PIPE_REGEX = /^[/\\][/\\]\.[/\\]pipe[/\\].+/;
    function createAgent(path) {
      if (process.platform === "win32" && !WINDOWS_PIPE_REGEX.test(path)) {
        return path === "pageant" ? new PageantAgent() : new CygwinAgent(path);
      }
      return new OpenSSHAgent(path);
    }
    __name(createAgent, "createAgent");
    var AgentProtocol = (() => {
      const SSH_AGENTC_REQUEST_IDENTITIES = 11;
      const SSH_AGENTC_SIGN_REQUEST = 13;
      const SSH_AGENT_FAILURE = 5;
      const SSH_AGENT_IDENTITIES_ANSWER = 12;
      const SSH_AGENT_SIGN_RESPONSE = 14;
      const SSH_AGENT_RSA_SHA2_256 = 1 << 1;
      const SSH_AGENT_RSA_SHA2_512 = 1 << 2;
      const ROLE_CLIENT = 0;
      const ROLE_SERVER = 1;
      function processResponses(protocol4) {
        let ret;
        while (protocol4[SYM_REQS].length) {
          const nextResponse = protocol4[SYM_REQS][0][SYM_RESP];
          if (nextResponse === void 0) break;
          protocol4[SYM_REQS].shift();
          ret = protocol4.push(nextResponse);
        }
        return ret;
      }
      __name(processResponses, "processResponses");
      const SYM_TYPE = Symbol("Inbound Request Type");
      const SYM_RESP = Symbol("Inbound Request Response");
      const SYM_CTX = Symbol("Inbound Request Context");
      let AgentInboundRequest = class AgentInboundRequest {
        static {
          __name(this, "AgentInboundRequest");
        }
        constructor(type, ctx) {
          this[SYM_TYPE] = type;
          this[SYM_RESP] = void 0;
          this[SYM_CTX] = ctx;
        }
        hasResponded() {
          return this[SYM_RESP] !== void 0;
        }
        getType() {
          return this[SYM_TYPE];
        }
        getContext() {
          return this[SYM_CTX];
        }
      };
      function respond(protocol4, req, data) {
        req[SYM_RESP] = data;
        return processResponses(protocol4);
      }
      __name(respond, "respond");
      function cleanup(protocol4) {
        protocol4[SYM_BUFFER] = null;
        if (protocol4[SYM_MODE] === ROLE_CLIENT) {
          const reqs = protocol4[SYM_REQS];
          if (reqs && reqs.length) {
            protocol4[SYM_REQS] = [];
            for (const req of reqs) req.cb(new Error("No reply from server"));
          }
        }
        try {
          protocol4.end();
        } catch {
        }
        setImmediate(() => {
          if (!protocol4[SYM_ENDED]) protocol4.emit("end");
          if (!protocol4[SYM_CLOSED]) protocol4.emit("close");
        });
      }
      __name(cleanup, "cleanup");
      function onClose() {
        this[SYM_CLOSED] = true;
      }
      __name(onClose, "onClose");
      function onEnd() {
        this[SYM_ENDED] = true;
      }
      __name(onEnd, "onEnd");
      const SYM_REQS = Symbol("Requests");
      const SYM_MODE = Symbol("Agent Protocol Role");
      const SYM_BUFFER = Symbol("Agent Protocol Buffer");
      const SYM_MSGLEN = Symbol("Agent Protocol Current Message Length");
      const SYM_CLOSED = Symbol("Agent Protocol Closed");
      const SYM_ENDED = Symbol("Agent Protocol Ended");
      return class AgentProtocol extends Duplex {
        static {
          __name(this, "AgentProtocol");
        }
        /*
            Notes:
              - `constraint` type consists of:
                   byte                    constraint_type
                   byte[]                  constraint_data
                where `constraint_type` is one of:
                  * SSH_AGENT_CONSTRAIN_LIFETIME
                    - `constraint_data` consists of:
                         uint32                  seconds
                  * SSH_AGENT_CONSTRAIN_CONFIRM
                    - `constraint_data` N/A
                  * SSH_AGENT_CONSTRAIN_EXTENSION
                    - `constraint_data` consists of:
                         string                  extension name
                         byte[]                  extension-specific details
        */
        constructor(isClient) {
          super({
            autoDestroy: true,
            emitClose: false
          });
          this[SYM_MODE] = isClient ? ROLE_CLIENT : ROLE_SERVER;
          this[SYM_REQS] = [];
          this[SYM_BUFFER] = null;
          this[SYM_MSGLEN] = -1;
          this.once("end", onEnd);
          this.once("close", onClose);
        }
        _read(n) {
        }
        _write(data, encoding, cb) {
          if (this[SYM_BUFFER] === null) this[SYM_BUFFER] = data;
          else this[SYM_BUFFER] = concat(this[SYM_BUFFER], data);
          let buffer = this[SYM_BUFFER];
          let bufferLen = buffer.length;
          let p = 0;
          while (p < bufferLen) {
            if (bufferLen < 5) break;
            if (this[SYM_MSGLEN] === -1) this[SYM_MSGLEN] = readUInt32BE(buffer, p);
            if (bufferLen < 4 + this[SYM_MSGLEN]) break;
            const msgType = buffer[p += 4];
            ++p;
            if (this[SYM_MODE] === ROLE_CLIENT) {
              if (this[SYM_REQS].length === 0) return cb(new Error("Received unexpected message from server"));
              const req = this[SYM_REQS].shift();
              switch (msgType) {
                case SSH_AGENT_FAILURE:
                  req.cb(new Error("Agent responded with failure"));
                  break;
                case SSH_AGENT_IDENTITIES_ANSWER: {
                  if (req.type !== SSH_AGENTC_REQUEST_IDENTITIES) return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  const numKeys = binaryParser.readUInt32BE();
                  if (numKeys === void 0) {
                    binaryParser.clear();
                    return cb(new Error("Malformed agent response"));
                  }
                  const keys = [];
                  for (let i = 0; i < numKeys; ++i) {
                    let pubKey = binaryParser.readString();
                    if (pubKey === void 0) {
                      binaryParser.clear();
                      return cb(new Error("Malformed agent response"));
                    }
                    const comment = binaryParser.readString(true);
                    if (comment === void 0) {
                      binaryParser.clear();
                      return cb(new Error("Malformed agent response"));
                    }
                    pubKey = parseKey(pubKey);
                    if (pubKey instanceof Error) continue;
                    pubKey.comment = pubKey.comment || comment;
                    keys.push(pubKey);
                  }
                  p = binaryParser.pos();
                  binaryParser.clear();
                  req.cb(null, keys);
                  break;
                }
                case SSH_AGENT_SIGN_RESPONSE: {
                  if (req.type !== SSH_AGENTC_SIGN_REQUEST) return cb(new Error("Agent responded with wrong message type"));
                  binaryParser.init(buffer, p);
                  let signature = binaryParser.readString();
                  p = binaryParser.pos();
                  binaryParser.clear();
                  if (signature === void 0) return cb(new Error("Malformed agent response"));
                  binaryParser.init(signature, 0);
                  binaryParser.readString(true);
                  signature = binaryParser.readString();
                  binaryParser.clear();
                  if (signature === void 0) return cb(new Error("Malformed OpenSSH signature format"));
                  req.cb(null, signature);
                  break;
                }
                default:
                  return cb(new Error("Agent responded with unsupported message type"));
              }
            } else {
              switch (msgType) {
                case SSH_AGENTC_REQUEST_IDENTITIES: {
                  const req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req);
                  this.emit("identities", req);
                  break;
                }
                case SSH_AGENTC_SIGN_REQUEST: {
                  binaryParser.init(buffer, p);
                  let pubKey = binaryParser.readString();
                  const data2 = binaryParser.readString();
                  const flagsVal = binaryParser.readUInt32BE();
                  p = binaryParser.pos();
                  binaryParser.clear();
                  if (flagsVal === void 0) {
                    const req2 = new AgentInboundRequest(msgType);
                    this[SYM_REQS].push(req2);
                    return this.failureReply(req2);
                  }
                  pubKey = parseKey(pubKey);
                  if (pubKey instanceof Error) {
                    const req2 = new AgentInboundRequest(msgType);
                    this[SYM_REQS].push(req2);
                    return this.failureReply(req2);
                  }
                  const flags = {
                    hash: void 0
                  };
                  let ctx;
                  if (pubKey.type === "ssh-rsa") {
                    if (flagsVal & SSH_AGENT_RSA_SHA2_256) {
                      ctx = "rsa-sha2-256";
                      flags.hash = "sha256";
                    } else if (flagsVal & SSH_AGENT_RSA_SHA2_512) {
                      ctx = "rsa-sha2-512";
                      flags.hash = "sha512";
                    }
                  }
                  if (ctx === void 0) ctx = pubKey.type;
                  const req = new AgentInboundRequest(msgType, ctx);
                  this[SYM_REQS].push(req);
                  this.emit("sign", req, pubKey, data2, flags);
                  break;
                }
                default: {
                  const req = new AgentInboundRequest(msgType);
                  this[SYM_REQS].push(req);
                  this.failureReply(req);
                }
              }
            }
            this[SYM_MSGLEN] = -1;
            if (p === bufferLen) {
              this[SYM_BUFFER] = null;
              break;
            } else {
              this[SYM_BUFFER] = buffer = buffer.slice(p);
              bufferLen = buffer.length;
              p = 0;
            }
          }
          cb();
        }
        _destroy(err, cb) {
          cleanup(this);
          cb();
        }
        _final(cb) {
          cleanup(this);
          cb();
        }
        // Client->Server messages =================================================
        sign(pubKey, data, options, cb) {
          if (this[SYM_MODE] !== ROLE_CLIENT) throw new Error("Client-only method called with server role");
          if (typeof options === "function") {
            cb = options;
            options = void 0;
          } else if (typeof options !== "object" || options === null) {
            options = void 0;
          }
          let flags = 0;
          pubKey = parseKey(pubKey);
          if (pubKey instanceof Error) throw new Error("Invalid public key argument");
          if (pubKey.type === "ssh-rsa" && options) {
            switch (options.hash) {
              case "sha256":
                flags = SSH_AGENT_RSA_SHA2_256;
                break;
              case "sha512":
                flags = SSH_AGENT_RSA_SHA2_512;
                break;
            }
          }
          pubKey = pubKey.getPublicSSH();
          const type = SSH_AGENTC_SIGN_REQUEST;
          const keyLen = pubKey.length;
          const dataLen = data.length;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1 + 4 + keyLen + 4 + dataLen + 4);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = type;
          writeUInt32BE(buf, keyLen, ++p);
          pubKey.copy(buf, p += 4);
          writeUInt32BE(buf, dataLen, p += keyLen);
          data.copy(buf, p += 4);
          writeUInt32BE(buf, flags, p += dataLen);
          if (typeof cb !== "function") cb = noop;
          this[SYM_REQS].push({
            type,
            cb
          });
          return this.push(buf);
        }
        getIdentities(cb) {
          if (this[SYM_MODE] !== ROLE_CLIENT) throw new Error("Client-only method called with server role");
          const type = SSH_AGENTC_REQUEST_IDENTITIES;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = type;
          if (typeof cb !== "function") cb = noop;
          this[SYM_REQS].push({
            type,
            cb
          });
          return this.push(buf);
        }
        // Server->Client messages =================================================
        failureReply(req) {
          if (this[SYM_MODE] !== ROLE_SERVER) throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest)) throw new Error("Wrong request argument");
          if (req.hasResponded()) return true;
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_FAILURE;
          return respond(this, req, buf);
        }
        getIdentitiesReply(req, keys) {
          if (this[SYM_MODE] !== ROLE_SERVER) throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest)) throw new Error("Wrong request argument");
          if (req.hasResponded()) return true;
          if (req.getType() !== SSH_AGENTC_REQUEST_IDENTITIES) throw new Error("Invalid response to request");
          if (!Array.isArray(keys)) throw new Error("Keys argument must be an array");
          let totalKeysLen = 4;
          const newKeys = [];
          for (let i = 0; i < keys.length; ++i) {
            const entry = keys[i];
            if (typeof entry !== "object" || entry === null) throw new Error(`Invalid key entry: ${entry}`);
            let pubKey;
            let comment;
            if (isParsedKey(entry)) {
              pubKey = entry;
            } else if (isParsedKey(entry.pubKey)) {
              pubKey = entry.pubKey;
            } else {
              if (typeof entry.pubKey !== "object" || entry.pubKey === null) continue;
              ({ pubKey, comment } = entry.pubKey);
              pubKey = parseKey(pubKey);
              if (pubKey instanceof Error) continue;
            }
            comment = pubKey.comment || comment;
            pubKey = pubKey.getPublicSSH();
            totalKeysLen += 4 + pubKey.length;
            if (comment && typeof comment === "string") comment = Buffer.from(comment);
            else if (!Buffer.isBuffer(comment)) comment = EMPTY_BUF;
            totalKeysLen += 4 + comment.length;
            newKeys.push({
              pubKey,
              comment
            });
          }
          let p = 0;
          const buf = Buffer.allocUnsafe(4 + 1 + totalKeysLen);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_IDENTITIES_ANSWER;
          writeUInt32BE(buf, newKeys.length, ++p);
          p += 4;
          for (let i = 0; i < newKeys.length; ++i) {
            const { pubKey, comment } = newKeys[i];
            writeUInt32BE(buf, pubKey.length, p);
            pubKey.copy(buf, p += 4);
            writeUInt32BE(buf, comment.length, p += pubKey.length);
            p += 4;
            if (comment.length) {
              comment.copy(buf, p);
              p += comment.length;
            }
          }
          return respond(this, req, buf);
        }
        signReply(req, signature) {
          if (this[SYM_MODE] !== ROLE_SERVER) throw new Error("Server-only method called with client role");
          if (!(req instanceof AgentInboundRequest)) throw new Error("Wrong request argument");
          if (req.hasResponded()) return true;
          if (req.getType() !== SSH_AGENTC_SIGN_REQUEST) throw new Error("Invalid response to request");
          if (!Buffer.isBuffer(signature)) throw new Error("Signature argument must be a Buffer");
          if (signature.length === 0) throw new Error("Signature argument must be non-empty");
          let p = 0;
          const sigFormat = req.getContext();
          const sigFormatLen = Buffer.byteLength(sigFormat);
          const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + sigFormatLen + 4 + signature.length);
          writeUInt32BE(buf, buf.length - 4, p);
          buf[p += 4] = SSH_AGENT_SIGN_RESPONSE;
          writeUInt32BE(buf, 4 + sigFormatLen + 4 + signature.length, ++p);
          writeUInt32BE(buf, sigFormatLen, p += 4);
          buf.utf8Write(sigFormat, p += 4, sigFormatLen);
          writeUInt32BE(buf, signature.length, p += sigFormatLen);
          signature.copy(buf, p += 4);
          return respond(this, req, buf);
        }
      };
    })();
    var SYM_AGENT = Symbol("Agent");
    var SYM_AGENT_KEYS = Symbol("Agent Keys");
    var SYM_AGENT_KEYS_IDX = Symbol("Agent Keys Index");
    var SYM_AGENT_CBS = Symbol("Agent Init Callbacks");
    var AgentContext = class AgentContext {
      static {
        __name(this, "AgentContext");
      }
      constructor(agent) {
        if (typeof agent === "string") agent = createAgent(agent);
        else if (!isAgent(agent)) throw new Error("Invalid agent argument");
        this[SYM_AGENT] = agent;
        this[SYM_AGENT_KEYS] = null;
        this[SYM_AGENT_KEYS_IDX] = -1;
        this[SYM_AGENT_CBS] = null;
      }
      init(cb) {
        if (typeof cb !== "function") cb = noop;
        if (this[SYM_AGENT_KEYS] === null) {
          if (this[SYM_AGENT_CBS] === null) {
            this[SYM_AGENT_CBS] = [
              cb
            ];
            const doCbs = /* @__PURE__ */ __name((...args) => {
              process.nextTick(() => {
                const cbs = this[SYM_AGENT_CBS];
                this[SYM_AGENT_CBS] = null;
                for (const cb2 of cbs) cb2(...args);
              });
            }, "doCbs");
            this[SYM_AGENT].getIdentities(once((err, keys) => {
              if (err) return doCbs(err);
              if (!Array.isArray(keys)) {
                return doCbs(new Error("Agent implementation failed to provide keys"));
              }
              const newKeys = [];
              for (let key of keys) {
                key = parseKey(key);
                if (key instanceof Error) {
                  continue;
                }
                newKeys.push(key);
              }
              this[SYM_AGENT_KEYS] = newKeys;
              this[SYM_AGENT_KEYS_IDX] = -1;
              doCbs();
            }));
          } else {
            this[SYM_AGENT_CBS].push(cb);
          }
        } else {
          process.nextTick(cb);
        }
      }
      nextKey() {
        if (this[SYM_AGENT_KEYS] === null || ++this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return false;
        }
        return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      currentKey() {
        if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return null;
        }
        return this[SYM_AGENT_KEYS][this[SYM_AGENT_KEYS_IDX]];
      }
      pos() {
        if (this[SYM_AGENT_KEYS] === null || this[SYM_AGENT_KEYS_IDX] >= this[SYM_AGENT_KEYS].length) {
          return -1;
        }
        return this[SYM_AGENT_KEYS_IDX];
      }
      reset() {
        this[SYM_AGENT_KEYS_IDX] = -1;
      }
      sign(...args) {
        this[SYM_AGENT].sign(...args);
      }
    };
    function isAgent(val) {
      return val instanceof BaseAgent;
    }
    __name(isAgent, "isAgent");
    module2.exports = {
      AgentContext,
      AgentProtocol,
      BaseAgent,
      createAgent,
      CygwinAgent,
      isAgent,
      OpenSSHAgent,
      PageantAgent
    };
  }
});

// node_modules/ssh2/lib/protocol/zlib.js
var require_zlib = __commonJS({
  "node_modules/ssh2/lib/protocol/zlib.js"(exports2, module2) {
    "use strict";
    var { kMaxLength } = require("buffer");
    var { createInflate, constants: { DEFLATE, INFLATE, Z_DEFAULT_CHUNK, Z_DEFAULT_COMPRESSION, Z_DEFAULT_MEMLEVEL, Z_DEFAULT_STRATEGY, Z_DEFAULT_WINDOWBITS, Z_PARTIAL_FLUSH } } = require("zlib");
    var ZlibHandle = createInflate()._handle.constructor;
    function processCallback() {
      throw new Error("Should not get here");
    }
    __name(processCallback, "processCallback");
    function zlibOnError(message, errno, code) {
      const self2 = this._owner;
      const error = new Error(message);
      error.errno = errno;
      error.code = code;
      self2._err = error;
    }
    __name(zlibOnError, "zlibOnError");
    function _close(engine) {
      if (!engine._handle) return;
      engine._handle.close();
      engine._handle = null;
    }
    __name(_close, "_close");
    var Zlib = class Zlib {
      static {
        __name(this, "Zlib");
      }
      constructor(mode) {
        const windowBits = Z_DEFAULT_WINDOWBITS;
        const level = Z_DEFAULT_COMPRESSION;
        const memLevel = Z_DEFAULT_MEMLEVEL;
        const strategy = Z_DEFAULT_STRATEGY;
        const dictionary = void 0;
        this._err = void 0;
        this._writeState = new Uint32Array(2);
        this._chunkSize = Z_DEFAULT_CHUNK;
        this._maxOutputLength = kMaxLength;
        this._outBuffer = Buffer.allocUnsafe(this._chunkSize);
        this._outOffset = 0;
        this._handle = new ZlibHandle(mode);
        this._handle._owner = this;
        this._handle.onerror = zlibOnError;
        this._handle.init(windowBits, level, memLevel, strategy, this._writeState, processCallback, dictionary);
      }
      writeSync(chunk, retChunks) {
        const handle = this._handle;
        if (!handle) throw new Error("Invalid Zlib instance");
        let availInBefore = chunk.length;
        let availOutBefore = this._chunkSize - this._outOffset;
        let inOff = 0;
        let availOutAfter;
        let availInAfter;
        let buffers;
        let nread = 0;
        const state = this._writeState;
        let buffer = this._outBuffer;
        let offset = this._outOffset;
        const chunkSize = this._chunkSize;
        while (true) {
          handle.writeSync(Z_PARTIAL_FLUSH, chunk, inOff, availInBefore, buffer, offset, availOutBefore);
          if (this._err) throw this._err;
          availOutAfter = state[0];
          availInAfter = state[1];
          const inDelta = availInBefore - availInAfter;
          const have = availOutBefore - availOutAfter;
          if (have > 0) {
            const out = offset === 0 && have === buffer.length ? buffer : buffer.slice(offset, offset + have);
            offset += have;
            if (!buffers) buffers = out;
            else if (buffers.push === void 0) buffers = [
              buffers,
              out
            ];
            else buffers.push(out);
            nread += out.byteLength;
            if (nread > this._maxOutputLength) {
              _close(this);
              throw new Error(`Output length exceeded maximum of ${this._maxOutputLength}`);
            }
          } else if (have !== 0) {
            throw new Error("have should not go down");
          }
          if (availOutAfter === 0 || offset >= chunkSize) {
            availOutBefore = chunkSize;
            offset = 0;
            buffer = Buffer.allocUnsafe(chunkSize);
          }
          if (availOutAfter === 0) {
            inOff += inDelta;
            availInBefore = availInAfter;
          } else {
            break;
          }
        }
        this._outBuffer = buffer;
        this._outOffset = offset;
        if (nread === 0) buffers = Buffer.alloc(0);
        if (retChunks) {
          buffers.totalLen = nread;
          return buffers;
        }
        if (buffers.push === void 0) return buffers;
        const output = Buffer.allocUnsafe(nread);
        for (let i = 0, p = 0; i < buffers.length; ++i) {
          const buf = buffers[i];
          output.set(buf, p);
          p += buf.length;
        }
        return output;
      }
    };
    var ZlibPacketWriter = class ZlibPacketWriter {
      static {
        __name(this, "ZlibPacketWriter");
      }
      constructor(protocol4) {
        this.allocStart = 0;
        this.allocStartKEX = 0;
        this._protocol = protocol4;
        this._zlib = new Zlib(DEFLATE);
      }
      cleanup() {
        if (this._zlib) _close(this._zlib);
      }
      alloc(payloadSize, force) {
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(payload, force) {
        if (this._protocol._kexinit === void 0 || force) {
          const output = this._zlib.writeSync(payload, true);
          const packet = this._protocol._cipher.allocPacket(output.totalLen);
          if (output.push === void 0) {
            packet.set(output, 5);
          } else {
            for (let i = 0, p = 5; i < output.length; ++i) {
              const chunk = output[i];
              packet.set(chunk, p);
              p += chunk.length;
            }
          }
          return packet;
        }
        return payload;
      }
    };
    var PacketWriter = class PacketWriter {
      static {
        __name(this, "PacketWriter");
      }
      constructor(protocol4) {
        this.allocStart = 5;
        this.allocStartKEX = 5;
        this._protocol = protocol4;
      }
      cleanup() {
      }
      alloc(payloadSize, force) {
        if (this._protocol._kexinit === void 0 || force) return this._protocol._cipher.allocPacket(payloadSize);
        return Buffer.allocUnsafe(payloadSize);
      }
      finalize(packet, force) {
        return packet;
      }
    };
    var ZlibPacketReader = class ZlibPacketReader {
      static {
        __name(this, "ZlibPacketReader");
      }
      constructor() {
        this._zlib = new Zlib(INFLATE);
      }
      cleanup() {
        if (this._zlib) _close(this._zlib);
      }
      read(data) {
        return this._zlib.writeSync(data, false);
      }
    };
    var PacketReader = class PacketReader {
      static {
        __name(this, "PacketReader");
      }
      cleanup() {
      }
      read(data) {
        return data;
      }
    };
    module2.exports = {
      PacketReader,
      PacketWriter,
      ZlibPacketReader,
      ZlibPacketWriter
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.misc.js
var require_handlers_misc = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.misc.js"(exports2, module2) {
    "use strict";
    var { bufferSlice, bufferParser, doFatalError, sigSSHToASN1, writeUInt32BE } = require_utils2();
    var { CHANNEL_OPEN_FAILURE, COMPAT, MESSAGE, TERMINAL_MODE } = require_constants2();
    var { parseKey } = require_keyParser();
    var TERMINAL_MODE_BY_VALUE = Array.from(Object.entries(TERMINAL_MODE)).reduce((obj, [key, value2]) => ({
      ...obj,
      [key]: value2
    }), {});
    module2.exports = {
      // Transport layer protocol ==================================================
      [MESSAGE.DISCONNECT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const reason = bufferParser.readUInt32BE();
        const desc = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(self2, "Inbound: Malformed DISCONNECT packet");
        }
        self2._debug && self2._debug(`Inbound: Received DISCONNECT (${reason}, "${desc}")`);
        const handler = self2._handlers.DISCONNECT;
        handler && handler(self2, reason, desc);
      },
      [MESSAGE.IGNORE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received IGNORE");
      },
      [MESSAGE.UNIMPLEMENTED]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const seqno = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (seqno === void 0) {
          return doFatalError(self2, "Inbound: Malformed UNIMPLEMENTED packet");
        }
        self2._debug && self2._debug(`Inbound: Received UNIMPLEMENTED (seqno ${seqno})`);
      },
      [MESSAGE.DEBUG]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const display = bufferParser.readBool();
        const msg = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(self2, "Inbound: Malformed DEBUG packet");
        }
        self2._debug && self2._debug("Inbound: Received DEBUG");
        const handler = self2._handlers.DEBUG;
        handler && handler(self2, display, msg);
      },
      [MESSAGE.SERVICE_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name = bufferParser.readString(true);
        bufferParser.clear();
        if (name === void 0) {
          return doFatalError(self2, "Inbound: Malformed SERVICE_REQUEST packet");
        }
        self2._debug && self2._debug(`Inbound: Received SERVICE_REQUEST (${name})`);
        const handler = self2._handlers.SERVICE_REQUEST;
        handler && handler(self2, name);
      },
      [MESSAGE.SERVICE_ACCEPT]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name = bufferParser.readString(true);
        bufferParser.clear();
        if (name === void 0) {
          return doFatalError(self2, "Inbound: Malformed SERVICE_ACCEPT packet");
        }
        self2._debug && self2._debug(`Inbound: Received SERVICE_ACCEPT (${name})`);
        const handler = self2._handlers.SERVICE_ACCEPT;
        handler && handler(self2, name);
      },
      [MESSAGE.EXT_INFO]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const numExts = bufferParser.readUInt32BE();
        let exts;
        if (numExts !== void 0) {
          exts = [];
          for (let i = 0; i < numExts; ++i) {
            const name = bufferParser.readString(true);
            const data = bufferParser.readString();
            if (data !== void 0) {
              switch (name) {
                case "server-sig-algs": {
                  const algs = data.latin1Slice(0, data.length).split(",");
                  exts.push({
                    name,
                    algs
                  });
                  continue;
                }
                default:
                  continue;
              }
            }
            exts = void 0;
            break;
          }
        }
        bufferParser.clear();
        if (exts === void 0) return doFatalError(self2, "Inbound: Malformed EXT_INFO packet");
        self2._debug && self2._debug("Inbound: Received EXT_INFO");
        const handler = self2._handlers.EXT_INFO;
        handler && handler(self2, exts);
      },
      // User auth protocol -- generic =============================================
      [MESSAGE.USERAUTH_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const user = bufferParser.readString(true);
        const service = bufferParser.readString(true);
        const method = bufferParser.readString(true);
        let methodData;
        let methodDesc;
        switch (method) {
          case "none":
            methodData = null;
            break;
          case "password": {
            const isChange = bufferParser.readBool();
            if (isChange !== void 0) {
              methodData = bufferParser.readString(true);
              if (methodData !== void 0 && isChange) {
                const newPassword = bufferParser.readString(true);
                if (newPassword !== void 0) methodData = {
                  oldPassword: methodData,
                  newPassword
                };
                else methodData = void 0;
              }
            }
            break;
          }
          case "publickey": {
            const hasSig = bufferParser.readBool();
            if (hasSig !== void 0) {
              const keyAlgo = bufferParser.readString(true);
              let realKeyAlgo = keyAlgo;
              const key = bufferParser.readString();
              let hashAlgo;
              switch (keyAlgo) {
                case "rsa-sha2-256":
                  realKeyAlgo = "ssh-rsa";
                  hashAlgo = "sha256";
                  break;
                case "rsa-sha2-512":
                  realKeyAlgo = "ssh-rsa";
                  hashAlgo = "sha512";
                  break;
              }
              if (hasSig) {
                const blobEnd = bufferParser.pos();
                let signature = bufferParser.readString();
                if (signature !== void 0) {
                  if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                    signature = bufferSlice(signature, 4 + keyAlgo.length + 4);
                  }
                  signature = sigSSHToASN1(signature, realKeyAlgo);
                  if (signature) {
                    const sessionID = self2._kex.sessionID;
                    const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                    writeUInt32BE(blob, sessionID.length, 0);
                    blob.set(sessionID, 4);
                    blob.set(new Uint8Array(payload.buffer, payload.byteOffset, blobEnd), 4 + sessionID.length);
                    methodData = {
                      keyAlgo: realKeyAlgo,
                      key,
                      signature,
                      blob,
                      hashAlgo
                    };
                  }
                }
              } else {
                methodData = {
                  keyAlgo: realKeyAlgo,
                  key,
                  hashAlgo
                };
                methodDesc = "publickey -- check";
              }
            }
            break;
          }
          case "hostbased": {
            const keyAlgo = bufferParser.readString(true);
            let realKeyAlgo = keyAlgo;
            const key = bufferParser.readString();
            const localHostname = bufferParser.readString(true);
            const localUsername = bufferParser.readString(true);
            let hashAlgo;
            switch (keyAlgo) {
              case "rsa-sha2-256":
                realKeyAlgo = "ssh-rsa";
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                realKeyAlgo = "ssh-rsa";
                hashAlgo = "sha512";
                break;
            }
            const blobEnd = bufferParser.pos();
            let signature = bufferParser.readString();
            if (signature !== void 0) {
              if (signature.length > 4 + keyAlgo.length + 4 && signature.utf8Slice(4, 4 + keyAlgo.length) === keyAlgo) {
                signature = bufferSlice(signature, 4 + keyAlgo.length + 4);
              }
              signature = sigSSHToASN1(signature, realKeyAlgo);
              if (signature !== void 0) {
                const sessionID = self2._kex.sessionID;
                const blob = Buffer.allocUnsafe(4 + sessionID.length + blobEnd);
                writeUInt32BE(blob, sessionID.length, 0);
                blob.set(sessionID, 4);
                blob.set(new Uint8Array(payload.buffer, payload.byteOffset, blobEnd), 4 + sessionID.length);
                methodData = {
                  keyAlgo: realKeyAlgo,
                  key,
                  signature,
                  blob,
                  localHostname,
                  localUsername,
                  hashAlgo
                };
              }
            }
            break;
          }
          case "keyboard-interactive":
            bufferParser.skipString();
            methodData = bufferParser.readList();
            break;
          default:
            if (method !== void 0) methodData = bufferParser.readRaw();
        }
        bufferParser.clear();
        if (methodData === void 0) {
          return doFatalError(self2, "Inbound: Malformed USERAUTH_REQUEST packet");
        }
        if (methodDesc === void 0) methodDesc = method;
        self2._authsQueue.push(method);
        self2._debug && self2._debug(`Inbound: Received USERAUTH_REQUEST (${methodDesc})`);
        const handler = self2._handlers.USERAUTH_REQUEST;
        handler && handler(self2, user, service, method, methodData);
      },
      [MESSAGE.USERAUTH_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const authMethods = bufferParser.readList();
        const partialSuccess = bufferParser.readBool();
        bufferParser.clear();
        if (partialSuccess === void 0) {
          return doFatalError(self2, "Inbound: Malformed USERAUTH_FAILURE packet");
        }
        self2._debug && self2._debug(`Inbound: Received USERAUTH_FAILURE (${authMethods})`);
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_FAILURE;
        handler && handler(self2, authMethods, partialSuccess);
      },
      [MESSAGE.USERAUTH_SUCCESS]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received USERAUTH_SUCCESS");
        self2._authsQueue.shift();
        const handler = self2._handlers.USERAUTH_SUCCESS;
        handler && handler(self2);
      },
      [MESSAGE.USERAUTH_BANNER]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const msg = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(self2, "Inbound: Malformed USERAUTH_BANNER packet");
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_BANNER");
        const handler = self2._handlers.USERAUTH_BANNER;
        handler && handler(self2, msg);
      },
      // User auth protocol -- method-specific =====================================
      60: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 60 without auth");
          return;
        }
        switch (self2._authsQueue[0]) {
          case "password": {
            bufferParser.init(payload, 1);
            const prompt = bufferParser.readString(true);
            const lang = bufferParser.readString();
            bufferParser.clear();
            if (lang === void 0) {
              return doFatalError(self2, "Inbound: Malformed USERAUTH_PASSWD_CHANGEREQ packet");
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_PASSWD_CHANGEREQ");
            const handler = self2._handlers.USERAUTH_PASSWD_CHANGEREQ;
            handler && handler(self2, prompt);
            break;
          }
          case "publickey": {
            bufferParser.init(payload, 1);
            const keyAlgo = bufferParser.readString(true);
            const key = bufferParser.readString();
            bufferParser.clear();
            if (key === void 0) {
              return doFatalError(self2, "Inbound: Malformed USERAUTH_PK_OK packet");
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_PK_OK");
            self2._authsQueue.shift();
            const handler = self2._handlers.USERAUTH_PK_OK;
            handler && handler(self2, keyAlgo, key);
            break;
          }
          case "keyboard-interactive": {
            bufferParser.init(payload, 1);
            const name = bufferParser.readString(true);
            const instructions = bufferParser.readString(true);
            bufferParser.readString();
            const numPrompts = bufferParser.readUInt32BE();
            let prompts;
            if (numPrompts !== void 0) {
              prompts = new Array(numPrompts);
              let i;
              for (i = 0; i < numPrompts; ++i) {
                const prompt = bufferParser.readString(true);
                const echo = bufferParser.readBool();
                if (echo === void 0) break;
                prompts[i] = {
                  prompt,
                  echo
                };
              }
              if (i !== numPrompts) prompts = void 0;
            }
            bufferParser.clear();
            if (prompts === void 0) {
              return doFatalError(self2, "Inbound: Malformed USERAUTH_INFO_REQUEST packet");
            }
            self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_REQUEST");
            const handler = self2._handlers.USERAUTH_INFO_REQUEST;
            handler && handler(self2, name, instructions, prompts);
            break;
          }
          default:
            self2._debug && self2._debug("Inbound: Received unexpected payload type 60");
        }
      },
      61: (self2, payload) => {
        if (!self2._authsQueue.length) {
          self2._debug && self2._debug("Inbound: Received payload type 61 without auth");
          return;
        }
        if (self2._authsQueue[0] !== "keyboard-interactive") {
          return doFatalError(self2, "Inbound: Received unexpected payload type 61");
        }
        bufferParser.init(payload, 1);
        const numResponses = bufferParser.readUInt32BE();
        let responses;
        if (numResponses !== void 0) {
          responses = new Array(numResponses);
          let i;
          for (i = 0; i < numResponses; ++i) {
            const response = bufferParser.readString(true);
            if (response === void 0) break;
            responses[i] = response;
          }
          if (i !== numResponses) responses = void 0;
        }
        bufferParser.clear();
        if (responses === void 0) {
          return doFatalError(self2, "Inbound: Malformed USERAUTH_INFO_RESPONSE packet");
        }
        self2._debug && self2._debug("Inbound: Received USERAUTH_INFO_RESPONSE");
        const handler = self2._handlers.USERAUTH_INFO_RESPONSE;
        handler && handler(self2, responses);
      },
      // Connection protocol -- generic ============================================
      [MESSAGE.GLOBAL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const name = bufferParser.readString(true);
        const wantReply = bufferParser.readBool();
        let data;
        if (wantReply !== void 0) {
          switch (name) {
            case "tcpip-forward":
            case "cancel-tcpip-forward": {
              const bindAddr = bufferParser.readString(true);
              const bindPort = bufferParser.readUInt32BE();
              if (bindPort !== void 0) data = {
                bindAddr,
                bindPort
              };
              break;
            }
            case "streamlocal-forward@openssh.com":
            case "cancel-streamlocal-forward@openssh.com": {
              const socketPath = bufferParser.readString(true);
              if (socketPath !== void 0) data = {
                socketPath
              };
              break;
            }
            case "no-more-sessions@openssh.com":
              data = null;
              break;
            case "hostkeys-00@openssh.com": {
              data = [];
              while (bufferParser.avail() > 0) {
                const keyRaw = bufferParser.readString();
                if (keyRaw === void 0) {
                  data = void 0;
                  break;
                }
                const key = parseKey(keyRaw);
                if (!(key instanceof Error)) data.push(key);
              }
              break;
            }
            default:
              data = bufferParser.readRaw();
          }
        }
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(self2, "Inbound: Malformed GLOBAL_REQUEST packet");
        }
        self2._debug && self2._debug(`Inbound: GLOBAL_REQUEST (${name})`);
        const handler = self2._handlers.GLOBAL_REQUEST;
        if (handler) handler(self2, name, wantReply, data);
        else self2.requestFailure();
      },
      [MESSAGE.REQUEST_SUCCESS]: (self2, payload) => {
        const data = payload.length > 1 ? bufferSlice(payload, 1) : null;
        self2._debug && self2._debug("Inbound: REQUEST_SUCCESS");
        const handler = self2._handlers.REQUEST_SUCCESS;
        handler && handler(self2, data);
      },
      [MESSAGE.REQUEST_FAILURE]: (self2, payload) => {
        self2._debug && self2._debug("Inbound: Received REQUEST_FAILURE");
        const handler = self2._handlers.REQUEST_FAILURE;
        handler && handler(self2);
      },
      // Connection protocol -- channel-related ====================================
      [MESSAGE.CHANNEL_OPEN]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const type = bufferParser.readString(true);
        const sender = bufferParser.readUInt32BE();
        const window2 = bufferParser.readUInt32BE();
        const packetSize = bufferParser.readUInt32BE();
        let channelInfo;
        switch (type) {
          case "forwarded-tcpip":
          case "direct-tcpip": {
            const destIP = bufferParser.readString(true);
            const destPort = bufferParser.readUInt32BE();
            const srcIP = bufferParser.readString(true);
            const srcPort = bufferParser.readUInt32BE();
            if (srcPort !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: {
                  destIP,
                  destPort,
                  srcIP,
                  srcPort
                }
              };
            }
            break;
          }
          case "forwarded-streamlocal@openssh.com":
          case "direct-streamlocal@openssh.com": {
            const socketPath = bufferParser.readString(true);
            if (socketPath !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: {
                  socketPath
                }
              };
            }
            break;
          }
          case "x11": {
            const srcIP = bufferParser.readString(true);
            const srcPort = bufferParser.readUInt32BE();
            if (srcPort !== void 0) {
              channelInfo = {
                type,
                sender,
                window: window2,
                packetSize,
                data: {
                  srcIP,
                  srcPort
                }
              };
            }
            break;
          }
          default:
            channelInfo = {
              type,
              sender,
              window: window2,
              packetSize,
              data: {}
            };
        }
        bufferParser.clear();
        if (channelInfo === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_OPEN packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN (s:${sender}, ${type})`);
        const handler = self2._handlers.CHANNEL_OPEN;
        if (handler) {
          handler(self2, channelInfo);
        } else {
          self2.channelOpenFail(channelInfo.sender, CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED, "", "");
        }
      },
      [MESSAGE.CHANNEL_OPEN_CONFIRMATION]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const sender = bufferParser.readUInt32BE();
        const window2 = bufferParser.readUInt32BE();
        const packetSize = bufferParser.readUInt32BE();
        const data = bufferParser.avail() ? bufferParser.readRaw() : void 0;
        bufferParser.clear();
        if (packetSize === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_OPEN_CONFIRMATION packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN_CONFIRMATION (r:${recipient}, s:${sender})`);
        const handler = self2._handlers.CHANNEL_OPEN_CONFIRMATION;
        if (handler) handler(self2, {
          recipient,
          sender,
          window: window2,
          packetSize,
          data
        });
      },
      [MESSAGE.CHANNEL_OPEN_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const reason = bufferParser.readUInt32BE();
        const description = bufferParser.readString(true);
        const lang = bufferParser.readString();
        bufferParser.clear();
        if (lang === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_OPEN_FAILURE packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_OPEN_FAILURE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_OPEN_FAILURE;
        handler && handler(self2, recipient, reason, description);
      },
      [MESSAGE.CHANNEL_WINDOW_ADJUST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const bytesToAdd = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (bytesToAdd === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_WINDOW_ADJUST packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_WINDOW_ADJUST (r:${recipient}, ${bytesToAdd})`);
        const handler = self2._handlers.CHANNEL_WINDOW_ADJUST;
        handler && handler(self2, recipient, bytesToAdd);
      },
      [MESSAGE.CHANNEL_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_DATA packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_DATA (r:${recipient}, ${data.length})`);
        const handler = self2._handlers.CHANNEL_DATA;
        handler && handler(self2, recipient, data);
      },
      [MESSAGE.CHANNEL_EXTENDED_DATA]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const type = bufferParser.readUInt32BE();
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_EXTENDED_DATA packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_EXTENDED_DATA (r:${recipient}, ${data.length})`);
        const handler = self2._handlers.CHANNEL_EXTENDED_DATA;
        handler && handler(self2, recipient, data, type);
      },
      [MESSAGE.CHANNEL_EOF]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_EOF packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_EOF (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_EOF;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_CLOSE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_CLOSE packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_CLOSE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_CLOSE;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_REQUEST]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        const type = bufferParser.readString(true);
        const wantReply = bufferParser.readBool();
        let data;
        if (wantReply !== void 0) {
          switch (type) {
            case "exit-status":
              data = bufferParser.readUInt32BE();
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);
              break;
            case "exit-signal": {
              let signal;
              let coreDumped;
              if (self2._compatFlags & COMPAT.OLD_EXIT) {
                const num = bufferParser.readUInt32BE();
                switch (num) {
                  case 1:
                    signal = "HUP";
                    break;
                  case 2:
                    signal = "INT";
                    break;
                  case 3:
                    signal = "QUIT";
                    break;
                  case 6:
                    signal = "ABRT";
                    break;
                  case 9:
                    signal = "KILL";
                    break;
                  case 14:
                    signal = "ALRM";
                    break;
                  case 15:
                    signal = "TERM";
                    break;
                  default:
                    if (num !== void 0) {
                      signal = `UNKNOWN (${num})`;
                    }
                }
                coreDumped = false;
              } else {
                signal = bufferParser.readString(true);
                coreDumped = bufferParser.readBool();
                if (coreDumped === void 0) signal = void 0;
              }
              const errorMessage = bufferParser.readString(true);
              if (bufferParser.skipString() !== void 0) data = {
                signal,
                coreDumped,
                errorMessage
              };
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${signal})`);
              break;
            }
            case "pty-req": {
              const term = bufferParser.readString(true);
              const cols = bufferParser.readUInt32BE();
              const rows = bufferParser.readUInt32BE();
              const width = bufferParser.readUInt32BE();
              const height = bufferParser.readUInt32BE();
              const modesBinary = bufferParser.readString();
              if (modesBinary !== void 0) {
                bufferParser.init(modesBinary, 1);
                let modes = {};
                while (bufferParser.avail()) {
                  const opcode = bufferParser.readByte();
                  if (opcode === TERMINAL_MODE.TTY_OP_END) break;
                  const name = TERMINAL_MODE_BY_VALUE[opcode];
                  const value2 = bufferParser.readUInt32BE();
                  if (opcode === void 0 || name === void 0 || value2 === void 0) {
                    modes = void 0;
                    break;
                  }
                  modes[name] = value2;
                }
                if (modes !== void 0) data = {
                  term,
                  cols,
                  rows,
                  width,
                  height,
                  modes
                };
              }
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);
              break;
            }
            case "window-change": {
              const cols = bufferParser.readUInt32BE();
              const rows = bufferParser.readUInt32BE();
              const width = bufferParser.readUInt32BE();
              const height = bufferParser.readUInt32BE();
              if (height !== void 0) data = {
                cols,
                rows,
                width,
                height
              };
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);
              break;
            }
            case "x11-req": {
              const single = bufferParser.readBool();
              const protocol4 = bufferParser.readString(true);
              const cookie = bufferParser.readString();
              const screen = bufferParser.readUInt32BE();
              if (screen !== void 0) data = {
                single,
                protocol: protocol4,
                cookie,
                screen
              };
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);
              break;
            }
            case "env": {
              const name = bufferParser.readString(true);
              const value2 = bufferParser.readString(true);
              if (value2 !== void 0) data = {
                name,
                value: value2
              };
              if (self2._debug) {
                self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${name}=${value2})`);
              }
              break;
            }
            case "shell":
              data = null;
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);
              break;
            case "exec":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);
              break;
            case "subsystem":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);
              break;
            case "signal":
              data = bufferParser.readString(true);
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);
              break;
            case "xon-xoff":
              data = bufferParser.readBool();
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type}: ${data})`);
              break;
            case "auth-agent-req@openssh.com":
              data = null;
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);
              break;
            default:
              data = bufferParser.avail() ? bufferParser.readRaw() : null;
              self2._debug && self2._debug(`Inbound: CHANNEL_REQUEST (r:${recipient}, ${type})`);
          }
        }
        bufferParser.clear();
        if (data === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_REQUEST packet");
        }
        const handler = self2._handlers.CHANNEL_REQUEST;
        handler && handler(self2, recipient, type, wantReply, data);
      },
      [MESSAGE.CHANNEL_SUCCESS]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_SUCCESS packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_SUCCESS (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_SUCCESS;
        handler && handler(self2, recipient);
      },
      [MESSAGE.CHANNEL_FAILURE]: (self2, payload) => {
        bufferParser.init(payload, 1);
        const recipient = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (recipient === void 0) {
          return doFatalError(self2, "Inbound: Malformed CHANNEL_FAILURE packet");
        }
        self2._debug && self2._debug(`Inbound: CHANNEL_FAILURE (r:${recipient})`);
        const handler = self2._handlers.CHANNEL_FAILURE;
        handler && handler(self2, recipient);
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/handlers.js
var require_handlers = __commonJS({
  "node_modules/ssh2/lib/protocol/handlers.js"(exports2, module2) {
    "use strict";
    var MESSAGE_HANDLERS = new Array(256);
    [
      require_kex().HANDLERS,
      require_handlers_misc()
    ].forEach((handlers) => {
      for (let [type, handler] of Object.entries(handlers)) {
        type = +type;
        if (isFinite(type) && type >= 0 && type < MESSAGE_HANDLERS.length) MESSAGE_HANDLERS[type] = handler;
      }
    });
    module2.exports = MESSAGE_HANDLERS;
  }
});

// node_modules/ssh2/lib/protocol/kex.js
var require_kex = __commonJS({
  "node_modules/ssh2/lib/protocol/kex.js"(exports2, module2) {
    "use strict";
    var { createDiffieHellman, createDiffieHellmanGroup, createECDH, createHash, createPublicKey, diffieHellman, generateKeyPairSync, randomFillSync } = require("crypto");
    var { Ber } = require_lib2();
    var { COMPAT, curve25519Supported, DEFAULT_KEX, DEFAULT_SERVER_HOST_KEY, DEFAULT_CIPHER, DEFAULT_MAC, DEFAULT_COMPRESSION, DISCONNECT_REASON, MESSAGE } = require_constants2();
    var { CIPHER_INFO, createCipher, createDecipher, MAC_INFO } = require_crypto();
    var { parseDERKey } = require_keyParser();
    var { bufferFill, bufferParser, convertSignature, doFatalError, FastBuffer, sigSSHToASN1, writeUInt32BE } = require_utils2();
    var { PacketReader, PacketWriter, ZlibPacketReader, ZlibPacketWriter } = require_zlib();
    var MESSAGE_HANDLERS;
    var GEX_MIN_BITS = 2048;
    var GEX_MAX_BITS = 8192;
    var EMPTY_BUFFER = Buffer.alloc(0);
    function kexinit(self2) {
      let payload;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        const entry = self2._offer.lists.kex;
        let kex = entry.array;
        let found = false;
        for (let i = 0; i < kex.length; ++i) {
          if (kex[i].includes("group-exchange")) {
            if (!found) {
              found = true;
              kex = kex.slice();
            }
            kex.splice(i--, 1);
          }
        }
        if (found) {
          let len = 1 + 16 + self2._offer.totalSize + 1 + 4;
          const newKexBuf = Buffer.from(kex.join(","));
          len -= entry.buffer.length - newKexBuf.length;
          const all = self2._offer.lists.all;
          const rest = new Uint8Array(all.buffer, all.byteOffset + 4 + entry.buffer.length, all.length - (4 + entry.buffer.length));
          payload = Buffer.allocUnsafe(len);
          writeUInt32BE(payload, newKexBuf.length, 17);
          payload.set(newKexBuf, 17 + 4);
          payload.set(rest, 17 + 4 + newKexBuf.length);
        }
      }
      if (payload === void 0) {
        payload = Buffer.allocUnsafe(1 + 16 + self2._offer.totalSize + 1 + 4);
        self2._offer.copyAllTo(payload, 17);
      }
      self2._debug && self2._debug("Outbound: Sending KEXINIT");
      payload[0] = MESSAGE.KEXINIT;
      randomFillSync(payload, 1, 16);
      bufferFill(payload, 0, payload.length - 5);
      self2._kexinit = payload;
      self2._packetRW.write.allocStart = 0;
      {
        const p = self2._packetRW.write.allocStartKEX;
        const packet = self2._packetRW.write.alloc(payload.length, true);
        packet.set(payload, p);
        self2._cipher.encrypt(self2._packetRW.write.finalize(packet, true));
      }
    }
    __name(kexinit, "kexinit");
    function handleKexInit(self2, payload) {
      const init = {
        kex: void 0,
        serverHostKey: void 0,
        cs: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        },
        sc: {
          cipher: void 0,
          mac: void 0,
          compress: void 0,
          lang: void 0
        }
      };
      bufferParser.init(payload, 17);
      if ((init.kex = bufferParser.readList()) === void 0 || (init.serverHostKey = bufferParser.readList()) === void 0 || (init.cs.cipher = bufferParser.readList()) === void 0 || (init.sc.cipher = bufferParser.readList()) === void 0 || (init.cs.mac = bufferParser.readList()) === void 0 || (init.sc.mac = bufferParser.readList()) === void 0 || (init.cs.compress = bufferParser.readList()) === void 0 || (init.sc.compress = bufferParser.readList()) === void 0 || (init.cs.lang = bufferParser.readList()) === void 0 || (init.sc.lang = bufferParser.readList()) === void 0) {
        bufferParser.clear();
        return doFatalError(self2, "Received malformed KEXINIT", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
      }
      const pos = bufferParser.pos();
      const firstFollows = pos < payload.length && payload[pos] === 1;
      bufferParser.clear();
      const local = self2._offer;
      const remote = init;
      let localKex = local.lists.kex.array;
      if (self2._compatFlags & COMPAT.BAD_DHGEX) {
        let found = false;
        for (let i2 = 0; i2 < localKex.length; ++i2) {
          if (localKex[i2].indexOf("group-exchange") !== -1) {
            if (!found) {
              found = true;
              localKex = localKex.slice();
            }
            localKex.splice(i2--, 1);
          }
        }
      }
      let clientList;
      let serverList;
      let i;
      const debug12 = self2._debug;
      debug12 && debug12("Inbound: Handshake in progress");
      debug12 && debug12(`Handshake: (local) KEX method: ${localKex}`);
      debug12 && debug12(`Handshake: (remote) KEX method: ${remote.kex}`);
      let remoteExtInfoEnabled;
      if (self2._server) {
        serverList = localKex;
        clientList = remote.kex;
        remoteExtInfoEnabled = clientList.indexOf("ext-info-c") !== -1;
      } else {
        serverList = remote.kex;
        clientList = localKex;
        remoteExtInfoEnabled = serverList.indexOf("ext-info-s") !== -1;
      }
      if (self2._strictMode === void 0) {
        if (self2._server) {
          self2._strictMode = clientList.indexOf("kex-strict-c-v00@openssh.com") !== -1;
        } else {
          self2._strictMode = serverList.indexOf("kex-strict-s-v00@openssh.com") !== -1;
        }
        if (self2._strictMode) {
          debug12 && debug12("Handshake: strict KEX mode enabled");
          if (self2._decipher.inSeqno !== 1) {
            if (debug12) debug12("Handshake: KEXINIT not first packet in strict KEX mode");
            return doFatalError(self2, "Handshake failed: KEXINIT not first packet in strict KEX mode", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
          }
        }
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length) {
        debug12 && debug12("Handshake: no matching key exchange algorithm");
        return doFatalError(self2, "Handshake failed: no matching key exchange algorithm", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
      }
      init.kex = clientList[i];
      debug12 && debug12(`Handshake: KEX algorithm: ${clientList[i]}`);
      if (firstFollows && (!remote.kex.length || clientList[i] !== remote.kex[0])) {
        self2._skipNextInboundPacket = true;
      }
      const localSrvHostKey = local.lists.serverHostKey.array;
      debug12 && debug12(`Handshake: (local) Host key format: ${localSrvHostKey}`);
      debug12 && debug12(`Handshake: (remote) Host key format: ${remote.serverHostKey}`);
      if (self2._server) {
        serverList = localSrvHostKey;
        clientList = remote.serverHostKey;
      } else {
        serverList = remote.serverHostKey;
        clientList = localSrvHostKey;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length) {
        debug12 && debug12("Handshake: No matching host key format");
        return doFatalError(self2, "Handshake failed: no matching host key format", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
      }
      init.serverHostKey = clientList[i];
      debug12 && debug12(`Handshake: Host key format: ${clientList[i]}`);
      const localCSCipher = local.lists.cs.cipher.array;
      debug12 && debug12(`Handshake: (local) C->S cipher: ${localCSCipher}`);
      debug12 && debug12(`Handshake: (remote) C->S cipher: ${remote.cs.cipher}`);
      if (self2._server) {
        serverList = localCSCipher;
        clientList = remote.cs.cipher;
      } else {
        serverList = remote.cs.cipher;
        clientList = localCSCipher;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length) {
        debug12 && debug12("Handshake: No matching C->S cipher");
        return doFatalError(self2, "Handshake failed: no matching C->S cipher", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
      }
      init.cs.cipher = clientList[i];
      debug12 && debug12(`Handshake: C->S Cipher: ${clientList[i]}`);
      const localSCCipher = local.lists.sc.cipher.array;
      debug12 && debug12(`Handshake: (local) S->C cipher: ${localSCCipher}`);
      debug12 && debug12(`Handshake: (remote) S->C cipher: ${remote.sc.cipher}`);
      if (self2._server) {
        serverList = localSCCipher;
        clientList = remote.sc.cipher;
      } else {
        serverList = remote.sc.cipher;
        clientList = localSCCipher;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length) {
        debug12 && debug12("Handshake: No matching S->C cipher");
        return doFatalError(self2, "Handshake failed: no matching S->C cipher", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
      }
      init.sc.cipher = clientList[i];
      debug12 && debug12(`Handshake: S->C cipher: ${clientList[i]}`);
      const localCSMAC = local.lists.cs.mac.array;
      debug12 && debug12(`Handshake: (local) C->S MAC: ${localCSMAC}`);
      debug12 && debug12(`Handshake: (remote) C->S MAC: ${remote.cs.mac}`);
      if (CIPHER_INFO[init.cs.cipher].authLen > 0) {
        init.cs.mac = "";
        debug12 && debug12("Handshake: C->S MAC: <implicit>");
      } else {
        if (self2._server) {
          serverList = localCSMAC;
          clientList = remote.cs.mac;
        } else {
          serverList = remote.cs.mac;
          clientList = localCSMAC;
        }
        for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
        if (i === clientList.length) {
          debug12 && debug12("Handshake: No matching C->S MAC");
          return doFatalError(self2, "Handshake failed: no matching C->S MAC", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
        }
        init.cs.mac = clientList[i];
        debug12 && debug12(`Handshake: C->S MAC: ${clientList[i]}`);
      }
      const localSCMAC = local.lists.sc.mac.array;
      debug12 && debug12(`Handshake: (local) S->C MAC: ${localSCMAC}`);
      debug12 && debug12(`Handshake: (remote) S->C MAC: ${remote.sc.mac}`);
      if (CIPHER_INFO[init.sc.cipher].authLen > 0) {
        init.sc.mac = "";
        debug12 && debug12("Handshake: S->C MAC: <implicit>");
      } else {
        if (self2._server) {
          serverList = localSCMAC;
          clientList = remote.sc.mac;
        } else {
          serverList = remote.sc.mac;
          clientList = localSCMAC;
        }
        for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
        if (i === clientList.length) {
          debug12 && debug12("Handshake: No matching S->C MAC");
          return doFatalError(self2, "Handshake failed: no matching S->C MAC", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
        }
        init.sc.mac = clientList[i];
        debug12 && debug12(`Handshake: S->C MAC: ${clientList[i]}`);
      }
      const localCSCompress = local.lists.cs.compress.array;
      debug12 && debug12(`Handshake: (local) C->S compression: ${localCSCompress}`);
      debug12 && debug12(`Handshake: (remote) C->S compression: ${remote.cs.compress}`);
      if (self2._server) {
        serverList = localCSCompress;
        clientList = remote.cs.compress;
      } else {
        serverList = remote.cs.compress;
        clientList = localCSCompress;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length) {
        debug12 && debug12("Handshake: No matching C->S compression");
        return doFatalError(self2, "Handshake failed: no matching C->S compression", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
      }
      init.cs.compress = clientList[i];
      debug12 && debug12(`Handshake: C->S compression: ${clientList[i]}`);
      const localSCCompress = local.lists.sc.compress.array;
      debug12 && debug12(`Handshake: (local) S->C compression: ${localSCCompress}`);
      debug12 && debug12(`Handshake: (remote) S->C compression: ${remote.sc.compress}`);
      if (self2._server) {
        serverList = localSCCompress;
        clientList = remote.sc.compress;
      } else {
        serverList = remote.sc.compress;
        clientList = localSCCompress;
      }
      for (i = 0; i < clientList.length && serverList.indexOf(clientList[i]) === -1; ++i) ;
      if (i === clientList.length) {
        debug12 && debug12("Handshake: No matching S->C compression");
        return doFatalError(self2, "Handshake failed: no matching S->C compression", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
      }
      init.sc.compress = clientList[i];
      debug12 && debug12(`Handshake: S->C compression: ${clientList[i]}`);
      init.cs.lang = "";
      init.sc.lang = "";
      if (self2._kex) {
        if (!self2._kexinit) {
          kexinit(self2);
        }
        self2._decipher._onPayload = onKEXPayload.bind(self2, {
          firstPacket: false
        });
      }
      self2._kex = createKeyExchange(init, self2, payload);
      self2._kex.remoteExtInfoEnabled = remoteExtInfoEnabled;
      self2._kex.start();
    }
    __name(handleKexInit, "handleKexInit");
    var createKeyExchange = /* @__PURE__ */ (() => {
      function convertToMpint(buf) {
        let idx = 0;
        let length = buf.length;
        while (buf[idx] === 0) {
          ++idx;
          --length;
        }
        let newBuf;
        if (buf[idx] & 128) {
          newBuf = Buffer.allocUnsafe(1 + length);
          newBuf[0] = 0;
          buf.copy(newBuf, 1, idx);
          buf = newBuf;
        } else if (length !== buf.length) {
          newBuf = Buffer.allocUnsafe(length);
          buf.copy(newBuf, 0, idx);
          buf = newBuf;
        }
        return buf;
      }
      __name(convertToMpint, "convertToMpint");
      let KeyExchange = class KeyExchange {
        static {
          __name(this, "KeyExchange");
        }
        constructor(negotiated, protocol4, remoteKexinit) {
          this._protocol = protocol4;
          this.sessionID = protocol4._kex ? protocol4._kex.sessionID : void 0;
          this.negotiated = negotiated;
          this.remoteExtInfoEnabled = false;
          this._step = 1;
          this._public = null;
          this._dh = null;
          this._sentNEWKEYS = false;
          this._receivedNEWKEYS = false;
          this._finished = false;
          this._hostVerified = false;
          this._kexinit = protocol4._kexinit;
          this._remoteKexinit = remoteKexinit;
          this._identRaw = protocol4._identRaw;
          this._remoteIdentRaw = protocol4._remoteIdentRaw;
          this._hostKey = void 0;
          this._dhData = void 0;
          this._sig = void 0;
        }
        finish(scOnly) {
          if (this._finished) return false;
          this._finished = true;
          const isServer = this._protocol._server;
          const negotiated = this.negotiated;
          const pubKey = this.convertPublicKey(this._dhData);
          let secret = this.computeSecret(this._dhData);
          if (secret instanceof Error) {
            secret.message = `Error while computing DH secret (${this.type}): ${secret.message}`;
            secret.level = "handshake";
            return doFatalError(this._protocol, secret, DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
          }
          const hash = createHash(this.hashName);
          hashString(hash, isServer ? this._remoteIdentRaw : this._identRaw);
          hashString(hash, isServer ? this._identRaw : this._remoteIdentRaw);
          hashString(hash, isServer ? this._remoteKexinit : this._kexinit);
          hashString(hash, isServer ? this._kexinit : this._remoteKexinit);
          const serverPublicHostKey = isServer ? this._hostKey.getPublicSSH() : this._hostKey;
          hashString(hash, serverPublicHostKey);
          if (this.type === "groupex") {
            const params2 = this.getDHParams();
            const num = Buffer.allocUnsafe(4);
            writeUInt32BE(num, this._minBits, 0);
            hash.update(num);
            writeUInt32BE(num, this._prefBits, 0);
            hash.update(num);
            writeUInt32BE(num, this._maxBits, 0);
            hash.update(num);
            hashString(hash, params2.prime);
            hashString(hash, params2.generator);
          }
          hashString(hash, isServer ? pubKey : this.getPublicKey());
          const serverPublicKey = isServer ? this.getPublicKey() : pubKey;
          hashString(hash, serverPublicKey);
          hashString(hash, secret);
          const exchangeHash = hash.digest();
          if (!isServer) {
            bufferParser.init(this._sig, 0);
            const sigType = bufferParser.readString(true);
            if (!sigType) {
              return doFatalError(this._protocol, "Malformed packet while reading signature", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
            }
            if (sigType !== negotiated.serverHostKey) {
              return doFatalError(this._protocol, `Wrong signature type: ${sigType}, expected: ${negotiated.serverHostKey}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
            }
            let sigValue = bufferParser.readString();
            bufferParser.clear();
            if (sigValue === void 0) {
              return doFatalError(this._protocol, "Malformed packet while reading signature", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
            }
            if (!(sigValue = sigSSHToASN1(sigValue, sigType))) {
              return doFatalError(this._protocol, "Malformed signature", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
            }
            let parsedHostKey;
            {
              bufferParser.init(this._hostKey, 0);
              const name = bufferParser.readString(true);
              const hostKey = this._hostKey.slice(bufferParser.pos());
              bufferParser.clear();
              parsedHostKey = parseDERKey(hostKey, name);
              if (parsedHostKey instanceof Error) {
                parsedHostKey.level = "handshake";
                return doFatalError(this._protocol, parsedHostKey, DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
              }
            }
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug("Verifying signature ...");
            const verified = parsedHostKey.verify(exchangeHash, sigValue, hashAlgo);
            if (verified !== true) {
              if (verified instanceof Error) {
                this._protocol._debug && this._protocol._debug(`Signature verification failed: ${verified.stack}`);
              } else {
                this._protocol._debug && this._protocol._debug("Signature verification failed");
              }
              return doFatalError(this._protocol, "Handshake failed: signature verification failed", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
            }
            this._protocol._debug && this._protocol._debug("Verified signature");
          } else {
            let hashAlgo;
            switch (this.negotiated.serverHostKey) {
              case "rsa-sha2-256":
                hashAlgo = "sha256";
                break;
              case "rsa-sha2-512":
                hashAlgo = "sha512";
                break;
            }
            this._protocol._debug && this._protocol._debug("Generating signature ...");
            let signature = this._hostKey.sign(exchangeHash, hashAlgo);
            if (signature instanceof Error) {
              return doFatalError(this._protocol, `Handshake failed: signature generation failed for ${this._hostKey.type} host key: ${signature.message}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
            }
            signature = convertSignature(signature, this._hostKey.type);
            if (signature === false) {
              return doFatalError(this._protocol, `Handshake failed: signature conversion failed for ${this._hostKey.type} host key`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
            }
            const sigType = this.negotiated.serverHostKey;
            const sigTypeLen = Buffer.byteLength(sigType);
            const sigLen = 4 + sigTypeLen + 4 + signature.length;
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(1 + 4 + serverPublicHostKey.length + 4 + serverPublicKey.length + 4 + sigLen, true);
            packet[p] = MESSAGE.KEXDH_REPLY;
            writeUInt32BE(packet, serverPublicHostKey.length, ++p);
            packet.set(serverPublicHostKey, p += 4);
            writeUInt32BE(packet, serverPublicKey.length, p += serverPublicHostKey.length);
            packet.set(serverPublicKey, p += 4);
            writeUInt32BE(packet, sigLen, p += serverPublicKey.length);
            writeUInt32BE(packet, sigTypeLen, p += 4);
            packet.utf8Write(sigType, p += 4, sigTypeLen);
            writeUInt32BE(packet, signature.length, p += sigTypeLen);
            packet.set(signature, p += 4);
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_REPLY";
                  break;
                case "groupex":
                  type = "KEXDH_GEX_REPLY";
                  break;
                default:
                  type = "KEXECDH_REPLY";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));
          }
          if (isServer || !scOnly) trySendNEWKEYS(this);
          let hsCipherConfig;
          let hsWrite;
          const completeHandshake = /* @__PURE__ */ __name((partial) => {
            if (hsCipherConfig) {
              trySendNEWKEYS(this);
              hsCipherConfig.outbound.seqno = this._protocol._cipher.outSeqno;
              this._protocol._cipher.free();
              this._protocol._cipher = createCipher(hsCipherConfig);
              this._protocol._packetRW.write = hsWrite;
              hsCipherConfig = void 0;
              hsWrite = void 0;
              this._protocol._onHandshakeComplete(negotiated);
              return false;
            }
            if (!this.sessionID) this.sessionID = exchangeHash;
            {
              const newSecret = Buffer.allocUnsafe(4 + secret.length);
              writeUInt32BE(newSecret, secret.length, 0);
              newSecret.set(secret, 4);
              secret = newSecret;
            }
            const csCipherInfo = CIPHER_INFO[negotiated.cs.cipher];
            const scCipherInfo = CIPHER_INFO[negotiated.sc.cipher];
            const csIV = generateKEXVal(csCipherInfo.ivLen, this.hashName, secret, exchangeHash, this.sessionID, "A");
            const scIV = generateKEXVal(scCipherInfo.ivLen, this.hashName, secret, exchangeHash, this.sessionID, "B");
            const csKey = generateKEXVal(csCipherInfo.keyLen, this.hashName, secret, exchangeHash, this.sessionID, "C");
            const scKey = generateKEXVal(scCipherInfo.keyLen, this.hashName, secret, exchangeHash, this.sessionID, "D");
            let csMacInfo;
            let csMacKey;
            if (!csCipherInfo.authLen) {
              csMacInfo = MAC_INFO[negotiated.cs.mac];
              csMacKey = generateKEXVal(csMacInfo.len, this.hashName, secret, exchangeHash, this.sessionID, "E");
            }
            let scMacInfo;
            let scMacKey;
            if (!scCipherInfo.authLen) {
              scMacInfo = MAC_INFO[negotiated.sc.mac];
              scMacKey = generateKEXVal(scMacInfo.len, this.hashName, secret, exchangeHash, this.sessionID, "F");
            }
            const config = {
              inbound: {
                onPayload: this._protocol._onPayload,
                seqno: this._protocol._decipher.inSeqno,
                decipherInfo: !isServer ? scCipherInfo : csCipherInfo,
                decipherIV: !isServer ? scIV : csIV,
                decipherKey: !isServer ? scKey : csKey,
                macInfo: !isServer ? scMacInfo : csMacInfo,
                macKey: !isServer ? scMacKey : csMacKey
              },
              outbound: {
                onWrite: this._protocol._onWrite,
                seqno: this._protocol._cipher.outSeqno,
                cipherInfo: isServer ? scCipherInfo : csCipherInfo,
                cipherIV: isServer ? scIV : csIV,
                cipherKey: isServer ? scKey : csKey,
                macInfo: isServer ? scMacInfo : csMacInfo,
                macKey: isServer ? scMacKey : csMacKey
              }
            };
            this._protocol._decipher.free();
            hsCipherConfig = config;
            this._protocol._decipher = createDecipher(config);
            const rw = {
              read: void 0,
              write: void 0
            };
            switch (negotiated.cs.compress) {
              case "zlib":
                if (isServer) rw.read = new ZlibPacketReader();
                else rw.write = new ZlibPacketWriter(this._protocol);
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  if (isServer) rw.read = new ZlibPacketReader();
                  else rw.write = new ZlibPacketWriter(this._protocol);
                  break;
                }
              // FALLTHROUGH
              default:
                if (isServer) rw.read = new PacketReader();
                else rw.write = new PacketWriter(this._protocol);
            }
            switch (negotiated.sc.compress) {
              case "zlib":
                if (isServer) rw.write = new ZlibPacketWriter(this._protocol);
                else rw.read = new ZlibPacketReader();
                break;
              case "zlib@openssh.com":
                if (this._protocol._authenticated) {
                  if (isServer) rw.write = new ZlibPacketWriter(this._protocol);
                  else rw.read = new ZlibPacketReader();
                  break;
                }
              // FALLTHROUGH
              default:
                if (isServer) rw.write = new PacketWriter(this._protocol);
                else rw.read = new PacketReader();
            }
            this._protocol._packetRW.read.cleanup();
            this._protocol._packetRW.write.cleanup();
            this._protocol._packetRW.read = rw.read;
            hsWrite = rw.write;
            this._public = null;
            this._dh = null;
            this._kexinit = this._protocol._kexinit = void 0;
            this._remoteKexinit = void 0;
            this._identRaw = void 0;
            this._remoteIdentRaw = void 0;
            this._hostKey = void 0;
            this._dhData = void 0;
            this._sig = void 0;
            if (!partial) return completeHandshake();
            return false;
          }, "completeHandshake");
          if (isServer || scOnly) this.finish = completeHandshake;
          if (!isServer) return completeHandshake(scOnly);
        }
        start() {
          if (!this._protocol._server) {
            if (this._protocol._debug) {
              let type;
              switch (this.type) {
                case "group":
                  type = "KEXDH_INIT";
                  break;
                default:
                  type = "KEXECDH_INIT";
              }
              this._protocol._debug(`Outbound: Sending ${type}`);
            }
            const pubKey = this.getPublicKey();
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);
            packet[p] = MESSAGE.KEXDH_INIT;
            writeUInt32BE(packet, pubKey.length, ++p);
            packet.set(pubKey, p += 4);
            this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));
          }
        }
        getPublicKey() {
          this.generateKeys();
          const key = this._public;
          if (key) return this.convertPublicKey(key);
        }
        convertPublicKey(key) {
          let newKey;
          let idx = 0;
          let len = key.length;
          while (key[idx] === 0) {
            ++idx;
            --len;
          }
          if (key[idx] & 128) {
            newKey = Buffer.allocUnsafe(1 + len);
            newKey[0] = 0;
            key.copy(newKey, 1, idx);
            return newKey;
          }
          if (len !== key.length) {
            newKey = Buffer.allocUnsafe(len);
            key.copy(newKey, 0, idx);
            key = newKey;
          }
          return key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            return convertToMpint(this._dh.computeSecret(otherPublicKey));
          } catch (ex) {
            return ex;
          }
        }
        parse(payload) {
          const type = payload[0];
          switch (this._step) {
            case 1:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_INIT) {
                  return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_INIT}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                }
                this._protocol._debug && this._protocol._debug("Received DH Init");
                bufferParser.init(payload, 1);
                const dhData = bufferParser.readString();
                bufferParser.clear();
                if (dhData === void 0) {
                  return doFatalError(this._protocol, "Received malformed KEX*_INIT", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                }
                this._dhData = dhData;
                let hostKey = this._protocol._hostKeys[this.negotiated.serverHostKey];
                if (Array.isArray(hostKey)) hostKey = hostKey[0];
                this._hostKey = hostKey;
                this.finish();
              } else {
                if (type !== MESSAGE.KEXDH_REPLY) {
                  return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_REPLY}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                }
                this._protocol._debug && this._protocol._debug("Received DH Reply");
                bufferParser.init(payload, 1);
                let hostPubKey;
                let dhData;
                let sig;
                if ((hostPubKey = bufferParser.readString()) === void 0 || (dhData = bufferParser.readString()) === void 0 || (sig = bufferParser.readString()) === void 0) {
                  bufferParser.clear();
                  return doFatalError(this._protocol, "Received malformed KEX*_REPLY", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                }
                bufferParser.clear();
                bufferParser.init(hostPubKey, 0);
                const hostPubKeyType = bufferParser.readString(true);
                bufferParser.clear();
                if (hostPubKeyType === void 0) {
                  return doFatalError(this._protocol, "Received malformed host public key", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                }
                if (hostPubKeyType !== this.negotiated.serverHostKey) {
                  switch (this.negotiated.serverHostKey) {
                    case "rsa-sha2-256":
                    case "rsa-sha2-512":
                      if (hostPubKeyType === "ssh-rsa") break;
                    // FALLTHROUGH
                    default:
                      return doFatalError(this._protocol, "Host key does not match negotiated type", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                  }
                }
                this._hostKey = hostPubKey;
                this._dhData = dhData;
                this._sig = sig;
                let checked = false;
                let ret;
                if (this._protocol._hostVerifier === void 0) {
                  ret = true;
                  this._protocol._debug && this._protocol._debug("Host accepted by default (no verification)");
                } else {
                  ret = this._protocol._hostVerifier(hostPubKey, (permitted) => {
                    if (checked) return;
                    checked = true;
                    if (permitted === false) {
                      this._protocol._debug && this._protocol._debug("Host denied (verification failed)");
                      return doFatalError(this._protocol, "Host denied (verification failed)", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                    }
                    this._protocol._debug && this._protocol._debug("Host accepted (verified)");
                    this._hostVerified = true;
                    if (this._receivedNEWKEYS) this.finish();
                    else trySendNEWKEYS(this);
                  });
                }
                if (ret === void 0) {
                  ++this._step;
                  return;
                }
                checked = true;
                if (ret === false) {
                  this._protocol._debug && this._protocol._debug("Host denied (verification failed)");
                  return doFatalError(this._protocol, "Host denied (verification failed)", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                }
                this._protocol._debug && this._protocol._debug("Host accepted (verified)");
                this._hostVerified = true;
                trySendNEWKEYS(this);
              }
              ++this._step;
              break;
            case 2:
              if (type !== MESSAGE.NEWKEYS) {
                return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.NEWKEYS}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
              }
              this._protocol._debug && this._protocol._debug("Inbound: NEWKEYS");
              this._receivedNEWKEYS = true;
              if (this._protocol._strictMode) this._protocol._decipher.inSeqno = 0;
              ++this._step;
              return this.finish(!this._protocol._server && !this._hostVerified);
            default:
              return doFatalError(this._protocol, `Received unexpected packet ${type} after NEWKEYS`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
          }
        }
      };
      let Curve25519Exchange = class Curve25519Exchange extends KeyExchange {
        static {
          __name(this, "Curve25519Exchange");
        }
        constructor(hashName, ...args) {
          super(...args);
          this.type = "25519";
          this.hashName = hashName;
          this._keys = null;
        }
        generateKeys() {
          if (!this._keys) this._keys = generateKeyPairSync("x25519");
        }
        getPublicKey() {
          this.generateKeys();
          const key = this._keys.publicKey.export({
            type: "spki",
            format: "der"
          });
          return key.slice(-32);
        }
        convertPublicKey(key) {
          let newKey;
          let idx = 0;
          let len = key.length;
          while (key[idx] === 0) {
            ++idx;
            --len;
          }
          if (key.length === 32) return key;
          if (len !== key.length) {
            newKey = Buffer.allocUnsafe(len);
            key.copy(newKey, 0, idx);
            key = newKey;
          }
          return key;
        }
        computeSecret(otherPublicKey) {
          this.generateKeys();
          try {
            const asnWriter = new Ber.Writer();
            asnWriter.startSequence();
            asnWriter.startSequence();
            asnWriter.writeOID("1.3.101.110");
            asnWriter.endSequence();
            asnWriter.startSequence(Ber.BitString);
            asnWriter.writeByte(0);
            asnWriter._ensure(otherPublicKey.length);
            otherPublicKey.copy(asnWriter._buf, asnWriter._offset, 0, otherPublicKey.length);
            asnWriter._offset += otherPublicKey.length;
            asnWriter.endSequence();
            asnWriter.endSequence();
            return convertToMpint(diffieHellman({
              privateKey: this._keys.privateKey,
              publicKey: createPublicKey({
                key: asnWriter.buffer,
                type: "spki",
                format: "der"
              })
            }));
          } catch (ex) {
            return ex;
          }
        }
      };
      let ECDHExchange = class ECDHExchange extends KeyExchange {
        static {
          __name(this, "ECDHExchange");
        }
        constructor(curveName, hashName, ...args) {
          super(...args);
          this.type = "ecdh";
          this.curveName = curveName;
          this.hashName = hashName;
        }
        generateKeys() {
          if (!this._dh) {
            this._dh = createECDH(this.curveName);
            this._public = this._dh.generateKeys();
          }
        }
      };
      let DHGroupExchange = class DHGroupExchange extends KeyExchange {
        static {
          __name(this, "DHGroupExchange");
        }
        constructor(hashName, ...args) {
          super(...args);
          this.type = "groupex";
          this.hashName = hashName;
          this._prime = null;
          this._generator = null;
          this._minBits = GEX_MIN_BITS;
          this._prefBits = dhEstimate(this.negotiated);
          if (this._protocol._compatFlags & COMPAT.BUG_DHGEX_LARGE) this._prefBits = Math.min(this._prefBits, 4096);
          this._maxBits = GEX_MAX_BITS;
        }
        start() {
          if (this._protocol._server) return;
          this._protocol._debug && this._protocol._debug("Outbound: Sending KEXDH_GEX_REQUEST");
          let p = this._protocol._packetRW.write.allocStartKEX;
          const packet = this._protocol._packetRW.write.alloc(1 + 4 + 4 + 4, true);
          packet[p] = MESSAGE.KEXDH_GEX_REQUEST;
          writeUInt32BE(packet, this._minBits, ++p);
          writeUInt32BE(packet, this._prefBits, p += 4);
          writeUInt32BE(packet, this._maxBits, p += 4);
          this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));
        }
        generateKeys() {
          if (!this._dh && this._prime && this._generator) {
            this._dh = createDiffieHellman(this._prime, this._generator);
            this._public = this._dh.generateKeys();
          }
        }
        setDHParams(prime, generator) {
          if (!Buffer.isBuffer(prime)) throw new Error("Invalid prime value");
          if (!Buffer.isBuffer(generator)) throw new Error("Invalid generator value");
          this._prime = prime;
          this._generator = generator;
        }
        getDHParams() {
          if (this._dh) {
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
          }
        }
        parse(payload) {
          const type = payload[0];
          switch (this._step) {
            case 1: {
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_GEX_REQUEST) {
                  return doFatalError(this._protocol, `Received packet ${type} instead of ` + MESSAGE.KEXDH_GEX_REQUEST, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                }
                return doFatalError(this._protocol, "Group exchange not implemented for server", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
              }
              if (type !== MESSAGE.KEXDH_GEX_GROUP) {
                return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_GROUP}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
              }
              this._protocol._debug && this._protocol._debug("Received DH GEX Group");
              bufferParser.init(payload, 1);
              let prime;
              let gen;
              if ((prime = bufferParser.readString()) === void 0 || (gen = bufferParser.readString()) === void 0) {
                bufferParser.clear();
                return doFatalError(this._protocol, "Received malformed KEXDH_GEX_GROUP", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
              }
              bufferParser.clear();
              this.setDHParams(prime, gen);
              this.generateKeys();
              const pubkey = this.getPublicKey();
              this._protocol._debug && this._protocol._debug("Outbound: Sending KEXDH_GEX_INIT");
              let p = this._protocol._packetRW.write.allocStartKEX;
              const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubkey.length, true);
              packet[p] = MESSAGE.KEXDH_GEX_INIT;
              writeUInt32BE(packet, pubkey.length, ++p);
              packet.set(pubkey, p += 4);
              this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));
              ++this._step;
              break;
            }
            case 2:
              if (this._protocol._server) {
                if (type !== MESSAGE.KEXDH_GEX_INIT) {
                  return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_INIT}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
                }
                this._protocol._debug && this._protocol._debug("Received DH GEX Init");
                return doFatalError(this._protocol, "Group exchange not implemented for server", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
              } else if (type !== MESSAGE.KEXDH_GEX_REPLY) {
                return doFatalError(this._protocol, `Received packet ${type} instead of ${MESSAGE.KEXDH_GEX_REPLY}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
              }
              this._protocol._debug && this._protocol._debug("Received DH GEX Reply");
              this._step = 1;
              payload[0] = MESSAGE.KEXDH_REPLY;
              this.parse = KeyExchange.prototype.parse;
              this.parse(payload);
          }
        }
      };
      let DHExchange = class DHExchange extends KeyExchange {
        static {
          __name(this, "DHExchange");
        }
        constructor(groupName, hashName, ...args) {
          super(...args);
          this.type = "group";
          this.groupName = groupName;
          this.hashName = hashName;
        }
        start() {
          if (!this._protocol._server) {
            this._protocol._debug && this._protocol._debug("Outbound: Sending KEXDH_INIT");
            const pubKey = this.getPublicKey();
            let p = this._protocol._packetRW.write.allocStartKEX;
            const packet = this._protocol._packetRW.write.alloc(1 + 4 + pubKey.length, true);
            packet[p] = MESSAGE.KEXDH_INIT;
            writeUInt32BE(packet, pubKey.length, ++p);
            packet.set(pubKey, p += 4);
            this._protocol._cipher.encrypt(this._protocol._packetRW.write.finalize(packet, true));
          }
        }
        generateKeys() {
          if (!this._dh) {
            this._dh = createDiffieHellmanGroup(this.groupName);
            this._public = this._dh.generateKeys();
          }
        }
        getDHParams() {
          if (this._dh) {
            return {
              prime: convertToMpint(this._dh.getPrime()),
              generator: convertToMpint(this._dh.getGenerator())
            };
          }
        }
      };
      return (negotiated, ...args) => {
        if (typeof negotiated !== "object" || negotiated === null) throw new Error("Invalid negotiated argument");
        const kexType = negotiated.kex;
        if (typeof kexType === "string") {
          args = [
            negotiated,
            ...args
          ];
          switch (kexType) {
            case "curve25519-sha256":
            case "curve25519-sha256@libssh.org":
              if (!curve25519Supported) break;
              return new Curve25519Exchange("sha256", ...args);
            case "ecdh-sha2-nistp256":
              return new ECDHExchange("prime256v1", "sha256", ...args);
            case "ecdh-sha2-nistp384":
              return new ECDHExchange("secp384r1", "sha384", ...args);
            case "ecdh-sha2-nistp521":
              return new ECDHExchange("secp521r1", "sha512", ...args);
            case "diffie-hellman-group1-sha1":
              return new DHExchange("modp2", "sha1", ...args);
            case "diffie-hellman-group14-sha1":
              return new DHExchange("modp14", "sha1", ...args);
            case "diffie-hellman-group14-sha256":
              return new DHExchange("modp14", "sha256", ...args);
            case "diffie-hellman-group15-sha512":
              return new DHExchange("modp15", "sha512", ...args);
            case "diffie-hellman-group16-sha512":
              return new DHExchange("modp16", "sha512", ...args);
            case "diffie-hellman-group17-sha512":
              return new DHExchange("modp17", "sha512", ...args);
            case "diffie-hellman-group18-sha512":
              return new DHExchange("modp18", "sha512", ...args);
            case "diffie-hellman-group-exchange-sha1":
              return new DHGroupExchange("sha1", ...args);
            case "diffie-hellman-group-exchange-sha256":
              return new DHGroupExchange("sha256", ...args);
          }
          throw new Error(`Unsupported key exchange algorithm: ${kexType}`);
        }
        throw new Error(`Invalid key exchange type: ${kexType}`);
      };
    })();
    var KexInit = /* @__PURE__ */ (() => {
      const KEX_PROPERTY_NAMES = [
        "kex",
        "serverHostKey",
        [
          "cs",
          "cipher"
        ],
        [
          "sc",
          "cipher"
        ],
        [
          "cs",
          "mac"
        ],
        [
          "sc",
          "mac"
        ],
        [
          "cs",
          "compress"
        ],
        [
          "sc",
          "compress"
        ],
        [
          "cs",
          "lang"
        ],
        [
          "sc",
          "lang"
        ]
      ];
      return class KexInit {
        static {
          __name(this, "KexInit");
        }
        constructor(obj) {
          if (typeof obj !== "object" || obj === null) throw new TypeError("Argument must be an object");
          const lists = {
            kex: void 0,
            serverHostKey: void 0,
            cs: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            sc: {
              cipher: void 0,
              mac: void 0,
              compress: void 0,
              lang: void 0
            },
            all: void 0
          };
          let totalSize = 0;
          for (const prop of KEX_PROPERTY_NAMES) {
            let base;
            let val;
            let desc;
            let key;
            if (typeof prop === "string") {
              base = lists;
              val = obj[prop];
              desc = key = prop;
            } else {
              const parent = prop[0];
              base = lists[parent];
              key = prop[1];
              val = obj[parent][key];
              desc = `${parent}.${key}`;
            }
            const entry = {
              array: void 0,
              buffer: void 0
            };
            if (Buffer.isBuffer(val)) {
              entry.array = ("" + val).split(",");
              entry.buffer = val;
              totalSize += 4 + val.length;
            } else {
              if (typeof val === "string") val = val.split(",");
              if (Array.isArray(val)) {
                entry.array = val;
                entry.buffer = Buffer.from(val.join(","));
              } else {
                throw new TypeError(`Invalid \`${desc}\` type: ${typeof val}`);
              }
              totalSize += 4 + entry.buffer.length;
            }
            base[key] = entry;
          }
          const all = Buffer.allocUnsafe(totalSize);
          lists.all = all;
          let allPos = 0;
          for (const prop of KEX_PROPERTY_NAMES) {
            let data;
            if (typeof prop === "string") data = lists[prop].buffer;
            else data = lists[prop[0]][prop[1]].buffer;
            allPos = writeUInt32BE(all, data.length, allPos);
            all.set(data, allPos);
            allPos += data.length;
          }
          this.totalSize = totalSize;
          this.lists = lists;
        }
        copyAllTo(buf, offset) {
          const src = this.lists.all;
          if (typeof offset !== "number") throw new TypeError(`Invalid offset value: ${typeof offset}`);
          if (buf.length - offset < src.length) throw new Error("Insufficient space to copy list");
          buf.set(src, offset);
          return src.length;
        }
      };
    })();
    var hashString = (() => {
      const LEN = Buffer.allocUnsafe(4);
      return (hash, buf) => {
        writeUInt32BE(LEN, buf.length, 0);
        hash.update(LEN);
        hash.update(buf);
      };
    })();
    function generateKEXVal(len, hashName, secret, exchangeHash, sessionID, char) {
      let ret;
      if (len) {
        let digest = createHash(hashName).update(secret).update(exchangeHash).update(char).update(sessionID).digest();
        while (digest.length < len) {
          const chunk = createHash(hashName).update(secret).update(exchangeHash).update(digest).digest();
          const extended = Buffer.allocUnsafe(digest.length + chunk.length);
          extended.set(digest, 0);
          extended.set(chunk, digest.length);
          digest = extended;
        }
        if (digest.length === len) ret = digest;
        else ret = new FastBuffer(digest.buffer, digest.byteOffset, len);
      } else {
        ret = EMPTY_BUFFER;
      }
      return ret;
    }
    __name(generateKEXVal, "generateKEXVal");
    function onKEXPayload(state, payload) {
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      if (this._skipNextInboundPacket) {
        this._skipNextInboundPacket = false;
        return;
      }
      payload = this._packetRW.read.read(payload);
      const type = payload[0];
      if (!this._strictMode) {
        switch (type) {
          case MESSAGE.IGNORE:
          case MESSAGE.UNIMPLEMENTED:
          case MESSAGE.DEBUG:
            if (!MESSAGE_HANDLERS) MESSAGE_HANDLERS = require_handlers();
            return MESSAGE_HANDLERS[type](this, payload);
        }
      }
      switch (type) {
        case MESSAGE.DISCONNECT:
          if (!MESSAGE_HANDLERS) MESSAGE_HANDLERS = require_handlers();
          return MESSAGE_HANDLERS[type](this, payload);
        case MESSAGE.KEXINIT:
          if (!state.firstPacket) {
            return doFatalError(this, "Received extra KEXINIT during handshake", "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
          }
          state.firstPacket = false;
          return handleKexInit(this, payload);
        default:
          if (type < 20 || type > 49) {
            return doFatalError(this, `Received unexpected packet type ${type}`, "handshake", DISCONNECT_REASON.KEY_EXCHANGE_FAILED);
          }
      }
      return this._kex.parse(payload);
    }
    __name(onKEXPayload, "onKEXPayload");
    function dhEstimate(neg) {
      const csCipher = CIPHER_INFO[neg.cs.cipher];
      const scCipher = CIPHER_INFO[neg.sc.cipher];
      const bits = Math.max(0, csCipher.sslName === "des-ede3-cbc" ? 14 : csCipher.keyLen, csCipher.blockLen, csCipher.ivLen, scCipher.sslName === "des-ede3-cbc" ? 14 : scCipher.keyLen, scCipher.blockLen, scCipher.ivLen) * 8;
      if (bits <= 112) return 2048;
      if (bits <= 128) return 3072;
      if (bits <= 192) return 7680;
      return 8192;
    }
    __name(dhEstimate, "dhEstimate");
    function trySendNEWKEYS(kex) {
      if (!kex._sentNEWKEYS) {
        kex._protocol._debug && kex._protocol._debug("Outbound: Sending NEWKEYS");
        const p = kex._protocol._packetRW.write.allocStartKEX;
        const packet = kex._protocol._packetRW.write.alloc(1, true);
        packet[p] = MESSAGE.NEWKEYS;
        kex._protocol._cipher.encrypt(kex._protocol._packetRW.write.finalize(packet, true));
        kex._sentNEWKEYS = true;
        if (kex._protocol._strictMode) kex._protocol._cipher.outSeqno = 0;
      }
    }
    __name(trySendNEWKEYS, "trySendNEWKEYS");
    module2.exports = {
      KexInit,
      kexinit,
      onKEXPayload,
      DEFAULT_KEXINIT_CLIENT: new KexInit({
        kex: DEFAULT_KEX.concat([
          "ext-info-c",
          "kex-strict-c-v00@openssh.com"
        ]),
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      DEFAULT_KEXINIT_SERVER: new KexInit({
        kex: DEFAULT_KEX.concat([
          "kex-strict-s-v00@openssh.com"
        ]),
        serverHostKey: DEFAULT_SERVER_HOST_KEY,
        cs: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        },
        sc: {
          cipher: DEFAULT_CIPHER,
          mac: DEFAULT_MAC,
          compress: DEFAULT_COMPRESSION,
          lang: []
        }
      }),
      HANDLERS: {
        [MESSAGE.KEXINIT]: handleKexInit
      }
    };
  }
});

// node_modules/ssh2/package.json
var require_package3 = __commonJS({
  "node_modules/ssh2/package.json"(exports2, module2) {
    module2.exports = {
      name: "ssh2",
      version: "1.16.0",
      author: "Brian White <mscdex@mscdex.net>",
      description: "SSH2 client and server modules written in pure JavaScript for node.js",
      main: "./lib/index.js",
      engines: {
        node: ">=10.16.0"
      },
      dependencies: {
        asn1: "^0.2.6",
        "bcrypt-pbkdf": "^1.0.2"
      },
      devDependencies: {
        "@mscdex/eslint-config": "^1.1.0",
        eslint: "^7.32.0"
      },
      optionalDependencies: {
        "cpu-features": "~0.0.10",
        nan: "^2.20.0"
      },
      scripts: {
        install: "node install.js",
        rebuild: "node install.js",
        test: "node test/test.js",
        lint: "eslint --cache --report-unused-disable-directives --ext=.js .eslintrc.js examples lib test",
        "lint:fix": "npm run lint -- --fix"
      },
      keywords: [
        "ssh",
        "ssh2",
        "sftp",
        "secure",
        "shell",
        "exec",
        "remote",
        "client"
      ],
      licenses: [
        {
          type: "MIT",
          url: "http://github.com/mscdex/ssh2/raw/master/LICENSE"
        }
      ],
      repository: {
        type: "git",
        url: "http://github.com/mscdex/ssh2.git"
      }
    };
  }
});

// node_modules/ssh2/lib/protocol/Protocol.js
var require_Protocol = __commonJS({
  "node_modules/ssh2/lib/protocol/Protocol.js"(exports2, module2) {
    "use strict";
    var { inspect: inspect2 } = require("util");
    var { bindingAvailable, NullCipher, NullDecipher } = require_crypto();
    var { COMPAT_CHECKS, DISCONNECT_REASON, eddsaSupported, MESSAGE, SIGNALS, TERMINAL_MODE } = require_constants2();
    var { DEFAULT_KEXINIT_CLIENT, DEFAULT_KEXINIT_SERVER, KexInit, kexinit, onKEXPayload } = require_kex();
    var { parseKey } = require_keyParser();
    var MESSAGE_HANDLERS = require_handlers();
    var { bufferCopy, bufferFill, bufferSlice, convertSignature, sendPacket, writeUInt32BE } = require_utils2();
    var { PacketReader, PacketWriter, ZlibPacketReader, ZlibPacketWriter } = require_zlib();
    var MODULE_VER = require_package3().version;
    var VALID_DISCONNECT_REASONS = new Map(Object.values(DISCONNECT_REASON).map((n) => [
      n,
      1
    ]));
    var IDENT_RAW = Buffer.from(`SSH-2.0-ssh2js${MODULE_VER}`);
    var IDENT = Buffer.from(`${IDENT_RAW}\r
`);
    var MAX_LINE_LEN = 8192;
    var MAX_LINES = 1024;
    var PING_PAYLOAD = Buffer.from([
      MESSAGE.GLOBAL_REQUEST,
      // "keepalive@openssh.com"
      0,
      0,
      0,
      21,
      107,
      101,
      101,
      112,
      97,
      108,
      105,
      118,
      101,
      64,
      111,
      112,
      101,
      110,
      115,
      115,
      104,
      46,
      99,
      111,
      109,
      // Request a reply
      1
    ]);
    var NO_TERMINAL_MODES_BUFFER = Buffer.from([
      TERMINAL_MODE.TTY_OP_END
    ]);
    function noop() {
    }
    __name(noop, "noop");
    var Protocol = class Protocol {
      static {
        __name(this, "Protocol");
      }
      constructor(config) {
        const onWrite = config.onWrite;
        if (typeof onWrite !== "function") throw new Error("Missing onWrite function");
        this._onWrite = (data) => {
          onWrite(data);
        };
        const onError = config.onError;
        if (typeof onError !== "function") throw new Error("Missing onError function");
        this._onError = (err) => {
          onError(err);
        };
        const debug12 = config.debug;
        this._debug = typeof debug12 === "function" ? (msg) => {
          debug12(msg);
        } : void 0;
        const onHeader = config.onHeader;
        this._onHeader = typeof onHeader === "function" ? (...args) => {
          onHeader(...args);
        } : noop;
        const onPacket = config.onPacket;
        this._onPacket = typeof onPacket === "function" ? () => {
          onPacket();
        } : noop;
        let onHandshakeComplete = config.onHandshakeComplete;
        if (typeof onHandshakeComplete !== "function") onHandshakeComplete = noop;
        let firstHandshake;
        this._onHandshakeComplete = (...args) => {
          this._debug && this._debug("Handshake completed");
          if (firstHandshake === void 0) firstHandshake = true;
          else firstHandshake = false;
          const oldQueue = this._queue;
          if (oldQueue) {
            this._queue = void 0;
            this._debug && this._debug(`Draining outbound queue (${oldQueue.length}) ...`);
            for (let i = 0; i < oldQueue.length; ++i) {
              const data = oldQueue[i];
              let finalized = this._packetRW.write.finalize(data);
              if (finalized === data) {
                const packet = this._cipher.allocPacket(data.length);
                packet.set(data, 5);
                finalized = packet;
              }
              sendPacket(this, finalized);
            }
            this._debug && this._debug("... finished draining outbound queue");
          }
          if (firstHandshake && this._server && this._kex.remoteExtInfoEnabled) sendExtInfo(this);
          onHandshakeComplete(...args);
        };
        this._queue = void 0;
        const messageHandlers = config.messageHandlers;
        if (typeof messageHandlers === "object" && messageHandlers !== null) this._handlers = messageHandlers;
        else this._handlers = {};
        this._onPayload = onPayload.bind(this);
        this._server = !!config.server;
        this._banner = void 0;
        let greeting;
        if (this._server) {
          if (typeof config.hostKeys !== "object" || config.hostKeys === null) throw new Error("Missing server host key(s)");
          this._hostKeys = config.hostKeys;
          if (typeof config.greeting === "string" && config.greeting.length) {
            greeting = config.greeting.slice(-2) === "\r\n" ? config.greeting : `${config.greeting}\r
`;
          }
          if (typeof config.banner === "string" && config.banner.length) {
            this._banner = config.banner.slice(-2) === "\r\n" ? config.banner : `${config.banner}\r
`;
          }
        } else {
          this._hostKeys = void 0;
        }
        let offer = config.offer;
        if (typeof offer !== "object" || offer === null) {
          offer = this._server ? DEFAULT_KEXINIT_SERVER : DEFAULT_KEXINIT_CLIENT;
        } else if (offer.constructor !== KexInit) {
          if (this._server) {
            offer.kex = offer.kex.concat([
              "kex-strict-s-v00@openssh.com"
            ]);
          } else {
            offer.kex = offer.kex.concat([
              "ext-info-c",
              "kex-strict-c-v00@openssh.com"
            ]);
          }
          offer = new KexInit(offer);
        }
        this._kex = void 0;
        this._strictMode = void 0;
        this._kexinit = void 0;
        this._offer = offer;
        this._cipher = new NullCipher(0, this._onWrite);
        this._decipher = void 0;
        this._skipNextInboundPacket = false;
        this._packetRW = {
          read: new PacketReader(),
          write: new PacketWriter(this)
        };
        this._hostVerifier = !this._server && typeof config.hostVerifier === "function" ? config.hostVerifier : void 0;
        this._parse = parseHeader;
        this._buffer = void 0;
        this._authsQueue = [];
        this._authenticated = false;
        this._remoteIdentRaw = void 0;
        let sentIdent;
        if (typeof config.ident === "string") {
          this._identRaw = Buffer.from(`SSH-2.0-${config.ident}`);
          sentIdent = Buffer.allocUnsafe(this._identRaw.length + 2);
          sentIdent.set(this._identRaw, 0);
          sentIdent[sentIdent.length - 2] = 13;
          sentIdent[sentIdent.length - 1] = 10;
        } else if (Buffer.isBuffer(config.ident)) {
          const fullIdent = Buffer.allocUnsafe(8 + config.ident.length);
          fullIdent.latin1Write("SSH-2.0-", 0, 8);
          fullIdent.set(config.ident, 8);
          this._identRaw = fullIdent;
          sentIdent = Buffer.allocUnsafe(fullIdent.length + 2);
          sentIdent.set(fullIdent, 0);
          sentIdent[sentIdent.length - 2] = 13;
          sentIdent[sentIdent.length - 1] = 10;
        } else {
          this._identRaw = IDENT_RAW;
          sentIdent = IDENT;
        }
        this._compatFlags = 0;
        if (this._debug) {
          if (bindingAvailable) this._debug("Custom crypto binding available");
          else this._debug("Custom crypto binding not available");
        }
        this._debug && this._debug(`Local ident: ${inspect2(this._identRaw.toString())}`);
        this.start = () => {
          this.start = void 0;
          if (greeting) this._onWrite(greeting);
          this._onWrite(sentIdent);
        };
      }
      _destruct(reason) {
        this._packetRW.read.cleanup();
        this._packetRW.write.cleanup();
        this._cipher && this._cipher.free();
        this._decipher && this._decipher.free();
        if (typeof reason !== "string" || reason.length === 0) reason = "fatal error";
        this.parse = () => {
          throw new Error(`Instance unusable after ${reason}`);
        };
        this._onWrite = () => {
          throw new Error(`Instance unusable after ${reason}`);
        };
        this._destruct = void 0;
      }
      cleanup() {
        this._destruct && this._destruct();
      }
      parse(chunk, i, len) {
        while (i < len) i = this._parse(chunk, i, len);
      }
      // Protocol message API
      // ===========================================================================
      // Common/Shared =============================================================
      // ===========================================================================
      // Global
      // ------
      disconnect(reason) {
        const pktLen = 1 + 4 + 4 + 4;
        let p = this._packetRW.write.allocStartKEX;
        const packet = this._packetRW.write.alloc(pktLen, true);
        const end = p + pktLen;
        if (!VALID_DISCONNECT_REASONS.has(reason)) reason = DISCONNECT_REASON.PROTOCOL_ERROR;
        packet[p] = MESSAGE.DISCONNECT;
        writeUInt32BE(packet, reason, ++p);
        packet.fill(0, p += 4, end);
        this._debug && this._debug(`Outbound: Sending DISCONNECT (${reason})`);
        sendPacket(this, this._packetRW.write.finalize(packet, true), true);
      }
      ping() {
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(PING_PAYLOAD.length);
        packet.set(PING_PAYLOAD, p);
        this._debug && this._debug("Outbound: Sending ping (GLOBAL_REQUEST: keepalive@openssh.com)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      rekey() {
        if (this._kexinit === void 0) {
          this._debug && this._debug("Outbound: Initiated explicit rekey");
          this._queue = [];
          kexinit(this);
        } else {
          this._debug && this._debug("Outbound: Ignoring rekey during handshake");
        }
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      requestSuccess(data) {
        let p = this._packetRW.write.allocStart;
        let packet;
        if (Buffer.isBuffer(data)) {
          packet = this._packetRW.write.alloc(1 + data.length);
          packet[p] = MESSAGE.REQUEST_SUCCESS;
          packet.set(data, ++p);
        } else {
          packet = this._packetRW.write.alloc(1);
          packet[p] = MESSAGE.REQUEST_SUCCESS;
        }
        this._debug && this._debug("Outbound: Sending REQUEST_SUCCESS");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      requestFailure() {
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.REQUEST_FAILURE;
        this._debug && this._debug("Outbound: Sending REQUEST_FAILURE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelSuccess(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_SUCCESS;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_SUCCESS (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelFailure(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_FAILURE;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_FAILURE (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelEOF(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_EOF;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_EOF (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelClose(chan) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4);
        packet[p] = MESSAGE.CHANNEL_CLOSE;
        writeUInt32BE(packet, chan, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_CLOSE (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelWindowAdjust(chan, amount) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_WINDOW_ADJUST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, amount, p += 4);
        this._debug && this._debug(`Outbound: Sending CHANNEL_WINDOW_ADJUST (r:${chan}, ${amount})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelData(chan, data) {
        const isBuffer = Buffer.isBuffer(data);
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + dataLen);
        packet[p] = MESSAGE.CHANNEL_DATA;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, dataLen, p += 4);
        if (isBuffer) packet.set(data, p += 4);
        else packet.utf8Write(data, p += 4, dataLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_DATA (r:${chan}, ${dataLen})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelExtData(chan, data, type) {
        const isBuffer = Buffer.isBuffer(data);
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + dataLen);
        packet[p] = MESSAGE.CHANNEL_EXTENDED_DATA;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, type, p += 4);
        writeUInt32BE(packet, dataLen, p += 4);
        if (isBuffer) packet.set(data, p += 4);
        else packet.utf8Write(data, p += 4, dataLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_EXTENDED_DATA (r:${chan})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenConfirm(remote, local, initWindow, maxPacket) {
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_CONFIRMATION;
        writeUInt32BE(packet, remote, ++p);
        writeUInt32BE(packet, local, p += 4);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_CONFIRMATION (r:${remote}, l:${local})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      channelOpenFail(remote, reason, desc) {
        if (typeof desc !== "string") desc = "";
        const descLen = Buffer.byteLength(desc);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + descLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN_FAILURE;
        writeUInt32BE(packet, remote, ++p);
        writeUInt32BE(packet, reason, p += 4);
        writeUInt32BE(packet, descLen, p += 4);
        p += 4;
        if (descLen) {
          packet.utf8Write(desc, p, descLen);
          p += descLen;
        }
        writeUInt32BE(packet, 0, p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN_FAILURE (r:${remote})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      service(name) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const nameLen = Buffer.byteLength(name);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + nameLen);
        packet[p] = MESSAGE.SERVICE_REQUEST;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(name, p += 4, nameLen);
        this._debug && this._debug(`Outbound: Sending SERVICE_REQUEST (${name})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      // -------------------------------
      authPassword(username, password, newPassword) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        const passLen = Buffer.byteLength(password);
        const newPassLen = newPassword ? Buffer.byteLength(newPassword) : 0;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 8 + 1 + 4 + passLen + (newPassword ? 4 + newPassLen : 0));
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 8, p += 14);
        packet.utf8Write("password", p += 4, 8);
        packet[p += 8] = newPassword ? 1 : 0;
        writeUInt32BE(packet, passLen, ++p);
        if (Buffer.isBuffer(password)) bufferCopy(password, packet, 0, passLen, p += 4);
        else packet.utf8Write(password, p += 4, passLen);
        if (newPassword) {
          writeUInt32BE(packet, newPassLen, p += passLen);
          if (Buffer.isBuffer(newPassword)) bufferCopy(newPassword, packet, 0, newPassLen, p += 4);
          else packet.utf8Write(newPassword, p += 4, newPassLen);
          this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (changed password)");
        } else {
          this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (password)");
        }
        this._authsQueue.push("password");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPK(username, pubKey, keyAlgo, cbSign) {
        if (this._server) throw new Error("Client-only method called in server mode");
        pubKey = parseKey(pubKey);
        if (pubKey instanceof Error) throw new Error("Invalid key");
        const keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH();
        if (typeof keyAlgo === "function") {
          cbSign = keyAlgo;
          keyAlgo = void 0;
        }
        if (!keyAlgo) keyAlgo = keyType;
        const userLen = Buffer.byteLength(username);
        const algoLen = Buffer.byteLength(keyAlgo);
        const pubKeyLen = pubKey.length;
        const sessionID = this._kex.sessionID;
        const sesLen = sessionID.length;
        const payloadLen = (cbSign ? 4 + sesLen : 0) + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen;
        let packet;
        let p;
        if (cbSign) {
          packet = Buffer.allocUnsafe(payloadLen);
          p = 0;
          writeUInt32BE(packet, sesLen, p);
          packet.set(sessionID, p += 4);
          p += sesLen;
        } else {
          packet = this._packetRW.write.alloc(payloadLen);
          p = this._packetRW.write.allocStart;
        }
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 9, p += 14);
        packet.utf8Write("publickey", p += 4, 9);
        packet[p += 9] = cbSign ? 1 : 0;
        writeUInt32BE(packet, algoLen, ++p);
        packet.utf8Write(keyAlgo, p += 4, algoLen);
        writeUInt32BE(packet, pubKeyLen, p += algoLen);
        packet.set(pubKey, p += 4);
        if (!cbSign) {
          this._authsQueue.push("publickey");
          this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (publickey -- check)");
          sendPacket(this, this._packetRW.write.finalize(packet));
          return;
        }
        cbSign(packet, (signature) => {
          signature = convertSignature(signature, keyType);
          if (signature === false) throw new Error("Error while converting handshake signature");
          const sigLen = signature.length;
          p = this._packetRW.write.allocStart;
          packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 9 + 1 + 4 + algoLen + 4 + pubKeyLen + 4 + 4 + algoLen + 4 + sigLen);
          packet[p] = MESSAGE.USERAUTH_REQUEST;
          writeUInt32BE(packet, userLen, ++p);
          packet.utf8Write(username, p += 4, userLen);
          writeUInt32BE(packet, 14, p += userLen);
          packet.utf8Write("ssh-connection", p += 4, 14);
          writeUInt32BE(packet, 9, p += 14);
          packet.utf8Write("publickey", p += 4, 9);
          packet[p += 9] = 1;
          writeUInt32BE(packet, algoLen, ++p);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, pubKeyLen, p += algoLen);
          packet.set(pubKey, p += 4);
          writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += pubKeyLen);
          writeUInt32BE(packet, algoLen, p += 4);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, sigLen, p += algoLen);
          packet.set(signature, p += 4);
          this._authsQueue.push("publickey");
          this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (publickey)");
          sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authHostbased(username, pubKey, hostname, userlocal, keyAlgo, cbSign) {
        if (this._server) throw new Error("Client-only method called in server mode");
        pubKey = parseKey(pubKey);
        if (pubKey instanceof Error) throw new Error("Invalid key");
        const keyType = pubKey.type;
        pubKey = pubKey.getPublicSSH();
        if (typeof keyAlgo === "function") {
          cbSign = keyAlgo;
          keyAlgo = void 0;
        }
        if (!keyAlgo) keyAlgo = keyType;
        const userLen = Buffer.byteLength(username);
        const algoLen = Buffer.byteLength(keyAlgo);
        const pubKeyLen = pubKey.length;
        const sessionID = this._kex.sessionID;
        const sesLen = sessionID.length;
        const hostnameLen = Buffer.byteLength(hostname);
        const userlocalLen = Buffer.byteLength(userlocal);
        const data = Buffer.allocUnsafe(4 + sesLen + 1 + 4 + userLen + 4 + 14 + 4 + 9 + 4 + algoLen + 4 + pubKeyLen + 4 + hostnameLen + 4 + userlocalLen);
        let p = 0;
        writeUInt32BE(data, sesLen, p);
        data.set(sessionID, p += 4);
        data[p += sesLen] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(data, userLen, ++p);
        data.utf8Write(username, p += 4, userLen);
        writeUInt32BE(data, 14, p += userLen);
        data.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(data, 9, p += 14);
        data.utf8Write("hostbased", p += 4, 9);
        writeUInt32BE(data, algoLen, p += 9);
        data.utf8Write(keyAlgo, p += 4, algoLen);
        writeUInt32BE(data, pubKeyLen, p += algoLen);
        data.set(pubKey, p += 4);
        writeUInt32BE(data, hostnameLen, p += pubKeyLen);
        data.utf8Write(hostname, p += 4, hostnameLen);
        writeUInt32BE(data, userlocalLen, p += hostnameLen);
        data.utf8Write(userlocal, p += 4, userlocalLen);
        cbSign(data, (signature) => {
          signature = convertSignature(signature, keyType);
          if (!signature) throw new Error("Error while converting handshake signature");
          const sigLen = signature.length;
          const reqDataLen = data.length - sesLen - 4;
          p = this._packetRW.write.allocStart;
          const packet = this._packetRW.write.alloc(reqDataLen + 4 + 4 + algoLen + 4 + sigLen);
          bufferCopy(data, packet, 4 + sesLen, data.length, p);
          writeUInt32BE(packet, 4 + algoLen + 4 + sigLen, p += reqDataLen);
          writeUInt32BE(packet, algoLen, p += 4);
          packet.utf8Write(keyAlgo, p += 4, algoLen);
          writeUInt32BE(packet, sigLen, p += algoLen);
          packet.set(signature, p += 4);
          this._authsQueue.push("hostbased");
          this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (hostbased)");
          sendPacket(this, this._packetRW.write.finalize(packet));
        });
      }
      authKeyboard(username) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 20 + 4 + 4);
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 20, p += 14);
        packet.utf8Write("keyboard-interactive", p += 4, 20);
        writeUInt32BE(packet, 0, p += 20);
        writeUInt32BE(packet, 0, p += 4);
        this._authsQueue.push("keyboard-interactive");
        this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (keyboard-interactive)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authNone(username) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const userLen = Buffer.byteLength(username);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + userLen + 4 + 14 + 4 + 4);
        packet[p] = MESSAGE.USERAUTH_REQUEST;
        writeUInt32BE(packet, userLen, ++p);
        packet.utf8Write(username, p += 4, userLen);
        writeUInt32BE(packet, 14, p += userLen);
        packet.utf8Write("ssh-connection", p += 4, 14);
        writeUInt32BE(packet, 4, p += 14);
        packet.utf8Write("none", p += 4, 4);
        this._authsQueue.push("none");
        this._debug && this._debug("Outbound: Sending USERAUTH_REQUEST (none)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoRes(responses) {
        if (this._server) throw new Error("Client-only method called in server mode");
        let responsesTotalLen = 0;
        let responseLens;
        if (responses) {
          responseLens = new Array(responses.length);
          for (let i = 0; i < responses.length; ++i) {
            const len = Buffer.byteLength(responses[i]);
            responseLens[i] = len;
            responsesTotalLen += 4 + len;
          }
        }
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + responsesTotalLen);
        packet[p] = MESSAGE.USERAUTH_INFO_RESPONSE;
        if (responses) {
          writeUInt32BE(packet, responses.length, ++p);
          p += 4;
          for (let i = 0; i < responses.length; ++i) {
            const len = responseLens[i];
            writeUInt32BE(packet, len, p);
            p += 4;
            if (len) {
              packet.utf8Write(responses[i], p, len);
              p += len;
            }
          }
        } else {
          writeUInt32BE(packet, 0, ++p);
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_RESPONSE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-connection' service-specific
      // ---------------------------------
      tcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const addrLen = Buffer.byteLength(bindAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 13 + 1 + 4 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 13, ++p);
        packet.utf8Write("tcpip-forward", p += 4, 13);
        packet[p += 13] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, addrLen, ++p);
        packet.utf8Write(bindAddr, p += 4, addrLen);
        writeUInt32BE(packet, bindPort, p += addrLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (tcpip-forward)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      cancelTcpipForward(bindAddr, bindPort, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const addrLen = Buffer.byteLength(bindAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 20 + 1 + 4 + addrLen + 4);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 20, ++p);
        packet.utf8Write("cancel-tcpip-forward", p += 4, 20);
        packet[p += 20] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, addrLen, ++p);
        packet.utf8Write(bindAddr, p += 4, addrLen);
        writeUInt32BE(packet, bindPort, p += addrLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-tcpip-forward)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_streamLocalForward(socketPath, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const socketPathLen = Buffer.byteLength(socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 31 + 1 + 4 + socketPathLen);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 31, ++p);
        packet.utf8Write("streamlocal-forward@openssh.com", p += 4, 31);
        packet[p += 31] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, socketPathLen, ++p);
        packet.utf8Write(socketPath, p += 4, socketPathLen);
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (streamlocal-forward@openssh.com)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_cancelStreamLocalForward(socketPath, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const socketPathLen = Buffer.byteLength(socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 38 + 1 + 4 + socketPathLen);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 38, ++p);
        packet.utf8Write("cancel-streamlocal-forward@openssh.com", p += 4, 38);
        packet[p += 38] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, socketPathLen, ++p);
        packet.utf8Write(socketPath, p += 4, socketPathLen);
        if (this._debug) {
          this._debug("Outbound: Sending GLOBAL_REQUEST (cancel-streamlocal-forward@openssh.com)");
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      directTcpip(chan, initWindow, maxPacket, cfg) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const srcLen = Buffer.byteLength(cfg.srcIP);
        const dstLen = Buffer.byteLength(cfg.dstIP);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 12 + 4 + 4 + 4 + 4 + srcLen + 4 + 4 + dstLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 12, ++p);
        packet.utf8Write("direct-tcpip", p += 4, 12);
        writeUInt32BE(packet, chan, p += 12);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, dstLen, p += 4);
        packet.utf8Write(cfg.dstIP, p += 4, dstLen);
        writeUInt32BE(packet, cfg.dstPort, p += dstLen);
        writeUInt32BE(packet, srcLen, p += 4);
        packet.utf8Write(cfg.srcIP, p += 4, srcLen);
        writeUInt32BE(packet, cfg.srcPort, p += srcLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-tcpip)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_directStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(cfg.socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 30 + 4 + 4 + 4 + 4 + pathLen + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 30, ++p);
        packet.utf8Write("direct-streamlocal@openssh.com", p += 4, 30);
        writeUInt32BE(packet, chan, p += 30);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, pathLen, p += 4);
        packet.utf8Write(cfg.socketPath, p += 4, pathLen);
        bufferFill(packet, 0, p += pathLen, p + 8);
        if (this._debug) {
          this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, direct-streamlocal@openssh.com)`);
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_noMoreSessions(wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 28 + 1);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 28, ++p);
        packet.utf8Write("no-more-sessions@openssh.com", p += 4, 28);
        packet[p += 28] = wantReply === void 0 || wantReply === true ? 1 : 0;
        this._debug && this._debug("Outbound: Sending GLOBAL_REQUEST (no-more-sessions@openssh.com)");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      session(chan, initWindow, maxPacket) {
        if (this._server) throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 7 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 7, ++p);
        packet.utf8Write("session", p += 4, 7);
        writeUInt32BE(packet, chan, p += 7);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, session)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      windowChange(chan, rows, cols, height, width) {
        if (this._server) throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 13 + 1 + 4 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 13, p += 4);
        packet.utf8Write("window-change", p += 4, 13);
        packet[p += 13] = 0;
        writeUInt32BE(packet, cols, ++p);
        writeUInt32BE(packet, rows, p += 4);
        writeUInt32BE(packet, width, p += 4);
        writeUInt32BE(packet, height, p += 4);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, window-change)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      pty(chan, rows, cols, height, width, term, modes, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        if (!term || !term.length) term = "vt100";
        if (modes && !Buffer.isBuffer(modes) && !Array.isArray(modes) && typeof modes === "object" && modes !== null) {
          modes = modesToBytes(modes);
        }
        if (!modes || !modes.length) modes = NO_TERMINAL_MODES_BUFFER;
        const termLen = term.length;
        const modesLen = modes.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 4 + termLen + 4 + 4 + 4 + 4 + 4 + modesLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 7, p += 4);
        packet.utf8Write("pty-req", p += 4, 7);
        packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, termLen, ++p);
        packet.utf8Write(term, p += 4, termLen);
        writeUInt32BE(packet, cols, p += termLen);
        writeUInt32BE(packet, rows, p += 4);
        writeUInt32BE(packet, width, p += 4);
        writeUInt32BE(packet, height, p += 4);
        writeUInt32BE(packet, modesLen, p += 4);
        p += 4;
        if (Array.isArray(modes)) {
          for (let i = 0; i < modesLen; ++i) packet[p++] = modes[i];
        } else if (Buffer.isBuffer(modes)) {
          packet.set(modes, p);
        }
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, pty-req)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      shell(chan, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 5 + 1);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 5, p += 4);
        packet.utf8Write("shell", p += 4, 5);
        packet[p += 5] = wantReply === void 0 || wantReply === true ? 1 : 0;
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, shell)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exec(chan, cmd, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const isBuf = Buffer.isBuffer(cmd);
        const cmdLen = isBuf ? cmd.length : Buffer.byteLength(cmd);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 4 + 1 + 4 + cmdLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 4, p += 4);
        packet.utf8Write("exec", p += 4, 4);
        packet[p += 4] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, cmdLen, ++p);
        if (isBuf) packet.set(cmd, p += 4);
        else packet.utf8Write(cmd, p += 4, cmdLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exec: ${cmd})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      signal(chan, signal) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const origSignal = signal;
        signal = signal.toUpperCase();
        if (signal.slice(0, 3) === "SIG") signal = signal.slice(3);
        if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);
        const signalLen = signal.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 6 + 1 + 4 + signalLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 6, p += 4);
        packet.utf8Write("signal", p += 4, 6);
        packet[p += 6] = 0;
        writeUInt32BE(packet, signalLen, ++p);
        packet.utf8Write(signal, p += 4, signalLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, signal: ${signal})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      env(chan, key, val, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const keyLen = Buffer.byteLength(key);
        const isBuf = Buffer.isBuffer(val);
        const valLen = isBuf ? val.length : Buffer.byteLength(val);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 3 + 1 + 4 + keyLen + 4 + valLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 3, p += 4);
        packet.utf8Write("env", p += 4, 3);
        packet[p += 3] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, keyLen, ++p);
        packet.utf8Write(key, p += 4, keyLen);
        writeUInt32BE(packet, valLen, p += keyLen);
        if (isBuf) packet.set(val, p += 4);
        else packet.utf8Write(val, p += 4, valLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, env: ${key}=${val})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11Forward(chan, cfg, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const protocol4 = cfg.protocol;
        const cookie = cfg.cookie;
        const isBufProto = Buffer.isBuffer(protocol4);
        const protoLen = isBufProto ? protocol4.length : Buffer.byteLength(protocol4);
        const isBufCookie = Buffer.isBuffer(cookie);
        const cookieLen = isBufCookie ? cookie.length : Buffer.byteLength(cookie);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 7 + 1 + 1 + 4 + protoLen + 4 + cookieLen + 4);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 7, p += 4);
        packet.utf8Write("x11-req", p += 4, 7);
        packet[p += 7] = wantReply === void 0 || wantReply === true ? 1 : 0;
        packet[++p] = cfg.single ? 1 : 0;
        writeUInt32BE(packet, protoLen, ++p);
        if (isBufProto) packet.set(protocol4, p += 4);
        else packet.utf8Write(protocol4, p += 4, protoLen);
        writeUInt32BE(packet, cookieLen, p += protoLen);
        if (isBufCookie) packet.set(cookie, p += 4);
        else packet.latin1Write(cookie, p += 4, cookieLen);
        writeUInt32BE(packet, cfg.screen || 0, p += cookieLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, x11-req)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      subsystem(chan, name, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        const nameLen = Buffer.byteLength(name);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 9 + 1 + 4 + nameLen);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 9, p += 4);
        packet.utf8Write("subsystem", p += 4, 9);
        packet[p += 9] = wantReply === void 0 || wantReply === true ? 1 : 0;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(name, p += 4, nameLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, subsystem: ${name})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_agentForward(chan, wantReply) {
        if (this._server) throw new Error("Client-only method called in server mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 26 + 1);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 26, p += 4);
        packet.utf8Write("auth-agent-req@openssh.com", p += 4, 26);
        packet[p += 26] = wantReply === void 0 || wantReply === true ? 1 : 0;
        if (this._debug) {
          this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, auth-agent-req@openssh.com)`);
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_hostKeysProve(keys) {
        if (this._server) throw new Error("Client-only method called in server mode");
        let keysTotal = 0;
        const publicKeys = [];
        for (const key of keys) {
          const publicKey = key.getPublicSSH();
          keysTotal += 4 + publicKey.length;
          publicKeys.push(publicKey);
        }
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 29 + 1 + keysTotal);
        packet[p] = MESSAGE.GLOBAL_REQUEST;
        writeUInt32BE(packet, 29, ++p);
        packet.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
        packet[p += 29] = 1;
        ++p;
        for (const buf of publicKeys) {
          writeUInt32BE(packet, buf.length, p);
          bufferCopy(buf, packet, 0, buf.length, p += 4);
          p += buf.length;
        }
        if (this._debug) {
          this._debug("Outbound: Sending GLOBAL_REQUEST (hostkeys-prove-00@openssh.com)");
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      // Global
      // ------
      serviceAccept(svcName) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        const svcNameLen = Buffer.byteLength(svcName);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + svcNameLen);
        packet[p] = MESSAGE.SERVICE_ACCEPT;
        writeUInt32BE(packet, svcNameLen, ++p);
        packet.utf8Write(svcName, p += 4, svcNameLen);
        this._debug && this._debug(`Outbound: Sending SERVICE_ACCEPT (${svcName})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
        if (this._server && this._banner && svcName === "ssh-userauth") {
          const banner = this._banner;
          this._banner = void 0;
          const bannerLen = Buffer.byteLength(banner);
          p = this._packetRW.write.allocStart;
          const packet2 = this._packetRW.write.alloc(1 + 4 + bannerLen + 4);
          packet2[p] = MESSAGE.USERAUTH_BANNER;
          writeUInt32BE(packet2, bannerLen, ++p);
          packet2.utf8Write(banner, p += 4, bannerLen);
          writeUInt32BE(packet2, 0, p += bannerLen);
          this._debug && this._debug("Outbound: Sending USERAUTH_BANNER");
          sendPacket(this, this._packetRW.write.finalize(packet2));
        }
      }
      // 'ssh-connection' service-specific
      forwardedTcpip(chan, initWindow, maxPacket, cfg) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        const boundAddrLen = Buffer.byteLength(cfg.boundAddr);
        const remoteAddrLen = Buffer.byteLength(cfg.remoteAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 15 + 4 + 4 + 4 + 4 + boundAddrLen + 4 + 4 + remoteAddrLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 15, ++p);
        packet.utf8Write("forwarded-tcpip", p += 4, 15);
        writeUInt32BE(packet, chan, p += 15);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, boundAddrLen, p += 4);
        packet.utf8Write(cfg.boundAddr, p += 4, boundAddrLen);
        writeUInt32BE(packet, cfg.boundPort, p += boundAddrLen);
        writeUInt32BE(packet, remoteAddrLen, p += 4);
        packet.utf8Write(cfg.remoteAddr, p += 4, remoteAddrLen);
        writeUInt32BE(packet, cfg.remotePort, p += remoteAddrLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-tcpip)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      x11(chan, initWindow, maxPacket, cfg) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        const addrLen = Buffer.byteLength(cfg.originAddr);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 3 + 4 + 4 + 4 + 4 + addrLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 3, ++p);
        packet.utf8Write("x11", p += 4, 3);
        writeUInt32BE(packet, chan, p += 3);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, addrLen, p += 4);
        packet.utf8Write(cfg.originAddr, p += 4, addrLen);
        writeUInt32BE(packet, cfg.originPort, p += addrLen);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, x11)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_authAgent(chan, initWindow, maxPacket) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 22 + 4 + 4 + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 22, ++p);
        packet.utf8Write("auth-agent@openssh.com", p += 4, 22);
        writeUInt32BE(packet, chan, p += 22);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        this._debug && this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, auth-agent@openssh.com)`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      openssh_forwardedStreamLocal(chan, initWindow, maxPacket, cfg) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        const pathLen = Buffer.byteLength(cfg.socketPath);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 33 + 4 + 4 + 4 + 4 + pathLen + 4);
        packet[p] = MESSAGE.CHANNEL_OPEN;
        writeUInt32BE(packet, 33, ++p);
        packet.utf8Write("forwarded-streamlocal@openssh.com", p += 4, 33);
        writeUInt32BE(packet, chan, p += 33);
        writeUInt32BE(packet, initWindow, p += 4);
        writeUInt32BE(packet, maxPacket, p += 4);
        writeUInt32BE(packet, pathLen, p += 4);
        packet.utf8Write(cfg.socketPath, p += 4, pathLen);
        writeUInt32BE(packet, 0, p += pathLen);
        if (this._debug) {
          this._debug(`Outbound: Sending CHANNEL_OPEN (r:${chan}, forwarded-streamlocal@openssh.com)`);
        }
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitStatus(chan, status) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 11, p += 4);
        packet.utf8Write("exit-status", p += 4, 11);
        packet[p += 11] = 0;
        writeUInt32BE(packet, status, ++p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-status: ${status})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      exitSignal(chan, name, coreDumped, msg) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        const origSignal = name;
        if (typeof origSignal !== "string" || !origSignal) throw new Error(`Invalid signal: ${origSignal}`);
        let signal = name.toUpperCase();
        if (signal.slice(0, 3) === "SIG") signal = signal.slice(3);
        if (SIGNALS[signal] !== 1) throw new Error(`Invalid signal: ${origSignal}`);
        const nameLen = Buffer.byteLength(signal);
        const msgLen = msg ? Buffer.byteLength(msg) : 0;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + 4 + 11 + 1 + 4 + nameLen + 1 + 4 + msgLen + 4);
        packet[p] = MESSAGE.CHANNEL_REQUEST;
        writeUInt32BE(packet, chan, ++p);
        writeUInt32BE(packet, 11, p += 4);
        packet.utf8Write("exit-signal", p += 4, 11);
        packet[p += 11] = 0;
        writeUInt32BE(packet, nameLen, ++p);
        packet.utf8Write(signal, p += 4, nameLen);
        packet[p += nameLen] = coreDumped ? 1 : 0;
        writeUInt32BE(packet, msgLen, ++p);
        p += 4;
        if (msgLen) {
          packet.utf8Write(msg, p, msgLen);
          p += msgLen;
        }
        writeUInt32BE(packet, 0, p);
        this._debug && this._debug(`Outbound: Sending CHANNEL_REQUEST (r:${chan}, exit-signal: ${name})`);
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      // 'ssh-userauth' service-specific
      authFailure(authMethods, isPartial) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0) throw new Error("No auth in progress");
        let methods;
        if (typeof authMethods === "boolean") {
          isPartial = authMethods;
          authMethods = void 0;
        }
        if (authMethods) {
          methods = [];
          for (let i = 0; i < authMethods.length; ++i) {
            if (authMethods[i].toLowerCase() === "none") continue;
            methods.push(authMethods[i]);
          }
          methods = methods.join(",");
        } else {
          methods = "";
        }
        const methodsLen = methods.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + methodsLen + 1);
        packet[p] = MESSAGE.USERAUTH_FAILURE;
        writeUInt32BE(packet, methodsLen, ++p);
        packet.utf8Write(methods, p += 4, methodsLen);
        packet[p += methodsLen] = isPartial === true ? 1 : 0;
        this._authsQueue.shift();
        this._debug && this._debug("Outbound: Sending USERAUTH_FAILURE");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authSuccess() {
        if (!this._server) throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0) throw new Error("No auth in progress");
        const p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1);
        packet[p] = MESSAGE.USERAUTH_SUCCESS;
        this._authsQueue.shift();
        this._authenticated = true;
        this._debug && this._debug("Outbound: Sending USERAUTH_SUCCESS");
        sendPacket(this, this._packetRW.write.finalize(packet));
        if (this._kex.negotiated.cs.compress === "zlib@openssh.com") this._packetRW.read = new ZlibPacketReader();
        if (this._kex.negotiated.sc.compress === "zlib@openssh.com") this._packetRW.write = new ZlibPacketWriter(this);
      }
      authPKOK(keyAlgo, key) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        if (this._authsQueue.length === 0 || this._authsQueue[0] !== "publickey") throw new Error('"publickey" auth not in progress');
        const keyAlgoLen = Buffer.byteLength(keyAlgo);
        const keyLen = key.length;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + keyAlgoLen + 4 + keyLen);
        packet[p] = MESSAGE.USERAUTH_PK_OK;
        writeUInt32BE(packet, keyAlgoLen, ++p);
        packet.utf8Write(keyAlgo, p += 4, keyAlgoLen);
        writeUInt32BE(packet, keyLen, p += keyAlgoLen);
        packet.set(key, p += 4);
        this._authsQueue.shift();
        this._debug && this._debug("Outbound: Sending USERAUTH_PK_OK");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authPasswdChg(prompt) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        const promptLen = Buffer.byteLength(prompt);
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + promptLen + 4);
        packet[p] = MESSAGE.USERAUTH_PASSWD_CHANGEREQ;
        writeUInt32BE(packet, promptLen, ++p);
        packet.utf8Write(prompt, p += 4, promptLen);
        writeUInt32BE(packet, 0, p += promptLen);
        this._debug && this._debug("Outbound: Sending USERAUTH_PASSWD_CHANGEREQ");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
      authInfoReq(name, instructions, prompts) {
        if (!this._server) throw new Error("Server-only method called in client mode");
        let promptsLen = 0;
        const nameLen = name ? Buffer.byteLength(name) : 0;
        const instrLen = instructions ? Buffer.byteLength(instructions) : 0;
        for (let i = 0; i < prompts.length; ++i) promptsLen += 4 + Buffer.byteLength(prompts[i].prompt) + 1;
        let p = this._packetRW.write.allocStart;
        const packet = this._packetRW.write.alloc(1 + 4 + nameLen + 4 + instrLen + 4 + 4 + promptsLen);
        packet[p] = MESSAGE.USERAUTH_INFO_REQUEST;
        writeUInt32BE(packet, nameLen, ++p);
        p += 4;
        if (name) {
          packet.utf8Write(name, p, nameLen);
          p += nameLen;
        }
        writeUInt32BE(packet, instrLen, p);
        p += 4;
        if (instructions) {
          packet.utf8Write(instructions, p, instrLen);
          p += instrLen;
        }
        writeUInt32BE(packet, 0, p);
        writeUInt32BE(packet, prompts.length, p += 4);
        p += 4;
        for (let i = 0; i < prompts.length; ++i) {
          const prompt = prompts[i];
          const promptLen = Buffer.byteLength(prompt.prompt);
          writeUInt32BE(packet, promptLen, p);
          p += 4;
          if (promptLen) {
            packet.utf8Write(prompt.prompt, p, promptLen);
            p += promptLen;
          }
          packet[p++] = prompt.echo ? 1 : 0;
        }
        this._debug && this._debug("Outbound: Sending USERAUTH_INFO_REQUEST");
        sendPacket(this, this._packetRW.write.finalize(packet));
      }
    };
    var RE_IDENT = /^SSH-(2\.0|1\.99)-([^ ]+)(?: (.*))?$/;
    function parseHeader(chunk, p, len) {
      let data;
      let chunkOffset;
      if (this._buffer) {
        data = Buffer.allocUnsafe(this._buffer.length + (len - p));
        data.set(this._buffer, 0);
        if (p === 0) {
          data.set(chunk, this._buffer.length);
        } else {
          data.set(new Uint8Array(chunk.buffer, chunk.byteOffset + p, len - p), this._buffer.length);
        }
        chunkOffset = this._buffer.length;
        p = 0;
      } else {
        data = chunk;
        chunkOffset = 0;
      }
      const op = p;
      let start = p;
      let end = p;
      let needNL = false;
      let lineLen = 0;
      let lines = 0;
      for (; p < data.length; ++p) {
        const ch = data[p];
        if (ch === 13) {
          needNL = true;
          continue;
        }
        if (ch === 10) {
          if (end > start && end - start > 4 && data[start] === 83 && data[start + 1] === 83 && data[start + 2] === 72 && data[start + 3] === 45) {
            const full = data.latin1Slice(op, end + 1);
            const identRaw = start === op ? full : full.slice(start - op);
            const m = RE_IDENT.exec(identRaw);
            if (!m) throw new Error("Invalid identification string");
            const header = {
              greeting: start === op ? "" : full.slice(0, start - op),
              identRaw,
              versions: {
                protocol: m[1],
                software: m[2]
              },
              comments: m[3]
            };
            this._remoteIdentRaw = Buffer.from(identRaw);
            this._debug && this._debug(`Remote ident: ${inspect2(identRaw)}`);
            this._compatFlags = getCompatFlags(header);
            this._buffer = void 0;
            this._decipher = new NullDecipher(0, onKEXPayload.bind(this, {
              firstPacket: true
            }));
            this._parse = parsePacket;
            this._onHeader(header);
            if (!this._destruct) {
              return len;
            }
            kexinit(this);
            return p + 1 - chunkOffset;
          }
          if (this._server) throw new Error("Greetings from clients not permitted");
          if (++lines > MAX_LINES) throw new Error("Max greeting lines exceeded");
          needNL = false;
          start = p + 1;
          lineLen = 0;
        } else if (needNL) {
          throw new Error("Invalid header: expected newline");
        } else if (++lineLen >= MAX_LINE_LEN) {
          throw new Error("Header line too long");
        }
        end = p;
      }
      if (!this._buffer) this._buffer = bufferSlice(data, op);
      return p - chunkOffset;
    }
    __name(parseHeader, "parseHeader");
    function parsePacket(chunk, p, len) {
      return this._decipher.decrypt(chunk, p, len);
    }
    __name(parsePacket, "parsePacket");
    function onPayload(payload) {
      this._onPacket();
      if (payload.length === 0) {
        this._debug && this._debug("Inbound: Skipping empty packet payload");
        return;
      }
      payload = this._packetRW.read.read(payload);
      const type = payload[0];
      if (type === MESSAGE.USERAUTH_SUCCESS && !this._server && !this._authenticated) {
        this._authenticated = true;
        if (this._kex.negotiated.cs.compress === "zlib@openssh.com") this._packetRW.write = new ZlibPacketWriter(this);
        if (this._kex.negotiated.sc.compress === "zlib@openssh.com") this._packetRW.read = new ZlibPacketReader();
      }
      const handler = MESSAGE_HANDLERS[type];
      if (handler === void 0) {
        this._debug && this._debug(`Inbound: Unsupported message type: ${type}`);
        return;
      }
      return handler(this, payload);
    }
    __name(onPayload, "onPayload");
    function getCompatFlags(header) {
      const software = header.versions.software;
      let flags = 0;
      for (const rule of COMPAT_CHECKS) {
        if (typeof rule[0] === "string") {
          if (software === rule[0]) flags |= rule[1];
        } else if (rule[0].test(software)) {
          flags |= rule[1];
        }
      }
      return flags;
    }
    __name(getCompatFlags, "getCompatFlags");
    function modesToBytes(modes) {
      const keys = Object.keys(modes);
      const bytes = Buffer.allocUnsafe(5 * keys.length + 1);
      let b = 0;
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        if (key === "TTY_OP_END") continue;
        const opcode = TERMINAL_MODE[key];
        if (opcode === void 0) continue;
        const val = modes[key];
        if (typeof val === "number" && isFinite(val)) {
          bytes[b++] = opcode;
          bytes[b++] = val >>> 24;
          bytes[b++] = val >>> 16;
          bytes[b++] = val >>> 8;
          bytes[b++] = val;
        }
      }
      bytes[b++] = TERMINAL_MODE.TTY_OP_END;
      if (b < bytes.length) return bufferSlice(bytes, 0, b);
      return bytes;
    }
    __name(modesToBytes, "modesToBytes");
    function sendExtInfo(proto) {
      let serverSigAlgs = "ecdsa-sha2-nistp256,ecdsa-sha2-nistp384,ecdsa-sha2-nistp521rsa-sha2-512,rsa-sha2-256,ssh-rsa,ssh-dss";
      if (eddsaSupported) serverSigAlgs = `ssh-ed25519,${serverSigAlgs}`;
      const algsLen = Buffer.byteLength(serverSigAlgs);
      let p = proto._packetRW.write.allocStart;
      const packet = proto._packetRW.write.alloc(1 + 4 + 4 + 15 + 4 + algsLen);
      packet[p] = MESSAGE.EXT_INFO;
      writeUInt32BE(packet, 1, ++p);
      writeUInt32BE(packet, 15, p += 4);
      packet.utf8Write("server-sig-algs", p += 4, 15);
      writeUInt32BE(packet, algsLen, p += 15);
      packet.utf8Write(serverSigAlgs, p += 4, algsLen);
      proto._debug && proto._debug("Outbound: Sending EXT_INFO");
      sendPacket(proto, proto._packetRW.write.finalize(packet));
    }
    __name(sendExtInfo, "sendExtInfo");
    module2.exports = Protocol;
  }
});

// node_modules/ssh2/lib/protocol/node-fs-compat.js
var require_node_fs_compat = __commonJS({
  "node_modules/ssh2/lib/protocol/node-fs-compat.js"(exports2) {
    "use strict";
    var assert = require("assert");
    var { inspect: inspect2 } = require("util");
    function addNumericalSeparator(val) {
      let res = "";
      let i = val.length;
      const start = val[0] === "-" ? 1 : 0;
      for (; i >= start + 4; i -= 3) res = `_${val.slice(i - 3, i)}${res}`;
      return `${val.slice(0, i)}${res}`;
    }
    __name(addNumericalSeparator, "addNumericalSeparator");
    function oneOf(expected, thing) {
      assert(typeof thing === "string", "`thing` has to be of type string");
      if (Array.isArray(expected)) {
        const len = expected.length;
        assert(len > 0, "At least one expected value needs to be specified");
        expected = expected.map((i) => String(i));
        if (len > 2) {
          return `one of ${thing} ${expected.slice(0, len - 1).join(", ")}, or ` + expected[len - 1];
        } else if (len === 2) {
          return `one of ${thing} ${expected[0]} or ${expected[1]}`;
        }
        return `of ${thing} ${expected[0]}`;
      }
      return `of ${thing} ${String(expected)}`;
    }
    __name(oneOf, "oneOf");
    exports2.ERR_INTERNAL_ASSERTION = class ERR_INTERNAL_ASSERTION extends Error {
      static {
        __name(this, "ERR_INTERNAL_ASSERTION");
      }
      constructor(message) {
        super();
        Error.captureStackTrace(this, ERR_INTERNAL_ASSERTION);
        const suffix = "This is caused by either a bug in ssh2 or incorrect usage of ssh2 internals.\nPlease open an issue with this stack trace at https://github.com/mscdex/ssh2/issues\n";
        this.message = message === void 0 ? suffix : `${message}
${suffix}`;
      }
    };
    var MAX_32BIT_INT = 2 ** 32;
    var MAX_32BIT_BIGINT = (() => {
      try {
        return new Function("return 2n ** 32n")();
      } catch {
      }
    })();
    exports2.ERR_OUT_OF_RANGE = class ERR_OUT_OF_RANGE extends RangeError {
      static {
        __name(this, "ERR_OUT_OF_RANGE");
      }
      constructor(str, range, input, replaceDefaultBoolean) {
        super();
        Error.captureStackTrace(this, ERR_OUT_OF_RANGE);
        assert(range, 'Missing "range" argument');
        let msg = replaceDefaultBoolean ? str : `The value of "${str}" is out of range.`;
        let received;
        if (Number.isInteger(input) && Math.abs(input) > MAX_32BIT_INT) {
          received = addNumericalSeparator(String(input));
        } else if (typeof input === "bigint") {
          received = String(input);
          if (input > MAX_32BIT_BIGINT || input < -MAX_32BIT_BIGINT) received = addNumericalSeparator(received);
          received += "n";
        } else {
          received = inspect2(input);
        }
        msg += ` It must be ${range}. Received ${received}`;
        this.message = msg;
      }
    };
    var ERR_INVALID_ARG_TYPE = class ERR_INVALID_ARG_TYPE2 extends TypeError {
      static {
        __name(this, "ERR_INVALID_ARG_TYPE");
      }
      constructor(name, expected, actual) {
        super();
        Error.captureStackTrace(this, ERR_INVALID_ARG_TYPE2);
        assert(typeof name === "string", `'name' must be a string`);
        let determiner;
        if (typeof expected === "string" && expected.startsWith("not ")) {
          determiner = "must not be";
          expected = expected.replace(/^not /, "");
        } else {
          determiner = "must be";
        }
        let msg;
        if (name.endsWith(" argument")) {
          msg = `The ${name} ${determiner} ${oneOf(expected, "type")}`;
        } else {
          const type = name.includes(".") ? "property" : "argument";
          msg = `The "${name}" ${type} ${determiner} ${oneOf(expected, "type")}`;
        }
        msg += `. Received type ${typeof actual}`;
        this.message = msg;
      }
    };
    exports2.ERR_INVALID_ARG_TYPE = ERR_INVALID_ARG_TYPE;
    exports2.validateNumber = /* @__PURE__ */ __name(function validateNumber(value2, name) {
      if (typeof value2 !== "number") throw new ERR_INVALID_ARG_TYPE(name, "number", value2);
    }, "validateNumber");
  }
});

// node_modules/ssh2/lib/protocol/SFTP.js
var require_SFTP = __commonJS({
  "node_modules/ssh2/lib/protocol/SFTP.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events");
    var fs = require("fs");
    var { constants } = fs;
    var { Readable: ReadableStream, Writable: WritableStream } = require("stream");
    var { inherits, types: { isDate } } = require("util");
    var FastBuffer = Buffer[Symbol.species];
    var { bufferCopy, bufferSlice, makeBufferParser, writeUInt32BE } = require_utils2();
    var ATTR = {
      SIZE: 1,
      UIDGID: 2,
      PERMISSIONS: 4,
      ACMODTIME: 8,
      EXTENDED: 2147483648
    };
    var ATTRS_BUF = Buffer.alloc(28);
    var STATUS_CODE = {
      OK: 0,
      EOF: 1,
      NO_SUCH_FILE: 2,
      PERMISSION_DENIED: 3,
      FAILURE: 4,
      BAD_MESSAGE: 5,
      NO_CONNECTION: 6,
      CONNECTION_LOST: 7,
      OP_UNSUPPORTED: 8
    };
    var VALID_STATUS_CODES = new Map(Object.values(STATUS_CODE).map((n) => [
      n,
      1
    ]));
    var STATUS_CODE_STR = {
      [STATUS_CODE.OK]: "No error",
      [STATUS_CODE.EOF]: "End of file",
      [STATUS_CODE.NO_SUCH_FILE]: "No such file or directory",
      [STATUS_CODE.PERMISSION_DENIED]: "Permission denied",
      [STATUS_CODE.FAILURE]: "Failure",
      [STATUS_CODE.BAD_MESSAGE]: "Bad message",
      [STATUS_CODE.NO_CONNECTION]: "No connection",
      [STATUS_CODE.CONNECTION_LOST]: "Connection lost",
      [STATUS_CODE.OP_UNSUPPORTED]: "Operation unsupported"
    };
    var REQUEST = {
      INIT: 1,
      OPEN: 3,
      CLOSE: 4,
      READ: 5,
      WRITE: 6,
      LSTAT: 7,
      FSTAT: 8,
      SETSTAT: 9,
      FSETSTAT: 10,
      OPENDIR: 11,
      READDIR: 12,
      REMOVE: 13,
      MKDIR: 14,
      RMDIR: 15,
      REALPATH: 16,
      STAT: 17,
      RENAME: 18,
      READLINK: 19,
      SYMLINK: 20,
      EXTENDED: 200
    };
    var RESPONSE = {
      VERSION: 2,
      STATUS: 101,
      HANDLE: 102,
      DATA: 103,
      NAME: 104,
      ATTRS: 105,
      EXTENDED: 201
    };
    var OPEN_MODE = {
      READ: 1,
      WRITE: 2,
      APPEND: 4,
      CREAT: 8,
      TRUNC: 16,
      EXCL: 32
    };
    var PKT_RW_OVERHEAD = 2 * 1024;
    var MAX_REQID = 2 ** 32 - 1;
    var CLIENT_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      REQUEST.INIT,
      0,
      0,
      0,
      3
      /* version */
    ]);
    var SERVER_VERSION_BUFFER = Buffer.from([
      0,
      0,
      0,
      5,
      RESPONSE.VERSION,
      0,
      0,
      0,
      3
      /* version */
    ]);
    var RE_OPENSSH = /^SSH-2.0-(?:OpenSSH|dropbear)/;
    var OPENSSH_MAX_PKT_LEN = 256 * 1024;
    var bufferParser = makeBufferParser();
    var fakeStderr = {
      readable: false,
      writable: false,
      push: /* @__PURE__ */ __name((data) => {
      }, "push"),
      once: /* @__PURE__ */ __name(() => {
      }, "once"),
      on: /* @__PURE__ */ __name(() => {
      }, "on"),
      emit: /* @__PURE__ */ __name(() => {
      }, "emit"),
      end: /* @__PURE__ */ __name(() => {
      }, "end")
    };
    function noop() {
    }
    __name(noop, "noop");
    var SFTP = class SFTP extends EventEmitter {
      static {
        __name(this, "SFTP");
      }
      constructor(client2, chanInfo, cfg) {
        super();
        if (typeof cfg !== "object" || !cfg) cfg = {};
        const remoteIdentRaw = client2._protocol._remoteIdentRaw;
        this.server = !!cfg.server;
        this._debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        this._isOpenSSH = remoteIdentRaw && RE_OPENSSH.test(remoteIdentRaw);
        this._version = -1;
        this._extensions = {};
        this._biOpt = cfg.biOpt;
        this._pktLenBytes = 0;
        this._pktLen = 0;
        this._pktPos = 0;
        this._pktType = 0;
        this._pktData = void 0;
        this._writeReqid = -1;
        this._requests = {};
        this._maxInPktLen = OPENSSH_MAX_PKT_LEN;
        this._maxOutPktLen = 34e3;
        this._maxReadLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
        this._maxWriteLen = (this._isOpenSSH ? OPENSSH_MAX_PKT_LEN : 34e3) - PKT_RW_OVERHEAD;
        this.maxOpenHandles = void 0;
        this._client = client2;
        this._protocol = client2._protocol;
        this._callbacks = [];
        this._hasX11 = false;
        this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        };
        this._waitWindow = false;
        this._chunkcb = void 0;
        this._buffer = [];
        this.type = chanInfo.type;
        this.subtype = void 0;
        this.incoming = chanInfo.incoming;
        this.outgoing = chanInfo.outgoing;
        this.stderr = fakeStderr;
        this.readable = true;
      }
      // This handles incoming data to parse
      push(data) {
        if (data === null) {
          cleanupRequests(this);
          if (!this.readable) return;
          this.readable = false;
          this.emit("end");
          return;
        }
        let p = 0;
        while (p < data.length) {
          if (this._pktLenBytes < 4) {
            let nb = Math.min(4 - this._pktLenBytes, data.length - p);
            this._pktLenBytes += nb;
            while (nb--) this._pktLen = (this._pktLen << 8) + data[p++];
            if (this._pktLenBytes < 4) return;
            if (this._pktLen === 0) return doFatalSFTPError(this, "Invalid packet length");
            if (this._pktLen > this._maxInPktLen) {
              const max = this._maxInPktLen;
              return doFatalSFTPError(this, `Packet length ${this._pktLen} exceeds max length of ${max}`);
            }
            if (p >= data.length) return;
          }
          if (this._pktPos < this._pktLen) {
            const nb = Math.min(this._pktLen - this._pktPos, data.length - p);
            if (p !== 0 || nb !== data.length) {
              if (nb === this._pktLen) {
                this._pkt = new FastBuffer(data.buffer, data.byteOffset + p, nb);
              } else {
                if (!this._pkt) this._pkt = Buffer.allocUnsafe(this._pktLen);
                this._pkt.set(new Uint8Array(data.buffer, data.byteOffset + p, nb), this._pktPos);
              }
            } else if (nb === this._pktLen) {
              this._pkt = data;
            } else {
              if (!this._pkt) this._pkt = Buffer.allocUnsafe(this._pktLen);
              this._pkt.set(data, this._pktPos);
            }
            p += nb;
            this._pktPos += nb;
            if (this._pktPos < this._pktLen) return;
          }
          const type = this._pkt[0];
          const payload = this._pkt;
          this._pktLen = 0;
          this._pktLenBytes = 0;
          this._pkt = void 0;
          this._pktPos = 0;
          const handler = this.server ? SERVER_HANDLERS[type] : CLIENT_HANDLERS[type];
          if (!handler) return doFatalSFTPError(this, `Unknown packet type ${type}`);
          if (this._version === -1) {
            if (this.server) {
              if (type !== REQUEST.INIT) return doFatalSFTPError(this, `Expected INIT packet, got ${type}`);
            } else if (type !== RESPONSE.VERSION) {
              return doFatalSFTPError(this, `Expected VERSION packet, got ${type}`);
            }
          }
          if (handler(this, payload) === false) return;
        }
      }
      end() {
        this.destroy();
      }
      destroy() {
        if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
          this.outgoing.state = "closing";
          this._protocol.channelClose(this.outgoing.id);
        }
      }
      _init() {
        this._init = noop;
        if (!this.server) sendOrBuffer(this, CLIENT_VERSION_BUFFER);
      }
      // ===========================================================================
      // Client-specific ===========================================================
      // ===========================================================================
      createReadStream(path, options) {
        if (this.server) throw new Error("Client-only method called in server mode");
        return new ReadStream(this, path, options);
      }
      createWriteStream(path, options) {
        if (this.server) throw new Error("Client-only method called in server mode");
        return new WriteStream(this, path, options);
      }
      open(path, flags_, attrs, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (typeof attrs === "function") {
          cb = attrs;
          attrs = void 0;
        }
        const flags = typeof flags_ === "number" ? flags_ : stringToFlags(flags_);
        if (flags === null) throw new Error(`Unknown flags string: ${flags_}`);
        let attrsFlags = 0;
        let attrsLen = 0;
        if (typeof attrs === "string" || typeof attrs === "number") attrs = {
          mode: attrs
        };
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          attrsFlags = attrs.flags;
          attrsLen = attrs.nb;
        }
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.OPEN;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        writeUInt32BE(buf, attrsFlags, p += 4);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);
          else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPEN`);
      }
      close(handle, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle)) throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.CLOSE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} CLOSE`);
      }
      read(handle, buf, off, len, position, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle)) throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf)) throw new Error("buffer is not a Buffer");
        if (off >= buf.length) throw new Error("offset is out of bounds");
        if (off + len > buf.length) throw new Error("length extends beyond buffer");
        if (position === null) throw new Error("null position currently unsupported");
        read_(this, handle, buf, off, len, position, cb);
      }
      readData(handle, buf, off, len, position, cb) {
        this.read(handle, buf, off, len, position, cb);
      }
      write(handle, buf, off, len, position, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle)) throw new Error("handle is not a Buffer");
        if (!Buffer.isBuffer(buf)) throw new Error("buffer is not a Buffer");
        if (off > buf.length) throw new Error("offset is out of bounds");
        if (off + len > buf.length) throw new Error("length extends beyond buffer");
        if (position === null) throw new Error("null position currently unsupported");
        if (!len) {
          cb && process.nextTick(cb, void 0, 0);
          return;
        }
        const maxDataLen = this._maxWriteLen;
        const overflow = Math.max(len - maxDataLen, 0);
        const origPosition = position;
        if (overflow) len = maxDataLen;
        const handleLen = handle.length;
        let p = 9;
        const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4 + len);
        writeUInt32BE(out, out.length - 4, 0);
        out[4] = REQUEST.WRITE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(out, reqid, 5);
        writeUInt32BE(out, handleLen, p);
        out.set(handle, p += 4);
        p += handleLen;
        for (let i = 7; i >= 0; --i) {
          out[p + i] = position & 255;
          position /= 256;
        }
        writeUInt32BE(out, len, p += 8);
        bufferCopy(buf, out, off, off + len, p += 4);
        this._requests[reqid] = {
          cb: /* @__PURE__ */ __name((err) => {
            if (err) {
              if (typeof cb === "function") cb(err);
            } else if (overflow) {
              this.write(handle, buf, off + len, overflow, origPosition + len, cb);
            } else if (typeof cb === "function") {
              cb(void 0, off + len);
            }
          }, "cb")
        };
        const isSent = sendOrBuffer(this, out);
        if (this._debug) {
          const how = isSent ? "Sent" : "Buffered";
          this._debug(`SFTP: Outbound: ${how} WRITE (id:${reqid})`);
        }
      }
      writeData(handle, buf, off, len, position, cb) {
        this.write(handle, buf, off, len, position, cb);
      }
      fastGet(remotePath, localPath, opts, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        fastXfer(this, fs, remotePath, localPath, opts, cb);
      }
      fastPut(localPath, remotePath, opts, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        fastXfer(fs, this, localPath, remotePath, opts, cb);
      }
      readFile(path, options, callback_) {
        if (this.server) throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string") options = {
          encoding: options,
          flag: "r"
        };
        else if (!options) options = {
          encoding: null,
          flag: "r"
        };
        else if (typeof options !== "object") throw new TypeError("Bad arguments");
        const encoding = options.encoding;
        if (encoding && !Buffer.isEncoding(encoding)) throw new Error(`Unknown encoding: ${encoding}`);
        let size;
        let buffer;
        let buffers;
        let pos = 0;
        let handle;
        let bytesRead = 0;
        const flag = options.flag || "r";
        const read = /* @__PURE__ */ __name(() => {
          if (size === 0) {
            buffer = Buffer.allocUnsafe(8192);
            this.read(handle, buffer, 0, 8192, bytesRead, afterRead);
          } else {
            this.read(handle, buffer, pos, size - pos, bytesRead, afterRead);
          }
        }, "read");
        const afterRead = /* @__PURE__ */ __name((er, nbytes) => {
          let eof;
          if (er) {
            eof = er.code === STATUS_CODE.EOF;
            if (!eof) {
              return this.close(handle, () => {
                return callback && callback(er);
              });
            }
          } else {
            eof = false;
          }
          if (eof || size === 0 && nbytes === 0) return close();
          bytesRead += nbytes;
          pos += nbytes;
          if (size !== 0) {
            if (pos === size) close();
            else read();
          } else {
            buffers.push(bufferSlice(buffer, 0, nbytes));
            read();
          }
        }, "afterRead");
        afterRead._wantEOFError = true;
        const close = /* @__PURE__ */ __name(() => {
          this.close(handle, (er) => {
            if (size === 0) {
              buffer = Buffer.concat(buffers, pos);
            } else if (pos < size) {
              buffer = bufferSlice(buffer, 0, pos);
            }
            if (encoding) buffer = buffer.toString(encoding);
            return callback && callback(er, buffer);
          });
        }, "close");
        this.open(path, flag, 438, (er, handle_) => {
          if (er) return callback && callback(er);
          handle = handle_;
          const tryStat = /* @__PURE__ */ __name((er2, st) => {
            if (er2) {
              this.stat(path, (er_, st_) => {
                if (er_) {
                  return this.close(handle, () => {
                    callback && callback(er2);
                  });
                }
                tryStat(null, st_);
              });
              return;
            }
            size = st.size || 0;
            if (size === 0) {
              buffers = [];
              return read();
            }
            buffer = Buffer.allocUnsafe(size);
            read();
          }, "tryStat");
          this.fstat(handle, tryStat);
        });
      }
      writeFile(path, data, options, callback_) {
        if (this.server) throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string") options = {
          encoding: options,
          mode: 438,
          flag: "w"
        };
        else if (!options) options = {
          encoding: "utf8",
          mode: 438,
          flag: "w"
        };
        else if (typeof options !== "object") throw new TypeError("Bad arguments");
        if (options.encoding && !Buffer.isEncoding(options.encoding)) throw new Error(`Unknown encoding: ${options.encoding}`);
        const flag = options.flag || "w";
        this.open(path, flag, options.mode, (openErr, handle) => {
          if (openErr) {
            callback && callback(openErr);
          } else {
            const buffer = Buffer.isBuffer(data) ? data : Buffer.from("" + data, options.encoding || "utf8");
            const position = /a/.test(flag) ? null : 0;
            if (position === null) {
              const tryStat = /* @__PURE__ */ __name((er, st) => {
                if (er) {
                  this.stat(path, (er_, st_) => {
                    if (er_) {
                      return this.close(handle, () => {
                        callback && callback(er);
                      });
                    }
                    tryStat(null, st_);
                  });
                  return;
                }
                writeAll(this, handle, buffer, 0, buffer.length, st.size, callback);
              }, "tryStat");
              this.fstat(handle, tryStat);
              return;
            }
            writeAll(this, handle, buffer, 0, buffer.length, position, callback);
          }
        });
      }
      appendFile(path, data, options, callback_) {
        if (this.server) throw new Error("Client-only method called in server mode");
        let callback;
        if (typeof callback_ === "function") {
          callback = callback_;
        } else if (typeof options === "function") {
          callback = options;
          options = void 0;
        }
        if (typeof options === "string") options = {
          encoding: options,
          mode: 438,
          flag: "a"
        };
        else if (!options) options = {
          encoding: "utf8",
          mode: 438,
          flag: "a"
        };
        else if (typeof options !== "object") throw new TypeError("Bad arguments");
        if (!options.flag) options = Object.assign({
          flag: "a"
        }, options);
        this.writeFile(path, data, options, callback);
      }
      exists(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        this.stat(path, (err) => {
          cb && cb(err ? false : true);
        });
      }
      unlink(filename, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const fnameLen = Buffer.byteLength(filename);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + fnameLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.REMOVE;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, fnameLen, p);
        buf.utf8Write(filename, p += 4, fnameLen);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REMOVE`);
      }
      rename(oldPath, newPath, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.RENAME;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, oldLen, p);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RENAME`);
      }
      mkdir(path, attrs, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "function") {
          cb = attrs;
          attrs = void 0;
        }
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        }
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.MKDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);
          else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} MKDIR`);
      }
      rmdir(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.RMDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} RMDIR`);
      }
      readdir(where, opts, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        if (typeof opts !== "object" || opts === null) opts = {};
        const doFilter = opts && opts.full ? false : true;
        if (!Buffer.isBuffer(where) && typeof where !== "string") throw new Error("missing directory handle or path");
        if (typeof where === "string") {
          const entries = [];
          let e = 0;
          const reread = /* @__PURE__ */ __name((err, handle) => {
            if (err) return cb(err);
            this.readdir(handle, opts, (err2, list) => {
              const eof = err2 && err2.code === STATUS_CODE.EOF;
              if (err2 && !eof) return this.close(handle, () => cb(err2));
              if (eof) {
                return this.close(handle, (err3) => {
                  if (err3) return cb(err3);
                  cb(void 0, entries);
                });
              }
              for (let i = 0; i < list.length; ++i, ++e) entries[e] = list[i];
              reread(void 0, handle);
            });
          }, "reread");
          return this.opendir(where, reread);
        }
        const handleLen = where.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.READDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(where, p += 4);
        this._requests[reqid] = {
          cb: doFilter ? (err, list) => {
            if (typeof cb !== "function") return;
            if (err) return cb(err);
            for (let i = list.length - 1; i >= 0; --i) {
              if (list[i].filename === "." || list[i].filename === "..") list.splice(i, 1);
            }
            cb(void 0, list);
          } : cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READDIR`);
      }
      fstat(handle, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle)) throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.FSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSTAT`);
      }
      stat(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.STAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STAT`);
      }
      lstat(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.LSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} LSTAT`);
      }
      opendir(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.OPENDIR;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} OPENDIR`);
      }
      setstat(path, attrs, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.SETSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);
          else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SETSTAT`);
      }
      fsetstat(handle, attrs, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (!Buffer.isBuffer(handle)) throw new Error("handle is not a Buffer");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.FSETSTAT;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        buf.set(handle, p += 4);
        writeUInt32BE(buf, flags, p += handleLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);
          else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} FSETSTAT`);
      }
      futimes(handle, atime, mtime, cb) {
        return this.fsetstat(handle, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      utimes(path, atime, mtime, cb) {
        return this.setstat(path, {
          atime: toUnixTimestamp(atime),
          mtime: toUnixTimestamp(mtime)
        }, cb);
      }
      fchown(handle, uid, gid, cb) {
        return this.fsetstat(handle, {
          uid,
          gid
        }, cb);
      }
      chown(path, uid, gid, cb) {
        return this.setstat(path, {
          uid,
          gid
        }, cb);
      }
      fchmod(handle, mode, cb) {
        return this.fsetstat(handle, {
          mode
        }, cb);
      }
      chmod(path, mode, cb) {
        return this.setstat(path, {
          mode
        }, cb);
      }
      readlink(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.READLINK;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb: /* @__PURE__ */ __name((err, names) => {
            if (typeof cb !== "function") return;
            if (err) return cb(err);
            if (!names || !names.length) return cb(new Error("Response missing link info"));
            cb(void 0, names[0].filename);
          }, "cb")
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READLINK`);
      }
      symlink(targetPath, linkPath, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const linkLen = Buffer.byteLength(linkPath);
        const targetLen = Buffer.byteLength(targetPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + linkLen + 4 + targetLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.SYMLINK;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        if (this._isOpenSSH) {
          writeUInt32BE(buf, targetLen, p);
          buf.utf8Write(targetPath, p += 4, targetLen);
          writeUInt32BE(buf, linkLen, p += targetLen);
          buf.utf8Write(linkPath, p += 4, linkLen);
        } else {
          writeUInt32BE(buf, linkLen, p);
          buf.utf8Write(linkPath, p += 4, linkLen);
          writeUInt32BE(buf, targetLen, p += linkLen);
          buf.utf8Write(targetPath, p += 4, targetLen);
        }
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} SYMLINK`);
      }
      realpath(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.REALPATH;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, pathLen, p);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb: /* @__PURE__ */ __name((err, names) => {
            if (typeof cb !== "function") return;
            if (err) return cb(err);
            if (!names || !names.length) return cb(new Error("Response missing path info"));
            cb(void 0, names[0].filename);
          }, "cb")
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} REALPATH`);
      }
      // extended requests
      ext_openssh_rename(oldPath, newPath, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["posix-rename@openssh.com"];
        if (!ext || ext !== "1") throw new Error("Server does not support this extended request");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 24 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 24, p);
        buf.utf8Write("posix-rename@openssh.com", p += 4, 24);
        writeUInt32BE(buf, oldLen, p += 24);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} posix-rename@openssh.com`);
        }
      }
      ext_openssh_statvfs(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["statvfs@openssh.com"];
        if (!ext || ext !== "2") throw new Error("Server does not support this extended request");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 19 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 19, p);
        buf.utf8Write("statvfs@openssh.com", p += 4, 19);
        writeUInt32BE(buf, pathLen, p += 19);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          extended: "statvfs@openssh.com",
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} statvfs@openssh.com`);
        }
      }
      ext_openssh_fstatvfs(handle, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["fstatvfs@openssh.com"];
        if (!ext || ext !== "2") throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle)) throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("fstatvfs@openssh.com", p += 4, 20);
        writeUInt32BE(buf, handleLen, p += 20);
        buf.set(handle, p += 4);
        this._requests[reqid] = {
          extended: "fstatvfs@openssh.com",
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} fstatvfs@openssh.com`);
        }
      }
      ext_openssh_hardlink(oldPath, newPath, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["hardlink@openssh.com"];
        if (ext !== "1") throw new Error("Server does not support this extended request");
        const oldLen = Buffer.byteLength(oldPath);
        const newLen = Buffer.byteLength(newPath);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + oldLen + 4 + newLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("hardlink@openssh.com", p += 4, 20);
        writeUInt32BE(buf, oldLen, p += 20);
        buf.utf8Write(oldPath, p += 4, oldLen);
        writeUInt32BE(buf, newLen, p += oldLen);
        buf.utf8Write(newPath, p += 4, newLen);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const which = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${which} hardlink@openssh.com`);
        }
      }
      ext_openssh_fsync(handle, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["fsync@openssh.com"];
        if (ext !== "1") throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(handle)) throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 17 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 17, p);
        buf.utf8Write("fsync@openssh.com", p += 4, 17);
        writeUInt32BE(buf, handleLen, p += 17);
        buf.set(handle, p += 4);
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} fsync@openssh.com`);
      }
      ext_openssh_lsetstat(path, attrs, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["lsetstat@openssh.com"];
        if (ext !== "1") throw new Error("Server does not support this extended request");
        let flags = 0;
        let attrsLen = 0;
        if (typeof attrs === "object" && attrs !== null) {
          attrs = attrsToBytes(attrs);
          flags = attrs.flags;
          attrsLen = attrs.nb;
        } else if (typeof attrs === "function") {
          cb = attrs;
        }
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 20 + 4 + pathLen + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 20, p);
        buf.utf8Write("lsetstat@openssh.com", p += 4, 20);
        writeUInt32BE(buf, pathLen, p += 20);
        buf.utf8Write(path, p += 4, pathLen);
        writeUInt32BE(buf, flags, p += pathLen);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);
          else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} lsetstat@openssh.com`);
        }
      }
      ext_openssh_expandPath(path, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["expand-path@openssh.com"];
        if (ext !== "1") throw new Error("Server does not support this extended request");
        const pathLen = Buffer.byteLength(path);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 23 + 4 + pathLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = REQUEST.EXTENDED;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, 23, p);
        buf.utf8Write("expand-path@openssh.com", p += 4, 23);
        writeUInt32BE(buf, pathLen, p += 20);
        buf.utf8Write(path, p += 4, pathLen);
        this._requests[reqid] = {
          cb: /* @__PURE__ */ __name((err, names) => {
            if (typeof cb !== "function") return;
            if (err) return cb(err);
            if (!names || !names.length) return cb(new Error("Response missing expanded path"));
            cb(void 0, names[0].filename);
          }, "cb")
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} expand-path@openssh.com`);
        }
      }
      ext_copy_data(srcHandle, srcOffset, len, dstHandle, dstOffset, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["copy-data"];
        if (ext !== "1") throw new Error("Server does not support this extended request");
        if (!Buffer.isBuffer(srcHandle)) throw new Error("Source handle is not a Buffer");
        if (!Buffer.isBuffer(dstHandle)) throw new Error("Destination handle is not a Buffer");
        let p = 0;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 9 + 4 + srcHandle.length + 8 + 8 + 4 + dstHandle.length + 8);
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 9, p);
        p += 4;
        buf.utf8Write("copy-data", p, 9);
        p += 9;
        writeUInt32BE(buf, srcHandle.length, p);
        p += 4;
        buf.set(srcHandle, p);
        p += srcHandle.length;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = srcOffset & 255;
          srcOffset /= 256;
        }
        p += 8;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = len & 255;
          len /= 256;
        }
        p += 8;
        writeUInt32BE(buf, dstHandle.length, p);
        p += 4;
        buf.set(dstHandle, p);
        p += dstHandle.length;
        for (let i = 7; i >= 0; --i) {
          buf[p + i] = dstOffset & 255;
          dstOffset /= 256;
        }
        this._requests[reqid] = {
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} copy-data`);
        }
      }
      ext_home_dir(username, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["home-directory"];
        if (ext !== "1") throw new Error("Server does not support this extended request");
        if (typeof username !== "string") throw new TypeError("username is not a string");
        let p = 0;
        const usernameLen = Buffer.byteLength(username);
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 14 + 4 + usernameLen);
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 14, p);
        p += 4;
        buf.utf8Write("home-directory", p, 14);
        p += 14;
        writeUInt32BE(buf, usernameLen, p);
        p += 4;
        buf.utf8Write(username, p, usernameLen);
        p += usernameLen;
        this._requests[reqid] = {
          cb: /* @__PURE__ */ __name((err, names) => {
            if (typeof cb !== "function") return;
            if (err) return cb(err);
            if (!names || !names.length) return cb(new Error("Response missing home directory"));
            cb(void 0, names[0].filename);
          }, "cb")
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} home-directory`);
        }
      }
      ext_users_groups(uids, gids, cb) {
        if (this.server) throw new Error("Client-only method called in server mode");
        const ext = this._extensions["users-groups-by-id@openssh.com"];
        if (ext !== "1") throw new Error("Server does not support this extended request");
        if (!Array.isArray(uids)) throw new TypeError("uids is not an array");
        for (const val of uids) {
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1) throw new Error("uid values must all be 32-bit unsigned integers");
        }
        if (!Array.isArray(gids)) throw new TypeError("gids is not an array");
        for (const val of gids) {
          if (!Number.isInteger(val) || val < 0 || val > 2 ** 32 - 1) throw new Error("gid values must all be 32-bit unsigned integers");
        }
        let p = 0;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 30 + 4 + 4 * uids.length + 4 + 4 * gids.length);
        writeUInt32BE(buf, buf.length - 4, p);
        p += 4;
        buf[p] = REQUEST.EXTENDED;
        ++p;
        const reqid = this._writeReqid = this._writeReqid + 1 & MAX_REQID;
        writeUInt32BE(buf, reqid, p);
        p += 4;
        writeUInt32BE(buf, 30, p);
        p += 4;
        buf.utf8Write("users-groups-by-id@openssh.com", p, 30);
        p += 30;
        writeUInt32BE(buf, 4 * uids.length, p);
        p += 4;
        for (const val of uids) {
          writeUInt32BE(buf, val, p);
          p += 4;
        }
        writeUInt32BE(buf, 4 * gids.length, p);
        p += 4;
        for (const val of gids) {
          writeUInt32BE(buf, val, p);
          p += 4;
        }
        this._requests[reqid] = {
          extended: "users-groups-by-id@openssh.com",
          cb
        };
        const isBuffered = sendOrBuffer(this, buf);
        if (this._debug) {
          const status = isBuffered ? "Buffered" : "Sending";
          this._debug(`SFTP: Outbound: ${status} users-groups-by-id@openssh.com`);
        }
      }
      // ===========================================================================
      // Server-specific ===========================================================
      // ===========================================================================
      handle(reqid, handle) {
        if (!this.server) throw new Error("Server-only method called in client mode");
        if (!Buffer.isBuffer(handle)) throw new Error("handle is not a Buffer");
        const handleLen = handle.length;
        if (handleLen > 256) throw new Error("handle too large (> 256 bytes)");
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.HANDLE;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, handleLen, p);
        if (handleLen) buf.set(handle, p += 4);
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} HANDLE`);
      }
      status(reqid, code, message) {
        if (!this.server) throw new Error("Server-only method called in client mode");
        if (!VALID_STATUS_CODES.has(code)) throw new Error(`Bad status code: ${code}`);
        message || (message = "");
        const msgLen = Buffer.byteLength(message);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 4 + msgLen + 4);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.STATUS;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, code, p);
        writeUInt32BE(buf, msgLen, p += 4);
        p += 4;
        if (msgLen) {
          buf.utf8Write(message, p, msgLen);
          p += msgLen;
        }
        writeUInt32BE(buf, 0, p);
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} STATUS`);
      }
      data(reqid, data, encoding) {
        if (!this.server) throw new Error("Server-only method called in client mode");
        const isBuffer = Buffer.isBuffer(data);
        if (!isBuffer && typeof data !== "string") throw new Error("data is not a Buffer or string");
        let isUTF8;
        if (!isBuffer && !encoding) {
          encoding = void 0;
          isUTF8 = true;
        }
        const dataLen = isBuffer ? data.length : Buffer.byteLength(data, encoding);
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + dataLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.DATA;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, dataLen, p);
        if (dataLen) {
          if (isBuffer) buf.set(data, p += 4);
          else if (isUTF8) buf.utf8Write(data, p += 4, dataLen);
          else buf.write(data, p += 4, dataLen, encoding);
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} DATA`);
      }
      name(reqid, names) {
        if (!this.server) throw new Error("Server-only method called in client mode");
        if (!Array.isArray(names)) {
          if (typeof names !== "object" || names === null) throw new Error("names is not an object or array");
          names = [
            names
          ];
        }
        const count = names.length;
        let namesLen = 0;
        let nameAttrs;
        const attrs = [];
        for (let i = 0; i < count; ++i) {
          const name = names[i];
          const filename = !name || !name.filename || typeof name.filename !== "string" ? "" : name.filename;
          namesLen += 4 + Buffer.byteLength(filename);
          const longname = !name || !name.longname || typeof name.longname !== "string" ? "" : name.longname;
          namesLen += 4 + Buffer.byteLength(longname);
          if (typeof name.attrs === "object" && name.attrs !== null) {
            nameAttrs = attrsToBytes(name.attrs);
            namesLen += 4 + nameAttrs.nb;
            if (nameAttrs.nb) {
              let bytes;
              if (nameAttrs.nb === ATTRS_BUF.length) {
                bytes = new Uint8Array(ATTRS_BUF);
              } else {
                bytes = new Uint8Array(nameAttrs.nb);
                bufferCopy(ATTRS_BUF, bytes, 0, nameAttrs.nb, 0);
              }
              nameAttrs.bytes = bytes;
            }
            attrs.push(nameAttrs);
          } else {
            namesLen += 4;
            attrs.push(null);
          }
        }
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + namesLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.NAME;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, count, p);
        p += 4;
        for (let i = 0; i < count; ++i) {
          const name = names[i];
          {
            const filename = !name || !name.filename || typeof name.filename !== "string" ? "" : name.filename;
            const len = Buffer.byteLength(filename);
            writeUInt32BE(buf, len, p);
            p += 4;
            if (len) {
              buf.utf8Write(filename, p, len);
              p += len;
            }
          }
          {
            const longname = !name || !name.longname || typeof name.longname !== "string" ? "" : name.longname;
            const len = Buffer.byteLength(longname);
            writeUInt32BE(buf, len, p);
            p += 4;
            if (len) {
              buf.utf8Write(longname, p, len);
              p += len;
            }
          }
          const attr = attrs[i];
          if (attr) {
            writeUInt32BE(buf, attr.flags, p);
            p += 4;
            if (attr.flags && attr.bytes) {
              buf.set(attr.bytes, p);
              p += attr.nb;
            }
          } else {
            writeUInt32BE(buf, 0, p);
            p += 4;
          }
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} NAME`);
      }
      attrs(reqid, attrs) {
        if (!this.server) throw new Error("Server-only method called in client mode");
        if (typeof attrs !== "object" || attrs === null) throw new Error("attrs is not an object");
        attrs = attrsToBytes(attrs);
        const flags = attrs.flags;
        const attrsLen = attrs.nb;
        let p = 9;
        const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + attrsLen);
        writeUInt32BE(buf, buf.length - 4, 0);
        buf[4] = RESPONSE.ATTRS;
        writeUInt32BE(buf, reqid, 5);
        writeUInt32BE(buf, flags, p);
        if (attrsLen) {
          p += 4;
          if (attrsLen === ATTRS_BUF.length) buf.set(ATTRS_BUF, p);
          else bufferCopy(ATTRS_BUF, buf, 0, attrsLen, p);
          p += attrsLen;
        }
        const isBuffered = sendOrBuffer(this, buf);
        this._debug && this._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} ATTRS`);
      }
    };
    function tryCreateBuffer(size) {
      try {
        return Buffer.allocUnsafe(size);
      } catch (ex) {
        return ex;
      }
    }
    __name(tryCreateBuffer, "tryCreateBuffer");
    function read_(self2, handle, buf, off, len, position, cb, req_) {
      const maxDataLen = self2._maxReadLen;
      const overflow = Math.max(len - maxDataLen, 0);
      if (overflow) len = maxDataLen;
      const handleLen = handle.length;
      let p = 9;
      let pos = position;
      const out = Buffer.allocUnsafe(4 + 1 + 4 + 4 + handleLen + 8 + 4);
      writeUInt32BE(out, out.length - 4, 0);
      out[4] = REQUEST.READ;
      const reqid = self2._writeReqid = self2._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(out, reqid, 5);
      writeUInt32BE(out, handleLen, p);
      out.set(handle, p += 4);
      p += handleLen;
      for (let i = 7; i >= 0; --i) {
        out[p + i] = pos & 255;
        pos /= 256;
      }
      writeUInt32BE(out, len, p += 8);
      if (typeof cb !== "function") cb = noop;
      const req = req_ || {
        nb: 0,
        position,
        off,
        origOff: off,
        len: void 0,
        overflow: void 0,
        cb: /* @__PURE__ */ __name((err, data, nb) => {
          const len2 = req.len;
          const overflow2 = req.overflow;
          if (err) {
            if (cb._wantEOFError || err.code !== STATUS_CODE.EOF) return cb(err);
          } else if (nb > len2) {
            return cb(new Error("Received more data than requested"));
          } else if (nb === len2 && overflow2) {
            req.nb += nb;
            req.position += nb;
            req.off += nb;
            read_(self2, handle, buf, req.off, overflow2, req.position, cb, req);
            return;
          }
          nb = nb || 0;
          if (req.origOff === 0 && buf.length === req.nb) data = buf;
          else data = bufferSlice(buf, req.origOff, req.origOff + req.nb + nb);
          cb(void 0, req.nb + nb, data, req.position);
        }, "cb"),
        buffer: void 0
      };
      req.len = len;
      req.overflow = overflow;
      req.buffer = bufferSlice(buf, off, off + len);
      self2._requests[reqid] = req;
      const isBuffered = sendOrBuffer(self2, out);
      self2._debug && self2._debug(`SFTP: Outbound: ${isBuffered ? "Buffered" : "Sending"} READ`);
    }
    __name(read_, "read_");
    function fastXfer(src, dst, srcPath, dstPath, opts, cb) {
      let concurrency = 64;
      let chunkSize = 32768;
      let onstep;
      let mode;
      let fileSize;
      if (typeof opts === "function") {
        cb = opts;
      } else if (typeof opts === "object" && opts !== null) {
        if (typeof opts.concurrency === "number" && opts.concurrency > 0 && !isNaN(opts.concurrency)) {
          concurrency = opts.concurrency;
        }
        if (typeof opts.chunkSize === "number" && opts.chunkSize > 0 && !isNaN(opts.chunkSize)) {
          chunkSize = opts.chunkSize;
        }
        if (typeof opts.fileSize === "number" && opts.fileSize > 0 && !isNaN(opts.fileSize)) {
          fileSize = opts.fileSize;
        }
        if (typeof opts.step === "function") onstep = opts.step;
        if (typeof opts.mode === "string" || typeof opts.mode === "number") mode = modeNum(opts.mode);
      }
      let fsize;
      let pdst = 0;
      let total = 0;
      let hadError = false;
      let srcHandle;
      let dstHandle;
      let readbuf;
      let bufsize = chunkSize * concurrency;
      function onerror(err) {
        if (hadError) return;
        hadError = true;
        let left2 = 0;
        let cbfinal;
        if (srcHandle || dstHandle) {
          cbfinal = /* @__PURE__ */ __name(() => {
            if (--left2 === 0) cb(err);
          }, "cbfinal");
          if (srcHandle && (src === fs || src.outgoing.state === "open")) ++left2;
          if (dstHandle && (dst === fs || dst.outgoing.state === "open")) ++left2;
          if (srcHandle && (src === fs || src.outgoing.state === "open")) src.close(srcHandle, cbfinal);
          if (dstHandle && (dst === fs || dst.outgoing.state === "open")) dst.close(dstHandle, cbfinal);
        } else {
          cb(err);
        }
      }
      __name(onerror, "onerror");
      src.open(srcPath, "r", (err, sourceHandle) => {
        if (err) return onerror(err);
        srcHandle = sourceHandle;
        if (fileSize === void 0) src.fstat(srcHandle, tryStat);
        else tryStat(null, {
          size: fileSize
        });
        function tryStat(err2, attrs) {
          if (err2) {
            if (src !== fs) {
              src.stat(srcPath, (err_, attrs_) => {
                if (err_) return onerror(err2);
                tryStat(null, attrs_);
              });
              return;
            }
            return onerror(err2);
          }
          fsize = attrs.size;
          dst.open(dstPath, "w", (err3, destHandle) => {
            if (err3) return onerror(err3);
            dstHandle = destHandle;
            if (fsize <= 0) return onerror();
            while (bufsize > fsize) {
              if (concurrency === 1) {
                bufsize = fsize;
                break;
              }
              bufsize -= chunkSize;
              --concurrency;
            }
            readbuf = tryCreateBuffer(bufsize);
            if (readbuf instanceof Error) return onerror(readbuf);
            if (mode !== void 0) {
              dst.fchmod(dstHandle, mode, /* @__PURE__ */ __name(function tryAgain(err4) {
                if (err4) {
                  dst.chmod(dstPath, mode, (err_) => tryAgain());
                  return;
                }
                startReads();
              }, "tryAgain"));
            } else {
              startReads();
            }
            function onread(err4, nb, data, dstpos, datapos, origChunkLen) {
              if (err4) return onerror(err4);
              datapos = datapos || 0;
              dst.write(dstHandle, readbuf, datapos, nb, dstpos, writeCb);
              function writeCb(err5) {
                if (err5) return onerror(err5);
                total += nb;
                onstep && onstep(total, nb, fsize);
                if (nb < origChunkLen) return singleRead(datapos, dstpos + nb, origChunkLen - nb);
                if (total === fsize) {
                  dst.close(dstHandle, (err6) => {
                    dstHandle = void 0;
                    if (err6) return onerror(err6);
                    src.close(srcHandle, (err7) => {
                      srcHandle = void 0;
                      if (err7) return onerror(err7);
                      cb();
                    });
                  });
                  return;
                }
                if (pdst >= fsize) return;
                const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(datapos, pdst, chunk);
                pdst += chunk;
              }
              __name(writeCb, "writeCb");
            }
            __name(onread, "onread");
            function makeCb(psrc, pdst2, chunk) {
              return (err4, nb, data) => {
                onread(err4, nb, data, pdst2, psrc, chunk);
              };
            }
            __name(makeCb, "makeCb");
            function singleRead(psrc, pdst2, chunk) {
              src.read(srcHandle, readbuf, psrc, chunk, pdst2, makeCb(psrc, pdst2, chunk));
            }
            __name(singleRead, "singleRead");
            function startReads() {
              let reads = 0;
              let psrc = 0;
              while (pdst < fsize && reads < concurrency) {
                const chunk = pdst + chunkSize > fsize ? fsize - pdst : chunkSize;
                singleRead(psrc, pdst, chunk);
                psrc += chunk;
                pdst += chunk;
                ++reads;
              }
            }
            __name(startReads, "startReads");
          });
        }
        __name(tryStat, "tryStat");
      });
    }
    __name(fastXfer, "fastXfer");
    function writeAll(sftp, handle, buffer, offset, length, position, callback_) {
      const callback = typeof callback_ === "function" ? callback_ : void 0;
      sftp.write(handle, buffer, offset, length, position, (writeErr, written) => {
        if (writeErr) {
          return sftp.close(handle, () => {
            callback && callback(writeErr);
          });
        }
        if (written === length) {
          sftp.close(handle, callback);
        } else {
          offset += written;
          length -= written;
          position += written;
          writeAll(sftp, handle, buffer, offset, length, position, callback);
        }
      });
    }
    __name(writeAll, "writeAll");
    var Stats = class Stats {
      static {
        __name(this, "Stats");
      }
      constructor(initial) {
        this.mode = initial && initial.mode;
        this.uid = initial && initial.uid;
        this.gid = initial && initial.gid;
        this.size = initial && initial.size;
        this.atime = initial && initial.atime;
        this.mtime = initial && initial.mtime;
        this.extended = initial && initial.extended;
      }
      isDirectory() {
        return (this.mode & constants.S_IFMT) === constants.S_IFDIR;
      }
      isFile() {
        return (this.mode & constants.S_IFMT) === constants.S_IFREG;
      }
      isBlockDevice() {
        return (this.mode & constants.S_IFMT) === constants.S_IFBLK;
      }
      isCharacterDevice() {
        return (this.mode & constants.S_IFMT) === constants.S_IFCHR;
      }
      isSymbolicLink() {
        return (this.mode & constants.S_IFMT) === constants.S_IFLNK;
      }
      isFIFO() {
        return (this.mode & constants.S_IFMT) === constants.S_IFIFO;
      }
      isSocket() {
        return (this.mode & constants.S_IFMT) === constants.S_IFSOCK;
      }
    };
    function attrsToBytes(attrs) {
      let flags = 0;
      let nb = 0;
      if (typeof attrs === "object" && attrs !== null) {
        if (typeof attrs.size === "number") {
          flags |= ATTR.SIZE;
          const val = attrs.size;
          ATTRS_BUF[nb++] = val / 72057594037927940;
          ATTRS_BUF[nb++] = val / 281474976710656;
          ATTRS_BUF[nb++] = val / 1099511627776;
          ATTRS_BUF[nb++] = val / 4294967296;
          ATTRS_BUF[nb++] = val / 16777216;
          ATTRS_BUF[nb++] = val / 65536;
          ATTRS_BUF[nb++] = val / 256;
          ATTRS_BUF[nb++] = val;
        }
        if (typeof attrs.uid === "number" && typeof attrs.gid === "number") {
          flags |= ATTR.UIDGID;
          const uid = attrs.uid;
          const gid = attrs.gid;
          ATTRS_BUF[nb++] = uid >>> 24;
          ATTRS_BUF[nb++] = uid >>> 16;
          ATTRS_BUF[nb++] = uid >>> 8;
          ATTRS_BUF[nb++] = uid;
          ATTRS_BUF[nb++] = gid >>> 24;
          ATTRS_BUF[nb++] = gid >>> 16;
          ATTRS_BUF[nb++] = gid >>> 8;
          ATTRS_BUF[nb++] = gid;
        }
        if (typeof attrs.mode === "number" || typeof attrs.mode === "string") {
          const mode = modeNum(attrs.mode);
          flags |= ATTR.PERMISSIONS;
          ATTRS_BUF[nb++] = mode >>> 24;
          ATTRS_BUF[nb++] = mode >>> 16;
          ATTRS_BUF[nb++] = mode >>> 8;
          ATTRS_BUF[nb++] = mode;
        }
        if ((typeof attrs.atime === "number" || isDate(attrs.atime)) && (typeof attrs.mtime === "number" || isDate(attrs.mtime))) {
          const atime = toUnixTimestamp(attrs.atime);
          const mtime = toUnixTimestamp(attrs.mtime);
          flags |= ATTR.ACMODTIME;
          ATTRS_BUF[nb++] = atime >>> 24;
          ATTRS_BUF[nb++] = atime >>> 16;
          ATTRS_BUF[nb++] = atime >>> 8;
          ATTRS_BUF[nb++] = atime;
          ATTRS_BUF[nb++] = mtime >>> 24;
          ATTRS_BUF[nb++] = mtime >>> 16;
          ATTRS_BUF[nb++] = mtime >>> 8;
          ATTRS_BUF[nb++] = mtime;
        }
      }
      return {
        flags,
        nb
      };
    }
    __name(attrsToBytes, "attrsToBytes");
    function toUnixTimestamp(time) {
      if (typeof time === "number" && time === time) return time;
      if (isDate(time)) return parseInt(time.getTime() / 1e3, 10);
      throw new Error(`Cannot parse time: ${time}`);
    }
    __name(toUnixTimestamp, "toUnixTimestamp");
    function modeNum(mode) {
      if (typeof mode === "number" && mode === mode) return mode;
      if (typeof mode === "string") return modeNum(parseInt(mode, 8));
      throw new Error(`Cannot parse mode: ${mode}`);
    }
    __name(modeNum, "modeNum");
    var stringFlagMap = {
      "r": OPEN_MODE.READ,
      "r+": OPEN_MODE.READ | OPEN_MODE.WRITE,
      "w": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      "wx": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "w+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "wx+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xw+": OPEN_MODE.TRUNC | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE,
      "ax": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "a+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE,
      "ax+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL,
      "xa+": OPEN_MODE.APPEND | OPEN_MODE.CREAT | OPEN_MODE.READ | OPEN_MODE.WRITE | OPEN_MODE.EXCL
    };
    function stringToFlags(str) {
      const flags = stringFlagMap[str];
      return flags !== void 0 ? flags : null;
    }
    __name(stringToFlags, "stringToFlags");
    var flagsToString = (() => {
      const stringFlagMapKeys = Object.keys(stringFlagMap);
      return (flags) => {
        for (let i = 0; i < stringFlagMapKeys.length; ++i) {
          const key = stringFlagMapKeys[i];
          if (stringFlagMap[key] === flags) return key;
        }
        return null;
      };
    })();
    function readAttrs(biOpt) {
      const flags = bufferParser.readUInt32BE();
      if (flags === void 0) return;
      const attrs = new Stats();
      if (flags & ATTR.SIZE) {
        const size = bufferParser.readUInt64BE(biOpt);
        if (size === void 0) return;
        attrs.size = size;
      }
      if (flags & ATTR.UIDGID) {
        const uid = bufferParser.readUInt32BE();
        const gid = bufferParser.readUInt32BE();
        if (gid === void 0) return;
        attrs.uid = uid;
        attrs.gid = gid;
      }
      if (flags & ATTR.PERMISSIONS) {
        const mode = bufferParser.readUInt32BE();
        if (mode === void 0) return;
        attrs.mode = mode;
      }
      if (flags & ATTR.ACMODTIME) {
        const atime = bufferParser.readUInt32BE();
        const mtime = bufferParser.readUInt32BE();
        if (mtime === void 0) return;
        attrs.atime = atime;
        attrs.mtime = mtime;
      }
      if (flags & ATTR.EXTENDED) {
        const count = bufferParser.readUInt32BE();
        if (count === void 0) return;
        const extended = {};
        for (let i = 0; i < count; ++i) {
          const type = bufferParser.readString(true);
          const data = bufferParser.readString();
          if (data === void 0) return;
          extended[type] = data;
        }
        attrs.extended = extended;
      }
      return attrs;
    }
    __name(readAttrs, "readAttrs");
    function sendOrBuffer(sftp, payload) {
      const ret = tryWritePayload(sftp, payload);
      if (ret !== void 0) {
        sftp._buffer.push(ret);
        return false;
      }
      return true;
    }
    __name(sendOrBuffer, "sendOrBuffer");
    function tryWritePayload(sftp, payload) {
      const outgoing = sftp.outgoing;
      if (outgoing.state !== "open") return;
      if (outgoing.window === 0) {
        sftp._waitWindow = true;
        sftp._chunkcb = drainBuffer;
        return payload;
      }
      let ret;
      const len = payload.length;
      let p = 0;
      while (len - p > 0 && outgoing.window > 0) {
        const actualLen = Math.min(len - p, outgoing.window, outgoing.packetSize);
        outgoing.window -= actualLen;
        if (outgoing.window === 0) {
          sftp._waitWindow = true;
          sftp._chunkcb = drainBuffer;
        }
        if (p === 0 && actualLen === len) {
          sftp._protocol.channelData(sftp.outgoing.id, payload);
        } else {
          sftp._protocol.channelData(sftp.outgoing.id, bufferSlice(payload, p, p + actualLen));
        }
        p += actualLen;
      }
      if (len - p > 0) {
        if (p > 0) ret = bufferSlice(payload, p, len);
        else ret = payload;
      }
      return ret;
    }
    __name(tryWritePayload, "tryWritePayload");
    function drainBuffer() {
      this._chunkcb = void 0;
      const buffer = this._buffer;
      let i = 0;
      while (i < buffer.length) {
        const payload = buffer[i];
        const ret = tryWritePayload(this, payload);
        if (ret !== void 0) {
          if (ret !== payload) buffer[i] = ret;
          if (i > 0) this._buffer = buffer.slice(i);
          return;
        }
        ++i;
      }
      if (i > 0) this._buffer = [];
    }
    __name(drainBuffer, "drainBuffer");
    function doFatalSFTPError(sftp, msg, noDebug) {
      const err = new Error(msg);
      err.level = "sftp-protocol";
      if (!noDebug && sftp._debug) sftp._debug(`SFTP: Inbound: ${msg}`);
      sftp.emit("error", err);
      sftp.destroy();
      cleanupRequests(sftp);
      return false;
    }
    __name(doFatalSFTPError, "doFatalSFTPError");
    function cleanupRequests(sftp) {
      const keys = Object.keys(sftp._requests);
      if (keys.length === 0) return;
      const reqs = sftp._requests;
      sftp._requests = {};
      const err = new Error("No response from server");
      for (let i = 0; i < keys.length; ++i) {
        const req = reqs[keys[i]];
        if (typeof req.cb === "function") req.cb(err);
      }
    }
    __name(cleanupRequests, "cleanupRequests");
    function requestLimits(sftp, cb) {
      let p = 9;
      const buf = Buffer.allocUnsafe(4 + 1 + 4 + 4 + 18);
      writeUInt32BE(buf, buf.length - 4, 0);
      buf[4] = REQUEST.EXTENDED;
      const reqid = sftp._writeReqid = sftp._writeReqid + 1 & MAX_REQID;
      writeUInt32BE(buf, reqid, 5);
      writeUInt32BE(buf, 18, p);
      buf.utf8Write("limits@openssh.com", p += 4, 18);
      sftp._requests[reqid] = {
        extended: "limits@openssh.com",
        cb
      };
      const isBuffered = sendOrBuffer(sftp, buf);
      if (sftp._debug) {
        const which = isBuffered ? "Buffered" : "Sending";
        sftp._debug(`SFTP: Outbound: ${which} limits@openssh.com`);
      }
    }
    __name(requestLimits, "requestLimits");
    var CLIENT_HANDLERS = {
      [RESPONSE.VERSION]: (sftp, payload) => {
        if (sftp._version !== -1) return doFatalSFTPError(sftp, "Duplicate VERSION packet");
        const extensions = {};
        bufferParser.init(payload, 1);
        let version2 = bufferParser.readUInt32BE();
        while (bufferParser.avail()) {
          const extName = bufferParser.readString(true);
          const extData = bufferParser.readString(true);
          if (extData === void 0) {
            version2 = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        bufferParser.clear();
        if (version2 === void 0) return doFatalSFTPError(sftp, "Malformed VERSION packet");
        if (sftp._debug) {
          const names = Object.keys(extensions);
          if (names.length) {
            sftp._debug(`SFTP: Inbound: Received VERSION (v${version2}, exts:${names})`);
          } else {
            sftp._debug(`SFTP: Inbound: Received VERSION (v${version2})`);
          }
        }
        sftp._version = version2;
        sftp._extensions = extensions;
        if (extensions["limits@openssh.com"] === "1") {
          return requestLimits(sftp, (err, limits) => {
            if (!err) {
              if (limits.maxPktLen > 0) sftp._maxOutPktLen = limits.maxPktLen;
              if (limits.maxReadLen > 0) sftp._maxReadLen = limits.maxReadLen;
              if (limits.maxWriteLen > 0) sftp._maxWriteLen = limits.maxWriteLen;
              sftp.maxOpenHandles = limits.maxOpenHandles > 0 ? limits.maxOpenHandles : Infinity;
            }
            sftp.emit("ready");
          });
        }
        sftp.emit("ready");
      },
      [RESPONSE.STATUS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const errorCode = bufferParser.readUInt32BE();
        const errorMsg = bufferParser.readString(true);
        bufferParser.clear();
        if (sftp._debug) {
          const jsonMsg = JSON.stringify(errorMsg);
          sftp._debug(`SFTP: Inbound: Received STATUS (id:${reqID}, ${errorCode}, ${jsonMsg})`);
        }
        const req = sftp._requests[reqID];
        delete sftp._requests[reqID];
        if (req && typeof req.cb === "function") {
          if (errorCode === STATUS_CODE.OK) {
            req.cb();
            return;
          }
          const err = new Error(errorMsg || STATUS_CODE_STR[errorCode] || "Unknown status");
          err.code = errorCode;
          req.cb(err);
        }
      },
      [RESPONSE.HANDLE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0) {
          if (reqID !== void 0) delete sftp._requests[reqID];
          return doFatalSFTPError(sftp, "Malformed HANDLE packet");
        }
        sftp._debug && sftp._debug(`SFTP: Inbound: Received HANDLE (id:${reqID})`);
        const req = sftp._requests[reqID];
        delete sftp._requests[reqID];
        if (req && typeof req.cb === "function") req.cb(void 0, handle);
      },
      [RESPONSE.DATA]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        if (req && typeof req.cb === "function") {
          if (req.buffer) {
            const nb = bufferParser.readString(req.buffer);
            bufferParser.clear();
            if (nb !== void 0) {
              sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`);
              req.cb(void 0, req.buffer, nb);
              return;
            }
          } else {
            const data = bufferParser.readString();
            bufferParser.clear();
            if (data !== void 0) {
              sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${data.length})`);
              req.cb(void 0, data);
              return;
            }
          }
        } else {
          const nb = bufferParser.skipString();
          bufferParser.clear();
          if (nb !== void 0) {
            sftp._debug && sftp._debug(`SFTP: Inbound: Received DATA (id:${reqID}, ${nb})`);
            return;
          }
        }
        return doFatalSFTPError(sftp, "Malformed DATA packet");
      },
      [RESPONSE.NAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        const count = bufferParser.readUInt32BE();
        if (count !== void 0) {
          let names = [];
          for (let i = 0; i < count; ++i) {
            const filename = bufferParser.readString(true);
            const longname = bufferParser.readString(true);
            const attrs = readAttrs(sftp._biOpt);
            if (attrs === void 0) {
              names = void 0;
              break;
            }
            names.push({
              filename,
              longname,
              attrs
            });
          }
          if (names !== void 0) {
            sftp._debug && sftp._debug(`SFTP: Inbound: Received NAME (id:${reqID}, ${names.length})`);
            bufferParser.clear();
            if (req && typeof req.cb === "function") req.cb(void 0, names);
            return;
          }
        }
        bufferParser.clear();
        return doFatalSFTPError(sftp, "Malformed NAME packet");
      },
      [RESPONSE.ATTRS]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        let req;
        if (reqID !== void 0) {
          req = sftp._requests[reqID];
          delete sftp._requests[reqID];
        }
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs !== void 0) {
          sftp._debug && sftp._debug(`SFTP: Inbound: Received ATTRS (id:${reqID})`);
          if (req && typeof req.cb === "function") req.cb(void 0, attrs);
          return;
        }
        return doFatalSFTPError(sftp, "Malformed ATTRS packet");
      },
      [RESPONSE.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        if (reqID !== void 0) {
          const req = sftp._requests[reqID];
          if (req) {
            delete sftp._requests[reqID];
            switch (req.extended) {
              case "statvfs@openssh.com":
              case "fstatvfs@openssh.com": {
                const biOpt = sftp._biOpt;
                const stats = {
                  f_bsize: bufferParser.readUInt64BE(biOpt),
                  f_frsize: bufferParser.readUInt64BE(biOpt),
                  f_blocks: bufferParser.readUInt64BE(biOpt),
                  f_bfree: bufferParser.readUInt64BE(biOpt),
                  f_bavail: bufferParser.readUInt64BE(biOpt),
                  f_files: bufferParser.readUInt64BE(biOpt),
                  f_ffree: bufferParser.readUInt64BE(biOpt),
                  f_favail: bufferParser.readUInt64BE(biOpt),
                  f_sid: bufferParser.readUInt64BE(biOpt),
                  f_flag: bufferParser.readUInt64BE(biOpt),
                  f_namemax: bufferParser.readUInt64BE(biOpt)
                };
                if (stats.f_namemax === void 0) break;
                if (sftp._debug) {
                  sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`);
                }
                bufferParser.clear();
                if (typeof req.cb === "function") req.cb(void 0, stats);
                return;
              }
              case "limits@openssh.com": {
                const limits = {
                  maxPktLen: bufferParser.readUInt64BE(),
                  maxReadLen: bufferParser.readUInt64BE(),
                  maxWriteLen: bufferParser.readUInt64BE(),
                  maxOpenHandles: bufferParser.readUInt64BE()
                };
                if (limits.maxOpenHandles === void 0) break;
                if (sftp._debug) {
                  sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`);
                }
                bufferParser.clear();
                if (typeof req.cb === "function") req.cb(void 0, limits);
                return;
              }
              case "users-groups-by-id@openssh.com": {
                const usernameCount = bufferParser.readUInt32BE();
                if (usernameCount === void 0) break;
                const usernames = new Array(usernameCount);
                for (let i = 0; i < usernames.length; ++i) usernames[i] = bufferParser.readString(true);
                const groupnameCount = bufferParser.readUInt32BE();
                if (groupnameCount === void 0) break;
                const groupnames = new Array(groupnameCount);
                for (let i = 0; i < groupnames.length; ++i) groupnames[i] = bufferParser.readString(true);
                if (groupnames.length > 0 && groupnames[groupnames.length - 1] === void 0) {
                  break;
                }
                if (sftp._debug) {
                  sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ${req.extended})`);
                }
                bufferParser.clear();
                if (typeof req.cb === "function") req.cb(void 0, usernames, groupnames);
                return;
              }
              default:
                sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`);
                bufferParser.clear();
                if (typeof req.cb === "function") req.cb();
                return;
            }
          } else {
            sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED_REPLY (id:${reqID}, ???)`);
            bufferParser.clear();
            return;
          }
        }
        bufferParser.clear();
        return doFatalSFTPError(sftp, "Malformed EXTENDED_REPLY packet");
      }
    };
    var SERVER_HANDLERS = {
      [REQUEST.INIT]: (sftp, payload) => {
        if (sftp._version !== -1) return doFatalSFTPError(sftp, "Duplicate INIT packet");
        const extensions = {};
        bufferParser.init(payload, 1);
        let version2 = bufferParser.readUInt32BE();
        while (bufferParser.avail()) {
          const extName = bufferParser.readString(true);
          const extData = bufferParser.readString(true);
          if (extData === void 0) {
            version2 = void 0;
            break;
          }
          extensions[extName] = extData;
        }
        bufferParser.clear();
        if (version2 === void 0) return doFatalSFTPError(sftp, "Malformed INIT packet");
        if (sftp._debug) {
          const names = Object.keys(extensions);
          if (names.length) {
            sftp._debug(`SFTP: Inbound: Received INIT (v${version2}, exts:${names})`);
          } else {
            sftp._debug(`SFTP: Inbound: Received INIT (v${version2})`);
          }
        }
        sendOrBuffer(sftp, SERVER_VERSION_BUFFER);
        sftp._version = version2;
        sftp._extensions = extensions;
        sftp.emit("ready");
      },
      [REQUEST.OPEN]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const filename = bufferParser.readString(true);
        const pflags = bufferParser.readUInt32BE();
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0) return doFatalSFTPError(sftp, "Malformed OPEN packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPEN (id:${reqID})`);
        if (!sftp.emit("OPEN", reqID, filename, pflags, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.CLOSE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256) return doFatalSFTPError(sftp, "Malformed CLOSE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received CLOSE (id:${reqID})`);
        if (!sftp.emit("CLOSE", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READ]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const offset = bufferParser.readUInt64BE(sftp._biOpt);
        const len = bufferParser.readUInt32BE();
        bufferParser.clear();
        if (len === void 0 || handle.length > 256) return doFatalSFTPError(sftp, "Malformed READ packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READ (id:${reqID})`);
        if (!sftp.emit("READ", reqID, handle, offset, len)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.WRITE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const offset = bufferParser.readUInt64BE(sftp._biOpt);
        const data = bufferParser.readString();
        bufferParser.clear();
        if (data === void 0 || handle.length > 256) return doFatalSFTPError(sftp, "Malformed WRITE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received WRITE (id:${reqID})`);
        if (!sftp.emit("WRITE", reqID, handle, offset, data)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.LSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0) return doFatalSFTPError(sftp, "Malformed LSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received LSTAT (id:${reqID})`);
        if (!sftp.emit("LSTAT", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.FSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256) return doFatalSFTPError(sftp, "Malformed FSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received FSTAT (id:${reqID})`);
        if (!sftp.emit("FSTAT", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.SETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0) return doFatalSFTPError(sftp, "Malformed SETSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SETSTAT (id:${reqID})`);
        if (!sftp.emit("SETSTAT", reqID, path, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.FSETSTAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0 || handle.length > 256) return doFatalSFTPError(sftp, "Malformed FSETSTAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received FSETSTAT (id:${reqID})`);
        if (!sftp.emit("FSETSTAT", reqID, handle, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.OPENDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0) return doFatalSFTPError(sftp, "Malformed OPENDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received OPENDIR (id:${reqID})`);
        if (!sftp.emit("OPENDIR", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const handle = bufferParser.readString();
        bufferParser.clear();
        if (handle === void 0 || handle.length > 256) return doFatalSFTPError(sftp, "Malformed READDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READDIR (id:${reqID})`);
        if (!sftp.emit("READDIR", reqID, handle)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.REMOVE]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0) return doFatalSFTPError(sftp, "Malformed REMOVE packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received REMOVE (id:${reqID})`);
        if (!sftp.emit("REMOVE", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.MKDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        const attrs = readAttrs(sftp._biOpt);
        bufferParser.clear();
        if (attrs === void 0) return doFatalSFTPError(sftp, "Malformed MKDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received MKDIR (id:${reqID})`);
        if (!sftp.emit("MKDIR", reqID, path, attrs)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.RMDIR]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0) return doFatalSFTPError(sftp, "Malformed RMDIR packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RMDIR (id:${reqID})`);
        if (!sftp.emit("RMDIR", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.REALPATH]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0) return doFatalSFTPError(sftp, "Malformed REALPATH packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received REALPATH (id:${reqID})`);
        if (!sftp.emit("REALPATH", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.STAT]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0) return doFatalSFTPError(sftp, "Malformed STAT packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received STAT (id:${reqID})`);
        if (!sftp.emit("STAT", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.RENAME]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const oldPath = bufferParser.readString(true);
        const newPath = bufferParser.readString(true);
        bufferParser.clear();
        if (newPath === void 0) return doFatalSFTPError(sftp, "Malformed RENAME packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received RENAME (id:${reqID})`);
        if (!sftp.emit("RENAME", reqID, oldPath, newPath)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.READLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const path = bufferParser.readString(true);
        bufferParser.clear();
        if (path === void 0) return doFatalSFTPError(sftp, "Malformed READLINK packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received READLINK (id:${reqID})`);
        if (!sftp.emit("READLINK", reqID, path)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.SYMLINK]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const linkPath = bufferParser.readString(true);
        const targetPath = bufferParser.readString(true);
        bufferParser.clear();
        if (targetPath === void 0) return doFatalSFTPError(sftp, "Malformed SYMLINK packet");
        sftp._debug && sftp._debug(`SFTP: Inbound: Received SYMLINK (id:${reqID})`);
        let handled;
        if (sftp._isOpenSSH) {
          handled = sftp.emit("SYMLINK", reqID, targetPath, linkPath);
        } else {
          handled = sftp.emit("SYMLINK", reqID, linkPath, targetPath);
        }
        if (!handled) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      },
      [REQUEST.EXTENDED]: (sftp, payload) => {
        bufferParser.init(payload, 1);
        const reqID = bufferParser.readUInt32BE();
        const extName = bufferParser.readString(true);
        if (extName === void 0) {
          bufferParser.clear();
          return doFatalSFTPError(sftp, "Malformed EXTENDED packet");
        }
        let extData;
        if (bufferParser.avail()) extData = bufferParser.readRaw();
        bufferParser.clear();
        sftp._debug && sftp._debug(`SFTP: Inbound: Received EXTENDED (id:${reqID})`);
        if (!sftp.emit("EXTENDED", reqID, extName, extData)) {
          sftp.status(reqID, STATUS_CODE.OP_UNSUPPORTED);
        }
      }
    };
    var { ERR_INVALID_ARG_TYPE, ERR_OUT_OF_RANGE, validateNumber } = require_node_fs_compat();
    var kMinPoolSpace = 128;
    var pool;
    var poolFragments = [];
    function allocNewPool(poolSize) {
      if (poolFragments.length > 0) pool = poolFragments.pop();
      else pool = Buffer.allocUnsafe(poolSize);
      pool.used = 0;
    }
    __name(allocNewPool, "allocNewPool");
    function checkPosition(pos, name) {
      if (!Number.isSafeInteger(pos)) {
        validateNumber(pos, name);
        if (!Number.isInteger(pos)) throw new ERR_OUT_OF_RANGE(name, "an integer", pos);
        throw new ERR_OUT_OF_RANGE(name, ">= 0 and <= 2 ** 53 - 1", pos);
      }
      if (pos < 0) throw new ERR_OUT_OF_RANGE(name, ">= 0 and <= 2 ** 53 - 1", pos);
    }
    __name(checkPosition, "checkPosition");
    function roundUpToMultipleOf8(n) {
      return n + 7 & ~7;
    }
    __name(roundUpToMultipleOf8, "roundUpToMultipleOf8");
    function ReadStream(sftp, path, options) {
      if (options === void 0) options = {};
      else if (typeof options === "string") options = {
        encoding: options
      };
      else if (options === null || typeof options !== "object") throw new TypeError('"options" argument must be a string or an object');
      else options = Object.create(options);
      if (options.highWaterMark === void 0) options.highWaterMark = 64 * 1024;
      options.emitClose = false;
      options.autoDestroy = false;
      ReadableStream.call(this, options);
      this.path = path;
      this.flags = options.flags === void 0 ? "r" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.end = options.end;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = 0;
      this.bytesRead = 0;
      this.isClosed = false;
      this.handle = options.handle === void 0 ? null : options.handle;
      this.sftp = sftp;
      this._opening = false;
      if (this.start !== void 0) {
        checkPosition(this.start, "start");
        this.pos = this.start;
      }
      if (this.end === void 0) {
        this.end = Infinity;
      } else if (this.end !== Infinity) {
        checkPosition(this.end, "end");
        if (this.start !== void 0 && this.start > this.end) {
          throw new ERR_OUT_OF_RANGE("start", `<= "end" (here: ${this.end})`, this.start);
        }
      }
      this.on("end", function() {
        if (this.autoClose) this.destroy();
      });
      if (!Buffer.isBuffer(this.handle)) this.open();
    }
    __name(ReadStream, "ReadStream");
    inherits(ReadStream, ReadableStream);
    ReadStream.prototype.open = function() {
      if (this._opening) return;
      this._opening = true;
      this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        this._opening = false;
        if (er) {
          this.emit("error", er);
          if (this.autoClose) this.destroy();
          return;
        }
        this.handle = handle;
        this.emit("open", handle);
        this.emit("ready");
        this.read();
      });
    };
    ReadStream.prototype._read = function(n) {
      if (!Buffer.isBuffer(this.handle)) return this.once("open", () => this._read(n));
      if (this.destroyed) return;
      if (!pool || pool.length - pool.used < kMinPoolSpace) {
        allocNewPool(this.readableHighWaterMark || this._readableState.highWaterMark);
      }
      const thisPool = pool;
      let toRead = Math.min(pool.length - pool.used, n);
      const start = pool.used;
      if (this.end !== void 0) toRead = Math.min(this.end - this.pos + 1, toRead);
      if (toRead <= 0) return this.push(null);
      this.sftp.read(this.handle, pool, pool.used, toRead, this.pos, (er, bytesRead) => {
        if (er) {
          this.emit("error", er);
          if (this.autoClose) this.destroy();
          return;
        }
        let b = null;
        if (start + toRead === thisPool.used && thisPool === pool) {
          thisPool.used = roundUpToMultipleOf8(thisPool.used + bytesRead - toRead);
        } else {
          const alignedEnd = start + toRead & ~7;
          const alignedStart = roundUpToMultipleOf8(start + bytesRead);
          if (alignedEnd - alignedStart >= kMinPoolSpace) poolFragments.push(thisPool.slice(alignedStart, alignedEnd));
        }
        if (bytesRead > 0) {
          this.bytesRead += bytesRead;
          b = thisPool.slice(start, start + bytesRead);
        }
        this.pos += bytesRead;
        this.push(b);
      });
      pool.used = roundUpToMultipleOf8(pool.used + toRead);
    };
    ReadStream.prototype._destroy = function(err, cb) {
      if (this._opening && !Buffer.isBuffer(this.handle)) {
        this.once("open", closeStream.bind(null, this, cb, err));
        return;
      }
      closeStream(this, cb, err);
      this.handle = null;
      this._opening = false;
    };
    function closeStream(stream, cb, err) {
      if (!stream.handle) return onclose();
      stream.sftp.close(stream.handle, onclose);
      function onclose(er) {
        er = er || err;
        cb(er);
        stream.isClosed = true;
        if (!er) stream.emit("close");
      }
      __name(onclose, "onclose");
    }
    __name(closeStream, "closeStream");
    ReadStream.prototype.close = function(cb) {
      this.destroy(null, cb);
    };
    Object.defineProperty(ReadStream.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: true
    });
    function WriteStream(sftp, path, options) {
      if (options === void 0) options = {};
      else if (typeof options === "string") options = {
        encoding: options
      };
      else if (options === null || typeof options !== "object") throw new TypeError('"options" argument must be a string or an object');
      else options = Object.create(options);
      options.emitClose = false;
      options.autoDestroy = false;
      WritableStream.call(this, options);
      this.path = path;
      this.flags = options.flags === void 0 ? "w" : options.flags;
      this.mode = options.mode === void 0 ? 438 : options.mode;
      this.start = options.start;
      this.autoClose = options.autoClose === void 0 ? true : options.autoClose;
      this.pos = 0;
      this.bytesWritten = 0;
      this.isClosed = false;
      this.handle = options.handle === void 0 ? null : options.handle;
      this.sftp = sftp;
      this._opening = false;
      if (this.start !== void 0) {
        checkPosition(this.start, "start");
        this.pos = this.start;
      }
      if (options.encoding) this.setDefaultEncoding(options.encoding);
      this.on("finish", function() {
        if (this._writableState.finalCalled) return;
        if (this.autoClose) this.destroy();
      });
      if (!Buffer.isBuffer(this.handle)) this.open();
    }
    __name(WriteStream, "WriteStream");
    inherits(WriteStream, WritableStream);
    WriteStream.prototype._final = function(cb) {
      if (this.autoClose) this.destroy();
      cb();
    };
    WriteStream.prototype.open = function() {
      if (this._opening) return;
      this._opening = true;
      this.sftp.open(this.path, this.flags, this.mode, (er, handle) => {
        this._opening = false;
        if (er) {
          this.emit("error", er);
          if (this.autoClose) this.destroy();
          return;
        }
        this.handle = handle;
        const tryAgain = /* @__PURE__ */ __name((err) => {
          if (err) {
            this.sftp.chmod(this.path, this.mode, (err_) => tryAgain());
            return;
          }
          if (this.flags[0] === "a") {
            const tryStat = /* @__PURE__ */ __name((err2, st) => {
              if (err2) {
                this.sftp.stat(this.path, (err_, st_) => {
                  if (err_) {
                    this.destroy();
                    this.emit("error", err2);
                    return;
                  }
                  tryStat(null, st_);
                });
                return;
              }
              this.pos = st.size;
              this.emit("open", handle);
              this.emit("ready");
            }, "tryStat");
            this.sftp.fstat(handle, tryStat);
            return;
          }
          this.emit("open", handle);
          this.emit("ready");
        }, "tryAgain");
        this.sftp.fchmod(handle, this.mode, tryAgain);
      });
    };
    WriteStream.prototype._write = function(data, encoding, cb) {
      if (!Buffer.isBuffer(data)) {
        const err = new ERR_INVALID_ARG_TYPE("data", "Buffer", data);
        return this.emit("error", err);
      }
      if (!Buffer.isBuffer(this.handle)) {
        return this.once("open", function() {
          this._write(data, encoding, cb);
        });
      }
      this.sftp.write(this.handle, data, 0, data.length, this.pos, (er, bytes) => {
        if (er) {
          if (this.autoClose) this.destroy();
          return cb(er);
        }
        this.bytesWritten += bytes;
        cb();
      });
      this.pos += data.length;
    };
    WriteStream.prototype._writev = function(data, cb) {
      if (!Buffer.isBuffer(this.handle)) {
        return this.once("open", function() {
          this._writev(data, cb);
        });
      }
      const sftp = this.sftp;
      const handle = this.handle;
      let writesLeft = data.length;
      const onwrite = /* @__PURE__ */ __name((er, bytes) => {
        if (er) {
          this.destroy();
          return cb(er);
        }
        this.bytesWritten += bytes;
        if (--writesLeft === 0) cb();
      }, "onwrite");
      for (let i = 0; i < data.length; ++i) {
        const chunk = data[i].chunk;
        sftp.write(handle, chunk, 0, chunk.length, this.pos, onwrite);
        this.pos += chunk.length;
      }
    };
    if (typeof WritableStream.prototype.destroy !== "function") WriteStream.prototype.destroy = ReadStream.prototype.destroy;
    WriteStream.prototype._destroy = ReadStream.prototype._destroy;
    WriteStream.prototype.close = function(cb) {
      if (cb) {
        if (this.isClosed) {
          process.nextTick(cb);
          return;
        }
        this.on("close", cb);
      }
      if (!this.autoClose) this.on("finish", this.destroy.bind(this));
      this.end();
    };
    WriteStream.prototype.destroySoon = WriteStream.prototype.end;
    Object.defineProperty(WriteStream.prototype, "pending", {
      get() {
        return this.handle === null;
      },
      configurable: true
    });
    module2.exports = {
      flagsToString,
      OPEN_MODE,
      SFTP,
      Stats,
      STATUS_CODE,
      stringToFlags
    };
  }
});

// node_modules/ssh2/lib/Channel.js
var require_Channel = __commonJS({
  "node_modules/ssh2/lib/Channel.js"(exports2, module2) {
    "use strict";
    var { Duplex: DuplexStream, Readable: ReadableStream, Writable: WritableStream } = require("stream");
    var { CHANNEL_EXTENDED_DATATYPE: { STDERR } } = require_constants2();
    var { bufferSlice } = require_utils2();
    var PACKET_SIZE = 32 * 1024;
    var MAX_WINDOW = 2 * 1024 * 1024;
    var WINDOW_THRESHOLD = MAX_WINDOW / 2;
    var ClientStderr = class ClientStderr extends ReadableStream {
      static {
        __name(this, "ClientStderr");
      }
      constructor(channel, streamOpts) {
        super(streamOpts);
        this._channel = channel;
      }
      _read(n) {
        if (this._channel._waitChanDrain) {
          this._channel._waitChanDrain = false;
          if (this._channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(this._channel);
        }
      }
    };
    var ServerStderr = class ServerStderr extends WritableStream {
      static {
        __name(this, "ServerStderr");
      }
      constructor(channel) {
        super({
          highWaterMark: MAX_WINDOW
        });
        this._channel = channel;
      }
      _write(data, encoding, cb) {
        const channel = this._channel;
        const protocol4 = channel._client._protocol;
        const outgoing = channel.outgoing;
        const packetSize = outgoing.packetSize;
        const id = outgoing.id;
        let window2 = outgoing.window;
        const len = data.length;
        let p = 0;
        if (outgoing.state !== "open") return;
        while (len - p > 0 && window2 > 0) {
          let sliceLen = len - p;
          if (sliceLen > window2) sliceLen = window2;
          if (sliceLen > packetSize) sliceLen = packetSize;
          if (p === 0 && sliceLen === len) protocol4.channelExtData(id, data, STDERR);
          else protocol4.channelExtData(id, bufferSlice(data, p, p + sliceLen), STDERR);
          p += sliceLen;
          window2 -= sliceLen;
        }
        outgoing.window = window2;
        if (len - p > 0) {
          if (window2 === 0) channel._waitWindow = true;
          if (p > 0) channel._chunkErr = bufferSlice(data, p, len);
          else channel._chunkErr = data;
          channel._chunkcbErr = cb;
          return;
        }
        cb();
      }
    };
    var Channel = class Channel extends DuplexStream {
      static {
        __name(this, "Channel");
      }
      constructor(client2, info, opts) {
        const streamOpts = {
          highWaterMark: MAX_WINDOW,
          allowHalfOpen: !opts || opts && opts.allowHalfOpen !== false,
          emitClose: false
        };
        super(streamOpts);
        this.allowHalfOpen = streamOpts.allowHalfOpen;
        const server = !!(opts && opts.server);
        this.server = server;
        this.type = info.type;
        this.subtype = void 0;
        this.incoming = info.incoming;
        this.outgoing = info.outgoing;
        this._callbacks = [];
        this._client = client2;
        this._hasX11 = false;
        this._exit = {
          code: void 0,
          signal: void 0,
          dump: void 0,
          desc: void 0
        };
        this.stdin = this.stdout = this;
        if (server) this.stderr = new ServerStderr(this);
        else this.stderr = new ClientStderr(this, streamOpts);
        this._waitWindow = false;
        this._waitChanDrain = false;
        this._chunk = void 0;
        this._chunkcb = void 0;
        this._chunkErr = void 0;
        this._chunkcbErr = void 0;
        this.on("finish", onFinish).on("prefinish", onFinish);
        this.on("end", onEnd).on("close", onEnd);
      }
      _read(n) {
        if (this._waitChanDrain) {
          this._waitChanDrain = false;
          if (this.incoming.window <= WINDOW_THRESHOLD) windowAdjust(this);
        }
      }
      _write(data, encoding, cb) {
        const protocol4 = this._client._protocol;
        const outgoing = this.outgoing;
        const packetSize = outgoing.packetSize;
        const id = outgoing.id;
        let window2 = outgoing.window;
        const len = data.length;
        let p = 0;
        if (outgoing.state !== "open") return;
        while (len - p > 0 && window2 > 0) {
          let sliceLen = len - p;
          if (sliceLen > window2) sliceLen = window2;
          if (sliceLen > packetSize) sliceLen = packetSize;
          if (p === 0 && sliceLen === len) protocol4.channelData(id, data);
          else protocol4.channelData(id, bufferSlice(data, p, p + sliceLen));
          p += sliceLen;
          window2 -= sliceLen;
        }
        outgoing.window = window2;
        if (len - p > 0) {
          if (window2 === 0) this._waitWindow = true;
          if (p > 0) this._chunk = bufferSlice(data, p, len);
          else this._chunk = data;
          this._chunkcb = cb;
          return;
        }
        cb();
      }
      eof() {
        if (this.outgoing.state === "open") {
          this.outgoing.state = "eof";
          this._client._protocol.channelEOF(this.outgoing.id);
        }
      }
      close() {
        if (this.outgoing.state === "open" || this.outgoing.state === "eof") {
          this.outgoing.state = "closing";
          this._client._protocol.channelClose(this.outgoing.id);
        }
      }
      destroy() {
        this.end();
        this.close();
        return this;
      }
      // Session type-specific methods =============================================
      setWindow(rows, cols, height, width) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (this.type === "session" && (this.subtype === "shell" || this.subtype === "exec") && this.writable && this.outgoing.state === "open") {
          this._client._protocol.windowChange(this.outgoing.id, rows, cols, height, width);
        }
      }
      signal(signalName) {
        if (this.server) throw new Error("Client-only method called in server mode");
        if (this.type === "session" && this.writable && this.outgoing.state === "open") {
          this._client._protocol.signal(this.outgoing.id, signalName);
        }
      }
      exit(statusOrSignal, coreDumped, msg) {
        if (!this.server) throw new Error("Server-only method called in client mode");
        if (this.type === "session" && this.writable && this.outgoing.state === "open") {
          if (typeof statusOrSignal === "number") {
            this._client._protocol.exitStatus(this.outgoing.id, statusOrSignal);
          } else {
            this._client._protocol.exitSignal(this.outgoing.id, statusOrSignal, coreDumped, msg);
          }
        }
      }
    };
    function onFinish() {
      this.eof();
      if (this.server || !this.allowHalfOpen) this.close();
      this.writable = false;
    }
    __name(onFinish, "onFinish");
    function onEnd() {
      this.readable = false;
    }
    __name(onEnd, "onEnd");
    function windowAdjust(self2) {
      if (self2.outgoing.state === "closed") return;
      const amt = MAX_WINDOW - self2.incoming.window;
      if (amt <= 0) return;
      self2.incoming.window += amt;
      self2._client._protocol.channelWindowAdjust(self2.outgoing.id, amt);
    }
    __name(windowAdjust, "windowAdjust");
    module2.exports = {
      Channel,
      MAX_WINDOW,
      PACKET_SIZE,
      windowAdjust,
      WINDOW_THRESHOLD
    };
  }
});

// node_modules/ssh2/lib/utils.js
var require_utils3 = __commonJS({
  "node_modules/ssh2/lib/utils.js"(exports2, module2) {
    "use strict";
    var { SFTP } = require_SFTP();
    var MAX_CHANNEL = 2 ** 32 - 1;
    function onChannelOpenFailure(self2, recipient, info, cb) {
      self2._chanMgr.remove(recipient);
      if (typeof cb !== "function") return;
      let err;
      if (info instanceof Error) {
        err = info;
      } else if (typeof info === "object" && info !== null) {
        err = new Error(`(SSH) Channel open failure: ${info.description}`);
        err.reason = info.reason;
      } else {
        err = new Error("(SSH) Channel open failure: server closed channel unexpectedly");
        err.reason = "";
      }
      cb(err);
    }
    __name(onChannelOpenFailure, "onChannelOpenFailure");
    function onCHANNEL_CLOSE(self2, recipient, channel, err, dead) {
      if (typeof channel === "function") {
        onChannelOpenFailure(self2, recipient, err, channel);
        return;
      }
      if (typeof channel !== "object" || channel === null) return;
      if (channel.incoming && channel.incoming.state === "closed") return;
      self2._chanMgr.remove(recipient);
      if (channel.server && channel.constructor.name === "Session") return;
      channel.incoming.state = "closed";
      if (channel.readable) channel.push(null);
      if (channel.server) {
        if (channel.stderr.writable) channel.stderr.end();
      } else if (channel.stderr.readable) {
        channel.stderr.push(null);
      }
      if (channel.constructor !== SFTP && (channel.outgoing.state === "open" || channel.outgoing.state === "eof") && !dead) {
        channel.close();
      }
      if (channel.outgoing.state === "closing") channel.outgoing.state = "closed";
      const readState = channel._readableState;
      const writeState = channel._writableState;
      if (writeState && !writeState.ending && !writeState.finished && !dead) channel.end();
      const chanCallbacks = channel._callbacks;
      channel._callbacks = [];
      for (let i = 0; i < chanCallbacks.length; ++i) chanCallbacks[i](true);
      if (channel.server) {
        if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {
          channel.emit("close");
        } else {
          channel.once("end", () => channel.emit("close"));
        }
      } else {
        let doClose;
        switch (channel.type) {
          case "direct-streamlocal@openssh.com":
          case "direct-tcpip":
            doClose = /* @__PURE__ */ __name(() => channel.emit("close"), "doClose");
            break;
          default: {
            const exit = channel._exit;
            doClose = /* @__PURE__ */ __name(() => {
              if (exit.code === null) channel.emit("close", exit.code, exit.signal, exit.dump, exit.desc);
              else channel.emit("close", exit.code);
            }, "doClose");
          }
        }
        if (!channel.readable || channel.destroyed || readState && readState.endEmitted) {
          doClose();
        } else {
          channel.once("end", doClose);
        }
        const errReadState = channel.stderr._readableState;
        if (!channel.stderr.readable || channel.stderr.destroyed || errReadState && errReadState.endEmitted) {
          channel.stderr.emit("close");
        } else {
          channel.stderr.once("end", () => channel.stderr.emit("close"));
        }
      }
    }
    __name(onCHANNEL_CLOSE, "onCHANNEL_CLOSE");
    var ChannelManager = class ChannelManager {
      static {
        __name(this, "ChannelManager");
      }
      constructor(client2) {
        this._client = client2;
        this._channels = {};
        this._cur = -1;
        this._count = 0;
      }
      add(val) {
        let id;
        if (this._cur < MAX_CHANNEL) {
          id = ++this._cur;
        } else if (this._count === 0) {
          this._cur = 0;
          id = 0;
        } else {
          const channels = this._channels;
          for (let i = 0; i < MAX_CHANNEL; ++i) {
            if (channels[i] === void 0) {
              id = i;
              break;
            }
          }
        }
        if (id === void 0) return -1;
        this._channels[id] = val || true;
        ++this._count;
        return id;
      }
      update(id, val) {
        if (typeof id !== "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);
        if (val && this._channels[id]) this._channels[id] = val;
      }
      get(id) {
        if (typeof id !== "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);
        return this._channels[id];
      }
      remove(id) {
        if (typeof id !== "number" || id < 0 || id >= MAX_CHANNEL || !isFinite(id)) throw new Error(`Invalid channel id: ${id}`);
        if (this._channels[id]) {
          delete this._channels[id];
          if (this._count) --this._count;
        }
      }
      cleanup(err) {
        const channels = this._channels;
        this._channels = {};
        this._cur = -1;
        this._count = 0;
        const chanIDs = Object.keys(channels);
        const client2 = this._client;
        for (let i = 0; i < chanIDs.length; ++i) {
          const id = +chanIDs[i];
          const channel = channels[id];
          onCHANNEL_CLOSE(client2, id, channel._channel || channel, err, true);
        }
      }
    };
    var isRegExp = /* @__PURE__ */ (() => {
      const toString2 = Object.prototype.toString;
      return (val) => toString2.call(val) === "[object RegExp]";
    })();
    function generateAlgorithmList(algoList, defaultList, supportedList) {
      if (Array.isArray(algoList) && algoList.length > 0) {
        for (let i = 0; i < algoList.length; ++i) {
          if (supportedList.indexOf(algoList[i]) === -1) throw new Error(`Unsupported algorithm: ${algoList[i]}`);
        }
        return algoList;
      }
      if (typeof algoList === "object" && algoList !== null) {
        const keys = Object.keys(algoList);
        let list = defaultList;
        for (let i = 0; i < keys.length; ++i) {
          const key = keys[i];
          let val = algoList[key];
          switch (key) {
            case "append":
              if (!Array.isArray(val)) val = [
                val
              ];
              if (Array.isArray(val)) {
                for (let j = 0; j < val.length; ++j) {
                  const append = val[j];
                  if (typeof append === "string") {
                    if (!append || list.indexOf(append) !== -1) continue;
                    if (supportedList.indexOf(append) === -1) throw new Error(`Unsupported algorithm: ${append}`);
                    if (list === defaultList) list = list.slice();
                    list.push(append);
                  } else if (isRegExp(append)) {
                    for (let k = 0; k < supportedList.length; ++k) {
                      const algo = supportedList[k];
                      if (append.test(algo)) {
                        if (list.indexOf(algo) !== -1) continue;
                        if (list === defaultList) list = list.slice();
                        list.push(algo);
                      }
                    }
                  }
                }
              }
              break;
            case "prepend":
              if (!Array.isArray(val)) val = [
                val
              ];
              if (Array.isArray(val)) {
                for (let j = val.length; j >= 0; --j) {
                  const prepend = val[j];
                  if (typeof prepend === "string") {
                    if (!prepend || list.indexOf(prepend) !== -1) continue;
                    if (supportedList.indexOf(prepend) === -1) throw new Error(`Unsupported algorithm: ${prepend}`);
                    if (list === defaultList) list = list.slice();
                    list.unshift(prepend);
                  } else if (isRegExp(prepend)) {
                    for (let k = supportedList.length; k >= 0; --k) {
                      const algo = supportedList[k];
                      if (prepend.test(algo)) {
                        if (list.indexOf(algo) !== -1) continue;
                        if (list === defaultList) list = list.slice();
                        list.unshift(algo);
                      }
                    }
                  }
                }
              }
              break;
            case "remove":
              if (!Array.isArray(val)) val = [
                val
              ];
              if (Array.isArray(val)) {
                for (let j = 0; j < val.length; ++j) {
                  const search = val[j];
                  if (typeof search === "string") {
                    if (!search) continue;
                    const idx = list.indexOf(search);
                    if (idx === -1) continue;
                    if (list === defaultList) list = list.slice();
                    list.splice(idx, 1);
                  } else if (isRegExp(search)) {
                    for (let k = 0; k < list.length; ++k) {
                      if (search.test(list[k])) {
                        if (list === defaultList) list = list.slice();
                        list.splice(k, 1);
                        --k;
                      }
                    }
                  }
                }
              }
              break;
          }
        }
        return list;
      }
      return defaultList;
    }
    __name(generateAlgorithmList, "generateAlgorithmList");
    module2.exports = {
      ChannelManager,
      generateAlgorithmList,
      onChannelOpenFailure,
      onCHANNEL_CLOSE,
      isWritable: /* @__PURE__ */ __name((stream) => {
        return stream && stream.writable && stream._readableState && stream._readableState.ended === false;
      }, "isWritable")
    };
  }
});

// node_modules/ssh2/lib/client.js
var require_client = __commonJS({
  "node_modules/ssh2/lib/client.js"(exports2, module2) {
    "use strict";
    var { createHash, getHashes, randomFillSync } = require("crypto");
    var { Socket: Socket3 } = require("net");
    var { lookup: dnsLookup } = require("dns");
    var EventEmitter = require("events");
    var HASHES = getHashes();
    var { COMPAT, CHANNEL_EXTENDED_DATATYPE: { STDERR }, CHANNEL_OPEN_FAILURE, DEFAULT_CIPHER, DEFAULT_COMPRESSION, DEFAULT_KEX, DEFAULT_MAC, DEFAULT_SERVER_HOST_KEY, DISCONNECT_REASON, DISCONNECT_REASON_BY_VALUE, SUPPORTED_CIPHER, SUPPORTED_COMPRESSION, SUPPORTED_KEX, SUPPORTED_MAC, SUPPORTED_SERVER_HOST_KEY } = require_constants2();
    var { init: cryptoInit } = require_crypto();
    var Protocol = require_Protocol();
    var { parseKey } = require_keyParser();
    var { SFTP } = require_SFTP();
    var { bufferCopy, makeBufferParser, makeError, readUInt32BE, sigSSHToASN1, writeUInt32BE } = require_utils2();
    var { AgentContext, createAgent, isAgent } = require_agent();
    var { Channel, MAX_WINDOW, PACKET_SIZE, windowAdjust, WINDOW_THRESHOLD } = require_Channel();
    var { ChannelManager, generateAlgorithmList, isWritable, onChannelOpenFailure, onCHANNEL_CLOSE } = require_utils3();
    var bufferParser = makeBufferParser();
    var sigParser = makeBufferParser();
    var RE_OPENSSH = /^OpenSSH_(?:(?![0-4])\d)|(?:\d{2,})/;
    var noop = /* @__PURE__ */ __name((err) => {
    }, "noop");
    var Client = class Client extends EventEmitter {
      static {
        __name(this, "Client");
      }
      constructor() {
        super();
        this.config = {
          host: void 0,
          port: void 0,
          localAddress: void 0,
          localPort: void 0,
          forceIPv4: void 0,
          forceIPv6: void 0,
          keepaliveCountMax: void 0,
          keepaliveInterval: void 0,
          readyTimeout: void 0,
          ident: void 0,
          username: void 0,
          password: void 0,
          privateKey: void 0,
          tryKeyboard: void 0,
          agent: void 0,
          allowAgentFwd: void 0,
          authHandler: void 0,
          hostHashAlgo: void 0,
          hostHashCb: void 0,
          strictVendor: void 0,
          debug: void 0
        };
        this._agent = void 0;
        this._readyTimeout = void 0;
        this._chanMgr = void 0;
        this._callbacks = void 0;
        this._forwarding = void 0;
        this._forwardingUnix = void 0;
        this._acceptX11 = void 0;
        this._agentFwdEnabled = void 0;
        this._remoteVer = void 0;
        this._protocol = void 0;
        this._sock = void 0;
        this._resetKA = void 0;
      }
      connect(cfg) {
        if (this._sock && isWritable(this._sock)) {
          this.once("close", () => {
            this.connect(cfg);
          });
          this.end();
          return this;
        }
        this.config.host = cfg.hostname || cfg.host || "localhost";
        this.config.port = cfg.port || 22;
        this.config.localAddress = typeof cfg.localAddress === "string" ? cfg.localAddress : void 0;
        this.config.localPort = typeof cfg.localPort === "string" || typeof cfg.localPort === "number" ? cfg.localPort : void 0;
        this.config.forceIPv4 = cfg.forceIPv4 || false;
        this.config.forceIPv6 = cfg.forceIPv6 || false;
        this.config.keepaliveCountMax = typeof cfg.keepaliveCountMax === "number" && cfg.keepaliveCountMax >= 0 ? cfg.keepaliveCountMax : 3;
        this.config.keepaliveInterval = typeof cfg.keepaliveInterval === "number" && cfg.keepaliveInterval > 0 ? cfg.keepaliveInterval : 0;
        this.config.readyTimeout = typeof cfg.readyTimeout === "number" && cfg.readyTimeout >= 0 ? cfg.readyTimeout : 2e4;
        this.config.ident = typeof cfg.ident === "string" || Buffer.isBuffer(cfg.ident) ? cfg.ident : void 0;
        const algorithms = {
          kex: void 0,
          serverHostKey: void 0,
          cs: {
            cipher: void 0,
            mac: void 0,
            compress: void 0,
            lang: []
          },
          sc: void 0
        };
        let allOfferDefaults = true;
        if (typeof cfg.algorithms === "object" && cfg.algorithms !== null) {
          algorithms.kex = generateAlgorithmList(cfg.algorithms.kex, DEFAULT_KEX, SUPPORTED_KEX);
          if (algorithms.kex !== DEFAULT_KEX) allOfferDefaults = false;
          algorithms.serverHostKey = generateAlgorithmList(cfg.algorithms.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);
          if (algorithms.serverHostKey !== DEFAULT_SERVER_HOST_KEY) allOfferDefaults = false;
          algorithms.cs.cipher = generateAlgorithmList(cfg.algorithms.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER);
          if (algorithms.cs.cipher !== DEFAULT_CIPHER) allOfferDefaults = false;
          algorithms.cs.mac = generateAlgorithmList(cfg.algorithms.hmac, DEFAULT_MAC, SUPPORTED_MAC);
          if (algorithms.cs.mac !== DEFAULT_MAC) allOfferDefaults = false;
          algorithms.cs.compress = generateAlgorithmList(cfg.algorithms.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION);
          if (algorithms.cs.compress !== DEFAULT_COMPRESSION) allOfferDefaults = false;
          if (!allOfferDefaults) algorithms.sc = algorithms.cs;
        }
        if (typeof cfg.username === "string") this.config.username = cfg.username;
        else if (typeof cfg.user === "string") this.config.username = cfg.user;
        else throw new Error("Invalid username");
        this.config.password = typeof cfg.password === "string" ? cfg.password : void 0;
        this.config.privateKey = typeof cfg.privateKey === "string" || Buffer.isBuffer(cfg.privateKey) ? cfg.privateKey : void 0;
        this.config.localHostname = typeof cfg.localHostname === "string" ? cfg.localHostname : void 0;
        this.config.localUsername = typeof cfg.localUsername === "string" ? cfg.localUsername : void 0;
        this.config.tryKeyboard = cfg.tryKeyboard === true;
        if (typeof cfg.agent === "string" && cfg.agent.length) this.config.agent = createAgent(cfg.agent);
        else if (isAgent(cfg.agent)) this.config.agent = cfg.agent;
        else this.config.agent = void 0;
        this.config.allowAgentFwd = cfg.agentForward === true && this.config.agent !== void 0;
        let authHandler = this.config.authHandler = typeof cfg.authHandler === "function" || Array.isArray(cfg.authHandler) ? cfg.authHandler : void 0;
        this.config.strictVendor = typeof cfg.strictVendor === "boolean" ? cfg.strictVendor : true;
        const debug12 = this.config.debug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        if (cfg.agentForward === true && !this.config.allowAgentFwd) {
          throw new Error("You must set a valid agent path to allow agent forwarding");
        }
        let callbacks = this._callbacks = [];
        this._chanMgr = new ChannelManager(this);
        this._forwarding = {};
        this._forwardingUnix = {};
        this._acceptX11 = 0;
        this._agentFwdEnabled = false;
        this._agent = this.config.agent ? this.config.agent : void 0;
        this._remoteVer = void 0;
        let privateKey;
        if (this.config.privateKey) {
          privateKey = parseKey(this.config.privateKey, cfg.passphrase);
          if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey)) {
            privateKey = privateKey[0];
          }
          if (privateKey.getPrivatePEM() === null) {
            throw new Error("privateKey value does not contain a (valid) private key");
          }
        }
        let hostVerifier;
        if (typeof cfg.hostVerifier === "function") {
          const hashCb = cfg.hostVerifier;
          let hashAlgo;
          if (HASHES.indexOf(cfg.hostHash) !== -1) {
            hashAlgo = cfg.hostHash;
          }
          hostVerifier = /* @__PURE__ */ __name((key, verify) => {
            if (hashAlgo) key = createHash(hashAlgo).update(key).digest("hex");
            const ret = hashCb(key, verify);
            if (ret !== void 0) verify(ret);
          }, "hostVerifier");
        }
        const sock = this._sock = cfg.sock || new Socket3();
        let ready = false;
        let sawHeader = false;
        if (this._protocol) this._protocol.cleanup();
        const DEBUG_HANDLER = !debug12 ? void 0 : (p, display, msg) => {
          debug12(`Debug output from server: ${JSON.stringify(msg)}`);
        };
        let serverSigAlgs;
        const proto = this._protocol = new Protocol({
          ident: this.config.ident,
          offer: allOfferDefaults ? void 0 : algorithms,
          onWrite: /* @__PURE__ */ __name((data) => {
            if (isWritable(sock)) sock.write(data);
          }, "onWrite"),
          onError: /* @__PURE__ */ __name((err) => {
            if (err.level === "handshake") clearTimeout(this._readyTimeout);
            if (!proto._destruct) sock.removeAllListeners("data");
            this.emit("error", err);
            try {
              sock.end();
            } catch {
            }
          }, "onError"),
          onHeader: /* @__PURE__ */ __name((header) => {
            sawHeader = true;
            this._remoteVer = header.versions.software;
            if (header.greeting) this.emit("greeting", header.greeting);
          }, "onHeader"),
          onHandshakeComplete: /* @__PURE__ */ __name((negotiated) => {
            this.emit("handshake", negotiated);
            if (!ready) {
              ready = true;
              proto.service("ssh-userauth");
            }
          }, "onHandshakeComplete"),
          debug: debug12,
          hostVerifier,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: /* @__PURE__ */ __name((p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                if (!desc) {
                  desc = DISCONNECT_REASON_BY_VALUE[reason];
                  if (desc === void 0) desc = `Unexpected disconnection reason: ${reason}`;
                }
                const err = new Error(desc);
                err.code = reason;
                this.emit("error", err);
              }
              sock.end();
            }, "DISCONNECT"),
            SERVICE_ACCEPT: /* @__PURE__ */ __name((p, name) => {
              if (name === "ssh-userauth") tryNextAuth();
            }, "SERVICE_ACCEPT"),
            EXT_INFO: /* @__PURE__ */ __name((p, exts) => {
              if (serverSigAlgs === void 0) {
                for (const ext of exts) {
                  if (ext.name === "server-sig-algs") {
                    serverSigAlgs = ext.algs;
                    return;
                  }
                }
                serverSigAlgs = null;
              }
            }, "EXT_INFO"),
            USERAUTH_BANNER: /* @__PURE__ */ __name((p, msg) => {
              this.emit("banner", msg);
            }, "USERAUTH_BANNER"),
            USERAUTH_SUCCESS: /* @__PURE__ */ __name((p) => {
              resetKA();
              clearTimeout(this._readyTimeout);
              this.emit("ready");
            }, "USERAUTH_SUCCESS"),
            USERAUTH_FAILURE: /* @__PURE__ */ __name((p, authMethods, partialSuccess) => {
              if (curAuth.keyAlgos) {
                const oldKeyAlgo = curAuth.keyAlgos[0][0];
                if (debug12) debug12(`Client: ${curAuth.type} (${oldKeyAlgo}) auth failed`);
                curAuth.keyAlgos.shift();
                if (curAuth.keyAlgos.length) {
                  const [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  switch (curAuth.type) {
                    case "agent":
                      proto.authPK(curAuth.username, curAuth.agentCtx.currentKey(), keyAlgo);
                      return;
                    case "publickey":
                      proto.authPK(curAuth.username, curAuth.key, keyAlgo);
                      return;
                    case "hostbased":
                      proto.authHostbased(curAuth.username, curAuth.key, curAuth.localHostname, curAuth.localUsername, keyAlgo, (buf, cb) => {
                        const signature = curAuth.key.sign(buf, hashAlgo);
                        if (signature instanceof Error) {
                          signature.message = `Error while signing with key: ${signature.message}`;
                          signature.level = "client-authentication";
                          this.emit("error", signature);
                          return tryNextAuth();
                        }
                        cb(signature);
                      });
                      return;
                  }
                } else {
                  curAuth.keyAlgos = void 0;
                }
              }
              if (curAuth.type === "agent") {
                const pos = curAuth.agentCtx.pos();
                debug12 && debug12(`Client: Agent key #${pos + 1} failed`);
                return tryNextAgentKey();
              }
              debug12 && debug12(`Client: ${curAuth.type} auth failed`);
              curPartial = partialSuccess;
              curAuthsLeft = authMethods;
              tryNextAuth();
            }, "USERAUTH_FAILURE"),
            USERAUTH_PASSWD_CHANGEREQ: /* @__PURE__ */ __name((p, prompt) => {
              if (curAuth.type === "password") {
                this.emit("change password", prompt, (newPassword) => {
                  proto.authPassword(this.config.username, this.config.password, newPassword);
                });
              }
            }, "USERAUTH_PASSWD_CHANGEREQ"),
            USERAUTH_PK_OK: /* @__PURE__ */ __name((p) => {
              let keyAlgo;
              let hashAlgo;
              if (curAuth.keyAlgos) [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
              if (curAuth.type === "agent") {
                const key = curAuth.agentCtx.currentKey();
                proto.authPK(curAuth.username, key, keyAlgo, (buf, cb) => {
                  const opts = {
                    hash: hashAlgo
                  };
                  curAuth.agentCtx.sign(key, buf, opts, (err, signed) => {
                    if (err) {
                      err.level = "agent";
                      this.emit("error", err);
                    } else {
                      return cb(signed);
                    }
                    tryNextAgentKey();
                  });
                });
              } else if (curAuth.type === "publickey") {
                proto.authPK(curAuth.username, curAuth.key, keyAlgo, (buf, cb) => {
                  const signature = curAuth.key.sign(buf, hashAlgo);
                  if (signature instanceof Error) {
                    signature.message = `Error signing data with key: ${signature.message}`;
                    signature.level = "client-authentication";
                    this.emit("error", signature);
                    return tryNextAuth();
                  }
                  cb(signature);
                });
              }
            }, "USERAUTH_PK_OK"),
            USERAUTH_INFO_REQUEST: /* @__PURE__ */ __name((p, name, instructions, prompts) => {
              if (curAuth.type === "keyboard-interactive") {
                const nprompts = Array.isArray(prompts) ? prompts.length : 0;
                if (nprompts === 0) {
                  debug12 && debug12("Client: Sending automatic USERAUTH_INFO_RESPONSE");
                  proto.authInfoRes();
                  return;
                }
                curAuth.prompt(name, instructions, "", prompts, (answers) => {
                  proto.authInfoRes(answers);
                });
              }
            }, "USERAUTH_INFO_REQUEST"),
            REQUEST_SUCCESS: /* @__PURE__ */ __name((p, data) => {
              if (callbacks.length) callbacks.shift()(false, data);
            }, "REQUEST_SUCCESS"),
            REQUEST_FAILURE: /* @__PURE__ */ __name((p) => {
              if (callbacks.length) callbacks.shift()(true);
            }, "REQUEST_FAILURE"),
            GLOBAL_REQUEST: /* @__PURE__ */ __name((p, name, wantReply, data) => {
              switch (name) {
                case "hostkeys-00@openssh.com":
                  hostKeysProve(this, data, (err, keys) => {
                    if (err) return;
                    this.emit("hostkeys", keys);
                  });
                  if (wantReply) proto.requestSuccess();
                  break;
                default:
                  if (wantReply) proto.requestFailure();
              }
            }, "GLOBAL_REQUEST"),
            CHANNEL_OPEN: /* @__PURE__ */ __name((p, info) => {
              onCHANNEL_OPEN(this, info);
            }, "CHANNEL_OPEN"),
            CHANNEL_OPEN_CONFIRMATION: /* @__PURE__ */ __name((p, info) => {
              const channel = this._chanMgr.get(info.recipient);
              if (typeof channel !== "function") return;
              const isSFTP = channel.type === "sftp";
              const type = isSFTP ? "session" : channel.type;
              const chanInfo = {
                type,
                incoming: {
                  id: info.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info.sender,
                  window: info.window,
                  packetSize: info.packetSize,
                  state: "open"
                }
              };
              const instance = isSFTP ? new SFTP(this, chanInfo, {
                debug: debug12
              }) : new Channel(this, chanInfo);
              this._chanMgr.update(info.recipient, instance);
              channel(void 0, instance);
            }, "CHANNEL_OPEN_CONFIRMATION"),
            CHANNEL_OPEN_FAILURE: /* @__PURE__ */ __name((p, recipient, reason, description) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "function") return;
              const info = {
                reason,
                description
              };
              onChannelOpenFailure(this, recipient, info, channel);
            }, "CHANNEL_OPEN_FAILURE"),
            CHANNEL_DATA: /* @__PURE__ */ __name((p, recipient, data) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.incoming.window === 0) return;
              channel.incoming.window -= data.length;
              if (channel.push(data) === false) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);
            }, "CHANNEL_DATA"),
            CHANNEL_EXTENDED_DATA: /* @__PURE__ */ __name((p, recipient, data, type) => {
              if (type !== STDERR) return;
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.incoming.window === 0) return;
              channel.incoming.window -= data.length;
              if (!channel.stderr.push(data)) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);
            }, "CHANNEL_EXTENDED_DATA"),
            CHANNEL_WINDOW_ADJUST: /* @__PURE__ */ __name((p, recipient, amount) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              channel.outgoing.window += amount;
              if (channel._waitWindow) {
                channel._waitWindow = false;
                if (channel._chunk) {
                  channel._write(channel._chunk, null, channel._chunkcb);
                } else if (channel._chunkcb) {
                  channel._chunkcb();
                } else if (channel._chunkErr) {
                  channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);
                } else if (channel._chunkcbErr) {
                  channel._chunkcbErr();
                }
              }
            }, "CHANNEL_WINDOW_ADJUST"),
            CHANNEL_SUCCESS: /* @__PURE__ */ __name((p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              this._resetKA();
              if (channel._callbacks.length) channel._callbacks.shift()(false);
            }, "CHANNEL_SUCCESS"),
            CHANNEL_FAILURE: /* @__PURE__ */ __name((p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              this._resetKA();
              if (channel._callbacks.length) channel._callbacks.shift()(true);
            }, "CHANNEL_FAILURE"),
            CHANNEL_REQUEST: /* @__PURE__ */ __name((p, recipient, type, wantReply, data) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              const exit = channel._exit;
              if (exit.code !== void 0) return;
              switch (type) {
                case "exit-status":
                  channel.emit("exit", exit.code = data);
                  return;
                case "exit-signal":
                  channel.emit("exit", exit.code = null, exit.signal = `SIG${data.signal}`, exit.dump = data.coreDumped, exit.desc = data.errorMessage);
                  return;
              }
              if (wantReply) p.channelFailure(channel.outgoing.id);
            }, "CHANNEL_REQUEST"),
            CHANNEL_EOF: /* @__PURE__ */ __name((p, recipient) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.incoming.state !== "open") return;
              channel.incoming.state = "eof";
              if (channel.readable) channel.push(null);
              if (channel.stderr.readable) channel.stderr.push(null);
            }, "CHANNEL_EOF"),
            CHANNEL_CLOSE: /* @__PURE__ */ __name((p, recipient) => {
              onCHANNEL_CLOSE(this, recipient, this._chanMgr.get(recipient));
            }, "CHANNEL_CLOSE")
          }
        });
        sock.pause();
        const kainterval = this.config.keepaliveInterval;
        const kacountmax = this.config.keepaliveCountMax;
        let kacount = 0;
        let katimer;
        const sendKA = /* @__PURE__ */ __name(() => {
          if (++kacount > kacountmax) {
            clearInterval(katimer);
            if (sock.readable) {
              const err = new Error("Keepalive timeout");
              err.level = "client-timeout";
              this.emit("error", err);
              sock.destroy();
            }
            return;
          }
          if (isWritable(sock)) {
            callbacks.push(resetKA);
            proto.ping();
          } else {
            clearInterval(katimer);
          }
        }, "sendKA");
        function resetKA() {
          if (kainterval > 0) {
            kacount = 0;
            clearInterval(katimer);
            if (isWritable(sock)) katimer = setInterval(sendKA, kainterval);
          }
        }
        __name(resetKA, "resetKA");
        this._resetKA = resetKA;
        const onDone = /* @__PURE__ */ (() => {
          let called = false;
          return () => {
            if (called) return;
            called = true;
            if (wasConnected && !sawHeader) {
              const err = makeError("Connection lost before handshake", "protocol", true);
              this.emit("error", err);
            }
          };
        })();
        const onConnect = /* @__PURE__ */ (() => {
          let called = false;
          return () => {
            if (called) return;
            called = true;
            wasConnected = true;
            debug12 && debug12("Socket connected");
            this.emit("connect");
            cryptoInit.then(() => {
              proto.start();
              sock.on("data", (data) => {
                try {
                  proto.parse(data, 0, data.length);
                } catch (ex) {
                  this.emit("error", ex);
                  try {
                    if (isWritable(sock)) sock.end();
                  } catch {
                  }
                }
              });
              if (sock.stderr && typeof sock.stderr.resume === "function") sock.stderr.resume();
              sock.resume();
            }).catch((err) => {
              this.emit("error", err);
              try {
                if (isWritable(sock)) sock.end();
              } catch {
              }
            });
          };
        })();
        let wasConnected = false;
        sock.on("connect", onConnect).on("timeout", () => {
          this.emit("timeout");
        }).on("error", (err) => {
          debug12 && debug12(`Socket error: ${err.message}`);
          clearTimeout(this._readyTimeout);
          err.level = "client-socket";
          this.emit("error", err);
        }).on("end", () => {
          debug12 && debug12("Socket ended");
          onDone();
          proto.cleanup();
          clearTimeout(this._readyTimeout);
          clearInterval(katimer);
          this.emit("end");
        }).on("close", () => {
          debug12 && debug12("Socket closed");
          onDone();
          proto.cleanup();
          clearTimeout(this._readyTimeout);
          clearInterval(katimer);
          this.emit("close");
          const callbacks_ = callbacks;
          callbacks = this._callbacks = [];
          const err = new Error("No response from server");
          for (let i = 0; i < callbacks_.length; ++i) callbacks_[i](err);
          this._chanMgr.cleanup(err);
        });
        let curAuth;
        let curPartial = null;
        let curAuthsLeft = null;
        const authsAllowed = [
          "none"
        ];
        if (this.config.password !== void 0) authsAllowed.push("password");
        if (privateKey !== void 0) authsAllowed.push("publickey");
        if (this._agent !== void 0) authsAllowed.push("agent");
        if (this.config.tryKeyboard) authsAllowed.push("keyboard-interactive");
        if (privateKey !== void 0 && this.config.localHostname !== void 0 && this.config.localUsername !== void 0) {
          authsAllowed.push("hostbased");
        }
        if (Array.isArray(authHandler)) authHandler = makeSimpleAuthHandler(authHandler);
        else if (typeof authHandler !== "function") authHandler = makeSimpleAuthHandler(authsAllowed);
        let hasSentAuth = false;
        const doNextAuth = /* @__PURE__ */ __name((nextAuth) => {
          if (hasSentAuth) return;
          hasSentAuth = true;
          if (nextAuth === false) {
            const err = new Error("All configured authentication methods failed");
            err.level = "client-authentication";
            this.emit("error", err);
            this.end();
            return;
          }
          if (typeof nextAuth === "string") {
            const type = nextAuth;
            if (authsAllowed.indexOf(type) === -1) return skipAuth(`Authentication method not allowed: ${type}`);
            const username = this.config.username;
            switch (type) {
              case "password":
                nextAuth = {
                  type,
                  username,
                  password: this.config.password
                };
                break;
              case "publickey":
                nextAuth = {
                  type,
                  username,
                  key: privateKey
                };
                break;
              case "hostbased":
                nextAuth = {
                  type,
                  username,
                  key: privateKey,
                  localHostname: this.config.localHostname,
                  localUsername: this.config.localUsername
                };
                break;
              case "agent":
                nextAuth = {
                  type,
                  username,
                  agentCtx: new AgentContext(this._agent)
                };
                break;
              case "keyboard-interactive":
                nextAuth = {
                  type,
                  username,
                  prompt: /* @__PURE__ */ __name((...args) => this.emit("keyboard-interactive", ...args), "prompt")
                };
                break;
              case "none":
                nextAuth = {
                  type,
                  username
                };
                break;
              default:
                return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);
            }
          } else if (typeof nextAuth !== "object" || nextAuth === null) {
            return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);
          } else {
            const username = nextAuth.username;
            if (typeof username !== "string") {
              return skipAuth(`Skipping invalid authentication attempt: ${nextAuth}`);
            }
            const type = nextAuth.type;
            switch (type) {
              case "password": {
                const { password } = nextAuth;
                if (typeof password !== "string" && !Buffer.isBuffer(password)) return skipAuth("Skipping invalid password auth attempt");
                nextAuth = {
                  type,
                  username,
                  password
                };
                break;
              }
              case "publickey": {
                const key = parseKey(nextAuth.key, nextAuth.passphrase);
                if (key instanceof Error) return skipAuth("Skipping invalid key auth attempt");
                if (!key.isPrivateKey()) return skipAuth("Skipping non-private key");
                nextAuth = {
                  type,
                  username,
                  key
                };
                break;
              }
              case "hostbased": {
                const { localHostname, localUsername } = nextAuth;
                const key = parseKey(nextAuth.key, nextAuth.passphrase);
                if (key instanceof Error || typeof localHostname !== "string" || typeof localUsername !== "string") {
                  return skipAuth("Skipping invalid hostbased auth attempt");
                }
                if (!key.isPrivateKey()) return skipAuth("Skipping non-private key");
                nextAuth = {
                  type,
                  username,
                  key,
                  localHostname,
                  localUsername
                };
                break;
              }
              case "agent": {
                let agent = nextAuth.agent;
                if (typeof agent === "string" && agent.length) {
                  agent = createAgent(agent);
                } else if (!isAgent(agent)) {
                  return skipAuth(`Skipping invalid agent: ${nextAuth.agent}`);
                }
                nextAuth = {
                  type,
                  username,
                  agentCtx: new AgentContext(agent)
                };
                break;
              }
              case "keyboard-interactive": {
                const { prompt } = nextAuth;
                if (typeof prompt !== "function") {
                  return skipAuth("Skipping invalid keyboard-interactive auth attempt");
                }
                nextAuth = {
                  type,
                  username,
                  prompt
                };
                break;
              }
              case "none":
                nextAuth = {
                  type,
                  username
                };
                break;
              default:
                return skipAuth(`Skipping unsupported authentication method: ${nextAuth}`);
            }
          }
          curAuth = nextAuth;
          try {
            const username = curAuth.username;
            switch (curAuth.type) {
              case "password":
                proto.authPassword(username, curAuth.password);
                break;
              case "publickey": {
                let keyAlgo;
                curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
                if (curAuth.keyAlgos) {
                  if (curAuth.keyAlgos.length) {
                    keyAlgo = curAuth.keyAlgos[0][0];
                  } else {
                    return skipAuth("Skipping key authentication (no mutual hash algorithm)");
                  }
                }
                proto.authPK(username, curAuth.key, keyAlgo);
                break;
              }
              case "hostbased": {
                let keyAlgo;
                let hashAlgo;
                curAuth.keyAlgos = getKeyAlgos(this, curAuth.key, serverSigAlgs);
                if (curAuth.keyAlgos) {
                  if (curAuth.keyAlgos.length) {
                    [keyAlgo, hashAlgo] = curAuth.keyAlgos[0];
                  } else {
                    return skipAuth("Skipping hostbased authentication (no mutual hash algorithm)");
                  }
                }
                proto.authHostbased(username, curAuth.key, curAuth.localHostname, curAuth.localUsername, keyAlgo, (buf, cb) => {
                  const signature = curAuth.key.sign(buf, hashAlgo);
                  if (signature instanceof Error) {
                    signature.message = `Error while signing with key: ${signature.message}`;
                    signature.level = "client-authentication";
                    this.emit("error", signature);
                    return tryNextAuth();
                  }
                  cb(signature);
                });
                break;
              }
              case "agent":
                curAuth.agentCtx.init((err) => {
                  if (err) {
                    err.level = "agent";
                    this.emit("error", err);
                    return tryNextAuth();
                  }
                  tryNextAgentKey();
                });
                break;
              case "keyboard-interactive":
                proto.authKeyboard(username);
                break;
              case "none":
                proto.authNone(username);
                break;
            }
          } finally {
            hasSentAuth = false;
          }
        }, "doNextAuth");
        function skipAuth(msg) {
          debug12 && debug12(msg);
          process.nextTick(tryNextAuth);
        }
        __name(skipAuth, "skipAuth");
        function tryNextAuth() {
          hasSentAuth = false;
          const auth = authHandler(curAuthsLeft, curPartial, doNextAuth);
          if (hasSentAuth || auth === void 0) return;
          doNextAuth(auth);
        }
        __name(tryNextAuth, "tryNextAuth");
        const tryNextAgentKey = /* @__PURE__ */ __name(() => {
          if (curAuth.type === "agent") {
            const key = curAuth.agentCtx.nextKey();
            if (key === false) {
              debug12 && debug12("Agent: No more keys left to try");
              debug12 && debug12("Client: agent auth failed");
              tryNextAuth();
            } else {
              const pos = curAuth.agentCtx.pos();
              let keyAlgo;
              curAuth.keyAlgos = getKeyAlgos(this, key, serverSigAlgs);
              if (curAuth.keyAlgos) {
                if (curAuth.keyAlgos.length) {
                  keyAlgo = curAuth.keyAlgos[0][0];
                } else {
                  debug12 && debug12(`Agent: Skipping key #${pos + 1} (no mutual hash algorithm)`);
                  tryNextAgentKey();
                  return;
                }
              }
              debug12 && debug12(`Agent: Trying key #${pos + 1}`);
              proto.authPK(curAuth.username, key, keyAlgo);
            }
          }
        }, "tryNextAgentKey");
        const startTimeout = /* @__PURE__ */ __name(() => {
          if (this.config.readyTimeout > 0) {
            this._readyTimeout = setTimeout(() => {
              const err = new Error("Timed out while waiting for handshake");
              err.level = "client-timeout";
              this.emit("error", err);
              sock.destroy();
            }, this.config.readyTimeout);
          }
        }, "startTimeout");
        if (!cfg.sock) {
          let host = this.config.host;
          const forceIPv4 = this.config.forceIPv4;
          const forceIPv6 = this.config.forceIPv6;
          debug12 && debug12(`Client: Trying ${host} on port ${this.config.port} ...`);
          const doConnect = /* @__PURE__ */ __name(() => {
            startTimeout();
            sock.connect({
              host,
              port: this.config.port,
              localAddress: this.config.localAddress,
              localPort: this.config.localPort
            });
            sock.setMaxListeners(0);
            sock.setTimeout(typeof cfg.timeout === "number" ? cfg.timeout : 0);
          }, "doConnect");
          if (!forceIPv4 && !forceIPv6 || forceIPv4 && forceIPv6) {
            doConnect();
          } else {
            dnsLookup(host, forceIPv4 ? 4 : 6, (err, address, family) => {
              if (err) {
                const type = forceIPv4 ? "IPv4" : "IPv6";
                const error = new Error(`Error while looking up ${type} address for '${host}': ${err}`);
                clearTimeout(this._readyTimeout);
                error.level = "client-dns";
                this.emit("error", error);
                this.emit("close");
                return;
              }
              host = address;
              doConnect();
            });
          }
        } else {
          startTimeout();
          if (typeof sock.connecting === "boolean") {
            if (!sock.connecting) {
              onConnect();
            }
          } else {
            onConnect();
          }
        }
        return this;
      }
      end() {
        if (this._sock && isWritable(this._sock)) {
          this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          this._sock.end();
        }
        return this;
      }
      destroy() {
        this._sock && isWritable(this._sock) && this._sock.destroy();
        return this;
      }
      exec(cmd, opts, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        if (typeof opts === "function") {
          cb = opts;
          opts = {};
        }
        const extraOpts = {
          allowHalfOpen: opts.allowHalfOpen !== false
        };
        openChannel(this, "session", extraOpts, (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          const todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close();
              cb(err2);
              return;
            }
            if (todo.length) todo.shift()();
          }
          __name(reqCb, "reqCb");
          if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
            todo.push(() => reqAgentFwd(chan, reqCb));
          }
          if (typeof opts === "object" && opts !== null) {
            if (typeof opts.env === "object" && opts.env !== null) reqEnv(chan, opts.env);
            if (typeof opts.pty === "object" && opts.pty !== null || opts.pty === true) {
              todo.push(() => reqPty(chan, opts.pty, reqCb));
            }
            if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
              todo.push(() => reqX11(chan, opts.x11, reqCb));
            }
          }
          todo.push(() => reqExec(chan, cmd, opts, cb));
          todo.shift()();
        });
        return this;
      }
      shell(wndopts, opts, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        if (typeof wndopts === "function") {
          cb = wndopts;
          wndopts = opts = void 0;
        } else if (typeof opts === "function") {
          cb = opts;
          opts = void 0;
        }
        if (wndopts && (wndopts.x11 !== void 0 || wndopts.env !== void 0)) {
          opts = wndopts;
          wndopts = void 0;
        }
        openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          const todo = [];
          function reqCb(err2) {
            if (err2) {
              chan.close();
              cb(err2);
              return;
            }
            if (todo.length) todo.shift()();
          }
          __name(reqCb, "reqCb");
          if (this.config.allowAgentFwd === true || opts && opts.agentForward === true && this._agent !== void 0) {
            todo.push(() => reqAgentFwd(chan, reqCb));
          }
          if (wndopts !== false) todo.push(() => reqPty(chan, wndopts, reqCb));
          if (typeof opts === "object" && opts !== null) {
            if (typeof opts.env === "object" && opts.env !== null) reqEnv(chan, opts.env);
            if (typeof opts.x11 === "object" && opts.x11 !== null || opts.x11 === "number" || opts.x11 === true) {
              todo.push(() => reqX11(chan, opts.x11, reqCb));
            }
          }
          todo.push(() => reqShell(chan, cb));
          todo.shift()();
        });
        return this;
      }
      subsys(name, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        openChannel(this, "session", (err, chan) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(chan, name, (err2, stream) => {
            if (err2) {
              cb(err2);
              return;
            }
            cb(void 0, stream);
          });
        });
        return this;
      }
      forwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (wantReply) {
          this._callbacks.push((had_err, data) => {
            if (had_err) {
              cb(had_err !== true ? had_err : new Error(`Unable to bind to ${bindAddr}:${bindPort}`));
              return;
            }
            let realPort = bindPort;
            if (bindPort === 0 && data && data.length >= 4) {
              realPort = readUInt32BE(data, 0);
              if (!(this._protocol._compatFlags & COMPAT.DYN_RPORT_BUG)) bindPort = realPort;
            }
            this._forwarding[`${bindAddr}:${bindPort}`] = realPort;
            cb(void 0, realPort);
          });
        }
        this._protocol.tcpipForward(bindAddr, bindPort, wantReply);
        return this;
      }
      unforwardIn(bindAddr, bindPort, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (wantReply) {
          this._callbacks.push((had_err) => {
            if (had_err) {
              cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${bindAddr}:${bindPort}`));
              return;
            }
            delete this._forwarding[`${bindAddr}:${bindPort}`];
            cb();
          });
        }
        this._protocol.cancelTcpipForward(bindAddr, bindPort, wantReply);
        return this;
      }
      forwardOut(srcIP, srcPort, dstIP, dstPort, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        const cfg = {
          srcIP,
          srcPort,
          dstIP,
          dstPort
        };
        if (typeof cb !== "function") cb = noop;
        openChannel(this, "direct-tcpip", cfg, cb);
        return this;
      }
      openssh_noMoreSessions(cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error("Unable to disable future sessions"));
                return;
              }
              cb();
            });
          }
          this._protocol.openssh_noMoreSessions(wantReply);
          return this;
        }
        if (!wantReply) return this;
        process.nextTick(cb, new Error("strictVendor enabled and server is not OpenSSH or compatible version"));
        return this;
      }
      openssh_forwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error(`Unable to bind to ${socketPath}`));
                return;
              }
              this._forwardingUnix[socketPath] = true;
              cb();
            });
          }
          this._protocol.openssh_streamLocalForward(socketPath, wantReply);
          return this;
        }
        if (!wantReply) return this;
        process.nextTick(cb, new Error("strictVendor enabled and server is not OpenSSH or compatible version"));
        return this;
      }
      openssh_unforwardInStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        const wantReply = typeof cb === "function";
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          if (wantReply) {
            this._callbacks.push((had_err) => {
              if (had_err) {
                cb(had_err !== true ? had_err : new Error(`Unable to unbind from ${socketPath}`));
                return;
              }
              delete this._forwardingUnix[socketPath];
              cb();
            });
          }
          this._protocol.openssh_cancelStreamLocalForward(socketPath, wantReply);
          return this;
        }
        if (!wantReply) return this;
        process.nextTick(cb, new Error("strictVendor enabled and server is not OpenSSH or compatible version"));
        return this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        if (typeof cb !== "function") cb = noop;
        if (!this.config.strictVendor || this.config.strictVendor && RE_OPENSSH.test(this._remoteVer)) {
          openChannel(this, "direct-streamlocal@openssh.com", {
            socketPath
          }, cb);
          return this;
        }
        process.nextTick(cb, new Error("strictVendor enabled and server is not OpenSSH or compatible version"));
        return this;
      }
      sftp(cb) {
        if (!this._sock || !isWritable(this._sock)) throw new Error("Not connected");
        openChannel(this, "sftp", (err, sftp) => {
          if (err) {
            cb(err);
            return;
          }
          reqSubsystem(sftp, "sftp", (err2, sftp_) => {
            if (err2) {
              cb(err2);
              return;
            }
            function removeListeners() {
              sftp.removeListener("ready", onReady);
              sftp.removeListener("error", onError);
              sftp.removeListener("exit", onExit);
              sftp.removeListener("close", onExit);
            }
            __name(removeListeners, "removeListeners");
            function onReady() {
              removeListeners();
              cb(void 0, sftp);
            }
            __name(onReady, "onReady");
            function onError(err3) {
              removeListeners();
              cb(err3);
            }
            __name(onError, "onError");
            function onExit(code, signal) {
              removeListeners();
              let msg;
              if (typeof code === "number") msg = `Received exit code ${code} while establishing SFTP session`;
              else if (signal !== void 0) msg = `Received signal ${signal} while establishing SFTP session`;
              else msg = "Received unexpected SFTP session termination";
              const err3 = new Error(msg);
              err3.code = code;
              err3.signal = signal;
              cb(err3);
            }
            __name(onExit, "onExit");
            sftp.on("ready", onReady).on("error", onError).on("exit", onExit).on("close", onExit);
            sftp._init();
          });
        });
        return this;
      }
      setNoDelay(noDelay) {
        if (this._sock && typeof this._sock.setNoDelay === "function") this._sock.setNoDelay(noDelay);
        return this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      const initWindow = MAX_WINDOW;
      const maxPacket = PACKET_SIZE;
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const wrapper = /* @__PURE__ */ __name((err, stream) => {
        cb(err, stream);
      }, "wrapper");
      wrapper.type = type;
      const localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "session":
        case "sftp":
          self2._protocol.session(localChan, initWindow, maxPacket);
          break;
        case "direct-tcpip":
          self2._protocol.directTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "direct-streamlocal@openssh.com":
          self2._protocol.openssh_directStreamLocal(localChan, initWindow, maxPacket, opts);
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    __name(openChannel, "openChannel");
    function reqX11(chan, screen, cb) {
      const cfg = {
        single: false,
        protocol: "MIT-MAGIC-COOKIE-1",
        cookie: void 0,
        screen: 0
      };
      if (typeof screen === "function") {
        cb = screen;
      } else if (typeof screen === "object" && screen !== null) {
        if (typeof screen.single === "boolean") cfg.single = screen.single;
        if (typeof screen.screen === "number") cfg.screen = screen.screen;
        if (typeof screen.protocol === "string") cfg.protocol = screen.protocol;
        if (typeof screen.cookie === "string") cfg.cookie = screen.cookie;
        else if (Buffer.isBuffer(screen.cookie)) cfg.cookie = screen.cookie.hexSlice(0, screen.cookie.length);
      }
      if (cfg.cookie === void 0) cfg.cookie = randomCookie();
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        if (wantReply) cb(new Error("Channel is not open"));
        return;
      }
      if (wantReply) {
        chan._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to request X11"));
            return;
          }
          chan._hasX11 = true;
          ++chan._client._acceptX11;
          chan.once("close", () => {
            if (chan._client._acceptX11) --chan._client._acceptX11;
          });
          cb();
        });
      }
      chan._client._protocol.x11Forward(chan.outgoing.id, cfg, wantReply);
    }
    __name(reqX11, "reqX11");
    function reqPty(chan, opts, cb) {
      let rows = 24;
      let cols = 80;
      let width = 640;
      let height = 480;
      let term = "vt100";
      let modes = null;
      if (typeof opts === "function") {
        cb = opts;
      } else if (typeof opts === "object" && opts !== null) {
        if (typeof opts.rows === "number") rows = opts.rows;
        if (typeof opts.cols === "number") cols = opts.cols;
        if (typeof opts.width === "number") width = opts.width;
        if (typeof opts.height === "number") height = opts.height;
        if (typeof opts.term === "string") term = opts.term;
        if (typeof opts.modes === "object") modes = opts.modes;
      }
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        if (wantReply) cb(new Error("Channel is not open"));
        return;
      }
      if (wantReply) {
        chan._callbacks.push((had_err) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Unable to request a pseudo-terminal"));
            return;
          }
          cb();
        });
      }
      chan._client._protocol.pty(chan.outgoing.id, rows, cols, height, width, term, modes, wantReply);
    }
    __name(reqPty, "reqPty");
    function reqAgentFwd(chan, cb) {
      const wantReply = typeof cb === "function";
      if (chan.outgoing.state !== "open") {
        wantReply && cb(new Error("Channel is not open"));
        return;
      }
      if (chan._client._agentFwdEnabled) {
        wantReply && cb(false);
        return;
      }
      chan._client._agentFwdEnabled = true;
      chan._callbacks.push((had_err) => {
        if (had_err) {
          chan._client._agentFwdEnabled = false;
          if (wantReply) {
            cb(had_err !== true ? had_err : new Error("Unable to request agent forwarding"));
          }
          return;
        }
        if (wantReply) cb();
      });
      chan._client._protocol.openssh_agentForward(chan.outgoing.id, true);
    }
    __name(reqAgentFwd, "reqAgentFwd");
    function reqShell(chan, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error("Unable to open shell"));
          return;
        }
        chan.subtype = "shell";
        cb(void 0, chan);
      });
      chan._client._protocol.shell(chan.outgoing.id, true);
    }
    __name(reqShell, "reqShell");
    function reqExec(chan, cmd, opts, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error("Unable to exec"));
          return;
        }
        chan.subtype = "exec";
        chan.allowHalfOpen = opts.allowHalfOpen !== false;
        cb(void 0, chan);
      });
      chan._client._protocol.exec(chan.outgoing.id, cmd, true);
    }
    __name(reqExec, "reqExec");
    function reqEnv(chan, env2) {
      if (chan.outgoing.state !== "open") return;
      const keys = Object.keys(env2 || {});
      for (let i = 0; i < keys.length; ++i) {
        const key = keys[i];
        const val = env2[key];
        chan._client._protocol.env(chan.outgoing.id, key, val, false);
      }
    }
    __name(reqEnv, "reqEnv");
    function reqSubsystem(chan, name, cb) {
      if (chan.outgoing.state !== "open") {
        cb(new Error("Channel is not open"));
        return;
      }
      chan._callbacks.push((had_err) => {
        if (had_err) {
          cb(had_err !== true ? had_err : new Error(`Unable to start subsystem: ${name}`));
          return;
        }
        chan.subtype = "subsystem";
        cb(void 0, chan);
      });
      chan._client._protocol.subsystem(chan.outgoing.id, name, true);
    }
    __name(reqSubsystem, "reqSubsystem");
    function onCHANNEL_OPEN(self2, info) {
      let localChan = -1;
      let reason;
      const accept = /* @__PURE__ */ __name(() => {
        const chanInfo = {
          type: info.type,
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info.sender,
            window: info.window,
            packetSize: info.packetSize,
            state: "open"
          }
        };
        const stream = new Channel(self2, chanInfo);
        self2._chanMgr.update(localChan, stream);
        self2._protocol.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);
        return stream;
      }, "accept");
      const reject = /* @__PURE__ */ __name(() => {
        if (reason === void 0) {
          if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
          else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
        }
        if (localChan !== -1) self2._chanMgr.remove(localChan);
        self2._protocol.channelOpenFail(info.sender, reason, "");
      }, "reject");
      const reserveChannel = /* @__PURE__ */ __name(() => {
        localChan = self2._chanMgr.add();
        if (localChan === -1) {
          reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
          if (self2.config.debug) {
            self2.config.debug("Client: Automatic rejection of incoming channel open: no channels available");
          }
        }
        return localChan !== -1;
      }, "reserveChannel");
      const data = info.data;
      switch (info.type) {
        case "forwarded-tcpip": {
          const val = self2._forwarding[`${data.destIP}:${data.destPort}`];
          if (val !== void 0 && reserveChannel()) {
            if (data.destPort === 0) data.destPort = val;
            self2.emit("tcp connection", data, accept, reject);
            return;
          }
          break;
        }
        case "forwarded-streamlocal@openssh.com":
          if (self2._forwardingUnix[data.socketPath] !== void 0 && reserveChannel()) {
            self2.emit("unix connection", data, accept, reject);
            return;
          }
          break;
        case "auth-agent@openssh.com":
          if (self2._agentFwdEnabled && typeof self2._agent.getStream === "function" && reserveChannel()) {
            self2._agent.getStream((err, stream) => {
              if (err) return reject();
              const upstream = accept();
              upstream.pipe(stream).pipe(upstream);
            });
            return;
          }
          break;
        case "x11":
          if (self2._acceptX11 !== 0 && reserveChannel()) {
            self2.emit("x11", data, accept, reject);
            return;
          }
          break;
        default:
          reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
          if (self2.config.debug) {
            self2.config.debug(`Client: Automatic rejection of unsupported incoming channel open type: ${info.type}`);
          }
      }
      if (reason === void 0) {
        reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
        if (self2.config.debug) {
          self2.config.debug("Client: Automatic rejection of unexpected incoming channel open for: " + info.type);
        }
      }
      reject();
    }
    __name(onCHANNEL_OPEN, "onCHANNEL_OPEN");
    var randomCookie = (() => {
      const buffer = Buffer.allocUnsafe(16);
      return () => {
        randomFillSync(buffer, 0, 16);
        return buffer.hexSlice(0, 16);
      };
    })();
    function makeSimpleAuthHandler(authList) {
      if (!Array.isArray(authList)) throw new Error("authList must be an array");
      let a = 0;
      return (authsLeft, partialSuccess, cb) => {
        if (a === authList.length) return false;
        return authList[a++];
      };
    }
    __name(makeSimpleAuthHandler, "makeSimpleAuthHandler");
    function hostKeysProve(client2, keys_, cb) {
      if (!client2._sock || !isWritable(client2._sock)) return;
      if (typeof cb !== "function") cb = noop;
      if (!Array.isArray(keys_)) throw new TypeError("Invalid keys argument type");
      const keys = [];
      for (const key of keys_) {
        const parsed = parseKey(key);
        if (parsed instanceof Error) throw parsed;
        keys.push(parsed);
      }
      if (!client2.config.strictVendor || client2.config.strictVendor && RE_OPENSSH.test(client2._remoteVer)) {
        client2._callbacks.push((had_err, data) => {
          if (had_err) {
            cb(had_err !== true ? had_err : new Error("Server failed to prove supplied keys"));
            return;
          }
          const ret = [];
          let keyIdx = 0;
          bufferParser.init(data, 0);
          while (bufferParser.avail()) {
            if (keyIdx === keys.length) break;
            const key = keys[keyIdx++];
            const keyPublic = key.getPublicSSH();
            const sigEntry = bufferParser.readString();
            sigParser.init(sigEntry, 0);
            const type = sigParser.readString(true);
            let value2 = sigParser.readString();
            let algo;
            if (type !== key.type) {
              if (key.type === "ssh-rsa") {
                switch (type) {
                  case "rsa-sha2-256":
                    algo = "sha256";
                    break;
                  case "rsa-sha2-512":
                    algo = "sha512";
                    break;
                  default:
                    continue;
                }
              } else {
                continue;
              }
            }
            const sessionID = client2._protocol._kex.sessionID;
            const verifyData = Buffer.allocUnsafe(4 + 29 + 4 + sessionID.length + 4 + keyPublic.length);
            let p = 0;
            writeUInt32BE(verifyData, 29, p);
            verifyData.utf8Write("hostkeys-prove-00@openssh.com", p += 4, 29);
            writeUInt32BE(verifyData, sessionID.length, p += 29);
            bufferCopy(sessionID, verifyData, 0, sessionID.length, p += 4);
            writeUInt32BE(verifyData, keyPublic.length, p += sessionID.length);
            bufferCopy(keyPublic, verifyData, 0, keyPublic.length, p += 4);
            if (!(value2 = sigSSHToASN1(value2, type))) continue;
            if (key.verify(verifyData, value2, algo) === true) ret.push(key);
          }
          sigParser.clear();
          bufferParser.clear();
          cb(null, ret);
        });
        client2._protocol.openssh_hostKeysProve(keys);
        return;
      }
      process.nextTick(cb, new Error("strictVendor enabled and server is not OpenSSH or compatible version"));
    }
    __name(hostKeysProve, "hostKeysProve");
    function getKeyAlgos(client2, key, serverSigAlgs) {
      switch (key.type) {
        case "ssh-rsa":
          if (client2._protocol._compatFlags & COMPAT.IMPLY_RSA_SHA2_SIGALGS) {
            if (!Array.isArray(serverSigAlgs)) serverSigAlgs = [
              "rsa-sha2-256",
              "rsa-sha2-512"
            ];
            else serverSigAlgs = [
              "rsa-sha2-256",
              "rsa-sha2-512",
              ...serverSigAlgs
            ];
          }
          if (Array.isArray(serverSigAlgs)) {
            if (serverSigAlgs.indexOf("rsa-sha2-256") !== -1) return [
              [
                "rsa-sha2-256",
                "sha256"
              ]
            ];
            if (serverSigAlgs.indexOf("rsa-sha2-512") !== -1) return [
              [
                "rsa-sha2-512",
                "sha512"
              ]
            ];
            if (serverSigAlgs.indexOf("ssh-rsa") === -1) return [];
          }
          return [
            [
              "ssh-rsa",
              "sha1"
            ]
          ];
      }
    }
    __name(getKeyAlgos, "getKeyAlgos");
    module2.exports = Client;
  }
});

// node_modules/ssh2/lib/http-agents.js
var require_http_agents = __commonJS({
  "node_modules/ssh2/lib/http-agents.js"(exports2) {
    "use strict";
    var { Agent: HttpAgent } = require("http");
    var { Agent: HttpsAgent } = require("https");
    var { connect: tlsConnect } = require("tls");
    var Client;
    for (const ctor of [
      HttpAgent,
      HttpsAgent
    ]) {
      let SSHAgent = class SSHAgent extends ctor {
        static {
          __name(this, "SSHAgent");
        }
        constructor(connectCfg, agentOptions) {
          super(agentOptions);
          this._connectCfg = connectCfg;
          this._defaultSrcIP = agentOptions && agentOptions.srcIP || "localhost";
        }
        createConnection(options, cb) {
          const srcIP = options && options.localAddress || this._defaultSrcIP;
          const srcPort = options && options.localPort || 0;
          const dstIP = options.host;
          const dstPort = options.port;
          if (Client === void 0) Client = require_client();
          const client2 = new Client();
          let triedForward = false;
          client2.on("ready", () => {
            client2.forwardOut(srcIP, srcPort, dstIP, dstPort, (err, stream) => {
              triedForward = true;
              if (err) {
                client2.end();
                return cb(err);
              }
              stream.once("close", () => client2.end());
              cb(null, decorateStream(stream, ctor, options));
            });
          }).on("error", cb).on("close", () => {
            if (!triedForward) cb(new Error("Unexpected connection close"));
          }).connect(this._connectCfg);
        }
      };
      exports2[ctor === HttpAgent ? "SSHTTPAgent" : "SSHTTPSAgent"] = SSHAgent;
    }
    function noop() {
    }
    __name(noop, "noop");
    function decorateStream(stream, ctor, options) {
      if (ctor === HttpAgent) {
        stream.setKeepAlive = noop;
        stream.setNoDelay = noop;
        stream.setTimeout = noop;
        stream.ref = noop;
        stream.unref = noop;
        stream.destroySoon = stream.destroy;
        return stream;
      }
      options.socket = stream;
      const wrapped = tlsConnect(options);
      const onClose = /* @__PURE__ */ (() => {
        let called = false;
        return () => {
          if (called) return;
          called = true;
          if (stream.isPaused()) stream.resume();
        };
      })();
      wrapped.on("end", onClose).on("close", onClose);
      return wrapped;
    }
    __name(decorateStream, "decorateStream");
  }
});

// node_modules/ssh2/lib/server.js
var require_server = __commonJS({
  "node_modules/ssh2/lib/server.js"(exports2, module2) {
    "use strict";
    var { Server: netServer } = require("net");
    var EventEmitter = require("events");
    var { listenerCount } = EventEmitter;
    var { CHANNEL_OPEN_FAILURE, DEFAULT_CIPHER, DEFAULT_COMPRESSION, DEFAULT_KEX, DEFAULT_MAC, DEFAULT_SERVER_HOST_KEY, DISCONNECT_REASON, DISCONNECT_REASON_BY_VALUE, SUPPORTED_CIPHER, SUPPORTED_COMPRESSION, SUPPORTED_KEX, SUPPORTED_MAC, SUPPORTED_SERVER_HOST_KEY } = require_constants2();
    var { init: cryptoInit } = require_crypto();
    var { KexInit } = require_kex();
    var { parseKey } = require_keyParser();
    var Protocol = require_Protocol();
    var { SFTP } = require_SFTP();
    var { writeUInt32BE } = require_utils2();
    var { Channel, MAX_WINDOW, PACKET_SIZE, windowAdjust, WINDOW_THRESHOLD } = require_Channel();
    var { ChannelManager, generateAlgorithmList, isWritable, onChannelOpenFailure, onCHANNEL_CLOSE } = require_utils3();
    var MAX_PENDING_AUTHS = 10;
    var AuthContext = class AuthContext extends EventEmitter {
      static {
        __name(this, "AuthContext");
      }
      constructor(protocol4, username, service, method, cb) {
        super();
        this.username = this.user = username;
        this.service = service;
        this.method = method;
        this._initialResponse = false;
        this._finalResponse = false;
        this._multistep = false;
        this._cbfinal = (allowed, methodsLeft, isPartial) => {
          if (!this._finalResponse) {
            this._finalResponse = true;
            cb(this, allowed, methodsLeft, isPartial);
          }
        };
        this._protocol = protocol4;
      }
      accept() {
        this._cleanup && this._cleanup();
        this._initialResponse = true;
        this._cbfinal(true);
      }
      reject(methodsLeft, isPartial) {
        this._cleanup && this._cleanup();
        this._initialResponse = true;
        this._cbfinal(false, methodsLeft, isPartial);
      }
    };
    var KeyboardAuthContext = class KeyboardAuthContext extends AuthContext {
      static {
        __name(this, "KeyboardAuthContext");
      }
      constructor(protocol4, username, service, method, submethods, cb) {
        super(protocol4, username, service, method, cb);
        this._multistep = true;
        this._cb = void 0;
        this._onInfoResponse = (responses) => {
          const callback = this._cb;
          if (callback) {
            this._cb = void 0;
            callback(responses);
          }
        };
        this.submethods = submethods;
        this.on("abort", () => {
          this._cb && this._cb(new Error("Authentication request aborted"));
        });
      }
      prompt(prompts, title, instructions, cb) {
        if (!Array.isArray(prompts)) prompts = [
          prompts
        ];
        if (typeof title === "function") {
          cb = title;
          title = instructions = void 0;
        } else if (typeof instructions === "function") {
          cb = instructions;
          instructions = void 0;
        } else if (typeof cb !== "function") {
          cb = void 0;
        }
        for (let i = 0; i < prompts.length; ++i) {
          if (typeof prompts[i] === "string") {
            prompts[i] = {
              prompt: prompts[i],
              echo: true
            };
          }
        }
        this._cb = cb;
        this._initialResponse = true;
        this._protocol.authInfoReq(title, instructions, prompts);
      }
    };
    var PKAuthContext = class PKAuthContext extends AuthContext {
      static {
        __name(this, "PKAuthContext");
      }
      constructor(protocol4, username, service, method, pkInfo, cb) {
        super(protocol4, username, service, method, cb);
        this.key = {
          algo: pkInfo.keyAlgo,
          data: pkInfo.key
        };
        this.hashAlgo = pkInfo.hashAlgo;
        this.signature = pkInfo.signature;
        this.blob = pkInfo.blob;
      }
      accept() {
        if (!this.signature) {
          this._initialResponse = true;
          this._protocol.authPKOK(this.key.algo, this.key.data);
        } else {
          AuthContext.prototype.accept.call(this);
        }
      }
    };
    var HostbasedAuthContext = class HostbasedAuthContext extends AuthContext {
      static {
        __name(this, "HostbasedAuthContext");
      }
      constructor(protocol4, username, service, method, pkInfo, cb) {
        super(protocol4, username, service, method, cb);
        this.key = {
          algo: pkInfo.keyAlgo,
          data: pkInfo.key
        };
        this.hashAlgo = pkInfo.hashAlgo;
        this.signature = pkInfo.signature;
        this.blob = pkInfo.blob;
        this.localHostname = pkInfo.localHostname;
        this.localUsername = pkInfo.localUsername;
      }
    };
    var PwdAuthContext = class PwdAuthContext extends AuthContext {
      static {
        __name(this, "PwdAuthContext");
      }
      constructor(protocol4, username, service, method, password, cb) {
        super(protocol4, username, service, method, cb);
        this.password = password;
        this._changeCb = void 0;
      }
      requestChange(prompt, cb) {
        if (this._changeCb) throw new Error("Change request already in progress");
        if (typeof prompt !== "string") throw new Error("prompt argument must be a string");
        if (typeof cb !== "function") throw new Error("Callback argument must be a function");
        this._changeCb = cb;
        this._protocol.authPasswdChg(prompt);
      }
    };
    var Session = class Session extends EventEmitter {
      static {
        __name(this, "Session");
      }
      constructor(client2, info, localChan) {
        super();
        this.type = "session";
        this.subtype = void 0;
        this.server = true;
        this._ending = false;
        this._channel = void 0;
        this._chanInfo = {
          type: "session",
          incoming: {
            id: localChan,
            window: MAX_WINDOW,
            packetSize: PACKET_SIZE,
            state: "open"
          },
          outgoing: {
            id: info.sender,
            window: info.window,
            packetSize: info.packetSize,
            state: "open"
          }
        };
      }
    };
    var Server = class Server extends EventEmitter {
      static {
        __name(this, "Server");
      }
      constructor(cfg, listener) {
        super();
        if (typeof cfg !== "object" || cfg === null) throw new Error("Missing configuration object");
        const hostKeys = /* @__PURE__ */ Object.create(null);
        const hostKeyAlgoOrder = [];
        const hostKeys_ = cfg.hostKeys;
        if (!Array.isArray(hostKeys_)) throw new Error("hostKeys must be an array");
        const cfgAlgos = typeof cfg.algorithms === "object" && cfg.algorithms !== null ? cfg.algorithms : {};
        const hostKeyAlgos = generateAlgorithmList(cfgAlgos.serverHostKey, DEFAULT_SERVER_HOST_KEY, SUPPORTED_SERVER_HOST_KEY);
        for (let i = 0; i < hostKeys_.length; ++i) {
          let privateKey;
          if (Buffer.isBuffer(hostKeys_[i]) || typeof hostKeys_[i] === "string") privateKey = parseKey(hostKeys_[i]);
          else privateKey = parseKey(hostKeys_[i].key, hostKeys_[i].passphrase);
          if (privateKey instanceof Error) throw new Error(`Cannot parse privateKey: ${privateKey.message}`);
          if (Array.isArray(privateKey)) {
            privateKey = privateKey[0];
          }
          if (privateKey.getPrivatePEM() === null) throw new Error("privateKey value contains an invalid private key");
          if (hostKeyAlgoOrder.includes(privateKey.type)) continue;
          if (privateKey.type === "ssh-rsa") {
            let sha1Pos = hostKeyAlgos.indexOf("ssh-rsa");
            const sha256Pos = hostKeyAlgos.indexOf("rsa-sha2-256");
            const sha512Pos = hostKeyAlgos.indexOf("rsa-sha2-512");
            if (sha1Pos === -1) {
              sha1Pos = Infinity;
            }
            [
              sha1Pos,
              sha256Pos,
              sha512Pos
            ].sort(compareNumbers).forEach((pos) => {
              if (pos === -1) return;
              let type;
              switch (pos) {
                case sha1Pos:
                  type = "ssh-rsa";
                  break;
                case sha256Pos:
                  type = "rsa-sha2-256";
                  break;
                case sha512Pos:
                  type = "rsa-sha2-512";
                  break;
                default:
                  return;
              }
              hostKeys[type] = privateKey;
              hostKeyAlgoOrder.push(type);
            });
          } else {
            hostKeys[privateKey.type] = privateKey;
            hostKeyAlgoOrder.push(privateKey.type);
          }
        }
        const algorithms = {
          kex: generateAlgorithmList(cfgAlgos.kex, DEFAULT_KEX, SUPPORTED_KEX).concat([
            "kex-strict-s-v00@openssh.com"
          ]),
          serverHostKey: hostKeyAlgoOrder,
          cs: {
            cipher: generateAlgorithmList(cfgAlgos.cipher, DEFAULT_CIPHER, SUPPORTED_CIPHER),
            mac: generateAlgorithmList(cfgAlgos.hmac, DEFAULT_MAC, SUPPORTED_MAC),
            compress: generateAlgorithmList(cfgAlgos.compress, DEFAULT_COMPRESSION, SUPPORTED_COMPRESSION),
            lang: []
          },
          sc: void 0
        };
        algorithms.sc = algorithms.cs;
        if (typeof listener === "function") this.on("connection", listener);
        const origDebug = typeof cfg.debug === "function" ? cfg.debug : void 0;
        const ident = cfg.ident ? Buffer.from(cfg.ident) : void 0;
        const offer = new KexInit(algorithms);
        this._srv = new netServer((socket) => {
          if (this._connections >= this.maxConnections) {
            socket.destroy();
            return;
          }
          ++this._connections;
          socket.once("close", () => {
            --this._connections;
          });
          let debug12;
          if (origDebug) {
            const debugPrefix = `[${process.hrtime().join(".")}] `;
            debug12 = /* @__PURE__ */ __name((msg) => {
              origDebug(`${debugPrefix}${msg}`);
            }, "debug");
          }
          new Client(socket, hostKeys, ident, offer, debug12, this, cfg);
        }).on("error", (err) => {
          this.emit("error", err);
        }).on("listening", () => {
          this.emit("listening");
        }).on("close", () => {
          this.emit("close");
        });
        this._connections = 0;
        this.maxConnections = Infinity;
      }
      injectSocket(socket) {
        this._srv.emit("connection", socket);
      }
      listen(...args) {
        this._srv.listen(...args);
        return this;
      }
      address() {
        return this._srv.address();
      }
      getConnections(cb) {
        this._srv.getConnections(cb);
        return this;
      }
      close(cb) {
        this._srv.close(cb);
        return this;
      }
      ref() {
        this._srv.ref();
        return this;
      }
      unref() {
        this._srv.unref();
        return this;
      }
    };
    Server.KEEPALIVE_CLIENT_INTERVAL = 15e3;
    Server.KEEPALIVE_CLIENT_COUNT_MAX = 3;
    var Client = class Client extends EventEmitter {
      static {
        __name(this, "Client");
      }
      constructor(socket, hostKeys, ident, offer, debug12, server, srvCfg) {
        super();
        let exchanges = 0;
        let acceptedAuthSvc = false;
        let pendingAuths = [];
        let authCtx;
        let kaTimer;
        let onPacket;
        const unsentGlobalRequestsReplies = [];
        this._sock = socket;
        this._chanMgr = new ChannelManager(this);
        this._debug = debug12;
        this.noMoreSessions = false;
        this.authenticated = false;
        function onClientPreHeaderError(err) {
        }
        __name(onClientPreHeaderError, "onClientPreHeaderError");
        this.on("error", onClientPreHeaderError);
        const DEBUG_HANDLER = !debug12 ? void 0 : (p, display, msg) => {
          debug12(`Debug output from client: ${JSON.stringify(msg)}`);
        };
        const kaIntvl = typeof srvCfg.keepaliveInterval === "number" && isFinite(srvCfg.keepaliveInterval) && srvCfg.keepaliveInterval > 0 ? srvCfg.keepaliveInterval : typeof Server.KEEPALIVE_CLIENT_INTERVAL === "number" && isFinite(Server.KEEPALIVE_CLIENT_INTERVAL) && Server.KEEPALIVE_CLIENT_INTERVAL > 0 ? Server.KEEPALIVE_CLIENT_INTERVAL : -1;
        const kaCountMax = typeof srvCfg.keepaliveCountMax === "number" && isFinite(srvCfg.keepaliveCountMax) && srvCfg.keepaliveCountMax >= 0 ? srvCfg.keepaliveCountMax : typeof Server.KEEPALIVE_CLIENT_COUNT_MAX === "number" && isFinite(Server.KEEPALIVE_CLIENT_COUNT_MAX) && Server.KEEPALIVE_CLIENT_COUNT_MAX >= 0 ? Server.KEEPALIVE_CLIENT_COUNT_MAX : -1;
        let kaCurCount = 0;
        if (kaIntvl !== -1 && kaCountMax !== -1) {
          this.once("ready", () => {
            const onClose = /* @__PURE__ */ __name(() => {
              clearInterval(kaTimer);
            }, "onClose");
            this.on("close", onClose).on("end", onClose);
            kaTimer = setInterval(() => {
              if (++kaCurCount > kaCountMax) {
                clearInterval(kaTimer);
                const err = new Error("Keepalive timeout");
                err.level = "client-timeout";
                this.emit("error", err);
                this.end();
              } else {
                proto.ping();
              }
            }, kaIntvl);
          });
          onPacket = /* @__PURE__ */ __name(() => {
            kaTimer && kaTimer.refresh();
            kaCurCount = 0;
          }, "onPacket");
        }
        const proto = this._protocol = new Protocol({
          server: true,
          hostKeys,
          ident,
          offer,
          onPacket,
          greeting: srvCfg.greeting,
          banner: srvCfg.banner,
          onWrite: /* @__PURE__ */ __name((data) => {
            if (isWritable(socket)) socket.write(data);
          }, "onWrite"),
          onError: /* @__PURE__ */ __name((err) => {
            if (!proto._destruct) socket.removeAllListeners("data");
            this.emit("error", err);
            try {
              socket.end();
            } catch {
            }
          }, "onError"),
          onHeader: /* @__PURE__ */ __name((header) => {
            this.removeListener("error", onClientPreHeaderError);
            const info = {
              ip: socket.remoteAddress,
              family: socket.remoteFamily,
              port: socket.remotePort,
              header
            };
            if (!server.emit("connection", this, info)) {
              proto.disconnect(DISCONNECT_REASON.BY_APPLICATION);
              socket.end();
              return;
            }
            if (header.greeting) this.emit("greeting", header.greeting);
          }, "onHeader"),
          onHandshakeComplete: /* @__PURE__ */ __name((negotiated) => {
            if (++exchanges > 1) this.emit("rekey");
            this.emit("handshake", negotiated);
          }, "onHandshakeComplete"),
          debug: debug12,
          messageHandlers: {
            DEBUG: DEBUG_HANDLER,
            DISCONNECT: /* @__PURE__ */ __name((p, reason, desc) => {
              if (reason !== DISCONNECT_REASON.BY_APPLICATION) {
                if (!desc) {
                  desc = DISCONNECT_REASON_BY_VALUE[reason];
                  if (desc === void 0) desc = `Unexpected disconnection reason: ${reason}`;
                }
                const err = new Error(desc);
                err.code = reason;
                this.emit("error", err);
              }
              socket.end();
            }, "DISCONNECT"),
            CHANNEL_OPEN: /* @__PURE__ */ __name((p, info) => {
              if (info.type === "session" && this.noMoreSessions || !this.authenticated) {
                const reasonCode = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                return proto.channelOpenFail(info.sender, reasonCode);
              }
              let localChan = -1;
              let reason;
              let replied = false;
              let accept;
              const reject = /* @__PURE__ */ __name(() => {
                if (replied) return;
                replied = true;
                if (reason === void 0) {
                  if (localChan === -1) reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
                  else reason = CHANNEL_OPEN_FAILURE.CONNECT_FAILED;
                }
                if (localChan !== -1) this._chanMgr.remove(localChan);
                proto.channelOpenFail(info.sender, reason, "");
              }, "reject");
              const reserveChannel = /* @__PURE__ */ __name(() => {
                localChan = this._chanMgr.add();
                if (localChan === -1) {
                  reason = CHANNEL_OPEN_FAILURE.RESOURCE_SHORTAGE;
                  if (debug12) {
                    debug12("Automatic rejection of incoming channel open: no channels available");
                  }
                }
                return localChan !== -1;
              }, "reserveChannel");
              const data = info.data;
              switch (info.type) {
                case "session":
                  if (listenerCount(this, "session") && reserveChannel()) {
                    accept = /* @__PURE__ */ __name(() => {
                      if (replied) return;
                      replied = true;
                      const instance = new Session(this, info, localChan);
                      this._chanMgr.update(localChan, instance);
                      proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);
                      return instance;
                    }, "accept");
                    this.emit("session", accept, reject);
                    return;
                  }
                  break;
                case "direct-tcpip":
                  if (listenerCount(this, "tcpip") && reserveChannel()) {
                    accept = /* @__PURE__ */ __name(() => {
                      if (replied) return;
                      replied = true;
                      const chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info.sender,
                          window: info.window,
                          packetSize: info.packetSize,
                          state: "open"
                        }
                      };
                      const stream = new Channel(this, chanInfo, {
                        server: true
                      });
                      this._chanMgr.update(localChan, stream);
                      proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);
                      return stream;
                    }, "accept");
                    this.emit("tcpip", accept, reject, data);
                    return;
                  }
                  break;
                case "direct-streamlocal@openssh.com":
                  if (listenerCount(this, "openssh.streamlocal") && reserveChannel()) {
                    accept = /* @__PURE__ */ __name(() => {
                      if (replied) return;
                      replied = true;
                      const chanInfo = {
                        type: void 0,
                        incoming: {
                          id: localChan,
                          window: MAX_WINDOW,
                          packetSize: PACKET_SIZE,
                          state: "open"
                        },
                        outgoing: {
                          id: info.sender,
                          window: info.window,
                          packetSize: info.packetSize,
                          state: "open"
                        }
                      };
                      const stream = new Channel(this, chanInfo, {
                        server: true
                      });
                      this._chanMgr.update(localChan, stream);
                      proto.channelOpenConfirm(info.sender, localChan, MAX_WINDOW, PACKET_SIZE);
                      return stream;
                    }, "accept");
                    this.emit("openssh.streamlocal", accept, reject, data);
                    return;
                  }
                  break;
                default:
                  reason = CHANNEL_OPEN_FAILURE.UNKNOWN_CHANNEL_TYPE;
                  if (debug12) {
                    debug12(`Automatic rejection of unsupported incoming channel open type: ${info.type}`);
                  }
              }
              if (reason === void 0) {
                reason = CHANNEL_OPEN_FAILURE.ADMINISTRATIVELY_PROHIBITED;
                if (debug12) {
                  debug12(`Automatic rejection of unexpected incoming channel open for: ${info.type}`);
                }
              }
              reject();
            }, "CHANNEL_OPEN"),
            CHANNEL_OPEN_CONFIRMATION: /* @__PURE__ */ __name((p, info) => {
              const channel = this._chanMgr.get(info.recipient);
              if (typeof channel !== "function") return;
              const chanInfo = {
                type: channel.type,
                incoming: {
                  id: info.recipient,
                  window: MAX_WINDOW,
                  packetSize: PACKET_SIZE,
                  state: "open"
                },
                outgoing: {
                  id: info.sender,
                  window: info.window,
                  packetSize: info.packetSize,
                  state: "open"
                }
              };
              const instance = new Channel(this, chanInfo, {
                server: true
              });
              this._chanMgr.update(info.recipient, instance);
              channel(void 0, instance);
            }, "CHANNEL_OPEN_CONFIRMATION"),
            CHANNEL_OPEN_FAILURE: /* @__PURE__ */ __name((p, recipient, reason, description) => {
              const channel = this._chanMgr.get(recipient);
              if (typeof channel !== "function") return;
              const info = {
                reason,
                description
              };
              onChannelOpenFailure(this, recipient, info, channel);
            }, "CHANNEL_OPEN_FAILURE"),
            CHANNEL_DATA: /* @__PURE__ */ __name((p, recipient, data) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel) return;
              }
              if (channel.incoming.window === 0) return;
              channel.incoming.window -= data.length;
              if (channel.push(data) === false) {
                channel._waitChanDrain = true;
                return;
              }
              if (channel.incoming.window <= WINDOW_THRESHOLD) windowAdjust(channel);
            }, "CHANNEL_DATA"),
            CHANNEL_EXTENDED_DATA: /* @__PURE__ */ __name((p, recipient, data, type) => {
            }, "CHANNEL_EXTENDED_DATA"),
            CHANNEL_WINDOW_ADJUST: /* @__PURE__ */ __name((p, recipient, amount) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel) return;
              }
              channel.outgoing.window += amount;
              if (channel._waitWindow) {
                channel._waitWindow = false;
                if (channel._chunk) {
                  channel._write(channel._chunk, null, channel._chunkcb);
                } else if (channel._chunkcb) {
                  channel._chunkcb();
                } else if (channel._chunkErr) {
                  channel.stderr._write(channel._chunkErr, null, channel._chunkcbErr);
                } else if (channel._chunkcbErr) {
                  channel._chunkcbErr();
                }
              }
            }, "CHANNEL_WINDOW_ADJUST"),
            CHANNEL_SUCCESS: /* @__PURE__ */ __name((p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel) return;
              }
              if (channel._callbacks.length) channel._callbacks.shift()(false);
            }, "CHANNEL_SUCCESS"),
            CHANNEL_FAILURE: /* @__PURE__ */ __name((p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.constructor === Session) {
                channel = channel._channel;
                if (!channel) return;
              }
              if (channel._callbacks.length) channel._callbacks.shift()(true);
            }, "CHANNEL_FAILURE"),
            CHANNEL_REQUEST: /* @__PURE__ */ __name((p, recipient, type, wantReply, data) => {
              const session = this._chanMgr.get(recipient);
              if (typeof session !== "object" || session === null) return;
              let replied = false;
              let accept;
              let reject;
              if (session.constructor !== Session) {
                if (wantReply) proto.channelFailure(session.outgoing.id);
                return;
              }
              if (wantReply) {
                if (type !== "shell" && type !== "exec" && type !== "subsystem") {
                  accept = /* @__PURE__ */ __name(() => {
                    if (replied || session._ending || session._channel) return;
                    replied = true;
                    proto.channelSuccess(session._chanInfo.outgoing.id);
                  }, "accept");
                }
                reject = /* @__PURE__ */ __name(() => {
                  if (replied || session._ending || session._channel) return;
                  replied = true;
                  proto.channelFailure(session._chanInfo.outgoing.id);
                }, "reject");
              }
              if (session._ending) {
                reject && reject();
                return;
              }
              switch (type) {
                // "pre-real session start" requests
                case "env":
                  if (listenerCount(session, "env")) {
                    session.emit("env", accept, reject, {
                      key: data.name,
                      val: data.value
                    });
                    return;
                  }
                  break;
                case "pty-req":
                  if (listenerCount(session, "pty")) {
                    session.emit("pty", accept, reject, data);
                    return;
                  }
                  break;
                case "window-change":
                  if (listenerCount(session, "window-change")) session.emit("window-change", accept, reject, data);
                  else reject && reject();
                  break;
                case "x11-req":
                  if (listenerCount(session, "x11")) {
                    session.emit("x11", accept, reject, data);
                    return;
                  }
                  break;
                // "post-real session start" requests
                case "signal":
                  if (listenerCount(session, "signal")) {
                    session.emit("signal", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                // XXX: is `auth-agent-req@openssh.com` really "post-real session
                // start"?
                case "auth-agent-req@openssh.com":
                  if (listenerCount(session, "auth-agent")) {
                    session.emit("auth-agent", accept, reject);
                    return;
                  }
                  break;
                // "real session start" requests
                case "shell":
                  if (listenerCount(session, "shell")) {
                    accept = /* @__PURE__ */ __name(() => {
                      if (replied || session._ending || session._channel) return;
                      replied = true;
                      if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);
                      const channel = new Channel(this, session._chanInfo, {
                        server: true
                      });
                      channel.subtype = session.subtype = type;
                      session._channel = channel;
                      return channel;
                    }, "accept");
                    session.emit("shell", accept, reject);
                    return;
                  }
                  break;
                case "exec":
                  if (listenerCount(session, "exec")) {
                    accept = /* @__PURE__ */ __name(() => {
                      if (replied || session._ending || session._channel) return;
                      replied = true;
                      if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);
                      const channel = new Channel(this, session._chanInfo, {
                        server: true
                      });
                      channel.subtype = session.subtype = type;
                      session._channel = channel;
                      return channel;
                    }, "accept");
                    session.emit("exec", accept, reject, {
                      command: data
                    });
                    return;
                  }
                  break;
                case "subsystem": {
                  let useSFTP = data === "sftp";
                  accept = /* @__PURE__ */ __name(() => {
                    if (replied || session._ending || session._channel) return;
                    replied = true;
                    if (wantReply) proto.channelSuccess(session._chanInfo.outgoing.id);
                    let instance;
                    if (useSFTP) {
                      instance = new SFTP(this, session._chanInfo, {
                        server: true,
                        debug: debug12
                      });
                    } else {
                      instance = new Channel(this, session._chanInfo, {
                        server: true
                      });
                      instance.subtype = session.subtype = `${type}:${data}`;
                    }
                    session._channel = instance;
                    return instance;
                  }, "accept");
                  if (data === "sftp") {
                    if (listenerCount(session, "sftp")) {
                      session.emit("sftp", accept, reject);
                      return;
                    }
                    useSFTP = false;
                  }
                  if (listenerCount(session, "subsystem")) {
                    session.emit("subsystem", accept, reject, {
                      name: data
                    });
                    return;
                  }
                  break;
                }
              }
              debug12 && debug12(`Automatic rejection of incoming channel request: ${type}`);
              reject && reject();
            }, "CHANNEL_REQUEST"),
            CHANNEL_EOF: /* @__PURE__ */ __name((p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.constructor === Session) {
                if (!channel._ending) {
                  channel._ending = true;
                  channel.emit("eof");
                  channel.emit("end");
                }
                channel = channel._channel;
                if (!channel) return;
              }
              if (channel.incoming.state !== "open") return;
              channel.incoming.state = "eof";
              if (channel.readable) channel.push(null);
            }, "CHANNEL_EOF"),
            CHANNEL_CLOSE: /* @__PURE__ */ __name((p, recipient) => {
              let channel = this._chanMgr.get(recipient);
              if (typeof channel !== "object" || channel === null) return;
              if (channel.constructor === Session) {
                channel._ending = true;
                channel.emit("close");
                channel = channel._channel;
                if (!channel) return;
              }
              onCHANNEL_CLOSE(this, recipient, channel);
            }, "CHANNEL_CLOSE"),
            // Begin service/auth-related ==========================================
            SERVICE_REQUEST: /* @__PURE__ */ __name((p, service) => {
              if (exchanges === 0 || acceptedAuthSvc || this.authenticated || service !== "ssh-userauth") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
                socket.end();
                return;
              }
              acceptedAuthSvc = true;
              proto.serviceAccept(service);
            }, "SERVICE_REQUEST"),
            USERAUTH_REQUEST: /* @__PURE__ */ __name((p, username, service, method, methodData) => {
              if (exchanges === 0 || this.authenticated || authCtx && (authCtx.username !== username || authCtx.service !== service) || method !== "password" && method !== "publickey" && method !== "hostbased" && method !== "keyboard-interactive" && method !== "none" || pendingAuths.length === MAX_PENDING_AUTHS) {
                proto.disconnect(DISCONNECT_REASON.PROTOCOL_ERROR);
                socket.end();
                return;
              } else if (service !== "ssh-connection") {
                proto.disconnect(DISCONNECT_REASON.SERVICE_NOT_AVAILABLE);
                socket.end();
                return;
              }
              let ctx;
              switch (method) {
                case "keyboard-interactive":
                  ctx = new KeyboardAuthContext(proto, username, service, method, methodData, onAuthDecide);
                  break;
                case "publickey":
                  ctx = new PKAuthContext(proto, username, service, method, methodData, onAuthDecide);
                  break;
                case "hostbased":
                  ctx = new HostbasedAuthContext(proto, username, service, method, methodData, onAuthDecide);
                  break;
                case "password":
                  if (authCtx && authCtx instanceof PwdAuthContext && authCtx._changeCb) {
                    const cb = authCtx._changeCb;
                    authCtx._changeCb = void 0;
                    cb(methodData.newPassword);
                    return;
                  }
                  ctx = new PwdAuthContext(proto, username, service, method, methodData, onAuthDecide);
                  break;
                case "none":
                  ctx = new AuthContext(proto, username, service, method, onAuthDecide);
                  break;
              }
              if (authCtx) {
                if (!authCtx._initialResponse) {
                  return pendingAuths.push(ctx);
                } else if (authCtx._multistep && !authCtx._finalResponse) {
                  authCtx._cleanup && authCtx._cleanup();
                  authCtx.emit("abort");
                }
              }
              authCtx = ctx;
              if (listenerCount(this, "authentication")) this.emit("authentication", authCtx);
              else authCtx.reject();
            }, "USERAUTH_REQUEST"),
            USERAUTH_INFO_RESPONSE: /* @__PURE__ */ __name((p, responses) => {
              if (authCtx && authCtx instanceof KeyboardAuthContext) authCtx._onInfoResponse(responses);
            }, "USERAUTH_INFO_RESPONSE"),
            // End service/auth-related ============================================
            GLOBAL_REQUEST: /* @__PURE__ */ __name((p, name, wantReply, data) => {
              const reply = {
                type: null,
                buf: null
              };
              function setReply(type, buf) {
                reply.type = type;
                reply.buf = buf;
                sendReplies();
              }
              __name(setReply, "setReply");
              if (wantReply) unsentGlobalRequestsReplies.push(reply);
              if ((name === "tcpip-forward" || name === "cancel-tcpip-forward" || name === "no-more-sessions@openssh.com" || name === "streamlocal-forward@openssh.com" || name === "cancel-streamlocal-forward@openssh.com") && listenerCount(this, "request") && this.authenticated) {
                let accept;
                let reject;
                if (wantReply) {
                  let replied = false;
                  accept = /* @__PURE__ */ __name((chosenPort) => {
                    if (replied) return;
                    replied = true;
                    let bufPort;
                    if (name === "tcpip-forward" && data.bindPort === 0 && typeof chosenPort === "number") {
                      bufPort = Buffer.allocUnsafe(4);
                      writeUInt32BE(bufPort, chosenPort, 0);
                    }
                    setReply("SUCCESS", bufPort);
                  }, "accept");
                  reject = /* @__PURE__ */ __name(() => {
                    if (replied) return;
                    replied = true;
                    setReply("FAILURE");
                  }, "reject");
                }
                if (name === "no-more-sessions@openssh.com") {
                  this.noMoreSessions = true;
                  accept && accept();
                  return;
                }
                this.emit("request", accept, reject, name, data);
              } else if (wantReply) {
                setReply("FAILURE");
              }
            }, "GLOBAL_REQUEST")
          }
        });
        socket.pause();
        cryptoInit.then(() => {
          proto.start();
          socket.on("data", (data) => {
            try {
              proto.parse(data, 0, data.length);
            } catch (ex) {
              this.emit("error", ex);
              try {
                if (isWritable(socket)) socket.end();
              } catch {
              }
            }
          });
          socket.resume();
        }).catch((err) => {
          this.emit("error", err);
          try {
            if (isWritable(socket)) socket.end();
          } catch {
          }
        });
        socket.on("error", (err) => {
          err.level = "socket";
          this.emit("error", err);
        }).once("end", () => {
          debug12 && debug12("Socket ended");
          proto.cleanup();
          this.emit("end");
        }).once("close", () => {
          debug12 && debug12("Socket closed");
          proto.cleanup();
          this.emit("close");
          const err = new Error("No response from server");
          this._chanMgr.cleanup(err);
        });
        const onAuthDecide = /* @__PURE__ */ __name((ctx, allowed, methodsLeft, isPartial) => {
          if (authCtx === ctx && !this.authenticated) {
            if (allowed) {
              authCtx = void 0;
              this.authenticated = true;
              proto.authSuccess();
              pendingAuths = [];
              this.emit("ready");
            } else {
              proto.authFailure(methodsLeft, isPartial);
              if (pendingAuths.length) {
                authCtx = pendingAuths.pop();
                if (listenerCount(this, "authentication")) this.emit("authentication", authCtx);
                else authCtx.reject();
              }
            }
          }
        }, "onAuthDecide");
        function sendReplies() {
          while (unsentGlobalRequestsReplies.length > 0 && unsentGlobalRequestsReplies[0].type) {
            const reply = unsentGlobalRequestsReplies.shift();
            if (reply.type === "SUCCESS") proto.requestSuccess(reply.buf);
            if (reply.type === "FAILURE") proto.requestFailure();
          }
        }
        __name(sendReplies, "sendReplies");
      }
      end() {
        if (this._sock && isWritable(this._sock)) {
          this._protocol.disconnect(DISCONNECT_REASON.BY_APPLICATION);
          this._sock.end();
        }
        return this;
      }
      x11(originAddr, originPort, cb) {
        const opts = {
          originAddr,
          originPort
        };
        openChannel(this, "x11", opts, cb);
        return this;
      }
      forwardOut(boundAddr, boundPort, remoteAddr, remotePort, cb) {
        const opts = {
          boundAddr,
          boundPort,
          remoteAddr,
          remotePort
        };
        openChannel(this, "forwarded-tcpip", opts, cb);
        return this;
      }
      openssh_forwardOutStreamLocal(socketPath, cb) {
        const opts = {
          socketPath
        };
        openChannel(this, "forwarded-streamlocal@openssh.com", opts, cb);
        return this;
      }
      rekey(cb) {
        let error;
        try {
          this._protocol.rekey();
        } catch (ex) {
          error = ex;
        }
        if (typeof cb === "function") {
          if (error) process.nextTick(cb, error);
          else this.once("rekey", cb);
        }
      }
      setNoDelay(noDelay) {
        if (this._sock && typeof this._sock.setNoDelay === "function") this._sock.setNoDelay(noDelay);
        return this;
      }
    };
    function openChannel(self2, type, opts, cb) {
      const initWindow = MAX_WINDOW;
      const maxPacket = PACKET_SIZE;
      if (typeof opts === "function") {
        cb = opts;
        opts = {};
      }
      const wrapper = /* @__PURE__ */ __name((err, stream) => {
        cb(err, stream);
      }, "wrapper");
      wrapper.type = type;
      const localChan = self2._chanMgr.add(wrapper);
      if (localChan === -1) {
        cb(new Error("No free channels available"));
        return;
      }
      switch (type) {
        case "forwarded-tcpip":
          self2._protocol.forwardedTcpip(localChan, initWindow, maxPacket, opts);
          break;
        case "x11":
          self2._protocol.x11(localChan, initWindow, maxPacket, opts);
          break;
        case "forwarded-streamlocal@openssh.com":
          self2._protocol.openssh_forwardedStreamLocal(localChan, initWindow, maxPacket, opts);
          break;
        default:
          throw new Error(`Unsupported channel type: ${type}`);
      }
    }
    __name(openChannel, "openChannel");
    function compareNumbers(a, b) {
      return a - b;
    }
    __name(compareNumbers, "compareNumbers");
    module2.exports = Server;
    module2.exports.IncomingClient = Client;
  }
});

// node_modules/ssh2/lib/keygen.js
var require_keygen = __commonJS({
  "node_modules/ssh2/lib/keygen.js"(exports2, module2) {
    "use strict";
    var { createCipheriv, generateKeyPair: generateKeyPair_, generateKeyPairSync: generateKeyPairSync_, getCurves, randomBytes } = require("crypto");
    var { Ber } = require_lib2();
    var bcrypt_pbkdf = require_bcrypt_pbkdf().pbkdf;
    var { CIPHER_INFO } = require_crypto();
    var SALT_LEN = 16;
    var DEFAULT_ROUNDS = 16;
    var curves = getCurves();
    var ciphers = new Map(Object.entries(CIPHER_INFO));
    function makeArgs(type, opts) {
      if (typeof type !== "string") throw new TypeError("Key type must be a string");
      const publicKeyEncoding = {
        type: "spki",
        format: "der"
      };
      const privateKeyEncoding = {
        type: "pkcs8",
        format: "der"
      };
      switch (type.toLowerCase()) {
        case "rsa": {
          if (typeof opts !== "object" || opts === null) throw new TypeError("Missing options object for RSA key");
          const modulusLength = opts.bits;
          if (!Number.isInteger(modulusLength)) throw new TypeError("RSA bits must be an integer");
          if (modulusLength <= 0 || modulusLength > 16384) throw new RangeError("RSA bits must be non-zero and <= 16384");
          return [
            "rsa",
            {
              modulusLength,
              publicKeyEncoding,
              privateKeyEncoding
            }
          ];
        }
        case "ecdsa": {
          if (typeof opts !== "object" || opts === null) throw new TypeError("Missing options object for ECDSA key");
          if (!Number.isInteger(opts.bits)) throw new TypeError("ECDSA bits must be an integer");
          let namedCurve;
          switch (opts.bits) {
            case 256:
              namedCurve = "prime256v1";
              break;
            case 384:
              namedCurve = "secp384r1";
              break;
            case 521:
              namedCurve = "secp521r1";
              break;
            default:
              throw new Error("ECDSA bits must be 256, 384, or 521");
          }
          if (!curves.includes(namedCurve)) throw new Error("Unsupported ECDSA bits value");
          return [
            "ec",
            {
              namedCurve,
              publicKeyEncoding,
              privateKeyEncoding
            }
          ];
        }
        case "ed25519":
          return [
            "ed25519",
            {
              publicKeyEncoding,
              privateKeyEncoding
            }
          ];
        default:
          throw new Error(`Unsupported key type: ${type}`);
      }
    }
    __name(makeArgs, "makeArgs");
    function parseDERs(keyType, pub, priv) {
      switch (keyType) {
        case "rsa": {
          let reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0) throw new Error("Unsupported version in RSA private key");
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.113549.1.1.1") throw new Error("Bad RSA private OID");
          if (reader.readByte() !== Ber.Null) throw new Error("Malformed RSA private key (expected null)");
          if (reader.readByte() !== 0) {
            throw new Error("Malformed RSA private key (expected zero-length null)");
          }
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          reader.readSequence();
          if (reader.readInt() !== 0) throw new Error("Unsupported version in RSA private key");
          const n = reader.readString(Ber.Integer, true);
          const e = reader.readString(Ber.Integer, true);
          const d = reader.readString(Ber.Integer, true);
          const p = reader.readString(Ber.Integer, true);
          const q = reader.readString(Ber.Integer, true);
          reader.readString(Ber.Integer, true);
          reader.readString(Ber.Integer, true);
          const iqmp = reader.readString(Ber.Integer, true);
          const keyName = Buffer.from("ssh-rsa");
          const privBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + n.length + 4 + e.length + 4 + d.length + 4 + iqmp.length + 4 + p.length + 4 + q.length);
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(n.length, pos += keyName.length);
          privBuf.set(n, pos += 4);
          privBuf.writeUInt32BE(e.length, pos += n.length);
          privBuf.set(e, pos += 4);
          privBuf.writeUInt32BE(d.length, pos += e.length);
          privBuf.set(d, pos += 4);
          privBuf.writeUInt32BE(iqmp.length, pos += d.length);
          privBuf.set(iqmp, pos += 4);
          privBuf.writeUInt32BE(p.length, pos += iqmp.length);
          privBuf.set(p, pos += 4);
          privBuf.writeUInt32BE(q.length, pos += p.length);
          privBuf.set(q, pos += 4);
          const pubBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + e.length + 4 + n.length);
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(e.length, pos += keyName.length);
          pubBuf.set(e, pos += 4);
          pubBuf.writeUInt32BE(n.length, pos += e.length);
          pubBuf.set(n, pos += 4);
          return {
            sshName: keyName.toString(),
            priv: privBuf,
            pub: pubBuf
          };
        }
        case "ec": {
          let reader = new Ber.Reader(pub);
          reader.readSequence();
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.10045.2.1") throw new Error("Bad ECDSA public OID");
          reader.readOID();
          let pubBin = reader.readString(Ber.BitString, true);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i) ;
            if (i > 0) pubBin = pubBin.slice(i);
          }
          reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0) throw new Error("Unsupported version in ECDSA private key");
          reader.readSequence();
          if (reader.readOID() !== "1.2.840.10045.2.1") throw new Error("Bad ECDSA private OID");
          const curveOID = reader.readOID();
          let sshCurveName;
          switch (curveOID) {
            case "1.2.840.10045.3.1.7":
              sshCurveName = "nistp256";
              break;
            case "1.3.132.0.34":
              sshCurveName = "nistp384";
              break;
            case "1.3.132.0.35":
              sshCurveName = "nistp521";
              break;
            default:
              throw new Error("Unsupported curve in ECDSA private key");
          }
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          reader.readSequence();
          if (reader.readInt() !== 1) throw new Error("Unsupported version in ECDSA private key");
          const privBin = Buffer.concat([
            Buffer.from([
              0
            ]),
            reader.readString(Ber.OctetString, true)
          ]);
          const keyName = Buffer.from(`ecdsa-sha2-${sshCurveName}`);
          sshCurveName = Buffer.from(sshCurveName);
          const privBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length + 4 + privBin.length);
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);
          privBuf.set(sshCurveName, pos += 4);
          privBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);
          privBuf.set(pubBin, pos += 4);
          privBuf.writeUInt32BE(privBin.length, pos += pubBin.length);
          privBuf.set(privBin, pos += 4);
          const pubBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + sshCurveName.length + 4 + pubBin.length);
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(sshCurveName.length, pos += keyName.length);
          pubBuf.set(sshCurveName, pos += 4);
          pubBuf.writeUInt32BE(pubBin.length, pos += sshCurveName.length);
          pubBuf.set(pubBin, pos += 4);
          return {
            sshName: keyName.toString(),
            priv: privBuf,
            pub: pubBuf
          };
        }
        case "ed25519": {
          let reader = new Ber.Reader(pub);
          reader.readSequence();
          reader.readSequence();
          if (reader.readOID() !== "1.3.101.112") throw new Error("Bad ED25519 public OID");
          let pubBin = reader.readString(Ber.BitString, true);
          {
            let i = 0;
            for (; i < pubBin.length && pubBin[i] === 0; ++i) ;
            if (i > 0) pubBin = pubBin.slice(i);
          }
          reader = new Ber.Reader(priv);
          reader.readSequence();
          if (reader.readInt() !== 0) throw new Error("Unsupported version in ED25519 private key");
          reader.readSequence();
          if (reader.readOID() !== "1.3.101.112") throw new Error("Bad ED25519 private OID");
          reader = new Ber.Reader(reader.readString(Ber.OctetString, true));
          const privBin = reader.readString(Ber.OctetString, true);
          const keyName = Buffer.from("ssh-ed25519");
          const privBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + pubBin.length + 4 + (privBin.length + pubBin.length));
          let pos = 0;
          privBuf.writeUInt32BE(keyName.length, pos += 0);
          privBuf.set(keyName, pos += 4);
          privBuf.writeUInt32BE(pubBin.length, pos += keyName.length);
          privBuf.set(pubBin, pos += 4);
          privBuf.writeUInt32BE(privBin.length + pubBin.length, pos += pubBin.length);
          privBuf.set(privBin, pos += 4);
          privBuf.set(pubBin, pos += privBin.length);
          const pubBuf = Buffer.allocUnsafe(4 + keyName.length + 4 + pubBin.length);
          pos = 0;
          pubBuf.writeUInt32BE(keyName.length, pos += 0);
          pubBuf.set(keyName, pos += 4);
          pubBuf.writeUInt32BE(pubBin.length, pos += keyName.length);
          pubBuf.set(pubBin, pos += 4);
          return {
            sshName: keyName.toString(),
            priv: privBuf,
            pub: pubBuf
          };
        }
      }
    }
    __name(parseDERs, "parseDERs");
    function convertKeys(keyType, pub, priv, opts) {
      let format5 = "new";
      let encrypted;
      let comment = "";
      if (typeof opts === "object" && opts !== null) {
        if (typeof opts.comment === "string" && opts.comment) comment = opts.comment;
        if (typeof opts.format === "string" && opts.format) format5 = opts.format;
        if (opts.passphrase) {
          let passphrase;
          if (typeof opts.passphrase === "string") passphrase = Buffer.from(opts.passphrase);
          else if (Buffer.isBuffer(opts.passphrase)) passphrase = opts.passphrase;
          else throw new Error("Invalid passphrase");
          if (opts.cipher === void 0) throw new Error("Missing cipher name");
          const cipher = ciphers.get(opts.cipher);
          if (cipher === void 0) throw new Error("Invalid cipher name");
          if (format5 === "new") {
            let rounds = DEFAULT_ROUNDS;
            if (opts.rounds !== void 0) {
              if (!Number.isInteger(opts.rounds)) throw new TypeError("rounds must be an integer");
              if (opts.rounds > 0) rounds = opts.rounds;
            }
            const gen = Buffer.allocUnsafe(cipher.keyLen + cipher.ivLen);
            const salt = randomBytes(SALT_LEN);
            const r = bcrypt_pbkdf(passphrase, passphrase.length, salt, salt.length, gen, gen.length, rounds);
            if (r !== 0) return new Error("Failed to generate information to encrypt key");
            const kdfOptions = Buffer.allocUnsafe(4 + salt.length + 4);
            {
              let pos = 0;
              kdfOptions.writeUInt32BE(salt.length, pos += 0);
              kdfOptions.set(salt, pos += 4);
              kdfOptions.writeUInt32BE(rounds, pos += salt.length);
            }
            encrypted = {
              cipher,
              cipherName: opts.cipher,
              kdfName: "bcrypt",
              kdfOptions,
              key: gen.slice(0, cipher.keyLen),
              iv: gen.slice(cipher.keyLen)
            };
          }
        }
      }
      switch (format5) {
        case "new": {
          let privateB64 = "-----BEGIN OPENSSH PRIVATE KEY-----\n";
          let publicB64;
          const cipherName = Buffer.from(encrypted ? encrypted.cipherName : "none");
          const kdfName = Buffer.from(encrypted ? encrypted.kdfName : "none");
          const kdfOptions = encrypted ? encrypted.kdfOptions : Buffer.alloc(0);
          const blockLen = encrypted ? encrypted.cipher.blockLen : 8;
          const parsed = parseDERs(keyType, pub, priv);
          const checkInt = randomBytes(4);
          const commentBin = Buffer.from(comment);
          const privBlobLen = 4 + 4 + parsed.priv.length + 4 + commentBin.length;
          let padding = [];
          for (let i = 1; (privBlobLen + padding.length) % blockLen; ++i) padding.push(i & 255);
          padding = Buffer.from(padding);
          let privBlob = Buffer.allocUnsafe(privBlobLen + padding.length);
          let extra;
          {
            let pos = 0;
            privBlob.set(checkInt, pos += 0);
            privBlob.set(checkInt, pos += 4);
            privBlob.set(parsed.priv, pos += 4);
            privBlob.writeUInt32BE(commentBin.length, pos += parsed.priv.length);
            privBlob.set(commentBin, pos += 4);
            privBlob.set(padding, pos += commentBin.length);
          }
          if (encrypted) {
            const options = {
              authTagLength: encrypted.cipher.authLen
            };
            const cipher = createCipheriv(encrypted.cipher.sslName, encrypted.key, encrypted.iv, options);
            cipher.setAutoPadding(false);
            privBlob = Buffer.concat([
              cipher.update(privBlob),
              cipher.final()
            ]);
            if (encrypted.cipher.authLen > 0) extra = cipher.getAuthTag();
            else extra = Buffer.alloc(0);
            encrypted.key.fill(0);
            encrypted.iv.fill(0);
          } else {
            extra = Buffer.alloc(0);
          }
          const magicBytes = Buffer.from("openssh-key-v1\0");
          const privBin = Buffer.allocUnsafe(magicBytes.length + 4 + cipherName.length + 4 + kdfName.length + 4 + kdfOptions.length + 4 + 4 + parsed.pub.length + 4 + privBlob.length + extra.length);
          {
            let pos = 0;
            privBin.set(magicBytes, pos += 0);
            privBin.writeUInt32BE(cipherName.length, pos += magicBytes.length);
            privBin.set(cipherName, pos += 4);
            privBin.writeUInt32BE(kdfName.length, pos += cipherName.length);
            privBin.set(kdfName, pos += 4);
            privBin.writeUInt32BE(kdfOptions.length, pos += kdfName.length);
            privBin.set(kdfOptions, pos += 4);
            privBin.writeUInt32BE(1, pos += kdfOptions.length);
            privBin.writeUInt32BE(parsed.pub.length, pos += 4);
            privBin.set(parsed.pub, pos += 4);
            privBin.writeUInt32BE(privBlob.length, pos += parsed.pub.length);
            privBin.set(privBlob, pos += 4);
            privBin.set(extra, pos += privBlob.length);
          }
          {
            const b64 = privBin.base64Slice(0, privBin.length);
            let formatted = b64.replace(/.{64}/g, "$&\n");
            if (b64.length & 63) formatted += "\n";
            privateB64 += formatted;
          }
          {
            const b64 = parsed.pub.base64Slice(0, parsed.pub.length);
            publicB64 = `${parsed.sshName} ${b64}${comment ? ` ${comment}` : ""}`;
          }
          privateB64 += "-----END OPENSSH PRIVATE KEY-----\n";
          return {
            private: privateB64,
            public: publicB64
          };
        }
        default:
          throw new Error("Invalid output key format");
      }
    }
    __name(convertKeys, "convertKeys");
    function noop() {
    }
    __name(noop, "noop");
    module2.exports = {
      generateKeyPair: /* @__PURE__ */ __name((keyType, opts, cb) => {
        if (typeof opts === "function") {
          cb = opts;
          opts = void 0;
        }
        if (typeof cb !== "function") cb = noop;
        const args = makeArgs(keyType, opts);
        generateKeyPair_(...args, (err, pub, priv) => {
          if (err) return cb(err);
          let ret;
          try {
            ret = convertKeys(args[0], pub, priv, opts);
          } catch (ex) {
            return cb(ex);
          }
          cb(null, ret);
        });
      }, "generateKeyPair"),
      generateKeyPairSync: /* @__PURE__ */ __name((keyType, opts) => {
        const args = makeArgs(keyType, opts);
        const { publicKey: pub, privateKey: priv } = generateKeyPairSync_(...args);
        return convertKeys(args[0], pub, priv, opts);
      }, "generateKeyPairSync")
    };
  }
});

// node_modules/ssh2/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/ssh2/lib/index.js"(exports2, module2) {
    "use strict";
    var { AgentProtocol, BaseAgent, createAgent, CygwinAgent, OpenSSHAgent, PageantAgent } = require_agent();
    var { SSHTTPAgent: HTTPAgent, SSHTTPSAgent: HTTPSAgent } = require_http_agents();
    var { parseKey } = require_keyParser();
    var { flagsToString, OPEN_MODE, STATUS_CODE, stringToFlags } = require_SFTP();
    module2.exports = {
      AgentProtocol,
      BaseAgent,
      createAgent,
      Client: require_client(),
      CygwinAgent,
      HTTPAgent,
      HTTPSAgent,
      OpenSSHAgent,
      PageantAgent,
      Server: require_server(),
      utils: {
        parseKey,
        ...require_keygen(),
        sftp: {
          flagsToString,
          OPEN_MODE,
          STATUS_CODE,
          stringToFlags
        }
      }
    };
  }
});

// node_modules/docker-modem/lib/ssh.js
var require_ssh = __commonJS({
  "node_modules/docker-modem/lib/ssh.js"(exports2, module2) {
    "use strict";
    var Client = require_lib4().Client;
    var http = require("http");
    module2.exports = function(opt) {
      var conn = new Client();
      var agent = new http.Agent();
      agent.createConnection = function(options, fn) {
        try {
          conn.once("ready", function() {
            conn.exec("docker system dial-stdio", function(err, stream) {
              if (err) {
                handleError(err, fn);
              }
              fn(null, stream);
              stream.addListener("error", (err2) => {
                handleError(err2, fn);
              });
              stream.once("close", () => {
                conn.end();
                agent.destroy();
              });
            });
          }).on("error", (err) => {
            handleError(err, fn);
          }).connect(opt);
          conn.once("end", () => agent.destroy());
        } catch (err) {
          handleError(err);
        }
      };
      function handleError(err, cb) {
        conn.end();
        agent.destroy();
        if (cb) {
          cb(err);
        } else {
          throw err;
        }
      }
      __name(handleError, "handleError");
      return agent;
    };
  }
});

// node_modules/docker-modem/lib/http_duplex.js
var require_http_duplex = __commonJS({
  "node_modules/docker-modem/lib/http_duplex.js"(exports2, module2) {
    "use strict";
    module2.exports = HttpDuplex;
    var util2 = require("util");
    var stream = require_readable();
    util2.inherits(HttpDuplex, stream.Duplex);
    function HttpDuplex(req, res, options) {
      var self2 = this;
      if (!(self2 instanceof HttpDuplex)) return new HttpDuplex(req, res, options);
      stream.Duplex.call(self2, options);
      self2._output = null;
      self2.connect(req, res);
    }
    __name(HttpDuplex, "HttpDuplex");
    HttpDuplex.prototype.connect = function(req, res) {
      var self2 = this;
      self2.req = req;
      self2._output = res;
      self2.emit("response", res);
      res.on("data", function(c) {
        if (!self2.push(c)) self2._output.pause();
      });
      res.on("end", function() {
        self2.push(null);
      });
    };
    HttpDuplex.prototype._read = function(n) {
      if (this._output) this._output.resume();
    };
    HttpDuplex.prototype._write = function(chunk, encoding, cb) {
      this.req.write(chunk, encoding);
      cb();
    };
    HttpDuplex.prototype.end = function(chunk, encoding, cb) {
      this._output.socket.destroySoon();
      return this.req.end(chunk, encoding, cb);
    };
    HttpDuplex.prototype.destroy = function() {
      this.req.destroy();
      this._output.socket.destroy();
    };
    HttpDuplex.prototype.destroySoon = function() {
      this.req.destroy();
      this._output.socket.destroy();
    };
  }
});

// node_modules/debug/src/common.js
var require_common5 = __commonJS({
  "node_modules/debug/src/common.js"(exports2, module2) {
    "use strict";
    function setup(env2) {
      createDebug.debug = createDebug;
      createDebug.default = createDebug;
      createDebug.coerce = coerce2;
      createDebug.disable = disable;
      createDebug.enable = enable;
      createDebug.enabled = enabled;
      createDebug.humanize = require_ms();
      createDebug.destroy = destroy;
      Object.keys(env2).forEach((key) => {
        createDebug[key] = env2[key];
      });
      createDebug.names = [];
      createDebug.skips = [];
      createDebug.formatters = {};
      function selectColor(namespace) {
        let hash = 0;
        for (let i = 0; i < namespace.length; i++) {
          hash = (hash << 5) - hash + namespace.charCodeAt(i);
          hash |= 0;
        }
        return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
      }
      __name(selectColor, "selectColor");
      createDebug.selectColor = selectColor;
      function createDebug(namespace) {
        let prevTime;
        let enableOverride = null;
        let namespacesCache;
        let enabledCache;
        function debug12(...args) {
          if (!debug12.enabled) {
            return;
          }
          const self2 = debug12;
          const curr = Number(/* @__PURE__ */ new Date());
          const ms = curr - (prevTime || curr);
          self2.diff = ms;
          self2.prev = prevTime;
          self2.curr = curr;
          prevTime = curr;
          args[0] = createDebug.coerce(args[0]);
          if (typeof args[0] !== "string") {
            args.unshift("%O");
          }
          let index = 0;
          args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format5) => {
            if (match === "%%") {
              return "%";
            }
            index++;
            const formatter = createDebug.formatters[format5];
            if (typeof formatter === "function") {
              const val = args[index];
              match = formatter.call(self2, val);
              args.splice(index, 1);
              index--;
            }
            return match;
          });
          createDebug.formatArgs.call(self2, args);
          const logFn = self2.log || createDebug.log;
          logFn.apply(self2, args);
        }
        __name(debug12, "debug");
        debug12.namespace = namespace;
        debug12.useColors = createDebug.useColors();
        debug12.color = createDebug.selectColor(namespace);
        debug12.extend = extend;
        debug12.destroy = createDebug.destroy;
        Object.defineProperty(debug12, "enabled", {
          enumerable: true,
          configurable: false,
          get: /* @__PURE__ */ __name(() => {
            if (enableOverride !== null) {
              return enableOverride;
            }
            if (namespacesCache !== createDebug.namespaces) {
              namespacesCache = createDebug.namespaces;
              enabledCache = createDebug.enabled(namespace);
            }
            return enabledCache;
          }, "get"),
          set: /* @__PURE__ */ __name((v) => {
            enableOverride = v;
          }, "set")
        });
        if (typeof createDebug.init === "function") {
          createDebug.init(debug12);
        }
        return debug12;
      }
      __name(createDebug, "createDebug");
      function extend(namespace, delimiter) {
        const newDebug = createDebug(this.namespace + (typeof delimiter === "undefined" ? ":" : delimiter) + namespace);
        newDebug.log = this.log;
        return newDebug;
      }
      __name(extend, "extend");
      function enable(namespaces) {
        createDebug.save(namespaces);
        createDebug.namespaces = namespaces;
        createDebug.names = [];
        createDebug.skips = [];
        const split = (typeof namespaces === "string" ? namespaces : "").trim().replace(" ", ",").split(",").filter(Boolean);
        for (const ns of split) {
          if (ns[0] === "-") {
            createDebug.skips.push(ns.slice(1));
          } else {
            createDebug.names.push(ns);
          }
        }
      }
      __name(enable, "enable");
      function matchesTemplate(search, template) {
        let searchIndex = 0;
        let templateIndex = 0;
        let starIndex = -1;
        let matchIndex = 0;
        while (searchIndex < search.length) {
          if (templateIndex < template.length && (template[templateIndex] === search[searchIndex] || template[templateIndex] === "*")) {
            if (template[templateIndex] === "*") {
              starIndex = templateIndex;
              matchIndex = searchIndex;
              templateIndex++;
            } else {
              searchIndex++;
              templateIndex++;
            }
          } else if (starIndex !== -1) {
            templateIndex = starIndex + 1;
            matchIndex++;
            searchIndex = matchIndex;
          } else {
            return false;
          }
        }
        while (templateIndex < template.length && template[templateIndex] === "*") {
          templateIndex++;
        }
        return templateIndex === template.length;
      }
      __name(matchesTemplate, "matchesTemplate");
      function disable() {
        const namespaces = [
          ...createDebug.names,
          ...createDebug.skips.map((namespace) => "-" + namespace)
        ].join(",");
        createDebug.enable("");
        return namespaces;
      }
      __name(disable, "disable");
      function enabled(name) {
        for (const skip of createDebug.skips) {
          if (matchesTemplate(name, skip)) {
            return false;
          }
        }
        for (const ns of createDebug.names) {
          if (matchesTemplate(name, ns)) {
            return true;
          }
        }
        return false;
      }
      __name(enabled, "enabled");
      function coerce2(val) {
        if (val instanceof Error) {
          return val.stack || val.message;
        }
        return val;
      }
      __name(coerce2, "coerce");
      function destroy() {
        console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
      }
      __name(destroy, "destroy");
      createDebug.enable(createDebug.load());
      return createDebug;
    }
    __name(setup, "setup");
    module2.exports = setup;
  }
});

// node_modules/debug/src/browser.js
var require_browser4 = __commonJS({
  "node_modules/debug/src/browser.js"(exports2, module2) {
    "use strict";
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.storage = localstorage();
    exports2.destroy = /* @__PURE__ */ (() => {
      let warned = false;
      return () => {
        if (!warned) {
          warned = true;
          console.warn("Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
        }
      };
    })();
    exports2.colors = [
      "#0000CC",
      "#0000FF",
      "#0033CC",
      "#0033FF",
      "#0066CC",
      "#0066FF",
      "#0099CC",
      "#0099FF",
      "#00CC00",
      "#00CC33",
      "#00CC66",
      "#00CC99",
      "#00CCCC",
      "#00CCFF",
      "#3300CC",
      "#3300FF",
      "#3333CC",
      "#3333FF",
      "#3366CC",
      "#3366FF",
      "#3399CC",
      "#3399FF",
      "#33CC00",
      "#33CC33",
      "#33CC66",
      "#33CC99",
      "#33CCCC",
      "#33CCFF",
      "#6600CC",
      "#6600FF",
      "#6633CC",
      "#6633FF",
      "#66CC00",
      "#66CC33",
      "#9900CC",
      "#9900FF",
      "#9933CC",
      "#9933FF",
      "#99CC00",
      "#99CC33",
      "#CC0000",
      "#CC0033",
      "#CC0066",
      "#CC0099",
      "#CC00CC",
      "#CC00FF",
      "#CC3300",
      "#CC3333",
      "#CC3366",
      "#CC3399",
      "#CC33CC",
      "#CC33FF",
      "#CC6600",
      "#CC6633",
      "#CC9900",
      "#CC9933",
      "#CCCC00",
      "#CCCC33",
      "#FF0000",
      "#FF0033",
      "#FF0066",
      "#FF0099",
      "#FF00CC",
      "#FF00FF",
      "#FF3300",
      "#FF3333",
      "#FF3366",
      "#FF3399",
      "#FF33CC",
      "#FF33FF",
      "#FF6600",
      "#FF6633",
      "#FF9900",
      "#FF9933",
      "#FFCC00",
      "#FFCC33"
    ];
    function useColors() {
      if (typeof window !== "undefined" && window.process && (window.process.type === "renderer" || window.process.__nwjs)) {
        return true;
      }
      if (typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
        return false;
      }
      let m;
      return typeof document !== "undefined" && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance || // Is firebug? http://stackoverflow.com/a/398120/376773
      typeof window !== "undefined" && window.console && (window.console.firebug || window.console.exception && window.console.table) || // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      typeof navigator !== "undefined" && navigator.userAgent && (m = navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/)) && parseInt(m[1], 10) >= 31 || // Double check webkit in userAgent just in case we are in a worker
      typeof navigator !== "undefined" && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      args[0] = (this.useColors ? "%c" : "") + this.namespace + (this.useColors ? " %c" : " ") + args[0] + (this.useColors ? "%c " : " ") + "+" + module2.exports.humanize(this.diff);
      if (!this.useColors) {
        return;
      }
      const c = "color: " + this.color;
      args.splice(1, 0, c, "color: inherit");
      let index = 0;
      let lastC = 0;
      args[0].replace(/%[a-zA-Z%]/g, (match) => {
        if (match === "%%") {
          return;
        }
        index++;
        if (match === "%c") {
          lastC = index;
        }
      });
      args.splice(lastC, 0, c);
    }
    __name(formatArgs, "formatArgs");
    exports2.log = console.debug || console.log || (() => {
    });
    function save(namespaces) {
      try {
        if (namespaces) {
          exports2.storage.setItem("debug", namespaces);
        } else {
          exports2.storage.removeItem("debug");
        }
      } catch (error) {
      }
    }
    __name(save, "save");
    function load() {
      let r;
      try {
        r = exports2.storage.getItem("debug");
      } catch (error) {
      }
      if (!r && typeof process !== "undefined" && "env" in process) {
        r = process.env.DEBUG;
      }
      return r;
    }
    __name(load, "load");
    function localstorage() {
      try {
        return localStorage;
      } catch (error) {
      }
    }
    __name(localstorage, "localstorage");
    module2.exports = require_common5()(exports2);
    var { formatters } = module2.exports;
    formatters.j = function(v) {
      try {
        return JSON.stringify(v);
      } catch (error) {
        return "[UnexpectedJSONParseError]: " + error.message;
      }
    };
  }
});

// node_modules/debug/src/node.js
var require_node6 = __commonJS({
  "node_modules/debug/src/node.js"(exports2, module2) {
    "use strict";
    var tty = require("tty");
    var util2 = require("util");
    exports2.init = init;
    exports2.log = log;
    exports2.formatArgs = formatArgs;
    exports2.save = save;
    exports2.load = load;
    exports2.useColors = useColors;
    exports2.destroy = util2.deprecate(() => {
    }, "Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.");
    exports2.colors = [
      6,
      2,
      3,
      4,
      5,
      1
    ];
    try {
      const supportsColor = require_supports_color();
      if (supportsColor && (supportsColor.stderr || supportsColor).level >= 2) {
        exports2.colors = [
          20,
          21,
          26,
          27,
          32,
          33,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          56,
          57,
          62,
          63,
          68,
          69,
          74,
          75,
          76,
          77,
          78,
          79,
          80,
          81,
          92,
          93,
          98,
          99,
          112,
          113,
          128,
          129,
          134,
          135,
          148,
          149,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          178,
          179,
          184,
          185,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          214,
          215,
          220,
          221
        ];
      }
    } catch (error) {
    }
    exports2.inspectOpts = Object.keys(process.env).filter((key) => {
      return /^debug_/i.test(key);
    }).reduce((obj, key) => {
      const prop = key.substring(6).toLowerCase().replace(/_([a-z])/g, (_, k) => {
        return k.toUpperCase();
      });
      let val = process.env[key];
      if (/^(yes|on|true|enabled)$/i.test(val)) {
        val = true;
      } else if (/^(no|off|false|disabled)$/i.test(val)) {
        val = false;
      } else if (val === "null") {
        val = null;
      } else {
        val = Number(val);
      }
      obj[prop] = val;
      return obj;
    }, {});
    function useColors() {
      return "colors" in exports2.inspectOpts ? Boolean(exports2.inspectOpts.colors) : tty.isatty(process.stderr.fd);
    }
    __name(useColors, "useColors");
    function formatArgs(args) {
      const { namespace: name, useColors: useColors2 } = this;
      if (useColors2) {
        const c = this.color;
        const colorCode = "\x1B[3" + (c < 8 ? c : "8;5;" + c);
        const prefix = `  ${colorCode};1m${name} \x1B[0m`;
        args[0] = prefix + args[0].split("\n").join("\n" + prefix);
        args.push(colorCode + "m+" + module2.exports.humanize(this.diff) + "\x1B[0m");
      } else {
        args[0] = getDate() + name + " " + args[0];
      }
    }
    __name(formatArgs, "formatArgs");
    function getDate() {
      if (exports2.inspectOpts.hideDate) {
        return "";
      }
      return (/* @__PURE__ */ new Date()).toISOString() + " ";
    }
    __name(getDate, "getDate");
    function log(...args) {
      return process.stderr.write(util2.formatWithOptions(exports2.inspectOpts, ...args) + "\n");
    }
    __name(log, "log");
    function save(namespaces) {
      if (namespaces) {
        process.env.DEBUG = namespaces;
      } else {
        delete process.env.DEBUG;
      }
    }
    __name(save, "save");
    function load() {
      return process.env.DEBUG;
    }
    __name(load, "load");
    function init(debug12) {
      debug12.inspectOpts = {};
      const keys = Object.keys(exports2.inspectOpts);
      for (let i = 0; i < keys.length; i++) {
        debug12.inspectOpts[keys[i]] = exports2.inspectOpts[keys[i]];
      }
    }
    __name(init, "init");
    module2.exports = require_common5()(exports2);
    var { formatters } = module2.exports;
    formatters.o = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts).split("\n").map((str) => str.trim()).join(" ");
    };
    formatters.O = function(v) {
      this.inspectOpts.colors = this.useColors;
      return util2.inspect(v, this.inspectOpts);
    };
  }
});

// node_modules/debug/src/index.js
var require_src4 = __commonJS({
  "node_modules/debug/src/index.js"(exports2, module2) {
    "use strict";
    if (typeof process === "undefined" || process.type === "renderer" || process.browser === true || process.__nwjs) {
      module2.exports = require_browser4();
    } else {
      module2.exports = require_node6();
    }
  }
});

// node_modules/split-ca/index.js
var require_split_ca = __commonJS({
  "node_modules/split-ca/index.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    module2.exports = function(filepath, split, encoding) {
      split = typeof split !== "undefined" ? split : "\n";
      encoding = typeof encoding !== "undefined" ? encoding : "utf8";
      var ca = [];
      var chain = fs.readFileSync(filepath, encoding);
      if (chain.indexOf("-END CERTIFICATE-") < 0 || chain.indexOf("-BEGIN CERTIFICATE-") < 0) {
        throw Error("File does not contain 'BEGIN CERTIFICATE' or 'END CERTIFICATE'");
      }
      chain = chain.split(split);
      var cert = [];
      var _i, _len;
      for (_i = 0, _len = chain.length; _i < _len; _i++) {
        var line = chain[_i];
        if (!(line.length !== 0)) {
          continue;
        }
        cert.push(line);
        if (line.match(/-END CERTIFICATE-/)) {
          ca.push(cert.join(split));
          cert = [];
        }
      }
      return ca;
    };
  }
});

// node_modules/docker-modem/lib/modem.js
var require_modem = __commonJS({
  "node_modules/docker-modem/lib/modem.js"(exports2, module2) {
    "use strict";
    var querystring = require("querystring");
    var http = require_http2();
    var fs = require("fs");
    var path = require("path");
    var url2 = require("url");
    var ssh = require_ssh();
    var HttpDuplex = require_http_duplex();
    var debug12 = require_src4()("modem");
    var utils = require_utils();
    var util2 = require("util");
    var splitca = require_split_ca();
    var os = require("os");
    var isWin = os.type() === "Windows_NT";
    var stream = require("stream");
    var defaultOpts = /* @__PURE__ */ __name(function() {
      var host;
      var opts = {};
      if (!process.env.DOCKER_HOST) {
        opts.socketPath = isWin ? "//./pipe/docker_engine" : findDefaultUnixSocket;
      } else if (process.env.DOCKER_HOST.indexOf("unix://") === 0) {
        opts.socketPath = process.env.DOCKER_HOST.substring(7) || findDefaultUnixSocket;
      } else if (process.env.DOCKER_HOST.indexOf("npipe://") === 0) {
        opts.socketPath = process.env.DOCKER_HOST.substring(8) || "//./pipe/docker_engine";
      } else {
        var hostStr = process.env.DOCKER_HOST;
        if (hostStr.indexOf("//") < 0) {
          hostStr = "tcp://" + hostStr;
        }
        try {
          host = new url2.URL(hostStr);
        } catch (err) {
          throw new Error("DOCKER_HOST env variable should be something like tcp://localhost:1234");
        }
        opts.port = host.port;
        if (process.env.DOCKER_TLS_VERIFY === "1" || opts.port === "2376") {
          opts.protocol = "https";
        } else if (host.protocol === "ssh:") {
          opts.protocol = "ssh";
          opts.username = host.username;
          opts.sshOptions = {
            agent: process.env.SSH_AUTH_SOCK
          };
        } else {
          opts.protocol = "http";
        }
        if (process.env.DOCKER_PATH_PREFIX) {
          opts.pathPrefix = process.env.DOCKER_PATH_PREFIX;
        } else {
          opts.pathPrefix = "/";
        }
        opts.host = host.hostname;
        if (process.env.DOCKER_CERT_PATH) {
          opts.ca = splitca(path.join(process.env.DOCKER_CERT_PATH, "ca.pem"));
          opts.cert = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, "cert.pem"));
          opts.key = fs.readFileSync(path.join(process.env.DOCKER_CERT_PATH, "key.pem"));
        }
        if (process.env.DOCKER_CLIENT_TIMEOUT) {
          opts.timeout = parseInt(process.env.DOCKER_CLIENT_TIMEOUT, 10);
        }
      }
      return opts;
    }, "defaultOpts");
    var findDefaultUnixSocket = /* @__PURE__ */ __name(function() {
      return new Promise(function(resolve5) {
        var userDockerSocket = path.join(os.homedir(), ".docker", "run", "docker.sock");
        fs.access(userDockerSocket, function(err) {
          if (err) resolve5("/var/run/docker.sock");
          else resolve5(userDockerSocket);
        });
      });
    }, "findDefaultUnixSocket");
    var Modem = /* @__PURE__ */ __name(function(options) {
      var optDefaults = defaultOpts();
      var opts = Object.assign({}, optDefaults, options);
      this.host = opts.host;
      if (!this.host) {
        this.socketPath = opts.socketPath;
      }
      this.port = opts.port;
      this.pathPrefix = opts.pathPrefix;
      this.username = opts.username;
      this.password = opts.password;
      this.version = opts.version;
      this.key = opts.key;
      this.cert = opts.cert;
      this.ca = opts.ca;
      this.timeout = opts.timeout;
      this.connectionTimeout = opts.connectionTimeout;
      this.checkServerIdentity = opts.checkServerIdentity;
      this.agent = opts.agent;
      this.headers = opts.headers || {};
      this.sshOptions = Object.assign({}, options ? options.sshOptions : {}, optDefaults.sshOptions);
      if (this.sshOptions.agentForward === void 0) {
        this.sshOptions.agentForward = opts.agentForward;
      }
      if (this.key && this.cert && this.ca) {
        this.protocol = "https";
      }
      this.protocol = opts.protocol || this.protocol || "http";
    }, "Modem");
    Modem.prototype.dial = function(options, callback) {
      var opts, address, data;
      if (options.options) {
        opts = options.options;
      }
      if (opts && opts.authconfig) {
        delete opts.authconfig;
      }
      if (opts && opts.abortSignal) {
        delete opts.abortSignal;
      }
      if (this.version) {
        options.path = "/" + this.version + options.path;
      }
      if (this.host) {
        var parsed = url2.parse(this.host);
        address = url2.format({
          protocol: parsed.protocol || this.protocol,
          hostname: parsed.hostname || this.host,
          port: this.port,
          pathname: parsed.pathname || this.pathPrefix
        });
        address = url2.resolve(address, options.path);
      } else {
        address = options.path;
      }
      if (options.path.indexOf("?") !== -1) {
        if (opts && Object.keys(opts).length > 0) {
          address += this.buildQuerystring(opts._query || opts);
        } else {
          address = address.substring(0, address.length - 1);
        }
      }
      var optionsf = {
        path: address,
        method: options.method,
        headers: options.headers || Object.assign({}, this.headers),
        key: this.key,
        cert: this.cert,
        ca: this.ca
      };
      if (this.checkServerIdentity) {
        optionsf.checkServerIdentity = this.checkServerIdentity;
      }
      if (this.agent) {
        optionsf.agent = this.agent;
      }
      if (options.authconfig) {
        optionsf.headers["X-Registry-Auth"] = options.authconfig.key || options.authconfig.base64 || Buffer.from(JSON.stringify(options.authconfig)).toString("base64").replace(/\+/g, "-").replace(/\//g, "_");
      }
      if (options.registryconfig) {
        optionsf.headers["X-Registry-Config"] = options.registryconfig.base64 || Buffer.from(JSON.stringify(options.registryconfig)).toString("base64");
      }
      if (options.abortSignal) {
        optionsf.signal = options.abortSignal;
      }
      if (options.file) {
        if (typeof options.file === "string") {
          data = fs.createReadStream(path.resolve(options.file));
        } else {
          data = options.file;
        }
        optionsf.headers["Content-Type"] = "application/tar";
      } else if (opts && options.method === "POST") {
        data = JSON.stringify(opts._body || opts);
        if (options.allowEmpty) {
          optionsf.headers["Content-Type"] = "application/json";
        } else {
          if (data !== "{}" && data !== '""') {
            optionsf.headers["Content-Type"] = "application/json";
          } else {
            data = void 0;
          }
        }
      }
      if (typeof data === "string") {
        optionsf.headers["Content-Length"] = Buffer.byteLength(data);
      } else if (Buffer.isBuffer(data) === true) {
        optionsf.headers["Content-Length"] = data.length;
      } else if (optionsf.method === "PUT" || options.hijack || options.openStdin) {
        optionsf.headers["Transfer-Encoding"] = "chunked";
      }
      if (options.hijack) {
        optionsf.headers.Connection = "Upgrade";
        optionsf.headers.Upgrade = optionsf.headers.Upgrade ?? "tcp";
      }
      if (this.socketPath) {
        this.getSocketPath().then((socketPath) => {
          optionsf.socketPath = socketPath;
          this.buildRequest(optionsf, options, data, callback);
        });
      } else {
        var urlp = url2.parse(address);
        optionsf.hostname = urlp.hostname;
        optionsf.port = urlp.port;
        optionsf.path = urlp.path;
        this.buildRequest(optionsf, options, data, callback);
      }
    };
    Modem.prototype.getSocketPath = function() {
      if (!this.socketPath) return;
      if (this.socketPathCache) return Promise.resolve(this.socketPathCache);
      var socketPathValue = typeof this.socketPath === "function" ? this.socketPath() : this.socketPath;
      this.socketPathCache = socketPathValue;
      return Promise.resolve(socketPathValue);
    };
    Modem.prototype.buildRequest = function(options, context, data, callback) {
      var self2 = this;
      var connectionTimeoutTimer;
      var finished = false;
      var opts = self2.protocol === "ssh" ? Object.assign(options, {
        agent: ssh(Object.assign({}, self2.sshOptions, {
          "host": self2.host,
          "port": self2.port,
          "username": self2.username,
          "password": self2.password
        })),
        protocol: "http:"
      }) : options;
      var req = http[self2.protocol === "ssh" ? "http" : self2.protocol].request(opts, function() {
      });
      debug12("Sending: %s", util2.inspect(options, {
        showHidden: true,
        depth: null
      }));
      if (self2.connectionTimeout) {
        connectionTimeoutTimer = setTimeout(function() {
          debug12("Connection Timeout of %s ms exceeded", self2.connectionTimeout);
          req.destroy();
        }, self2.connectionTimeout);
      }
      if (self2.timeout) {
        req.setTimeout(self2.timeout);
        req.on("timeout", function() {
          debug12("Timeout of %s ms exceeded", self2.timeout);
          req.destroy();
        });
      }
      if (context.hijack === true) {
        clearTimeout(connectionTimeoutTimer);
        req.on("upgrade", function(res, sock, head) {
          if (finished === false) {
            finished = true;
            if (head.length > 0) {
              sock.unshift(head);
            }
            return callback(null, sock);
          }
        });
      }
      req.on("connect", function() {
        clearTimeout(connectionTimeoutTimer);
      });
      req.on("disconnect", function() {
        clearTimeout(connectionTimeoutTimer);
      });
      req.on("response", function(res) {
        clearTimeout(connectionTimeoutTimer);
        if (context.isStream === true) {
          if (finished === false) {
            finished = true;
            self2.buildPayload(null, context.isStream, context.statusCodes, context.openStdin, req, res, null, callback);
          }
        } else {
          if (options.signal != null) {
            stream.addAbortSignal(options.signal, res);
          }
          var chunks = [];
          res.on("data", function(chunk) {
            chunks.push(chunk);
          });
          res.on("end", function() {
            var buffer = Buffer.concat(chunks);
            var result2 = buffer.toString();
            debug12("Received: %s", result2);
            var json = utils.parseJSON(result2) || buffer;
            if (finished === false) {
              finished = true;
              self2.buildPayload(null, context.isStream, context.statusCodes, false, req, res, json, callback);
            }
          });
        }
      });
      req.on("error", function(error) {
        clearTimeout(connectionTimeoutTimer);
        if (finished === false) {
          finished = true;
          self2.buildPayload(error, context.isStream, context.statusCodes, false, {}, {}, null, callback);
        }
      });
      if (typeof data === "string" || Buffer.isBuffer(data)) {
        req.write(data);
      } else if (data) {
        data.on("error", function(error) {
          req.destroy(error);
        });
        data.pipe(req);
      }
      if (!context.openStdin && (typeof data === "string" || data === void 0 || Buffer.isBuffer(data))) {
        req.end();
      }
    };
    Modem.prototype.buildPayload = function(err, isStream, statusCodes, openStdin, req, res, json, cb) {
      if (err) return cb(err, null);
      if (statusCodes[res.statusCode] !== true) {
        getCause(isStream, res, json, function(err2, cause) {
          if (err2) {
            return cb(err2, null);
          }
          var msg = new Error("(HTTP code " + res.statusCode + ") " + (statusCodes[res.statusCode] || "unexpected") + " - " + (cause.message || cause.error || cause) + " ");
          msg.reason = statusCodes[res.statusCode];
          msg.statusCode = res.statusCode;
          msg.json = json;
          cb(msg, null);
        });
      } else {
        if (openStdin) {
          cb(null, new HttpDuplex(req, res));
        } else if (isStream) {
          cb(null, res);
        } else {
          cb(null, json);
        }
      }
      function getCause(isStream2, res2, json2, callback) {
        var chunks = "";
        var done = false;
        if (isStream2) {
          res2.on("data", function(chunk) {
            chunks += chunk;
          });
          res2.on("error", function(err2) {
            handler(err2, null);
          });
          res2.on("end", function() {
            handler(null, utils.parseJSON(chunks) || chunks);
          });
        } else {
          callback(null, json2);
        }
        function handler(err2, data) {
          if (done === false) {
            if (err2) {
              callback(err2);
            } else {
              callback(null, data);
            }
          }
          done = true;
        }
        __name(handler, "handler");
      }
      __name(getCause, "getCause");
    };
    Modem.prototype.demuxStream = function(streama, stdout, stderr) {
      var nextDataType = null;
      var nextDataLength = null;
      var buffer = Buffer.from("");
      function processData(data) {
        if (data) {
          buffer = Buffer.concat([
            buffer,
            data
          ]);
        }
        if (!nextDataType) {
          if (buffer.length >= 8) {
            var header = bufferSlice(8);
            nextDataType = header.readUInt8(0);
            nextDataLength = header.readUInt32BE(4);
            processData();
          }
        } else {
          if (buffer.length >= nextDataLength) {
            var content = bufferSlice(nextDataLength);
            if (nextDataType === 1) {
              stdout.write(content);
            } else {
              stderr.write(content);
            }
            nextDataType = null;
            processData();
          }
        }
      }
      __name(processData, "processData");
      function bufferSlice(end) {
        var out = buffer.subarray(0, end);
        buffer = Buffer.from(buffer.subarray(end, buffer.length));
        return out;
      }
      __name(bufferSlice, "bufferSlice");
      streama.on("data", processData);
    };
    Modem.prototype.followProgress = function(streama, onFinished, onProgress) {
      var buf = "";
      var output = [];
      var finished = false;
      streama.on("data", onStreamEvent);
      streama.on("error", onStreamError);
      streama.on("end", onStreamEnd);
      streama.on("close", onStreamEnd);
      function onStreamEvent(data) {
        buf += data.toString();
        pump();
        function pump() {
          var pos;
          while ((pos = buf.indexOf("\n")) >= 0) {
            if (pos == 0) {
              buf = buf.slice(1);
              continue;
            }
            processLine(buf.slice(0, pos));
            buf = buf.slice(pos + 1);
          }
        }
        __name(pump, "pump");
        function processLine(line) {
          if (line[line.length - 1] == "\r") line = line.substr(0, line.length - 1);
          if (line.length > 0) {
            var obj = JSON.parse(line);
            output.push(obj);
            if (onProgress) {
              onProgress(obj);
            }
          }
        }
        __name(processLine, "processLine");
      }
      __name(onStreamEvent, "onStreamEvent");
      ;
      function onStreamError(err) {
        finished = true;
        streama.removeListener("data", onStreamEvent);
        streama.removeListener("error", onStreamError);
        streama.removeListener("end", onStreamEnd);
        streama.removeListener("close", onStreamEnd);
        onFinished(err, output);
      }
      __name(onStreamError, "onStreamError");
      function onStreamEnd() {
        if (!finished) onFinished(null, output);
        finished = true;
      }
      __name(onStreamEnd, "onStreamEnd");
    };
    Modem.prototype.buildQuerystring = function(opts) {
      var clone = {};
      Object.keys(opts).map(function(key, i) {
        if (opts[key] && typeof opts[key] === "object" && !Array.isArray(opts[key])) {
          clone[key] = JSON.stringify(opts[key]);
        } else {
          clone[key] = opts[key];
        }
      });
      return querystring.stringify(clone);
    };
    module2.exports = Modem;
  }
});

// node_modules/@balena/dockerignore/ignore.js
var require_ignore = __commonJS({
  "node_modules/@balena/dockerignore/ignore.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var factory = /* @__PURE__ */ __name((options) => new IgnoreBase(options), "factory");
    factory.default = factory;
    module2.exports = factory;
    function make_array(subject) {
      return Array.isArray(subject) ? subject : [
        subject
      ];
    }
    __name(make_array, "make_array");
    var REGEX_TRAILING_SLASH = /(?<=.)\/$/;
    var REGEX_TRAILING_BACKSLASH = /(?<=.)\\$/;
    var REGEX_TRAILING_PATH_SEP = path.sep === "\\" ? REGEX_TRAILING_BACKSLASH : REGEX_TRAILING_SLASH;
    var KEY_IGNORE = typeof Symbol !== "undefined" ? Symbol.for("dockerignore") : "dockerignore";
    function cleanPath(file) {
      return path.normalize(file).replace(REGEX_TRAILING_PATH_SEP, "");
    }
    __name(cleanPath, "cleanPath");
    function toSlash(file) {
      if (path.sep === "/") {
        return file;
      }
      return file.replace(/\\/g, "/");
    }
    __name(toSlash, "toSlash");
    function fromSlash(file) {
      if (path.sep === "/") {
        return file;
      }
      return file.replace(/\//g, path.sep);
    }
    __name(fromSlash, "fromSlash");
    var IgnoreBase = class IgnoreBase {
      static {
        __name(this, "IgnoreBase");
      }
      constructor({
        // https://github.com/kaelzhang/node-ignore/blob/5.1.4/index.js#L372
        ignorecase = true
      } = {}) {
        this._rules = [];
        this._ignorecase = ignorecase;
        this[KEY_IGNORE] = true;
        this._initCache();
      }
      _initCache() {
        this._cache = {};
      }
      add(pattern) {
        this._added = false;
        if (typeof pattern === "string") {
          pattern = pattern.split(/\r?\n/g);
        }
        make_array(pattern).forEach(this._addPattern, this);
        if (this._added) {
          this._initCache();
        }
        return this;
      }
      addPattern(pattern) {
        return this.add(pattern);
      }
      _addPattern(pattern) {
        if (pattern && pattern[KEY_IGNORE]) {
          this._rules = this._rules.concat(pattern._rules);
          this._added = true;
          return;
        }
        if (this._checkPattern(pattern)) {
          const rule = this._createRule(pattern.trim());
          if (rule !== null) {
            this._added = true;
            this._rules.push(rule);
          }
        }
      }
      _checkPattern(pattern) {
        return pattern && typeof pattern === "string" && pattern.indexOf("#") !== 0 && pattern.trim() !== "";
      }
      filter(paths) {
        return make_array(paths).filter((path2) => this._filter(path2));
      }
      createFilter() {
        return (path2) => this._filter(path2);
      }
      ignores(path2) {
        return !this._filter(path2);
      }
      // https://github.com/moby/moby/blob/v19.03.8/pkg/fileutils/fileutils.go#L29-L55
      _createRule(pattern) {
        const origin = pattern;
        let negative = false;
        if (pattern[0] === "!") {
          negative = true;
          pattern = pattern.substring(1).trim();
        }
        if (pattern.length > 0) {
          pattern = cleanPath(pattern);
          pattern = toSlash(pattern);
          if (pattern.length > 1 && pattern[0] === "/") {
            pattern = pattern.slice(1);
          }
        }
        if (negative) {
          pattern = "!" + pattern;
        }
        pattern = pattern.trim();
        if (pattern === "") {
          return null;
        }
        pattern = cleanPath(pattern);
        if (pattern[0] === "!") {
          if (pattern.length === 1) {
            return null;
          }
          negative = true;
          pattern = pattern.substring(1);
        } else {
          negative = false;
        }
        return {
          origin,
          pattern,
          // https://github.com/moby/moby/blob/v19.03.8/pkg/fileutils/fileutils.go#L54
          dirs: pattern.split(path.sep),
          negative
        };
      }
      _filter(path2) {
        if (!path2) {
          return false;
        }
        if (path2 in this._cache) {
          return this._cache[path2];
        }
        return this._cache[path2] = this._test(path2);
      }
      // https://github.com/moby/moby/blob/v19.03.8/pkg/fileutils/fileutils.go#L62
      _test(file) {
        file = fromSlash(file);
        const parentPath = cleanPath(path.dirname(file));
        const parentPathDirs = parentPath.split(path.sep);
        let matched = false;
        this._rules.forEach((rule) => {
          let match = this._match(file, rule);
          if (!match && parentPath !== ".") {
            if (rule.dirs.includes("**")) {
              for (let i = rule.dirs.filter((x) => x !== "**").length; i <= parentPathDirs.length; i++) {
                match = match || this._match(parentPathDirs.slice(0, i).join(path.sep), rule);
              }
            } else if (rule.dirs.length <= parentPathDirs.length) {
              match = this._match(parentPathDirs.slice(0, rule.dirs.length).join(path.sep), rule);
            }
          }
          if (match) {
            matched = !rule.negative;
          }
        });
        return !matched;
      }
      _match(file, rule) {
        return this._compile(rule).regexp.test(file);
      }
      _compile(rule) {
        if (rule.regexp) {
          return rule;
        }
        let regStr = "^";
        let escapedSlash = path.sep === "\\" ? "\\\\" : path.sep;
        for (let i = 0; i < rule.pattern.length; i++) {
          const ch = rule.pattern[i];
          if (ch === "*") {
            if (rule.pattern[i + 1] === "*") {
              i++;
              if (rule.pattern[i + 1] === path.sep) {
                i++;
              }
              if (rule.pattern[i + 1] === void 0) {
                regStr += ".*";
              } else {
                regStr += `(.*${escapedSlash})?`;
              }
            } else {
              regStr += `[^${escapedSlash}]*`;
            }
          } else if (ch === "?") {
            regStr += `[^${escapedSlash}]`;
          } else if (ch === "." || ch === "$") {
            regStr += `\\${ch}`;
          } else if (ch === "\\") {
            if (path.sep === "\\") {
              regStr += escapedSlash;
              continue;
            }
            if (rule.pattern[i + 1] !== void 0) {
              regStr += "\\" + rule.pattern[i + 1];
              i++;
            } else {
              regStr += "\\";
            }
          } else {
            regStr += ch;
          }
        }
        regStr += "$";
        rule.regexp = new RegExp(regStr, this._ignorecase ? "i" : "");
        return rule;
      }
    };
  }
});

// node_modules/chownr/chownr.js
var require_chownr = __commonJS({
  "node_modules/chownr/chownr.js"(exports2, module2) {
    "use strict";
    var fs = require("fs");
    var path = require("path");
    var LCHOWN = fs.lchown ? "lchown" : "chown";
    var LCHOWNSYNC = fs.lchownSync ? "lchownSync" : "chownSync";
    var needEISDIRHandled = fs.lchown && !process.version.match(/v1[1-9]+\./) && !process.version.match(/v10\.[6-9]/);
    var lchownSync = /* @__PURE__ */ __name((path2, uid, gid) => {
      try {
        return fs[LCHOWNSYNC](path2, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT") throw er;
      }
    }, "lchownSync");
    var chownSync = /* @__PURE__ */ __name((path2, uid, gid) => {
      try {
        return fs.chownSync(path2, uid, gid);
      } catch (er) {
        if (er.code !== "ENOENT") throw er;
      }
    }, "chownSync");
    var handleEISDIR = needEISDIRHandled ? (path2, uid, gid, cb) => (er) => {
      if (!er || er.code !== "EISDIR") cb(er);
      else fs.chown(path2, uid, gid, cb);
    } : (_, __, ___, cb) => cb;
    var handleEISDirSync = needEISDIRHandled ? (path2, uid, gid) => {
      try {
        return lchownSync(path2, uid, gid);
      } catch (er) {
        if (er.code !== "EISDIR") throw er;
        chownSync(path2, uid, gid);
      }
    } : (path2, uid, gid) => lchownSync(path2, uid, gid);
    var nodeVersion2 = process.version;
    var readdir = /* @__PURE__ */ __name((path2, options, cb) => fs.readdir(path2, options, cb), "readdir");
    var readdirSync2 = /* @__PURE__ */ __name((path2, options) => fs.readdirSync(path2, options), "readdirSync");
    if (/^v4\./.test(nodeVersion2)) readdir = /* @__PURE__ */ __name((path2, options, cb) => fs.readdir(path2, cb), "readdir");
    var chown = /* @__PURE__ */ __name((cpath, uid, gid, cb) => {
      fs[LCHOWN](cpath, uid, gid, handleEISDIR(cpath, uid, gid, (er) => {
        cb(er && er.code !== "ENOENT" ? er : null);
      }));
    }, "chown");
    var chownrKid = /* @__PURE__ */ __name((p, child, uid, gid, cb) => {
      if (typeof child === "string") return fs.lstat(path.resolve(p, child), (er, stats) => {
        if (er) return cb(er.code !== "ENOENT" ? er : null);
        stats.name = child;
        chownrKid(p, stats, uid, gid, cb);
      });
      if (child.isDirectory()) {
        chownr(path.resolve(p, child.name), uid, gid, (er) => {
          if (er) return cb(er);
          const cpath = path.resolve(p, child.name);
          chown(cpath, uid, gid, cb);
        });
      } else {
        const cpath = path.resolve(p, child.name);
        chown(cpath, uid, gid, cb);
      }
    }, "chownrKid");
    var chownr = /* @__PURE__ */ __name((p, uid, gid, cb) => {
      readdir(p, {
        withFileTypes: true
      }, (er, children) => {
        if (er) {
          if (er.code === "ENOENT") return cb();
          else if (er.code !== "ENOTDIR" && er.code !== "ENOTSUP") return cb(er);
        }
        if (er || !children.length) return chown(p, uid, gid, cb);
        let len = children.length;
        let errState = null;
        const then = /* @__PURE__ */ __name((er2) => {
          if (errState) return;
          if (er2) return cb(errState = er2);
          if (--len === 0) return chown(p, uid, gid, cb);
        }, "then");
        children.forEach((child) => chownrKid(p, child, uid, gid, then));
      });
    }, "chownr");
    var chownrKidSync = /* @__PURE__ */ __name((p, child, uid, gid) => {
      if (typeof child === "string") {
        try {
          const stats = fs.lstatSync(path.resolve(p, child));
          stats.name = child;
          child = stats;
        } catch (er) {
          if (er.code === "ENOENT") return;
          else throw er;
        }
      }
      if (child.isDirectory()) chownrSync(path.resolve(p, child.name), uid, gid);
      handleEISDirSync(path.resolve(p, child.name), uid, gid);
    }, "chownrKidSync");
    var chownrSync = /* @__PURE__ */ __name((p, uid, gid) => {
      let children;
      try {
        children = readdirSync2(p, {
          withFileTypes: true
        });
      } catch (er) {
        if (er.code === "ENOENT") return;
        else if (er.code === "ENOTDIR" || er.code === "ENOTSUP") return handleEISDirSync(p, uid, gid);
        else throw er;
      }
      if (children && children.length) children.forEach((child) => chownrKidSync(p, child, uid, gid));
      return handleEISDirSync(p, uid, gid);
    }, "chownrSync");
    module2.exports = chownr;
    chownr.sync = chownrSync;
  }
});

// node_modules/bl/BufferList.js
var require_BufferList = __commonJS({
  "node_modules/bl/BufferList.js"(exports2, module2) {
    "use strict";
    var { Buffer: Buffer2 } = require("buffer");
    var symbol = Symbol.for("BufferList");
    function BufferList(buf) {
      if (!(this instanceof BufferList)) {
        return new BufferList(buf);
      }
      BufferList._init.call(this, buf);
    }
    __name(BufferList, "BufferList");
    BufferList._init = /* @__PURE__ */ __name(function _init(buf) {
      Object.defineProperty(this, symbol, {
        value: true
      });
      this._bufs = [];
      this.length = 0;
      if (buf) {
        this.append(buf);
      }
    }, "_init");
    BufferList.prototype._new = /* @__PURE__ */ __name(function _new(buf) {
      return new BufferList(buf);
    }, "_new");
    BufferList.prototype._offset = /* @__PURE__ */ __name(function _offset(offset) {
      if (offset === 0) {
        return [
          0,
          0
        ];
      }
      let tot = 0;
      for (let i = 0; i < this._bufs.length; i++) {
        const _t = tot + this._bufs[i].length;
        if (offset < _t || i === this._bufs.length - 1) {
          return [
            i,
            offset - tot
          ];
        }
        tot = _t;
      }
    }, "_offset");
    BufferList.prototype._reverseOffset = function(blOffset) {
      const bufferId = blOffset[0];
      let offset = blOffset[1];
      for (let i = 0; i < bufferId; i++) {
        offset += this._bufs[i].length;
      }
      return offset;
    };
    BufferList.prototype.get = /* @__PURE__ */ __name(function get(index) {
      if (index > this.length || index < 0) {
        return void 0;
      }
      const offset = this._offset(index);
      return this._bufs[offset[0]][offset[1]];
    }, "get");
    BufferList.prototype.slice = /* @__PURE__ */ __name(function slice(start, end) {
      if (typeof start === "number" && start < 0) {
        start += this.length;
      }
      if (typeof end === "number" && end < 0) {
        end += this.length;
      }
      return this.copy(null, 0, start, end);
    }, "slice");
    BufferList.prototype.copy = /* @__PURE__ */ __name(function copy(dst, dstStart, srcStart, srcEnd) {
      if (typeof srcStart !== "number" || srcStart < 0) {
        srcStart = 0;
      }
      if (typeof srcEnd !== "number" || srcEnd > this.length) {
        srcEnd = this.length;
      }
      if (srcStart >= this.length) {
        return dst || Buffer2.alloc(0);
      }
      if (srcEnd <= 0) {
        return dst || Buffer2.alloc(0);
      }
      const copy2 = !!dst;
      const off = this._offset(srcStart);
      const len = srcEnd - srcStart;
      let bytes = len;
      let bufoff = copy2 && dstStart || 0;
      let start = off[1];
      if (srcStart === 0 && srcEnd === this.length) {
        if (!copy2) {
          return this._bufs.length === 1 ? this._bufs[0] : Buffer2.concat(this._bufs, this.length);
        }
        for (let i = 0; i < this._bufs.length; i++) {
          this._bufs[i].copy(dst, bufoff);
          bufoff += this._bufs[i].length;
        }
        return dst;
      }
      if (bytes <= this._bufs[off[0]].length - start) {
        return copy2 ? this._bufs[off[0]].copy(dst, dstStart, start, start + bytes) : this._bufs[off[0]].slice(start, start + bytes);
      }
      if (!copy2) {
        dst = Buffer2.allocUnsafe(len);
      }
      for (let i = off[0]; i < this._bufs.length; i++) {
        const l = this._bufs[i].length - start;
        if (bytes > l) {
          this._bufs[i].copy(dst, bufoff, start);
          bufoff += l;
        } else {
          this._bufs[i].copy(dst, bufoff, start, start + bytes);
          bufoff += l;
          break;
        }
        bytes -= l;
        if (start) {
          start = 0;
        }
      }
      if (dst.length > bufoff) return dst.slice(0, bufoff);
      return dst;
    }, "copy");
    BufferList.prototype.shallowSlice = /* @__PURE__ */ __name(function shallowSlice(start, end) {
      start = start || 0;
      end = typeof end !== "number" ? this.length : end;
      if (start < 0) {
        start += this.length;
      }
      if (end < 0) {
        end += this.length;
      }
      if (start === end) {
        return this._new();
      }
      const startOffset = this._offset(start);
      const endOffset = this._offset(end);
      const buffers = this._bufs.slice(startOffset[0], endOffset[0] + 1);
      if (endOffset[1] === 0) {
        buffers.pop();
      } else {
        buffers[buffers.length - 1] = buffers[buffers.length - 1].slice(0, endOffset[1]);
      }
      if (startOffset[1] !== 0) {
        buffers[0] = buffers[0].slice(startOffset[1]);
      }
      return this._new(buffers);
    }, "shallowSlice");
    BufferList.prototype.toString = /* @__PURE__ */ __name(function toString2(encoding, start, end) {
      return this.slice(start, end).toString(encoding);
    }, "toString");
    BufferList.prototype.consume = /* @__PURE__ */ __name(function consume(bytes) {
      bytes = Math.trunc(bytes);
      if (Number.isNaN(bytes) || bytes <= 0) return this;
      while (this._bufs.length) {
        if (bytes >= this._bufs[0].length) {
          bytes -= this._bufs[0].length;
          this.length -= this._bufs[0].length;
          this._bufs.shift();
        } else {
          this._bufs[0] = this._bufs[0].slice(bytes);
          this.length -= bytes;
          break;
        }
      }
      return this;
    }, "consume");
    BufferList.prototype.duplicate = /* @__PURE__ */ __name(function duplicate() {
      const copy = this._new();
      for (let i = 0; i < this._bufs.length; i++) {
        copy.append(this._bufs[i]);
      }
      return copy;
    }, "duplicate");
    BufferList.prototype.append = /* @__PURE__ */ __name(function append(buf) {
      if (buf == null) {
        return this;
      }
      if (buf.buffer) {
        this._appendBuffer(Buffer2.from(buf.buffer, buf.byteOffset, buf.byteLength));
      } else if (Array.isArray(buf)) {
        for (let i = 0; i < buf.length; i++) {
          this.append(buf[i]);
        }
      } else if (this._isBufferList(buf)) {
        for (let i = 0; i < buf._bufs.length; i++) {
          this.append(buf._bufs[i]);
        }
      } else {
        if (typeof buf === "number") {
          buf = buf.toString();
        }
        this._appendBuffer(Buffer2.from(buf));
      }
      return this;
    }, "append");
    BufferList.prototype._appendBuffer = /* @__PURE__ */ __name(function appendBuffer(buf) {
      this._bufs.push(buf);
      this.length += buf.length;
    }, "appendBuffer");
    BufferList.prototype.indexOf = function(search, offset, encoding) {
      if (encoding === void 0 && typeof offset === "string") {
        encoding = offset;
        offset = void 0;
      }
      if (typeof search === "function" || Array.isArray(search)) {
        throw new TypeError('The "value" argument must be one of type string, Buffer, BufferList, or Uint8Array.');
      } else if (typeof search === "number") {
        search = Buffer2.from([
          search
        ]);
      } else if (typeof search === "string") {
        search = Buffer2.from(search, encoding);
      } else if (this._isBufferList(search)) {
        search = search.slice();
      } else if (Array.isArray(search.buffer)) {
        search = Buffer2.from(search.buffer, search.byteOffset, search.byteLength);
      } else if (!Buffer2.isBuffer(search)) {
        search = Buffer2.from(search);
      }
      offset = Number(offset || 0);
      if (isNaN(offset)) {
        offset = 0;
      }
      if (offset < 0) {
        offset = this.length + offset;
      }
      if (offset < 0) {
        offset = 0;
      }
      if (search.length === 0) {
        return offset > this.length ? this.length : offset;
      }
      const blOffset = this._offset(offset);
      let blIndex = blOffset[0];
      let buffOffset = blOffset[1];
      for (; blIndex < this._bufs.length; blIndex++) {
        const buff = this._bufs[blIndex];
        while (buffOffset < buff.length) {
          const availableWindow = buff.length - buffOffset;
          if (availableWindow >= search.length) {
            const nativeSearchResult = buff.indexOf(search, buffOffset);
            if (nativeSearchResult !== -1) {
              return this._reverseOffset([
                blIndex,
                nativeSearchResult
              ]);
            }
            buffOffset = buff.length - search.length + 1;
          } else {
            const revOffset = this._reverseOffset([
              blIndex,
              buffOffset
            ]);
            if (this._match(revOffset, search)) {
              return revOffset;
            }
            buffOffset++;
          }
        }
        buffOffset = 0;
      }
      return -1;
    };
    BufferList.prototype._match = function(offset, search) {
      if (this.length - offset < search.length) {
        return false;
      }
      for (let searchOffset = 0; searchOffset < search.length; searchOffset++) {
        if (this.get(offset + searchOffset) !== search[searchOffset]) {
          return false;
        }
      }
      return true;
    };
    (function() {
      const methods = {
        readDoubleBE: 8,
        readDoubleLE: 8,
        readFloatBE: 4,
        readFloatLE: 4,
        readInt32BE: 4,
        readInt32LE: 4,
        readUInt32BE: 4,
        readUInt32LE: 4,
        readInt16BE: 2,
        readInt16LE: 2,
        readUInt16BE: 2,
        readUInt16LE: 2,
        readInt8: 1,
        readUInt8: 1,
        readIntBE: null,
        readIntLE: null,
        readUIntBE: null,
        readUIntLE: null
      };
      for (const m in methods) {
        (function(m2) {
          if (methods[m2] === null) {
            BufferList.prototype[m2] = function(offset, byteLength2) {
              return this.slice(offset, offset + byteLength2)[m2](0, byteLength2);
            };
          } else {
            BufferList.prototype[m2] = function(offset = 0) {
              return this.slice(offset, offset + methods[m2])[m2](0);
            };
          }
        })(m);
      }
    })();
    BufferList.prototype._isBufferList = /* @__PURE__ */ __name(function _isBufferList(b) {
      return b instanceof BufferList || BufferList.isBufferList(b);
    }, "_isBufferList");
    BufferList.isBufferList = /* @__PURE__ */ __name(function isBufferList(b) {
      return b != null && b[symbol];
    }, "isBufferList");
    module2.exports = BufferList;
  }
});

// node_modules/bl/bl.js
var require_bl = __commonJS({
  "node_modules/bl/bl.js"(exports2, module2) {
    "use strict";
    var DuplexStream = require_readable().Duplex;
    var inherits = require_inherits();
    var BufferList = require_BufferList();
    function BufferListStream(callback) {
      if (!(this instanceof BufferListStream)) {
        return new BufferListStream(callback);
      }
      if (typeof callback === "function") {
        this._callback = callback;
        const piper = (/* @__PURE__ */ __name(function piper2(err) {
          if (this._callback) {
            this._callback(err);
            this._callback = null;
          }
        }, "piper")).bind(this);
        this.on("pipe", /* @__PURE__ */ __name(function onPipe(src) {
          src.on("error", piper);
        }, "onPipe"));
        this.on("unpipe", /* @__PURE__ */ __name(function onUnpipe(src) {
          src.removeListener("error", piper);
        }, "onUnpipe"));
        callback = null;
      }
      BufferList._init.call(this, callback);
      DuplexStream.call(this);
    }
    __name(BufferListStream, "BufferListStream");
    inherits(BufferListStream, DuplexStream);
    Object.assign(BufferListStream.prototype, BufferList.prototype);
    BufferListStream.prototype._new = /* @__PURE__ */ __name(function _new(callback) {
      return new BufferListStream(callback);
    }, "_new");
    BufferListStream.prototype._write = /* @__PURE__ */ __name(function _write(buf, encoding, callback) {
      this._appendBuffer(buf);
      if (typeof callback === "function") {
        callback();
      }
    }, "_write");
    BufferListStream.prototype._read = /* @__PURE__ */ __name(function _read(size) {
      if (!this.length) {
        return this.push(null);
      }
      size = Math.min(size, this.length);
      this.push(this.slice(0, size));
      this.consume(size);
    }, "_read");
    BufferListStream.prototype.end = /* @__PURE__ */ __name(function end(chunk) {
      DuplexStream.prototype.end.call(this, chunk);
      if (this._callback) {
        this._callback(null, this.slice());
        this._callback = null;
      }
    }, "end");
    BufferListStream.prototype._destroy = /* @__PURE__ */ __name(function _destroy(err, cb) {
      this._bufs.length = 0;
      this.length = 0;
      cb(err);
    }, "_destroy");
    BufferListStream.prototype._isBufferList = /* @__PURE__ */ __name(function _isBufferList(b) {
      return b instanceof BufferListStream || b instanceof BufferList || BufferListStream.isBufferList(b);
    }, "_isBufferList");
    BufferListStream.isBufferList = BufferList.isBufferList;
    module2.exports = BufferListStream;
    module2.exports.BufferListStream = BufferListStream;
    module2.exports.BufferList = BufferList;
  }
});

// node_modules/tar-fs/node_modules/tar-stream/headers.js
var require_headers = __commonJS({
  "node_modules/tar-fs/node_modules/tar-stream/headers.js"(exports2) {
    "use strict";
    var alloc = Buffer.alloc;
    var ZEROS = "0000000000000000000";
    var SEVENS = "7777777777777777777";
    var ZERO_OFFSET = "0".charCodeAt(0);
    var USTAR_MAGIC = Buffer.from("ustar\0", "binary");
    var USTAR_VER = Buffer.from("00", "binary");
    var GNU_MAGIC = Buffer.from("ustar ", "binary");
    var GNU_VER = Buffer.from(" \0", "binary");
    var MASK = parseInt("7777", 8);
    var MAGIC_OFFSET = 257;
    var VERSION_OFFSET = 263;
    var clamp = /* @__PURE__ */ __name(function(index, len, defaultValue) {
      if (typeof index !== "number") return defaultValue;
      index = ~~index;
      if (index >= len) return len;
      if (index >= 0) return index;
      index += len;
      if (index >= 0) return index;
      return 0;
    }, "clamp");
    var toType = /* @__PURE__ */ __name(function(flag) {
      switch (flag) {
        case 0:
          return "file";
        case 1:
          return "link";
        case 2:
          return "symlink";
        case 3:
          return "character-device";
        case 4:
          return "block-device";
        case 5:
          return "directory";
        case 6:
          return "fifo";
        case 7:
          return "contiguous-file";
        case 72:
          return "pax-header";
        case 55:
          return "pax-global-header";
        case 27:
          return "gnu-long-link-path";
        case 28:
        case 30:
          return "gnu-long-path";
      }
      return null;
    }, "toType");
    var toTypeflag = /* @__PURE__ */ __name(function(flag) {
      switch (flag) {
        case "file":
          return 0;
        case "link":
          return 1;
        case "symlink":
          return 2;
        case "character-device":
          return 3;
        case "block-device":
          return 4;
        case "directory":
          return 5;
        case "fifo":
          return 6;
        case "contiguous-file":
          return 7;
        case "pax-header":
          return 72;
      }
      return 0;
    }, "toTypeflag");
    var indexOf = /* @__PURE__ */ __name(function(block, num, offset, end) {
      for (; offset < end; offset++) {
        if (block[offset] === num) return offset;
      }
      return end;
    }, "indexOf");
    var cksum = /* @__PURE__ */ __name(function(block) {
      var sum = 8 * 32;
      for (var i = 0; i < 148; i++) sum += block[i];
      for (var j = 156; j < 512; j++) sum += block[j];
      return sum;
    }, "cksum");
    var encodeOct = /* @__PURE__ */ __name(function(val, n) {
      val = val.toString(8);
      if (val.length > n) return SEVENS.slice(0, n) + " ";
      else return ZEROS.slice(0, n - val.length) + val + " ";
    }, "encodeOct");
    function parse256(buf) {
      var positive;
      if (buf[0] === 128) positive = true;
      else if (buf[0] === 255) positive = false;
      else return null;
      var tuple = [];
      for (var i = buf.length - 1; i > 0; i--) {
        var byte = buf[i];
        if (positive) tuple.push(byte);
        else tuple.push(255 - byte);
      }
      var sum = 0;
      var l = tuple.length;
      for (i = 0; i < l; i++) {
        sum += tuple[i] * Math.pow(256, i);
      }
      return positive ? sum : -1 * sum;
    }
    __name(parse256, "parse256");
    var decodeOct = /* @__PURE__ */ __name(function(val, offset, length) {
      val = val.slice(offset, offset + length);
      offset = 0;
      if (val[offset] & 128) {
        return parse256(val);
      } else {
        while (offset < val.length && val[offset] === 32) offset++;
        var end = clamp(indexOf(val, 32, offset, val.length), val.length, val.length);
        while (offset < end && val[offset] === 0) offset++;
        if (end === offset) return 0;
        return parseInt(val.slice(offset, end).toString(), 8);
      }
    }, "decodeOct");
    var decodeStr = /* @__PURE__ */ __name(function(val, offset, length, encoding) {
      return val.slice(offset, indexOf(val, 0, offset, offset + length)).toString(encoding);
    }, "decodeStr");
    var addLength = /* @__PURE__ */ __name(function(str) {
      var len = Buffer.byteLength(str);
      var digits = Math.floor(Math.log(len) / Math.log(10)) + 1;
      if (len + digits >= Math.pow(10, digits)) digits++;
      return len + digits + str;
    }, "addLength");
    exports2.decodeLongPath = function(buf, encoding) {
      return decodeStr(buf, 0, buf.length, encoding);
    };
    exports2.encodePax = function(opts) {
      var result2 = "";
      if (opts.name) result2 += addLength(" path=" + opts.name + "\n");
      if (opts.linkname) result2 += addLength(" linkpath=" + opts.linkname + "\n");
      var pax = opts.pax;
      if (pax) {
        for (var key in pax) {
          result2 += addLength(" " + key + "=" + pax[key] + "\n");
        }
      }
      return Buffer.from(result2);
    };
    exports2.decodePax = function(buf) {
      var result2 = {};
      while (buf.length) {
        var i = 0;
        while (i < buf.length && buf[i] !== 32) i++;
        var len = parseInt(buf.slice(0, i).toString(), 10);
        if (!len) return result2;
        var b = buf.slice(i + 1, len - 1).toString();
        var keyIndex = b.indexOf("=");
        if (keyIndex === -1) return result2;
        result2[b.slice(0, keyIndex)] = b.slice(keyIndex + 1);
        buf = buf.slice(len);
      }
      return result2;
    };
    exports2.encode = function(opts) {
      var buf = alloc(512);
      var name = opts.name;
      var prefix = "";
      if (opts.typeflag === 5 && name[name.length - 1] !== "/") name += "/";
      if (Buffer.byteLength(name) !== name.length) return null;
      while (Buffer.byteLength(name) > 100) {
        var i = name.indexOf("/");
        if (i === -1) return null;
        prefix += prefix ? "/" + name.slice(0, i) : name.slice(0, i);
        name = name.slice(i + 1);
      }
      if (Buffer.byteLength(name) > 100 || Buffer.byteLength(prefix) > 155) return null;
      if (opts.linkname && Buffer.byteLength(opts.linkname) > 100) return null;
      buf.write(name);
      buf.write(encodeOct(opts.mode & MASK, 6), 100);
      buf.write(encodeOct(opts.uid, 6), 108);
      buf.write(encodeOct(opts.gid, 6), 116);
      buf.write(encodeOct(opts.size, 11), 124);
      buf.write(encodeOct(opts.mtime.getTime() / 1e3 | 0, 11), 136);
      buf[156] = ZERO_OFFSET + toTypeflag(opts.type);
      if (opts.linkname) buf.write(opts.linkname, 157);
      USTAR_MAGIC.copy(buf, MAGIC_OFFSET);
      USTAR_VER.copy(buf, VERSION_OFFSET);
      if (opts.uname) buf.write(opts.uname, 265);
      if (opts.gname) buf.write(opts.gname, 297);
      buf.write(encodeOct(opts.devmajor || 0, 6), 329);
      buf.write(encodeOct(opts.devminor || 0, 6), 337);
      if (prefix) buf.write(prefix, 345);
      buf.write(encodeOct(cksum(buf), 6), 148);
      return buf;
    };
    exports2.decode = function(buf, filenameEncoding, allowUnknownFormat) {
      var typeflag = buf[156] === 0 ? 0 : buf[156] - ZERO_OFFSET;
      var name = decodeStr(buf, 0, 100, filenameEncoding);
      var mode = decodeOct(buf, 100, 8);
      var uid = decodeOct(buf, 108, 8);
      var gid = decodeOct(buf, 116, 8);
      var size = decodeOct(buf, 124, 12);
      var mtime = decodeOct(buf, 136, 12);
      var type = toType(typeflag);
      var linkname = buf[157] === 0 ? null : decodeStr(buf, 157, 100, filenameEncoding);
      var uname = decodeStr(buf, 265, 32);
      var gname = decodeStr(buf, 297, 32);
      var devmajor = decodeOct(buf, 329, 8);
      var devminor = decodeOct(buf, 337, 8);
      var c = cksum(buf);
      if (c === 8 * 32) return null;
      if (c !== decodeOct(buf, 148, 8)) throw new Error("Invalid tar header. Maybe the tar is corrupted or it needs to be gunzipped?");
      if (USTAR_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0) {
        if (buf[345]) name = decodeStr(buf, 345, 155, filenameEncoding) + "/" + name;
      } else if (GNU_MAGIC.compare(buf, MAGIC_OFFSET, MAGIC_OFFSET + 6) === 0 && GNU_VER.compare(buf, VERSION_OFFSET, VERSION_OFFSET + 2) === 0) {
      } else {
        if (!allowUnknownFormat) {
          throw new Error("Invalid tar header: unknown format.");
        }
      }
      if (typeflag === 0 && name && name[name.length - 1] === "/") typeflag = 5;
      return {
        name,
        mode,
        uid,
        gid,
        size,
        mtime: new Date(1e3 * mtime),
        type,
        linkname,
        uname,
        gname,
        devmajor,
        devminor
      };
    };
  }
});

// node_modules/tar-fs/node_modules/tar-stream/extract.js
var require_extract = __commonJS({
  "node_modules/tar-fs/node_modules/tar-stream/extract.js"(exports2, module2) {
    "use strict";
    var util2 = require("util");
    var bl = require_bl();
    var headers = require_headers();
    var Writable = require_readable().Writable;
    var PassThrough = require_readable().PassThrough;
    var noop = /* @__PURE__ */ __name(function() {
    }, "noop");
    var overflow = /* @__PURE__ */ __name(function(size) {
      size &= 511;
      return size && 512 - size;
    }, "overflow");
    var emptyStream = /* @__PURE__ */ __name(function(self2, offset) {
      var s = new Source(self2, offset);
      s.end();
      return s;
    }, "emptyStream");
    var mixinPax = /* @__PURE__ */ __name(function(header, pax) {
      if (pax.path) header.name = pax.path;
      if (pax.linkpath) header.linkname = pax.linkpath;
      if (pax.size) header.size = parseInt(pax.size, 10);
      header.pax = pax;
      return header;
    }, "mixinPax");
    var Source = /* @__PURE__ */ __name(function(self2, offset) {
      this._parent = self2;
      this.offset = offset;
      PassThrough.call(this, {
        autoDestroy: false
      });
    }, "Source");
    util2.inherits(Source, PassThrough);
    Source.prototype.destroy = function(err) {
      this._parent.destroy(err);
    };
    var Extract = /* @__PURE__ */ __name(function(opts) {
      if (!(this instanceof Extract)) return new Extract(opts);
      Writable.call(this, opts);
      opts = opts || {};
      this._offset = 0;
      this._buffer = bl();
      this._missing = 0;
      this._partial = false;
      this._onparse = noop;
      this._header = null;
      this._stream = null;
      this._overflow = null;
      this._cb = null;
      this._locked = false;
      this._destroyed = false;
      this._pax = null;
      this._paxGlobal = null;
      this._gnuLongPath = null;
      this._gnuLongLinkPath = null;
      var self2 = this;
      var b = self2._buffer;
      var oncontinue = /* @__PURE__ */ __name(function() {
        self2._continue();
      }, "oncontinue");
      var onunlock = /* @__PURE__ */ __name(function(err) {
        self2._locked = false;
        if (err) return self2.destroy(err);
        if (!self2._stream) oncontinue();
      }, "onunlock");
      var onstreamend = /* @__PURE__ */ __name(function() {
        self2._stream = null;
        var drain = overflow(self2._header.size);
        if (drain) self2._parse(drain, ondrain);
        else self2._parse(512, onheader);
        if (!self2._locked) oncontinue();
      }, "onstreamend");
      var ondrain = /* @__PURE__ */ __name(function() {
        self2._buffer.consume(overflow(self2._header.size));
        self2._parse(512, onheader);
        oncontinue();
      }, "ondrain");
      var onpaxglobalheader = /* @__PURE__ */ __name(function() {
        var size = self2._header.size;
        self2._paxGlobal = headers.decodePax(b.slice(0, size));
        b.consume(size);
        onstreamend();
      }, "onpaxglobalheader");
      var onpaxheader = /* @__PURE__ */ __name(function() {
        var size = self2._header.size;
        self2._pax = headers.decodePax(b.slice(0, size));
        if (self2._paxGlobal) self2._pax = Object.assign({}, self2._paxGlobal, self2._pax);
        b.consume(size);
        onstreamend();
      }, "onpaxheader");
      var ongnulongpath = /* @__PURE__ */ __name(function() {
        var size = self2._header.size;
        this._gnuLongPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      }, "ongnulongpath");
      var ongnulonglinkpath = /* @__PURE__ */ __name(function() {
        var size = self2._header.size;
        this._gnuLongLinkPath = headers.decodeLongPath(b.slice(0, size), opts.filenameEncoding);
        b.consume(size);
        onstreamend();
      }, "ongnulonglinkpath");
      var onheader = /* @__PURE__ */ __name(function() {
        var offset = self2._offset;
        var header;
        try {
          header = self2._header = headers.decode(b.slice(0, 512), opts.filenameEncoding, opts.allowUnknownFormat);
        } catch (err) {
          self2.emit("error", err);
        }
        b.consume(512);
        if (!header) {
          self2._parse(512, onheader);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-path") {
          self2._parse(header.size, ongnulongpath);
          oncontinue();
          return;
        }
        if (header.type === "gnu-long-link-path") {
          self2._parse(header.size, ongnulonglinkpath);
          oncontinue();
          return;
        }
        if (header.type === "pax-global-header") {
          self2._parse(header.size, onpaxglobalheader);
          oncontinue();
          return;
        }
        if (header.type === "pax-header") {
          self2._parse(header.size, onpaxheader);
          oncontinue();
          return;
        }
        if (self2._gnuLongPath) {
          header.name = self2._gnuLongPath;
          self2._gnuLongPath = null;
        }
        if (self2._gnuLongLinkPath) {
          header.linkname = self2._gnuLongLinkPath;
          self2._gnuLongLinkPath = null;
        }
        if (self2._pax) {
          self2._header = header = mixinPax(header, self2._pax);
          self2._pax = null;
        }
        self2._locked = true;
        if (!header.size || header.type === "directory") {
          self2._parse(512, onheader);
          self2.emit("entry", header, emptyStream(self2, offset), onunlock);
          return;
        }
        self2._stream = new Source(self2, offset);
        self2.emit("entry", header, self2._stream, onunlock);
        self2._parse(header.size, onstreamend);
        oncontinue();
      }, "onheader");
      this._onheader = onheader;
      this._parse(512, onheader);
    }, "Extract");
    util2.inherits(Extract, Writable);
    Extract.prototype.destroy = function(err) {
      if (this._destroyed) return;
      this._destroyed = true;
      if (err) this.emit("error", err);
      this.emit("close");
      if (this._stream) this._stream.emit("close");
    };
    Extract.prototype._parse = function(size, onparse) {
      if (this._destroyed) return;
      this._offset += size;
      this._missing = size;
      if (onparse === this._onheader) this._partial = false;
      this._onparse = onparse;
    };
    Extract.prototype._continue = function() {
      if (this._destroyed) return;
      var cb = this._cb;
      this._cb = noop;
      if (this._overflow) this._write(this._overflow, void 0, cb);
      else cb();
    };
    Extract.prototype._write = function(data, enc, cb) {
      if (this._destroyed) return;
      var s = this._stream;
      var b = this._buffer;
      var missing = this._missing;
      if (data.length) this._partial = true;
      if (data.length < missing) {
        this._missing -= data.length;
        this._overflow = null;
        if (s) return s.write(data, cb);
        b.append(data);
        return cb();
      }
      this._cb = cb;
      this._missing = 0;
      var overflow2 = null;
      if (data.length > missing) {
        overflow2 = data.slice(missing);
        data = data.slice(0, missing);
      }
      if (s) s.end(data);
      else b.append(data);
      this._overflow = overflow2;
      this._onparse();
    };
    Extract.prototype._final = function(cb) {
      if (this._partial) return this.destroy(new Error("Unexpected end of data"));
      cb();
    };
    module2.exports = Extract;
  }
});

// node_modules/fs-constants/index.js
var require_fs_constants = __commonJS({
  "node_modules/fs-constants/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require("fs").constants || require("constants");
  }
});

// node_modules/wrappy/wrappy.js
var require_wrappy = __commonJS({
  "node_modules/wrappy/wrappy.js"(exports2, module2) {
    "use strict";
    module2.exports = wrappy;
    function wrappy(fn, cb) {
      if (fn && cb) return wrappy(fn)(cb);
      if (typeof fn !== "function") throw new TypeError("need wrapper function");
      Object.keys(fn).forEach(function(k) {
        wrapper[k] = fn[k];
      });
      return wrapper;
      function wrapper() {
        var args = new Array(arguments.length);
        for (var i = 0; i < args.length; i++) {
          args[i] = arguments[i];
        }
        var ret = fn.apply(this, args);
        var cb2 = args[args.length - 1];
        if (typeof ret === "function" && ret !== cb2) {
          Object.keys(cb2).forEach(function(k) {
            ret[k] = cb2[k];
          });
        }
        return ret;
      }
      __name(wrapper, "wrapper");
    }
    __name(wrappy, "wrappy");
  }
});

// node_modules/once/once.js
var require_once2 = __commonJS({
  "node_modules/once/once.js"(exports2, module2) {
    "use strict";
    var wrappy = require_wrappy();
    module2.exports = wrappy(once);
    module2.exports.strict = wrappy(onceStrict);
    once.proto = once(function() {
      Object.defineProperty(Function.prototype, "once", {
        value: /* @__PURE__ */ __name(function() {
          return once(this);
        }, "value"),
        configurable: true
      });
      Object.defineProperty(Function.prototype, "onceStrict", {
        value: /* @__PURE__ */ __name(function() {
          return onceStrict(this);
        }, "value"),
        configurable: true
      });
    });
    function once(fn) {
      var f = /* @__PURE__ */ __name(function() {
        if (f.called) return f.value;
        f.called = true;
        return f.value = fn.apply(this, arguments);
      }, "f");
      f.called = false;
      return f;
    }
    __name(once, "once");
    function onceStrict(fn) {
      var f = /* @__PURE__ */ __name(function() {
        if (f.called) throw new Error(f.onceError);
        f.called = true;
        return f.value = fn.apply(this, arguments);
      }, "f");
      var name = fn.name || "Function wrapped with `once`";
      f.onceError = name + " shouldn't be called more than once";
      f.called = false;
      return f;
    }
    __name(onceStrict, "onceStrict");
  }
});

// node_modules/end-of-stream/index.js
var require_end_of_stream2 = __commonJS({
  "node_modules/end-of-stream/index.js"(exports2, module2) {
    "use strict";
    var once = require_once2();
    var noop = /* @__PURE__ */ __name(function() {
    }, "noop");
    var isRequest = /* @__PURE__ */ __name(function(stream) {
      return stream.setHeader && typeof stream.abort === "function";
    }, "isRequest");
    var isChildProcess = /* @__PURE__ */ __name(function(stream) {
      return stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3;
    }, "isChildProcess");
    var eos = /* @__PURE__ */ __name(function(stream, opts, callback) {
      if (typeof opts === "function") return eos(stream, null, opts);
      if (!opts) opts = {};
      callback = once(callback || noop);
      var ws = stream._writableState;
      var rs = stream._readableState;
      var readable = opts.readable || opts.readable !== false && stream.readable;
      var writable = opts.writable || opts.writable !== false && stream.writable;
      var cancelled = false;
      var onlegacyfinish = /* @__PURE__ */ __name(function() {
        if (!stream.writable) onfinish();
      }, "onlegacyfinish");
      var onfinish = /* @__PURE__ */ __name(function() {
        writable = false;
        if (!readable) callback.call(stream);
      }, "onfinish");
      var onend = /* @__PURE__ */ __name(function() {
        readable = false;
        if (!writable) callback.call(stream);
      }, "onend");
      var onexit = /* @__PURE__ */ __name(function(exitCode) {
        callback.call(stream, exitCode ? new Error("exited with error code: " + exitCode) : null);
      }, "onexit");
      var onerror = /* @__PURE__ */ __name(function(err) {
        callback.call(stream, err);
      }, "onerror");
      var onclose = /* @__PURE__ */ __name(function() {
        process.nextTick(onclosenexttick);
      }, "onclose");
      var onclosenexttick = /* @__PURE__ */ __name(function() {
        if (cancelled) return;
        if (readable && !(rs && rs.ended && !rs.destroyed)) return callback.call(stream, new Error("premature close"));
        if (writable && !(ws && ws.ended && !ws.destroyed)) return callback.call(stream, new Error("premature close"));
      }, "onclosenexttick");
      var onrequest = /* @__PURE__ */ __name(function() {
        stream.req.on("finish", onfinish);
      }, "onrequest");
      if (isRequest(stream)) {
        stream.on("complete", onfinish);
        stream.on("abort", onclose);
        if (stream.req) onrequest();
        else stream.on("request", onrequest);
      } else if (writable && !ws) {
        stream.on("end", onlegacyfinish);
        stream.on("close", onlegacyfinish);
      }
      if (isChildProcess(stream)) stream.on("exit", onexit);
      stream.on("end", onend);
      stream.on("finish", onfinish);
      if (opts.error !== false) stream.on("error", onerror);
      stream.on("close", onclose);
      return function() {
        cancelled = true;
        stream.removeListener("complete", onfinish);
        stream.removeListener("abort", onclose);
        stream.removeListener("request", onrequest);
        if (stream.req) stream.req.removeListener("finish", onfinish);
        stream.removeListener("end", onlegacyfinish);
        stream.removeListener("close", onlegacyfinish);
        stream.removeListener("finish", onfinish);
        stream.removeListener("exit", onexit);
        stream.removeListener("end", onend);
        stream.removeListener("error", onerror);
        stream.removeListener("close", onclose);
      };
    }, "eos");
    module2.exports = eos;
  }
});

// node_modules/tar-fs/node_modules/tar-stream/pack.js
var require_pack = __commonJS({
  "node_modules/tar-fs/node_modules/tar-stream/pack.js"(exports2, module2) {
    "use strict";
    var constants = require_fs_constants();
    var eos = require_end_of_stream2();
    var inherits = require_inherits();
    var alloc = Buffer.alloc;
    var Readable = require_readable().Readable;
    var Writable = require_readable().Writable;
    var StringDecoder = require("string_decoder").StringDecoder;
    var headers = require_headers();
    var DMODE = parseInt("755", 8);
    var FMODE = parseInt("644", 8);
    var END_OF_TAR = alloc(1024);
    var noop = /* @__PURE__ */ __name(function() {
    }, "noop");
    var overflow = /* @__PURE__ */ __name(function(self2, size) {
      size &= 511;
      if (size) self2.push(END_OF_TAR.slice(0, 512 - size));
    }, "overflow");
    function modeToType(mode) {
      switch (mode & constants.S_IFMT) {
        case constants.S_IFBLK:
          return "block-device";
        case constants.S_IFCHR:
          return "character-device";
        case constants.S_IFDIR:
          return "directory";
        case constants.S_IFIFO:
          return "fifo";
        case constants.S_IFLNK:
          return "symlink";
      }
      return "file";
    }
    __name(modeToType, "modeToType");
    var Sink = /* @__PURE__ */ __name(function(to) {
      Writable.call(this);
      this.written = 0;
      this._to = to;
      this._destroyed = false;
    }, "Sink");
    inherits(Sink, Writable);
    Sink.prototype._write = function(data, enc, cb) {
      this.written += data.length;
      if (this._to.push(data)) return cb();
      this._to._drain = cb;
    };
    Sink.prototype.destroy = function() {
      if (this._destroyed) return;
      this._destroyed = true;
      this.emit("close");
    };
    var LinkSink = /* @__PURE__ */ __name(function() {
      Writable.call(this);
      this.linkname = "";
      this._decoder = new StringDecoder("utf-8");
      this._destroyed = false;
    }, "LinkSink");
    inherits(LinkSink, Writable);
    LinkSink.prototype._write = function(data, enc, cb) {
      this.linkname += this._decoder.write(data);
      cb();
    };
    LinkSink.prototype.destroy = function() {
      if (this._destroyed) return;
      this._destroyed = true;
      this.emit("close");
    };
    var Void = /* @__PURE__ */ __name(function() {
      Writable.call(this);
      this._destroyed = false;
    }, "Void");
    inherits(Void, Writable);
    Void.prototype._write = function(data, enc, cb) {
      cb(new Error("No body allowed for this entry"));
    };
    Void.prototype.destroy = function() {
      if (this._destroyed) return;
      this._destroyed = true;
      this.emit("close");
    };
    var Pack = /* @__PURE__ */ __name(function(opts) {
      if (!(this instanceof Pack)) return new Pack(opts);
      Readable.call(this, opts);
      this._drain = noop;
      this._finalized = false;
      this._finalizing = false;
      this._destroyed = false;
      this._stream = null;
    }, "Pack");
    inherits(Pack, Readable);
    Pack.prototype.entry = function(header, buffer, callback) {
      if (this._stream) throw new Error("already piping an entry");
      if (this._finalized || this._destroyed) return;
      if (typeof buffer === "function") {
        callback = buffer;
        buffer = null;
      }
      if (!callback) callback = noop;
      var self2 = this;
      if (!header.size || header.type === "symlink") header.size = 0;
      if (!header.type) header.type = modeToType(header.mode);
      if (!header.mode) header.mode = header.type === "directory" ? DMODE : FMODE;
      if (!header.uid) header.uid = 0;
      if (!header.gid) header.gid = 0;
      if (!header.mtime) header.mtime = /* @__PURE__ */ new Date();
      if (typeof buffer === "string") buffer = Buffer.from(buffer);
      if (Buffer.isBuffer(buffer)) {
        header.size = buffer.length;
        this._encode(header);
        var ok = this.push(buffer);
        overflow(self2, header.size);
        if (ok) process.nextTick(callback);
        else this._drain = callback;
        return new Void();
      }
      if (header.type === "symlink" && !header.linkname) {
        var linkSink = new LinkSink();
        eos(linkSink, function(err) {
          if (err) {
            self2.destroy();
            return callback(err);
          }
          header.linkname = linkSink.linkname;
          self2._encode(header);
          callback();
        });
        return linkSink;
      }
      this._encode(header);
      if (header.type !== "file" && header.type !== "contiguous-file") {
        process.nextTick(callback);
        return new Void();
      }
      var sink = new Sink(this);
      this._stream = sink;
      eos(sink, function(err) {
        self2._stream = null;
        if (err) {
          self2.destroy();
          return callback(err);
        }
        if (sink.written !== header.size) {
          self2.destroy();
          return callback(new Error("size mismatch"));
        }
        overflow(self2, header.size);
        if (self2._finalizing) self2.finalize();
        callback();
      });
      return sink;
    };
    Pack.prototype.finalize = function() {
      if (this._stream) {
        this._finalizing = true;
        return;
      }
      if (this._finalized) return;
      this._finalized = true;
      this.push(END_OF_TAR);
      this.push(null);
    };
    Pack.prototype.destroy = function(err) {
      if (this._destroyed) return;
      this._destroyed = true;
      if (err) this.emit("error", err);
      this.emit("close");
      if (this._stream && this._stream.destroy) this._stream.destroy();
    };
    Pack.prototype._encode = function(header) {
      if (!header.pax) {
        var buf = headers.encode(header);
        if (buf) {
          this.push(buf);
          return;
        }
      }
      this._encodePax(header);
    };
    Pack.prototype._encodePax = function(header) {
      var paxHeader = headers.encodePax({
        name: header.name,
        linkname: header.linkname,
        pax: header.pax
      });
      var newHeader = {
        name: "PaxHeader",
        mode: header.mode,
        uid: header.uid,
        gid: header.gid,
        size: paxHeader.length,
        mtime: header.mtime,
        type: "pax-header",
        linkname: header.linkname && "PaxHeader",
        uname: header.uname,
        gname: header.gname,
        devmajor: header.devmajor,
        devminor: header.devminor
      };
      this.push(headers.encode(newHeader));
      this.push(paxHeader);
      overflow(this, paxHeader.length);
      newHeader.size = header.size;
      newHeader.type = header.type;
      this.push(headers.encode(newHeader));
    };
    Pack.prototype._read = function(n) {
      var drain = this._drain;
      this._drain = noop;
      drain();
    };
    module2.exports = Pack;
  }
});

// node_modules/tar-fs/node_modules/tar-stream/index.js
var require_tar_stream = __commonJS({
  "node_modules/tar-fs/node_modules/tar-stream/index.js"(exports2) {
    "use strict";
    exports2.extract = require_extract();
    exports2.pack = require_pack();
  }
});

// node_modules/pump/index.js
var require_pump = __commonJS({
  "node_modules/pump/index.js"(exports2, module2) {
    "use strict";
    var once = require_once2();
    var eos = require_end_of_stream2();
    var fs;
    try {
      fs = require("fs");
    } catch (e) {
    }
    var noop = /* @__PURE__ */ __name(function() {
    }, "noop");
    var ancient = /^v?\.0/.test(process.version);
    var isFn = /* @__PURE__ */ __name(function(fn) {
      return typeof fn === "function";
    }, "isFn");
    var isFS = /* @__PURE__ */ __name(function(stream) {
      if (!ancient) return false;
      if (!fs) return false;
      return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close);
    }, "isFS");
    var isRequest = /* @__PURE__ */ __name(function(stream) {
      return stream.setHeader && isFn(stream.abort);
    }, "isRequest");
    var destroyer = /* @__PURE__ */ __name(function(stream, reading, writing, callback) {
      callback = once(callback);
      var closed = false;
      stream.on("close", function() {
        closed = true;
      });
      eos(stream, {
        readable: reading,
        writable: writing
      }, function(err) {
        if (err) return callback(err);
        closed = true;
        callback();
      });
      var destroyed = false;
      return function(err) {
        if (closed) return;
        if (destroyed) return;
        destroyed = true;
        if (isFS(stream)) return stream.close(noop);
        if (isRequest(stream)) return stream.abort();
        if (isFn(stream.destroy)) return stream.destroy();
        callback(err || new Error("stream was destroyed"));
      };
    }, "destroyer");
    var call = /* @__PURE__ */ __name(function(fn) {
      fn();
    }, "call");
    var pipe = /* @__PURE__ */ __name(function(from, to) {
      return from.pipe(to);
    }, "pipe");
    var pump = /* @__PURE__ */ __name(function() {
      var streams = Array.prototype.slice.call(arguments);
      var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop;
      if (Array.isArray(streams[0])) streams = streams[0];
      if (streams.length < 2) throw new Error("pump requires two streams per minimum");
      var error;
      var destroys = streams.map(function(stream, i) {
        var reading = i < streams.length - 1;
        var writing = i > 0;
        return destroyer(stream, reading, writing, function(err) {
          if (!error) error = err;
          if (err) destroys.forEach(call);
          if (reading) return;
          destroys.forEach(call);
          callback(error);
        });
      });
      return streams.reduce(pipe);
    }, "pump");
    module2.exports = pump;
  }
});

// node_modules/mkdirp-classic/index.js
var require_mkdirp_classic = __commonJS({
  "node_modules/mkdirp-classic/index.js"(exports2, module2) {
    "use strict";
    var path = require("path");
    var fs = require("fs");
    var _0777 = parseInt("0777", 8);
    module2.exports = mkdirP.mkdirp = mkdirP.mkdirP = mkdirP;
    function mkdirP(p, opts, f, made) {
      if (typeof opts === "function") {
        f = opts;
        opts = {};
      } else if (!opts || typeof opts !== "object") {
        opts = {
          mode: opts
        };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777 & ~process.umask();
      }
      if (!made) made = null;
      var cb = f || function() {
      };
      p = path.resolve(p);
      xfs.mkdir(p, mode, function(er) {
        if (!er) {
          made = made || p;
          return cb(null, made);
        }
        switch (er.code) {
          case "ENOENT":
            mkdirP(path.dirname(p), opts, function(er2, made2) {
              if (er2) cb(er2, made2);
              else mkdirP(p, opts, cb, made2);
            });
            break;
          // In the case of any other error, just see if there's a dir
          // there already.  If so, then hooray!  If not, then something
          // is borked.
          default:
            xfs.stat(p, function(er2, stat) {
              if (er2 || !stat.isDirectory()) cb(er, made);
              else cb(null, made);
            });
            break;
        }
      });
    }
    __name(mkdirP, "mkdirP");
    mkdirP.sync = /* @__PURE__ */ __name(function sync(p, opts, made) {
      if (!opts || typeof opts !== "object") {
        opts = {
          mode: opts
        };
      }
      var mode = opts.mode;
      var xfs = opts.fs || fs;
      if (mode === void 0) {
        mode = _0777 & ~process.umask();
      }
      if (!made) made = null;
      p = path.resolve(p);
      try {
        xfs.mkdirSync(p, mode);
        made = made || p;
      } catch (err0) {
        switch (err0.code) {
          case "ENOENT":
            made = sync(path.dirname(p), opts, made);
            sync(p, opts, made);
            break;
          // In the case of any other error, just see if there's a dir
          // there already.  If so, then hooray!  If not, then something
          // is borked.
          default:
            var stat;
            try {
              stat = xfs.statSync(p);
            } catch (err1) {
              throw err0;
            }
            if (!stat.isDirectory()) throw err0;
            break;
        }
      }
      return made;
    }, "sync");
  }
});

// node_modules/tar-fs/index.js
var require_tar_fs = __commonJS({
  "node_modules/tar-fs/index.js"(exports2) {
    "use strict";
    var chownr = require_chownr();
    var tar = require_tar_stream();
    var pump = require_pump();
    var mkdirp = require_mkdirp_classic();
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var win32 = os.platform() === "win32";
    var noop = /* @__PURE__ */ __name(function() {
    }, "noop");
    var echo = /* @__PURE__ */ __name(function(name) {
      return name;
    }, "echo");
    var normalize2 = !win32 ? echo : function(name) {
      return name.replace(/\\/g, "/").replace(/[:?<>|]/g, "_");
    };
    var statAll = /* @__PURE__ */ __name(function(fs2, stat, cwd, ignore, entries, sort) {
      var queue = entries || [
        "."
      ];
      return /* @__PURE__ */ __name(function loop(callback) {
        if (!queue.length) return callback();
        var next = queue.shift();
        var nextAbs = path.join(cwd, next);
        stat(nextAbs, function(err, stat2) {
          if (err) return callback(err);
          if (!stat2.isDirectory()) return callback(null, next, stat2);
          fs2.readdir(nextAbs, function(err2, files) {
            if (err2) return callback(err2);
            if (sort) files.sort();
            for (var i = 0; i < files.length; i++) {
              if (!ignore(path.join(cwd, next, files[i]))) queue.push(path.join(next, files[i]));
            }
            callback(null, next, stat2);
          });
        });
      }, "loop");
    }, "statAll");
    var strip = /* @__PURE__ */ __name(function(map, level) {
      return function(header) {
        header.name = header.name.split("/").slice(level).join("/");
        var linkname = header.linkname;
        if (linkname && (header.type === "link" || path.isAbsolute(linkname))) {
          header.linkname = linkname.split("/").slice(level).join("/");
        }
        return map(header);
      };
    }, "strip");
    exports2.pack = function(cwd, opts) {
      if (!cwd) cwd = ".";
      if (!opts) opts = {};
      var xfs = opts.fs || fs;
      var ignore = opts.ignore || opts.filter || noop;
      var map = opts.map || noop;
      var mapStream = opts.mapStream || echo;
      var statNext = statAll(xfs, opts.dereference ? xfs.stat : xfs.lstat, cwd, ignore, opts.entries, opts.sort);
      var strict = opts.strict !== false;
      var umask = typeof opts.umask === "number" ? ~opts.umask : ~processUmask();
      var dmode = typeof opts.dmode === "number" ? opts.dmode : 0;
      var fmode = typeof opts.fmode === "number" ? opts.fmode : 0;
      var pack = opts.pack || tar.pack();
      var finish = opts.finish || noop;
      if (opts.strip) map = strip(map, opts.strip);
      if (opts.readable) {
        dmode |= parseInt(555, 8);
        fmode |= parseInt(444, 8);
      }
      if (opts.writable) {
        dmode |= parseInt(333, 8);
        fmode |= parseInt(222, 8);
      }
      var onsymlink = /* @__PURE__ */ __name(function(filename, header) {
        xfs.readlink(path.join(cwd, filename), function(err, linkname) {
          if (err) return pack.destroy(err);
          header.linkname = normalize2(linkname);
          pack.entry(header, onnextentry);
        });
      }, "onsymlink");
      var onstat = /* @__PURE__ */ __name(function(err, filename, stat) {
        if (err) return pack.destroy(err);
        if (!filename) {
          if (opts.finalize !== false) pack.finalize();
          return finish(pack);
        }
        if (stat.isSocket()) return onnextentry();
        var header = {
          name: normalize2(filename),
          mode: (stat.mode | (stat.isDirectory() ? dmode : fmode)) & umask,
          mtime: stat.mtime,
          size: stat.size,
          type: "file",
          uid: stat.uid,
          gid: stat.gid
        };
        if (stat.isDirectory()) {
          header.size = 0;
          header.type = "directory";
          header = map(header) || header;
          return pack.entry(header, onnextentry);
        }
        if (stat.isSymbolicLink()) {
          header.size = 0;
          header.type = "symlink";
          header = map(header) || header;
          return onsymlink(filename, header);
        }
        header = map(header) || header;
        if (!stat.isFile()) {
          if (strict) return pack.destroy(new Error("unsupported type for " + filename));
          return onnextentry();
        }
        var entry = pack.entry(header, onnextentry);
        if (!entry) return;
        var rs = mapStream(xfs.createReadStream(path.join(cwd, filename)), header);
        rs.on("error", function(err2) {
          entry.destroy(err2);
        });
        pump(rs, entry);
      }, "onstat");
      var onnextentry = /* @__PURE__ */ __name(function(err) {
        if (err) return pack.destroy(err);
        statNext(onstat);
      }, "onnextentry");
      onnextentry();
      return pack;
    };
    var head = /* @__PURE__ */ __name(function(list) {
      return list.length ? list[list.length - 1] : null;
    }, "head");
    var processGetuid = /* @__PURE__ */ __name(function() {
      return process.getuid ? process.getuid() : -1;
    }, "processGetuid");
    var processUmask = /* @__PURE__ */ __name(function() {
      return process.umask ? process.umask() : 0;
    }, "processUmask");
    exports2.extract = function(cwd, opts) {
      if (!cwd) cwd = ".";
      if (!opts) opts = {};
      var xfs = opts.fs || fs;
      var ignore = opts.ignore || opts.filter || noop;
      var map = opts.map || noop;
      var mapStream = opts.mapStream || echo;
      var own = opts.chown !== false && !win32 && processGetuid() === 0;
      var extract = opts.extract || tar.extract();
      var stack = [];
      var now = /* @__PURE__ */ new Date();
      var umask = typeof opts.umask === "number" ? ~opts.umask : ~processUmask();
      var dmode = typeof opts.dmode === "number" ? opts.dmode : 0;
      var fmode = typeof opts.fmode === "number" ? opts.fmode : 0;
      var strict = opts.strict !== false;
      if (opts.strip) map = strip(map, opts.strip);
      if (opts.readable) {
        dmode |= parseInt(555, 8);
        fmode |= parseInt(444, 8);
      }
      if (opts.writable) {
        dmode |= parseInt(333, 8);
        fmode |= parseInt(222, 8);
      }
      var utimesParent = /* @__PURE__ */ __name(function(name, cb) {
        var top2;
        while ((top2 = head(stack)) && name.slice(0, top2[0].length) !== top2[0]) stack.pop();
        if (!top2) return cb();
        xfs.utimes(top2[0], now, top2[1], cb);
      }, "utimesParent");
      var utimes = /* @__PURE__ */ __name(function(name, header, cb) {
        if (opts.utimes === false) return cb();
        if (header.type === "directory") return xfs.utimes(name, now, header.mtime, cb);
        if (header.type === "symlink") return utimesParent(name, cb);
        xfs.utimes(name, now, header.mtime, function(err) {
          if (err) return cb(err);
          utimesParent(name, cb);
        });
      }, "utimes");
      var chperm = /* @__PURE__ */ __name(function(name, header, cb) {
        var link = header.type === "symlink";
        var chmod = link ? xfs.lchmod : xfs.chmod;
        var chown = link ? xfs.lchown : xfs.chown;
        if (!chmod) return cb();
        var mode = (header.mode | (header.type === "directory" ? dmode : fmode)) & umask;
        chmod(name, mode, function(err) {
          if (err) return cb(err);
          if (!own) return cb();
          if (!chown) return cb();
          chown(name, header.uid, header.gid, cb);
        });
      }, "chperm");
      extract.on("entry", function(header, stream, next) {
        header = map(header) || header;
        header.name = normalize2(header.name);
        var name = path.join(cwd, path.join("/", header.name));
        if (ignore(name, header)) {
          stream.resume();
          return next();
        }
        var stat = /* @__PURE__ */ __name(function(err) {
          if (err) return next(err);
          utimes(name, header, function(err2) {
            if (err2) return next(err2);
            if (win32) return next();
            chperm(name, header, next);
          });
        }, "stat");
        var onsymlink = /* @__PURE__ */ __name(function() {
          if (win32) return next();
          xfs.unlink(name, function() {
            xfs.symlink(header.linkname, name, stat);
          });
        }, "onsymlink");
        var onlink = /* @__PURE__ */ __name(function() {
          if (win32) return next();
          xfs.unlink(name, function() {
            var srcpath = path.join(cwd, path.join("/", header.linkname));
            xfs.link(srcpath, name, function(err) {
              if (err && err.code === "EPERM" && opts.hardlinkAsFilesFallback) {
                stream = xfs.createReadStream(srcpath);
                return onfile();
              }
              stat(err);
            });
          });
        }, "onlink");
        var onfile = /* @__PURE__ */ __name(function() {
          var ws = xfs.createWriteStream(name);
          var rs = mapStream(stream, header);
          ws.on("error", function(err) {
            rs.destroy(err);
          });
          pump(rs, ws, function(err) {
            if (err) return next(err);
            ws.on("close", stat);
          });
        }, "onfile");
        if (header.type === "directory") {
          stack.push([
            name,
            header.mtime
          ]);
          return mkdirfix(name, {
            fs: xfs,
            own,
            uid: header.uid,
            gid: header.gid
          }, stat);
        }
        var dir = path.dirname(name);
        validate2(xfs, dir, path.join(cwd, "."), function(err, valid) {
          if (err) return next(err);
          if (!valid) return next(new Error(dir + " is not a valid path"));
          mkdirfix(dir, {
            fs: xfs,
            own,
            uid: header.uid,
            gid: header.gid
          }, function(err2) {
            if (err2) return next(err2);
            switch (header.type) {
              case "file":
                return onfile();
              case "link":
                return onlink();
              case "symlink":
                return onsymlink();
            }
            if (strict) return next(new Error("unsupported type for " + name + " (" + header.type + ")"));
            stream.resume();
            next();
          });
        });
      });
      if (opts.finish) extract.on("finish", opts.finish);
      return extract;
    };
    function validate2(fs2, name, root, cb) {
      if (name === root) return cb(null, true);
      fs2.lstat(name, function(err, st) {
        if (err && err.code !== "ENOENT") return cb(err);
        if (err || st.isDirectory()) return validate2(fs2, path.join(name, ".."), root, cb);
        cb(null, false);
      });
    }
    __name(validate2, "validate");
    function mkdirfix(name, opts, cb) {
      mkdirp(name, {
        fs: opts.fs
      }, function(err, made) {
        if (!err && made && opts.own) {
          chownr(made, opts.uid, opts.gid, cb);
        } else {
          cb(err);
        }
      });
    }
    __name(mkdirfix, "mkdirfix");
  }
});

// node_modules/dockerode/lib/util.js
var require_util2 = __commonJS({
  "node_modules/dockerode/lib/util.js"(exports2, module2) {
    "use strict";
    var DockerIgnore = require_ignore();
    var fs = require("fs");
    var path = require("path");
    var tar = require_tar_fs();
    var zlib = require("zlib");
    var arr = [];
    var each = arr.forEach;
    var slice = arr.slice;
    module2.exports.extend = function(obj) {
      each.call(slice.call(arguments, 1), function(source) {
        if (source) {
          for (var prop in source) {
            obj[prop] = source[prop];
          }
        }
      });
      return obj;
    };
    module2.exports.processArgs = function(opts, callback, defaultOpts) {
      if (!callback && typeof opts === "function") {
        callback = opts;
        opts = null;
      }
      return {
        callback,
        opts: module2.exports.extend({}, defaultOpts, opts)
      };
    };
    module2.exports.parseRepositoryTag = function(input) {
      var separatorPos;
      var digestPos = input.indexOf("@");
      var colonPos = input.lastIndexOf(":");
      if (digestPos >= 0) {
        separatorPos = digestPos;
      } else if (colonPos >= 0) {
        separatorPos = colonPos;
      } else {
        return {
          repository: input
        };
      }
      var tag = input.slice(separatorPos + 1);
      if (tag.indexOf("/") === -1) {
        return {
          repository: input.slice(0, separatorPos),
          tag
        };
      }
      return {
        repository: input
      };
    };
    module2.exports.prepareBuildContext = function(file, next) {
      if (file && file.context) {
        fs.readFile(path.join(file.context, ".dockerignore"), (err, data) => {
          let ignoreFn;
          let filterFn;
          if (!err) {
            const dockerIgnore = DockerIgnore({
              ignorecase: false
            }).add(data.toString());
            filterFn = dockerIgnore.createFilter();
            ignoreFn = /* @__PURE__ */ __name((path2) => {
              return !filterFn(path2);
            }, "ignoreFn");
          }
          const entries = file.src.slice() || [];
          const pack = tar.pack(file.context, {
            entries: filterFn ? entries.filter(filterFn) : entries,
            ignore: ignoreFn
            // Only works on directories
          });
          next(pack.pipe(zlib.createGzip()));
        });
      } else {
        next(file);
      }
    };
  }
});

// node_modules/dockerode/lib/exec.js
var require_exec = __commonJS({
  "node_modules/dockerode/lib/exec.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Exec = /* @__PURE__ */ __name(function(modem, id) {
      this.modem = modem;
      this.id = id;
    }, "Exec");
    Exec.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Exec.prototype.start = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/exec/" + this.id + "/start",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        isStream: true,
        allowEmpty: true,
        hijack: args.opts.hijack,
        openStdin: args.opts.stdin,
        statusCodes: {
          200: true,
          204: true,
          404: "no such exec",
          409: "container stopped/paused",
          500: "container not running"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, data);
        });
      }
    };
    Exec.prototype.resize = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/exec/" + this.id + "/resize?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such exec",
          500: "container not running"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, data);
        });
      }
    };
    Exec.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/exec/" + this.id + "/json",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such exec",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, data);
        });
      }
    };
    module2.exports = Exec;
  }
});

// node_modules/dockerode/lib/container.js
var require_container2 = __commonJS({
  "node_modules/dockerode/lib/container.js"(exports2, module2) {
    "use strict";
    var extend = require_util2().extend;
    var Exec = require_exec();
    var util2 = require_util2();
    var Container2 = /* @__PURE__ */ __name(function(modem, id) {
      this.modem = modem;
      this.id = id;
      this.defaultOptions = {
        top: {},
        start: {},
        commit: {},
        stop: {},
        pause: {},
        unpause: {},
        restart: {},
        resize: {},
        attach: {},
        remove: {},
        copy: {},
        kill: {},
        exec: {},
        rename: {},
        log: {},
        stats: {},
        getArchive: {},
        infoArchive: {},
        putArchive: {},
        update: {},
        wait: {}
      };
    }, "Container");
    Container2.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Container2.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/containers/" + this.id + "/json?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.rename = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.rename);
      var optsf = {
        path: "/containers/" + this.id + "/rename?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.update = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.update);
      var optsf = {
        path: "/containers/" + this.id + "/update",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          400: "bad parameter",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.top = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.top);
      var optsf = {
        path: "/containers/" + this.id + "/top?",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.changes = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/containers/" + this.id + "/changes",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.listCheckpoint = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/containers/" + this.id + "/checkpoints?",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.deleteCheckpoint = function(checkpoint, opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/containers/" + this.id + "/checkpoints/" + checkpoint + "?",
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.createCheckpoint = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/containers/" + this.id + "/checkpoints",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        allowEmpty: true,
        statusCodes: {
          200: true,
          201: true,
          204: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.export = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/containers/" + this.id + "/export",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.start = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.start);
      var optsf = {
        path: "/containers/" + this.id + "/start?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          304: "container already started",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.pause = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.pause);
      var optsf = {
        path: "/containers/" + this.id + "/pause",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.unpause = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.unpause);
      var optsf = {
        path: "/containers/" + this.id + "/unpause",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.exec = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.exec);
      var optsf = {
        path: "/containers/" + this.id + "/exec",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          404: "no such container",
          409: "container stopped/paused",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(new Exec(self2.modem, data.Id));
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, new Exec(self2.modem, data.Id));
        });
      }
    };
    Container2.prototype.commit = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.commit);
      args.opts.container = this.id;
      var optsf = {
        path: "/commit?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.stop = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.stop);
      var optsf = {
        path: "/containers/" + this.id + "/stop?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          304: "container already stopped",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.restart = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.restart);
      var optsf = {
        path: "/containers/" + this.id + "/restart?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.kill = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.kill);
      var optsf = {
        path: "/containers/" + this.id + "/kill?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.resize = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.resize);
      var optsf = {
        path: "/containers/" + this.id + "/resize?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.attach = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.attach);
      var optsf = {
        path: "/containers/" + this.id + "/attach?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        isStream: true,
        hijack: args.opts.hijack,
        openStdin: args.opts.stdin,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, stream) {
            if (err) {
              return reject(err);
            }
            resolve5(stream);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, stream) {
          args.callback(err, stream);
        });
      }
    };
    Container2.prototype.wait = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.wait);
      var optsf = {
        path: "/containers/" + this.id + "/wait?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.remove);
      var optsf = {
        path: "/containers/" + this.id + "?",
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          400: "bad parameter",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.copy = function(opts, callback) {
      var self2 = this;
      console.log("container.copy is deprecated since Docker v1.8.x");
      var args = util2.processArgs(opts, callback, this.defaultOptions.copy);
      var optsf = {
        path: "/containers/" + this.id + "/copy",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.getArchive = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.getArchive);
      var optsf = {
        path: "/containers/" + this.id + "/archive?",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          400: "client error, bad parameters",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.infoArchive = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.infoArchive);
      var optsf = {
        path: "/containers/" + this.id + "/archive?",
        method: "HEAD",
        abortSignal: args.opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          400: "client error, bad parameters",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.putArchive = function(file, opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.putArchive);
      var optsf = {
        path: "/containers/" + this.id + "/archive?",
        method: "PUT",
        file,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "client error, bad parameters",
          403: "client error, permission denied",
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.logs = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.log);
      var optsf = {
        path: "/containers/" + this.id + "/logs?",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        isStream: args.opts.follow || false,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Container2.prototype.stats = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.stats);
      var isStream = true;
      if (args.opts.stream === false) {
        isStream = false;
      }
      var optsf = {
        path: "/containers/" + this.id + "/stats?",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        isStream,
        statusCodes: {
          200: true,
          404: "no such container",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Container2;
  }
});

// node_modules/dockerode/lib/image.js
var require_image = __commonJS({
  "node_modules/dockerode/lib/image.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Image = /* @__PURE__ */ __name(function(modem, name) {
      this.modem = modem;
      this.name = name;
    }, "Image");
    Image.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Image.prototype.inspect = function(callback) {
      var self2 = this;
      var opts = {
        path: "/images/" + this.name + "/json",
        method: "GET",
        statusCodes: {
          200: true,
          404: "no such image",
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(opts, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(opts, function(err, data) {
          if (err) return callback(err, data);
          callback(err, data);
        });
      }
    };
    Image.prototype.distribution = function(opts, callback) {
      var args = util2.processArgs(opts, callback);
      var self2 = this;
      var fopts = {
        path: "/distribution/" + this.name + "/json",
        method: "GET",
        statusCodes: {
          200: true,
          401: "no such image",
          500: "server error"
        },
        authconfig: args.opts ? args.opts.authconfig : void 0
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(fopts, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(fopts, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, data);
        });
      }
    };
    Image.prototype.history = function(callback) {
      var self2 = this;
      var opts = {
        path: "/images/" + this.name + "/history",
        method: "GET",
        statusCodes: {
          200: true,
          404: "no such image",
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(opts, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(opts, function(err, data) {
          if (err) return callback(err, data);
          callback(err, data);
        });
      }
    };
    Image.prototype.get = function(callback) {
      var self2 = this;
      var opts = {
        path: "/images/" + this.name + "/get",
        method: "GET",
        isStream: true,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(opts, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(opts, function(err, data) {
          if (err) return callback(err, data);
          callback(err, data);
        });
      }
    };
    Image.prototype.push = function(opts, callback, auth) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var isStream = true;
      if (args.opts.stream === false) {
        isStream = false;
      }
      var optsf = {
        path: "/images/" + this.name + "/push?",
        method: "POST",
        options: args.opts,
        authconfig: args.opts.authconfig || auth,
        abortSignal: args.opts.abortSignal,
        isStream,
        statusCodes: {
          200: true,
          404: "no such image",
          500: "server error"
        }
      };
      delete optsf.options.authconfig;
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Image.prototype.tag = function(opts, callback) {
      var self2 = this;
      var optsf = {
        path: "/images/" + this.name + "/tag?",
        method: "POST",
        options: opts,
        abortSignal: opts && opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          400: "bad parameter",
          404: "no such image",
          409: "conflict",
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Image.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/images/" + this.name + "?",
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such image",
          409: "conflict",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Image;
  }
});

// node_modules/dockerode/lib/volume.js
var require_volume = __commonJS({
  "node_modules/dockerode/lib/volume.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Volume = /* @__PURE__ */ __name(function(modem, name) {
      this.modem = modem;
      this.name = name;
    }, "Volume");
    Volume.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Volume.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/volumes/" + this.name,
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such volume",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Volume.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/volumes/" + this.name,
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          204: true,
          404: "no such volume",
          409: "conflict",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Volume;
  }
});

// node_modules/dockerode/lib/network.js
var require_network2 = __commonJS({
  "node_modules/dockerode/lib/network.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Network = /* @__PURE__ */ __name(function(modem, id) {
      this.modem = modem;
      this.id = id;
    }, "Network");
    Network.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Network.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var opts = {
        path: "/networks/" + this.id + "?",
        method: "GET",
        statusCodes: {
          200: true,
          404: "no such network",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(opts, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(opts, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Network.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/networks/" + this.id,
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "no such network",
          409: "conflict",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Network.prototype.connect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/networks/" + this.id + "/connect",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          404: "network or container is not found",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Network.prototype.disconnect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/networks/" + this.id + "/disconnect",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          404: "network or container is not found",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Network;
  }
});

// node_modules/dockerode/lib/service.js
var require_service = __commonJS({
  "node_modules/dockerode/lib/service.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Service = /* @__PURE__ */ __name(function(modem, id) {
      this.modem = modem;
      this.id = id;
    }, "Service");
    Service.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Service.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/services/" + this.id,
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such service",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Service.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/services/" + this.id,
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "no such service",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Service.prototype.update = function(auth, opts, callback) {
      var self2 = this;
      if (!callback) {
        var t = typeof opts;
        if (t === "function") {
          callback = opts;
          opts = auth;
          auth = opts.authconfig || void 0;
        } else if (t === "undefined") {
          opts = auth;
          auth = opts.authconfig || void 0;
        }
      }
      var optsf = {
        path: "/services/" + this.id + "/update?",
        method: "POST",
        abortSignal: opts && opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such service",
          500: "server error"
        },
        authconfig: auth,
        options: opts
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Service.prototype.logs = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, {});
      var optsf = {
        path: "/services/" + this.id + "/logs?",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        isStream: args.opts.follow || false,
        statusCodes: {
          200: true,
          404: "no such service",
          500: "server error",
          503: "node is not part of a swarm"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Service;
  }
});

// node_modules/dockerode/lib/plugin.js
var require_plugin = __commonJS({
  "node_modules/dockerode/lib/plugin.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Plugin = /* @__PURE__ */ __name(function(modem, name, remote) {
      this.modem = modem;
      this.name = name;
      this.remote = remote || name;
    }, "Plugin");
    Plugin.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Plugin.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins/" + this.name + "/json",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "plugin is not installed",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Plugin.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins/" + this.name + "?",
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "plugin is not installed",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, data);
        });
      }
    };
    Plugin.prototype.privileges = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins/privileges?",
        method: "GET",
        options: {
          "remote": this.remote
        },
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Plugin.prototype.pull = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      if (args.opts._query && !args.opts._query.name) {
        args.opts._query.name = this.name;
      }
      if (args.opts._query && !args.opts._query.remote) {
        args.opts._query.remote = this.remote;
      }
      var optsf = {
        path: "/plugins/pull?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        isStream: true,
        options: args.opts,
        statusCodes: {
          200: true,
          204: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Plugin.prototype.enable = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins/" + this.name + "/enable?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Plugin.prototype.disable = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins/" + this.name + "/disable",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Plugin.prototype.push = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins/" + this.name + "/push",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "plugin not installed",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Plugin.prototype.configure = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins/" + this.name + "/set",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "plugin not installed",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Plugin.prototype.upgrade = function(auth, opts, callback) {
      var self2 = this;
      if (!callback && typeof opts === "function") {
        callback = opts;
        opts = auth;
        auth = opts.authconfig || void 0;
      }
      var optsf = {
        path: "/plugins/" + this.name + "/upgrade?",
        method: "POST",
        abortSignal: opts && opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "plugin not installed",
          500: "server error"
        },
        authconfig: auth,
        options: opts
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    module2.exports = Plugin;
  }
});

// node_modules/dockerode/lib/secret.js
var require_secret = __commonJS({
  "node_modules/dockerode/lib/secret.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Secret = /* @__PURE__ */ __name(function(modem, id) {
      this.modem = modem;
      this.id = id;
    }, "Secret");
    Secret.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Secret.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/secrets/" + this.id,
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "secret not found",
          406: "node is not part of a swarm",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Secret.prototype.update = function(opts, callback) {
      var self2 = this;
      if (!callback && typeof opts === "function") {
        callback = opts;
      }
      var optsf = {
        path: "/secrets/" + this.id + "/update?",
        method: "POST",
        abortSignal: opts && opts.abortSignal,
        statusCodes: {
          200: true,
          404: "secret not found",
          500: "server error"
        },
        options: opts
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Secret.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/secrets/" + this.id,
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "secret not found",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Secret;
  }
});

// node_modules/dockerode/lib/config.js
var require_config3 = __commonJS({
  "node_modules/dockerode/lib/config.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Config = /* @__PURE__ */ __name(function(modem, id) {
      this.modem = modem;
      this.id = id;
    }, "Config");
    Config.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Config.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/configs/" + this.id,
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "config not found",
          500: "server error",
          503: "node is not part of a swarm"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Config.prototype.update = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/configs/" + this.id + "/update?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "config not found",
          500: "server error",
          503: "node is not part of a swarm"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Config.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/configs/" + this.id,
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          404: "config not found",
          500: "server error",
          503: "node is not part of a swarm"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Config;
  }
});

// node_modules/dockerode/lib/task.js
var require_task = __commonJS({
  "node_modules/dockerode/lib/task.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Task = /* @__PURE__ */ __name(function(modem, id) {
      this.modem = modem;
      this.id = id;
      this.defaultOptions = {
        log: {}
      };
    }, "Task");
    Task.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Task.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/tasks/" + this.id,
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "unknown task",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Task.prototype.logs = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback, this.defaultOptions.log);
      var optsf = {
        path: "/tasks/" + this.id + "/logs?",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        isStream: args.opts.follow || false,
        statusCodes: {
          101: true,
          200: true,
          404: "no such container",
          500: "server error",
          503: "node is not part of a swarm"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Task;
  }
});

// node_modules/dockerode/lib/node.js
var require_node7 = __commonJS({
  "node_modules/dockerode/lib/node.js"(exports2, module2) {
    "use strict";
    var util2 = require_util2();
    var Node = /* @__PURE__ */ __name(function(modem, id) {
      this.modem = modem;
      this.id = id;
    }, "Node");
    Node.prototype[require("util").inspect.custom] = function() {
      return this;
    };
    Node.prototype.inspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/nodes/" + this.id,
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such node",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Node.prototype.update = function(opts, callback) {
      var self2 = this;
      if (!callback && typeof opts === "function") {
        callback = opts;
      }
      var optsf = {
        path: "/nodes/" + this.id + "/update?",
        method: "POST",
        abortSignal: opts && opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such node",
          406: "node is not part of a swarm",
          500: "server error"
        },
        options: opts
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Node.prototype.remove = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/nodes/" + this.id + "?",
        method: "DELETE",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          404: "no such node",
          500: "server error"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    module2.exports = Node;
  }
});

// node_modules/@grpc/grpc-js/build/src/constants.js
var require_constants3 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/constants.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = exports2.Propagate = exports2.LogVerbosity = exports2.Status = void 0;
    var Status;
    (function(Status2) {
      Status2[Status2["OK"] = 0] = "OK";
      Status2[Status2["CANCELLED"] = 1] = "CANCELLED";
      Status2[Status2["UNKNOWN"] = 2] = "UNKNOWN";
      Status2[Status2["INVALID_ARGUMENT"] = 3] = "INVALID_ARGUMENT";
      Status2[Status2["DEADLINE_EXCEEDED"] = 4] = "DEADLINE_EXCEEDED";
      Status2[Status2["NOT_FOUND"] = 5] = "NOT_FOUND";
      Status2[Status2["ALREADY_EXISTS"] = 6] = "ALREADY_EXISTS";
      Status2[Status2["PERMISSION_DENIED"] = 7] = "PERMISSION_DENIED";
      Status2[Status2["RESOURCE_EXHAUSTED"] = 8] = "RESOURCE_EXHAUSTED";
      Status2[Status2["FAILED_PRECONDITION"] = 9] = "FAILED_PRECONDITION";
      Status2[Status2["ABORTED"] = 10] = "ABORTED";
      Status2[Status2["OUT_OF_RANGE"] = 11] = "OUT_OF_RANGE";
      Status2[Status2["UNIMPLEMENTED"] = 12] = "UNIMPLEMENTED";
      Status2[Status2["INTERNAL"] = 13] = "INTERNAL";
      Status2[Status2["UNAVAILABLE"] = 14] = "UNAVAILABLE";
      Status2[Status2["DATA_LOSS"] = 15] = "DATA_LOSS";
      Status2[Status2["UNAUTHENTICATED"] = 16] = "UNAUTHENTICATED";
    })(Status || (exports2.Status = Status = {}));
    var LogVerbosity;
    (function(LogVerbosity2) {
      LogVerbosity2[LogVerbosity2["DEBUG"] = 0] = "DEBUG";
      LogVerbosity2[LogVerbosity2["INFO"] = 1] = "INFO";
      LogVerbosity2[LogVerbosity2["ERROR"] = 2] = "ERROR";
      LogVerbosity2[LogVerbosity2["NONE"] = 3] = "NONE";
    })(LogVerbosity || (exports2.LogVerbosity = LogVerbosity = {}));
    var Propagate;
    (function(Propagate2) {
      Propagate2[Propagate2["DEADLINE"] = 1] = "DEADLINE";
      Propagate2[Propagate2["CENSUS_STATS_CONTEXT"] = 2] = "CENSUS_STATS_CONTEXT";
      Propagate2[Propagate2["CENSUS_TRACING_CONTEXT"] = 4] = "CENSUS_TRACING_CONTEXT";
      Propagate2[Propagate2["CANCELLATION"] = 8] = "CANCELLATION";
      Propagate2[Propagate2["DEFAULTS"] = 65535] = "DEFAULTS";
    })(Propagate || (exports2.Propagate = Propagate = {}));
    exports2.DEFAULT_MAX_SEND_MESSAGE_LENGTH = -1;
    exports2.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH = 4 * 1024 * 1024;
  }
});

// node_modules/@grpc/grpc-js/package.json
var require_package4 = __commonJS({
  "node_modules/@grpc/grpc-js/package.json"(exports2, module2) {
    module2.exports = {
      name: "@grpc/grpc-js",
      version: "1.12.6",
      description: "gRPC Library for Node - pure JS implementation",
      homepage: "https://grpc.io/",
      repository: "https://github.com/grpc/grpc-node/tree/master/packages/grpc-js",
      main: "build/src/index.js",
      engines: {
        node: ">=12.10.0"
      },
      keywords: [],
      author: {
        name: "Google Inc."
      },
      types: "build/src/index.d.ts",
      license: "Apache-2.0",
      devDependencies: {
        "@grpc/proto-loader": "file:../proto-loader",
        "@types/gulp": "^4.0.17",
        "@types/gulp-mocha": "0.0.37",
        "@types/lodash": "^4.14.202",
        "@types/mocha": "^10.0.6",
        "@types/ncp": "^2.0.8",
        "@types/node": ">=20.11.20",
        "@types/pify": "^5.0.4",
        "@types/semver": "^7.5.8",
        "@typescript-eslint/eslint-plugin": "^7.1.0",
        "@typescript-eslint/parser": "^7.1.0",
        "@typescript-eslint/typescript-estree": "^7.1.0",
        "clang-format": "^1.8.0",
        eslint: "^8.42.0",
        "eslint-config-prettier": "^8.8.0",
        "eslint-plugin-node": "^11.1.0",
        "eslint-plugin-prettier": "^4.2.1",
        execa: "^2.0.3",
        gulp: "^4.0.2",
        "gulp-mocha": "^6.0.0",
        lodash: "^4.17.21",
        madge: "^5.0.1",
        "mocha-jenkins-reporter": "^0.4.1",
        ncp: "^2.0.0",
        pify: "^4.0.1",
        prettier: "^2.8.8",
        rimraf: "^3.0.2",
        semver: "^7.6.0",
        "ts-node": "^10.9.2",
        typescript: "^5.3.3"
      },
      contributors: [
        {
          name: "Google Inc."
        }
      ],
      scripts: {
        build: "npm run compile",
        clean: "rimraf ./build",
        compile: "tsc -p .",
        format: 'clang-format -i -style="{Language: JavaScript, BasedOnStyle: Google, ColumnLimit: 80}" src/*.ts test/*.ts',
        lint: "eslint src/*.ts test/*.ts",
        prepare: "npm run generate-types && npm run compile",
        test: "gulp test",
        check: "npm run lint",
        fix: "eslint --fix src/*.ts test/*.ts",
        pretest: "npm run generate-types && npm run generate-test-types && npm run compile",
        posttest: "npm run check && madge -c ./build/src",
        "generate-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --includeDirs proto/ --include-dirs test/fixtures/ -O src/generated/ --grpcLib ../index channelz.proto",
        "generate-test-types": "proto-loader-gen-types --keepCase --longs String --enums String --defaults --oneofs --includeComments --include-dirs test/fixtures/ -O test/generated/ --grpcLib ../../src/index test_service.proto"
      },
      dependencies: {
        "@grpc/proto-loader": "^0.7.13",
        "@js-sdsl/ordered-map": "^4.4.2"
      },
      files: [
        "src/**/*.ts",
        "build/src/**/*.{js,d.ts,js.map}",
        "proto/*.proto",
        "LICENSE",
        "deps/envoy-api/envoy/api/v2/**/*.proto",
        "deps/envoy-api/envoy/config/**/*.proto",
        "deps/envoy-api/envoy/service/**/*.proto",
        "deps/envoy-api/envoy/type/**/*.proto",
        "deps/udpa/udpa/**/*.proto",
        "deps/googleapis/google/api/*.proto",
        "deps/googleapis/google/rpc/*.proto",
        "deps/protoc-gen-validate/validate/**/*.proto"
      ]
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/logging.js
var require_logging = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/logging.js"(exports2) {
    "use strict";
    var _a2;
    var _b2;
    var _c2;
    var _d;
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.log = exports2.setLoggerVerbosity = exports2.setLogger = exports2.getLogger = void 0;
    exports2.trace = trace;
    exports2.isTracerEnabled = isTracerEnabled;
    var constants_1 = require_constants3();
    var process_1 = require("process");
    var clientVersion = require_package4().version;
    var DEFAULT_LOGGER = {
      error: /* @__PURE__ */ __name((message, ...optionalParams) => {
        console.error("E " + message, ...optionalParams);
      }, "error"),
      info: /* @__PURE__ */ __name((message, ...optionalParams) => {
        console.error("I " + message, ...optionalParams);
      }, "info"),
      debug: /* @__PURE__ */ __name((message, ...optionalParams) => {
        console.error("D " + message, ...optionalParams);
      }, "debug")
    };
    var _logger = DEFAULT_LOGGER;
    var _logVerbosity = constants_1.LogVerbosity.ERROR;
    var verbosityString = (_b2 = (_a2 = process.env.GRPC_NODE_VERBOSITY) !== null && _a2 !== void 0 ? _a2 : process.env.GRPC_VERBOSITY) !== null && _b2 !== void 0 ? _b2 : "";
    switch (verbosityString.toUpperCase()) {
      case "DEBUG":
        _logVerbosity = constants_1.LogVerbosity.DEBUG;
        break;
      case "INFO":
        _logVerbosity = constants_1.LogVerbosity.INFO;
        break;
      case "ERROR":
        _logVerbosity = constants_1.LogVerbosity.ERROR;
        break;
      case "NONE":
        _logVerbosity = constants_1.LogVerbosity.NONE;
        break;
      default:
    }
    var getLogger = /* @__PURE__ */ __name(() => {
      return _logger;
    }, "getLogger");
    exports2.getLogger = getLogger;
    var setLogger = /* @__PURE__ */ __name((logger2) => {
      _logger = logger2;
    }, "setLogger");
    exports2.setLogger = setLogger;
    var setLoggerVerbosity = /* @__PURE__ */ __name((verbosity) => {
      _logVerbosity = verbosity;
    }, "setLoggerVerbosity");
    exports2.setLoggerVerbosity = setLoggerVerbosity;
    var log = /* @__PURE__ */ __name((severity, ...args) => {
      let logFunction;
      if (severity >= _logVerbosity) {
        switch (severity) {
          case constants_1.LogVerbosity.DEBUG:
            logFunction = _logger.debug;
            break;
          case constants_1.LogVerbosity.INFO:
            logFunction = _logger.info;
            break;
          case constants_1.LogVerbosity.ERROR:
            logFunction = _logger.error;
            break;
        }
        if (!logFunction) {
          logFunction = _logger.error;
        }
        if (logFunction) {
          logFunction.bind(_logger)(...args);
        }
      }
    }, "log");
    exports2.log = log;
    var tracersString = (_d = (_c2 = process.env.GRPC_NODE_TRACE) !== null && _c2 !== void 0 ? _c2 : process.env.GRPC_TRACE) !== null && _d !== void 0 ? _d : "";
    var enabledTracers = /* @__PURE__ */ new Set();
    var disabledTracers = /* @__PURE__ */ new Set();
    for (const tracerName of tracersString.split(",")) {
      if (tracerName.startsWith("-")) {
        disabledTracers.add(tracerName.substring(1));
      } else {
        enabledTracers.add(tracerName);
      }
    }
    var allEnabled = enabledTracers.has("all");
    function trace(severity, tracer, text) {
      if (isTracerEnabled(tracer)) {
        (0, exports2.log)(severity, (/* @__PURE__ */ new Date()).toISOString() + " | v" + clientVersion + " " + process_1.pid + " | " + tracer + " | " + text);
      }
    }
    __name(trace, "trace");
    function isTracerEnabled(tracer) {
      return !disabledTracers.has(tracer) && (allEnabled || enabledTracers.has(tracer));
    }
    __name(isTracerEnabled, "isTracerEnabled");
  }
});

// node_modules/@grpc/grpc-js/build/src/error.js
var require_error = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/error.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getErrorMessage = getErrorMessage;
    exports2.getErrorCode = getErrorCode;
    function getErrorMessage(error) {
      if (error instanceof Error) {
        return error.message;
      } else {
        return String(error);
      }
    }
    __name(getErrorMessage, "getErrorMessage");
    function getErrorCode(error) {
      if (typeof error === "object" && error !== null && "code" in error && typeof error.code === "number") {
        return error.code;
      } else {
        return null;
      }
    }
    __name(getErrorCode, "getErrorCode");
  }
});

// node_modules/@grpc/grpc-js/build/src/metadata.js
var require_metadata2 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/metadata.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Metadata = void 0;
    var logging_1 = require_logging();
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var LEGAL_KEY_REGEX = /^[0-9a-z_.-]+$/;
    var LEGAL_NON_BINARY_VALUE_REGEX = /^[ -~]*$/;
    function isLegalKey(key) {
      return LEGAL_KEY_REGEX.test(key);
    }
    __name(isLegalKey, "isLegalKey");
    function isLegalNonBinaryValue(value2) {
      return LEGAL_NON_BINARY_VALUE_REGEX.test(value2);
    }
    __name(isLegalNonBinaryValue, "isLegalNonBinaryValue");
    function isBinaryKey(key) {
      return key.endsWith("-bin");
    }
    __name(isBinaryKey, "isBinaryKey");
    function isCustomMetadata(key) {
      return !key.startsWith("grpc-");
    }
    __name(isCustomMetadata, "isCustomMetadata");
    function normalizeKey(key) {
      return key.toLowerCase();
    }
    __name(normalizeKey, "normalizeKey");
    function validate2(key, value2) {
      if (!isLegalKey(key)) {
        throw new Error('Metadata key "' + key + '" contains illegal characters');
      }
      if (value2 !== null && value2 !== void 0) {
        if (isBinaryKey(key)) {
          if (!Buffer.isBuffer(value2)) {
            throw new Error("keys that end with '-bin' must have Buffer values");
          }
        } else {
          if (Buffer.isBuffer(value2)) {
            throw new Error("keys that don't end with '-bin' must have String values");
          }
          if (!isLegalNonBinaryValue(value2)) {
            throw new Error('Metadata string value "' + value2 + '" contains illegal characters');
          }
        }
      }
    }
    __name(validate2, "validate");
    var Metadata = class Metadata2 {
      static {
        __name(this, "Metadata");
      }
      constructor(options = {}) {
        this.internalRepr = /* @__PURE__ */ new Map();
        this.options = options;
      }
      /**
       * Sets the given value for the given key by replacing any other values
       * associated with that key. Normalizes the key.
       * @param key The key to whose value should be set.
       * @param value The value to set. Must be a buffer if and only
       *   if the normalized key ends with '-bin'.
       */
      set(key, value2) {
        key = normalizeKey(key);
        validate2(key, value2);
        this.internalRepr.set(key, [
          value2
        ]);
      }
      /**
       * Adds the given value for the given key by appending to a list of previous
       * values associated with that key. Normalizes the key.
       * @param key The key for which a new value should be appended.
       * @param value The value to add. Must be a buffer if and only
       *   if the normalized key ends with '-bin'.
       */
      add(key, value2) {
        key = normalizeKey(key);
        validate2(key, value2);
        const existingValue = this.internalRepr.get(key);
        if (existingValue === void 0) {
          this.internalRepr.set(key, [
            value2
          ]);
        } else {
          existingValue.push(value2);
        }
      }
      /**
       * Removes the given key and any associated values. Normalizes the key.
       * @param key The key whose values should be removed.
       */
      remove(key) {
        key = normalizeKey(key);
        this.internalRepr.delete(key);
      }
      /**
       * Gets a list of all values associated with the key. Normalizes the key.
       * @param key The key whose value should be retrieved.
       * @return A list of values associated with the given key.
       */
      get(key) {
        key = normalizeKey(key);
        return this.internalRepr.get(key) || [];
      }
      /**
       * Gets a plain object mapping each key to the first value associated with it.
       * This reflects the most common way that people will want to see metadata.
       * @return A key/value mapping of the metadata.
       */
      getMap() {
        const result2 = {};
        for (const [key, values] of this.internalRepr) {
          if (values.length > 0) {
            const v = values[0];
            result2[key] = Buffer.isBuffer(v) ? Buffer.from(v) : v;
          }
        }
        return result2;
      }
      /**
       * Clones the metadata object.
       * @return The newly cloned object.
       */
      clone() {
        const newMetadata = new Metadata2(this.options);
        const newInternalRepr = newMetadata.internalRepr;
        for (const [key, value2] of this.internalRepr) {
          const clonedValue = value2.map((v) => {
            if (Buffer.isBuffer(v)) {
              return Buffer.from(v);
            } else {
              return v;
            }
          });
          newInternalRepr.set(key, clonedValue);
        }
        return newMetadata;
      }
      /**
       * Merges all key-value pairs from a given Metadata object into this one.
       * If both this object and the given object have values in the same key,
       * values from the other Metadata object will be appended to this object's
       * values.
       * @param other A Metadata object.
       */
      merge(other) {
        for (const [key, values] of other.internalRepr) {
          const mergedValue = (this.internalRepr.get(key) || []).concat(values);
          this.internalRepr.set(key, mergedValue);
        }
      }
      setOptions(options) {
        this.options = options;
      }
      getOptions() {
        return this.options;
      }
      /**
       * Creates an OutgoingHttpHeaders object that can be used with the http2 API.
       */
      toHttp2Headers() {
        const result2 = {};
        for (const [key, values] of this.internalRepr) {
          result2[key] = values.map(bufToString);
        }
        return result2;
      }
      /**
       * This modifies the behavior of JSON.stringify to show an object
       * representation of the metadata map.
       */
      toJSON() {
        const result2 = {};
        for (const [key, values] of this.internalRepr) {
          result2[key] = values;
        }
        return result2;
      }
      /**
       * Returns a new Metadata object based fields in a given IncomingHttpHeaders
       * object.
       * @param headers An IncomingHttpHeaders object.
       */
      static fromHttp2Headers(headers) {
        const result2 = new Metadata2();
        for (const key of Object.keys(headers)) {
          if (key.charAt(0) === ":") {
            continue;
          }
          const values = headers[key];
          try {
            if (isBinaryKey(key)) {
              if (Array.isArray(values)) {
                values.forEach((value2) => {
                  result2.add(key, Buffer.from(value2, "base64"));
                });
              } else if (values !== void 0) {
                if (isCustomMetadata(key)) {
                  values.split(",").forEach((v) => {
                    result2.add(key, Buffer.from(v.trim(), "base64"));
                  });
                } else {
                  result2.add(key, Buffer.from(values, "base64"));
                }
              }
            } else {
              if (Array.isArray(values)) {
                values.forEach((value2) => {
                  result2.add(key, value2);
                });
              } else if (values !== void 0) {
                result2.add(key, values);
              }
            }
          } catch (error) {
            const message = `Failed to add metadata entry ${key}: ${values}. ${(0, error_1.getErrorMessage)(error)}. For more information see https://github.com/grpc/grpc-node/issues/1173`;
            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, message);
          }
        }
        return result2;
      }
    };
    exports2.Metadata = Metadata;
    var bufToString = /* @__PURE__ */ __name((val) => {
      return Buffer.isBuffer(val) ? val.toString("base64") : val;
    }, "bufToString");
  }
});

// node_modules/@grpc/grpc-js/build/src/call-credentials.js
var require_call_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CallCredentials = void 0;
    var metadata_1 = require_metadata2();
    function isCurrentOauth2Client(client2) {
      return "getRequestHeaders" in client2 && typeof client2.getRequestHeaders === "function";
    }
    __name(isCurrentOauth2Client, "isCurrentOauth2Client");
    var CallCredentials = class CallCredentials2 {
      static {
        __name(this, "CallCredentials");
      }
      /**
       * Creates a new CallCredentials object from a given function that generates
       * Metadata objects.
       * @param metadataGenerator A function that accepts a set of options, and
       * generates a Metadata object based on these options, which is passed back
       * to the caller via a supplied (err, metadata) callback.
       */
      static createFromMetadataGenerator(metadataGenerator) {
        return new SingleCallCredentials(metadataGenerator);
      }
      /**
       * Create a gRPC credential from a Google credential object.
       * @param googleCredentials The authentication client to use.
       * @return The resulting CallCredentials object.
       */
      static createFromGoogleCredential(googleCredentials) {
        return CallCredentials2.createFromMetadataGenerator((options, callback) => {
          let getHeaders;
          if (isCurrentOauth2Client(googleCredentials)) {
            getHeaders = googleCredentials.getRequestHeaders(options.service_url);
          } else {
            getHeaders = new Promise((resolve5, reject) => {
              googleCredentials.getRequestMetadata(options.service_url, (err, headers) => {
                if (err) {
                  reject(err);
                  return;
                }
                if (!headers) {
                  reject(new Error("Headers not set by metadata plugin"));
                  return;
                }
                resolve5(headers);
              });
            });
          }
          getHeaders.then((headers) => {
            const metadata = new metadata_1.Metadata();
            for (const key of Object.keys(headers)) {
              metadata.add(key, headers[key]);
            }
            callback(null, metadata);
          }, (err) => {
            callback(err);
          });
        });
      }
      static createEmpty() {
        return new EmptyCallCredentials();
      }
    };
    exports2.CallCredentials = CallCredentials;
    var ComposedCallCredentials = class ComposedCallCredentials2 extends CallCredentials {
      static {
        __name(this, "ComposedCallCredentials");
      }
      constructor(creds) {
        super();
        this.creds = creds;
      }
      async generateMetadata(options) {
        const base = new metadata_1.Metadata();
        const generated = await Promise.all(this.creds.map((cred) => cred.generateMetadata(options)));
        for (const gen of generated) {
          base.merge(gen);
        }
        return base;
      }
      compose(other) {
        return new ComposedCallCredentials2(this.creds.concat([
          other
        ]));
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedCallCredentials2) {
          return this.creds.every((value2, index) => value2._equals(other.creds[index]));
        } else {
          return false;
        }
      }
    };
    var SingleCallCredentials = class SingleCallCredentials2 extends CallCredentials {
      static {
        __name(this, "SingleCallCredentials");
      }
      constructor(metadataGenerator) {
        super();
        this.metadataGenerator = metadataGenerator;
      }
      generateMetadata(options) {
        return new Promise((resolve5, reject) => {
          this.metadataGenerator(options, (err, metadata) => {
            if (metadata !== void 0) {
              resolve5(metadata);
            } else {
              reject(err);
            }
          });
        });
      }
      compose(other) {
        return new ComposedCallCredentials([
          this,
          other
        ]);
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SingleCallCredentials2) {
          return this.metadataGenerator === other.metadataGenerator;
        } else {
          return false;
        }
      }
    };
    var EmptyCallCredentials = class EmptyCallCredentials2 extends CallCredentials {
      static {
        __name(this, "EmptyCallCredentials");
      }
      generateMetadata(options) {
        return Promise.resolve(new metadata_1.Metadata());
      }
      compose(other) {
        return other;
      }
      _equals(other) {
        return other instanceof EmptyCallCredentials2;
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/tls-helpers.js
var require_tls_helpers = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/tls-helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CIPHER_SUITES = void 0;
    exports2.getDefaultRootsData = getDefaultRootsData;
    var fs = require("fs");
    exports2.CIPHER_SUITES = process.env.GRPC_SSL_CIPHER_SUITES;
    var DEFAULT_ROOTS_FILE_PATH = process.env.GRPC_DEFAULT_SSL_ROOTS_FILE_PATH;
    var defaultRootsData = null;
    function getDefaultRootsData() {
      if (DEFAULT_ROOTS_FILE_PATH) {
        if (defaultRootsData === null) {
          defaultRootsData = fs.readFileSync(DEFAULT_ROOTS_FILE_PATH);
        }
        return defaultRootsData;
      }
      return null;
    }
    __name(getDefaultRootsData, "getDefaultRootsData");
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-credentials.js
var require_channel_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ChannelCredentials = void 0;
    exports2.createCertificateProviderChannelCredentials = createCertificateProviderChannelCredentials;
    var tls_1 = require("tls");
    var call_credentials_1 = require_call_credentials();
    var tls_helpers_1 = require_tls_helpers();
    function verifyIsBufferOrNull(obj, friendlyName) {
      if (obj && !(obj instanceof Buffer)) {
        throw new TypeError(`${friendlyName}, if provided, must be a Buffer.`);
      }
    }
    __name(verifyIsBufferOrNull, "verifyIsBufferOrNull");
    var ChannelCredentials = class ChannelCredentials {
      static {
        __name(this, "ChannelCredentials");
      }
      constructor(callCredentials) {
        this.callCredentials = callCredentials || call_credentials_1.CallCredentials.createEmpty();
      }
      /**
       * Gets the set of per-call credentials associated with this instance.
       */
      _getCallCredentials() {
        return this.callCredentials;
      }
      _ref() {
      }
      _unref() {
      }
      /**
       * Return a new ChannelCredentials instance with a given set of credentials.
       * The resulting instance can be used to construct a Channel that communicates
       * over TLS.
       * @param rootCerts The root certificate data.
       * @param privateKey The client certificate private key, if available.
       * @param certChain The client certificate key chain, if available.
       * @param verifyOptions Additional options to modify certificate verification
       */
      static createSsl(rootCerts, privateKey, certChain, verifyOptions) {
        var _a2;
        verifyIsBufferOrNull(rootCerts, "Root certificate");
        verifyIsBufferOrNull(privateKey, "Private key");
        verifyIsBufferOrNull(certChain, "Certificate chain");
        if (privateKey && !certChain) {
          throw new Error("Private key must be given with accompanying certificate chain");
        }
        if (!privateKey && certChain) {
          throw new Error("Certificate chain must be given with accompanying private key");
        }
        const secureContext = (0, tls_1.createSecureContext)({
          ca: (_a2 = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a2 !== void 0 ? _a2 : void 0,
          key: privateKey !== null && privateKey !== void 0 ? privateKey : void 0,
          cert: certChain !== null && certChain !== void 0 ? certChain : void 0,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
      }
      /**
       * Return a new ChannelCredentials instance with credentials created using
       * the provided secureContext. The resulting instances can be used to
       * construct a Channel that communicates over TLS. gRPC will not override
       * anything in the provided secureContext, so the environment variables
       * GRPC_SSL_CIPHER_SUITES and GRPC_DEFAULT_SSL_ROOTS_FILE_PATH will
       * not be applied.
       * @param secureContext The return value of tls.createSecureContext()
       * @param verifyOptions Additional options to modify certificate verification
       */
      static createFromSecureContext(secureContext, verifyOptions) {
        return new SecureChannelCredentialsImpl(secureContext, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : {});
      }
      /**
       * Return a new ChannelCredentials instance with no credentials.
       */
      static createInsecure() {
        return new InsecureChannelCredentialsImpl();
      }
    };
    exports2.ChannelCredentials = ChannelCredentials;
    var InsecureChannelCredentialsImpl = class InsecureChannelCredentialsImpl2 extends ChannelCredentials {
      static {
        __name(this, "InsecureChannelCredentialsImpl");
      }
      constructor() {
        super();
      }
      compose(callCredentials) {
        throw new Error("Cannot compose insecure credentials");
      }
      _getConnectionOptions() {
        return {};
      }
      _isSecure() {
        return false;
      }
      _equals(other) {
        return other instanceof InsecureChannelCredentialsImpl2;
      }
    };
    var SecureChannelCredentialsImpl = class SecureChannelCredentialsImpl2 extends ChannelCredentials {
      static {
        __name(this, "SecureChannelCredentialsImpl");
      }
      constructor(secureContext, verifyOptions) {
        super();
        this.secureContext = secureContext;
        this.verifyOptions = verifyOptions;
        this.connectionOptions = {
          secureContext
        };
        if (verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.checkServerIdentity) {
          this.connectionOptions.checkServerIdentity = verifyOptions.checkServerIdentity;
        }
        if ((verifyOptions === null || verifyOptions === void 0 ? void 0 : verifyOptions.rejectUnauthorized) !== void 0) {
          this.connectionOptions.rejectUnauthorized = verifyOptions.rejectUnauthorized;
        }
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return Object.assign({}, this.connectionOptions);
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof SecureChannelCredentialsImpl2) {
          return this.secureContext === other.secureContext && this.verifyOptions.checkServerIdentity === other.verifyOptions.checkServerIdentity;
        } else {
          return false;
        }
      }
    };
    var CertificateProviderChannelCredentialsImpl = class CertificateProviderChannelCredentialsImpl2 extends ChannelCredentials {
      static {
        __name(this, "CertificateProviderChannelCredentialsImpl");
      }
      constructor(caCertificateProvider, identityCertificateProvider, verifyOptions) {
        super();
        this.caCertificateProvider = caCertificateProvider;
        this.identityCertificateProvider = identityCertificateProvider;
        this.verifyOptions = verifyOptions;
        this.refcount = 0;
        this.latestCaUpdate = null;
        this.latestIdentityUpdate = null;
        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl(this, combinedCallCredentials);
      }
      _getConnectionOptions() {
        var _a2, _b2, _c2;
        if (this.latestCaUpdate === null) {
          return null;
        }
        if (this.identityCertificateProvider !== null && this.latestIdentityUpdate === null) {
          return null;
        }
        const secureContext = (0, tls_1.createSecureContext)({
          ca: this.latestCaUpdate.caCertificate,
          key: (_a2 = this.latestIdentityUpdate) === null || _a2 === void 0 ? void 0 : _a2.privateKey,
          cert: (_b2 = this.latestIdentityUpdate) === null || _b2 === void 0 ? void 0 : _b2.certificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
        const options = {
          secureContext
        };
        if ((_c2 = this.verifyOptions) === null || _c2 === void 0 ? void 0 : _c2.checkServerIdentity) {
          options.checkServerIdentity = this.verifyOptions.checkServerIdentity;
        }
        return options;
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        var _a2, _b2;
        if (this === other) {
          return true;
        }
        if (other instanceof CertificateProviderChannelCredentialsImpl2) {
          return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && ((_a2 = this.verifyOptions) === null || _a2 === void 0 ? void 0 : _a2.checkServerIdentity) === ((_b2 = other.verifyOptions) === null || _b2 === void 0 ? void 0 : _b2.checkServerIdentity);
        } else {
          return false;
        }
      }
      _ref() {
        var _a2;
        if (this.refcount === 0) {
          this.caCertificateProvider.addCaCertificateListener(this.caCertificateUpdateListener);
          (_a2 = this.identityCertificateProvider) === null || _a2 === void 0 ? void 0 : _a2.addIdentityCertificateListener(this.identityCertificateUpdateListener);
        }
        this.refcount += 1;
      }
      _unref() {
        var _a2;
        this.refcount -= 1;
        if (this.refcount === 0) {
          this.caCertificateProvider.removeCaCertificateListener(this.caCertificateUpdateListener);
          (_a2 = this.identityCertificateProvider) === null || _a2 === void 0 ? void 0 : _a2.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
        }
      }
      handleCaCertificateUpdate(update) {
        this.latestCaUpdate = update;
      }
      handleIdentityCertitificateUpdate(update) {
        this.latestIdentityUpdate = update;
      }
    };
    function createCertificateProviderChannelCredentials(caCertificateProvider, identityCertificateProvider, verifyOptions) {
      return new CertificateProviderChannelCredentialsImpl(caCertificateProvider, identityCertificateProvider, verifyOptions !== null && verifyOptions !== void 0 ? verifyOptions : null);
    }
    __name(createCertificateProviderChannelCredentials, "createCertificateProviderChannelCredentials");
    var ComposedChannelCredentialsImpl = class ComposedChannelCredentialsImpl2 extends ChannelCredentials {
      static {
        __name(this, "ComposedChannelCredentialsImpl");
      }
      constructor(channelCredentials, callCreds) {
        super(callCreds);
        this.channelCredentials = channelCredentials;
        if (!channelCredentials._isSecure()) {
          throw new Error("Cannot compose insecure credentials");
        }
      }
      compose(callCredentials) {
        const combinedCallCredentials = this.callCredentials.compose(callCredentials);
        return new ComposedChannelCredentialsImpl2(this.channelCredentials, combinedCallCredentials);
      }
      _getConnectionOptions() {
        return this.channelCredentials._getConnectionOptions();
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (other instanceof ComposedChannelCredentialsImpl2) {
          return this.channelCredentials._equals(other.channelCredentials) && this.callCredentials._equals(other.callCredentials);
        } else {
          return false;
        }
      }
    };
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer.js
var require_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createChildChannelControlHelper = createChildChannelControlHelper;
    exports2.registerLoadBalancerType = registerLoadBalancerType;
    exports2.registerDefaultLoadBalancerType = registerDefaultLoadBalancerType;
    exports2.createLoadBalancer = createLoadBalancer;
    exports2.isLoadBalancerNameRegistered = isLoadBalancerNameRegistered;
    exports2.parseLoadBalancingConfig = parseLoadBalancingConfig;
    exports2.getDefaultConfig = getDefaultConfig;
    exports2.selectLbConfigFromList = selectLbConfigFromList;
    var logging_1 = require_logging();
    var constants_1 = require_constants3();
    function createChildChannelControlHelper(parent, overrides) {
      var _a2, _b2, _c2, _d, _e, _f, _g, _h, _j, _k;
      return {
        createSubchannel: (_b2 = (_a2 = overrides.createSubchannel) === null || _a2 === void 0 ? void 0 : _a2.bind(overrides)) !== null && _b2 !== void 0 ? _b2 : parent.createSubchannel.bind(parent),
        updateState: (_d = (_c2 = overrides.updateState) === null || _c2 === void 0 ? void 0 : _c2.bind(overrides)) !== null && _d !== void 0 ? _d : parent.updateState.bind(parent),
        requestReresolution: (_f = (_e = overrides.requestReresolution) === null || _e === void 0 ? void 0 : _e.bind(overrides)) !== null && _f !== void 0 ? _f : parent.requestReresolution.bind(parent),
        addChannelzChild: (_h = (_g = overrides.addChannelzChild) === null || _g === void 0 ? void 0 : _g.bind(overrides)) !== null && _h !== void 0 ? _h : parent.addChannelzChild.bind(parent),
        removeChannelzChild: (_k = (_j = overrides.removeChannelzChild) === null || _j === void 0 ? void 0 : _j.bind(overrides)) !== null && _k !== void 0 ? _k : parent.removeChannelzChild.bind(parent)
      };
    }
    __name(createChildChannelControlHelper, "createChildChannelControlHelper");
    var registeredLoadBalancerTypes = {};
    var defaultLoadBalancerType = null;
    function registerLoadBalancerType(typeName, loadBalancerType, loadBalancingConfigType) {
      registeredLoadBalancerTypes[typeName] = {
        LoadBalancer: loadBalancerType,
        LoadBalancingConfig: loadBalancingConfigType
      };
    }
    __name(registerLoadBalancerType, "registerLoadBalancerType");
    function registerDefaultLoadBalancerType(typeName) {
      defaultLoadBalancerType = typeName;
    }
    __name(registerDefaultLoadBalancerType, "registerDefaultLoadBalancerType");
    function createLoadBalancer(config, channelControlHelper, credentials, options) {
      const typeName = config.getLoadBalancerName();
      if (typeName in registeredLoadBalancerTypes) {
        return new registeredLoadBalancerTypes[typeName].LoadBalancer(channelControlHelper, credentials, options);
      } else {
        return null;
      }
    }
    __name(createLoadBalancer, "createLoadBalancer");
    function isLoadBalancerNameRegistered(typeName) {
      return typeName in registeredLoadBalancerTypes;
    }
    __name(isLoadBalancerNameRegistered, "isLoadBalancerNameRegistered");
    function parseLoadBalancingConfig(rawConfig) {
      const keys = Object.keys(rawConfig);
      if (keys.length !== 1) {
        throw new Error("Provided load balancing config has multiple conflicting entries");
      }
      const typeName = keys[0];
      if (typeName in registeredLoadBalancerTypes) {
        try {
          return registeredLoadBalancerTypes[typeName].LoadBalancingConfig.createFromJson(rawConfig[typeName]);
        } catch (e) {
          throw new Error(`${typeName}: ${e.message}`);
        }
      } else {
        throw new Error(`Unrecognized load balancing config name ${typeName}`);
      }
    }
    __name(parseLoadBalancingConfig, "parseLoadBalancingConfig");
    function getDefaultConfig() {
      if (!defaultLoadBalancerType) {
        throw new Error("No default load balancer type registered");
      }
      return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
    }
    __name(getDefaultConfig, "getDefaultConfig");
    function selectLbConfigFromList(configs, fallbackTodefault = false) {
      for (const config of configs) {
        try {
          return parseLoadBalancingConfig(config);
        } catch (e) {
          (0, logging_1.log)(constants_1.LogVerbosity.DEBUG, "Config parsing failed with error", e.message);
          continue;
        }
      }
      if (fallbackTodefault) {
        if (defaultLoadBalancerType) {
          return new registeredLoadBalancerTypes[defaultLoadBalancerType].LoadBalancingConfig();
        } else {
          return null;
        }
      } else {
        return null;
      }
    }
    __name(selectLbConfigFromList, "selectLbConfigFromList");
  }
});

// node_modules/@grpc/grpc-js/build/src/service-config.js
var require_service_config = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/service-config.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.validateRetryThrottling = validateRetryThrottling;
    exports2.validateServiceConfig = validateServiceConfig;
    exports2.extractAndSelectServiceConfig = extractAndSelectServiceConfig;
    var os = require("os");
    var constants_1 = require_constants3();
    var DURATION_REGEX = /^\d+(\.\d{1,9})?s$/;
    var CLIENT_LANGUAGE_STRING = "node";
    function validateName(obj) {
      if ("service" in obj && obj.service !== "") {
        if (typeof obj.service !== "string") {
          throw new Error(`Invalid method config name: invalid service: expected type string, got ${typeof obj.service}`);
        }
        if ("method" in obj && obj.method !== "") {
          if (typeof obj.method !== "string") {
            throw new Error(`Invalid method config name: invalid method: expected type string, got ${typeof obj.service}`);
          }
          return {
            service: obj.service,
            method: obj.method
          };
        } else {
          return {
            service: obj.service
          };
        }
      } else {
        if ("method" in obj && obj.method !== void 0) {
          throw new Error(`Invalid method config name: method set with empty or unset service`);
        }
        return {};
      }
    }
    __name(validateName, "validateName");
    function validateRetryPolicy(obj) {
      if (!("maxAttempts" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {
        throw new Error("Invalid method config retry policy: maxAttempts must be an integer at least 2");
      }
      if (!("initialBackoff" in obj) || typeof obj.initialBackoff !== "string" || !DURATION_REGEX.test(obj.initialBackoff)) {
        throw new Error("Invalid method config retry policy: initialBackoff must be a string consisting of a positive integer or decimal followed by s");
      }
      if (!("maxBackoff" in obj) || typeof obj.maxBackoff !== "string" || !DURATION_REGEX.test(obj.maxBackoff)) {
        throw new Error("Invalid method config retry policy: maxBackoff must be a string consisting of a positive integer or decimal followed by s");
      }
      if (!("backoffMultiplier" in obj) || typeof obj.backoffMultiplier !== "number" || obj.backoffMultiplier <= 0) {
        throw new Error("Invalid method config retry policy: backoffMultiplier must be a number greater than 0");
      }
      if (!("retryableStatusCodes" in obj && Array.isArray(obj.retryableStatusCodes))) {
        throw new Error("Invalid method config retry policy: retryableStatusCodes is required");
      }
      if (obj.retryableStatusCodes.length === 0) {
        throw new Error("Invalid method config retry policy: retryableStatusCodes must be non-empty");
      }
      for (const value2 of obj.retryableStatusCodes) {
        if (typeof value2 === "number") {
          if (!Object.values(constants_1.Status).includes(value2)) {
            throw new Error("Invalid method config retry policy: retryableStatusCodes value not in status code range");
          }
        } else if (typeof value2 === "string") {
          if (!Object.values(constants_1.Status).includes(value2.toUpperCase())) {
            throw new Error("Invalid method config retry policy: retryableStatusCodes value not a status code name");
          }
        } else {
          throw new Error("Invalid method config retry policy: retryableStatusCodes value must be a string or number");
        }
      }
      return {
        maxAttempts: obj.maxAttempts,
        initialBackoff: obj.initialBackoff,
        maxBackoff: obj.maxBackoff,
        backoffMultiplier: obj.backoffMultiplier,
        retryableStatusCodes: obj.retryableStatusCodes
      };
    }
    __name(validateRetryPolicy, "validateRetryPolicy");
    function validateHedgingPolicy(obj) {
      if (!("maxAttempts" in obj) || !Number.isInteger(obj.maxAttempts) || obj.maxAttempts < 2) {
        throw new Error("Invalid method config hedging policy: maxAttempts must be an integer at least 2");
      }
      if ("hedgingDelay" in obj && (typeof obj.hedgingDelay !== "string" || !DURATION_REGEX.test(obj.hedgingDelay))) {
        throw new Error("Invalid method config hedging policy: hedgingDelay must be a string consisting of a positive integer followed by s");
      }
      if ("nonFatalStatusCodes" in obj && Array.isArray(obj.nonFatalStatusCodes)) {
        for (const value2 of obj.nonFatalStatusCodes) {
          if (typeof value2 === "number") {
            if (!Object.values(constants_1.Status).includes(value2)) {
              throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value not in status code range");
            }
          } else if (typeof value2 === "string") {
            if (!Object.values(constants_1.Status).includes(value2.toUpperCase())) {
              throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value not a status code name");
            }
          } else {
            throw new Error("Invalid method config hedging policy: nonFatalStatusCodes value must be a string or number");
          }
        }
      }
      const result2 = {
        maxAttempts: obj.maxAttempts
      };
      if (obj.hedgingDelay) {
        result2.hedgingDelay = obj.hedgingDelay;
      }
      if (obj.nonFatalStatusCodes) {
        result2.nonFatalStatusCodes = obj.nonFatalStatusCodes;
      }
      return result2;
    }
    __name(validateHedgingPolicy, "validateHedgingPolicy");
    function validateMethodConfig(obj) {
      var _a2;
      const result2 = {
        name: []
      };
      if (!("name" in obj) || !Array.isArray(obj.name)) {
        throw new Error("Invalid method config: invalid name array");
      }
      for (const name of obj.name) {
        result2.name.push(validateName(name));
      }
      if ("waitForReady" in obj) {
        if (typeof obj.waitForReady !== "boolean") {
          throw new Error("Invalid method config: invalid waitForReady");
        }
        result2.waitForReady = obj.waitForReady;
      }
      if ("timeout" in obj) {
        if (typeof obj.timeout === "object") {
          if (!("seconds" in obj.timeout) || !(typeof obj.timeout.seconds === "number")) {
            throw new Error("Invalid method config: invalid timeout.seconds");
          }
          if (!("nanos" in obj.timeout) || !(typeof obj.timeout.nanos === "number")) {
            throw new Error("Invalid method config: invalid timeout.nanos");
          }
          result2.timeout = obj.timeout;
        } else if (typeof obj.timeout === "string" && DURATION_REGEX.test(obj.timeout)) {
          const timeoutParts = obj.timeout.substring(0, obj.timeout.length - 1).split(".");
          result2.timeout = {
            seconds: timeoutParts[0] | 0,
            nanos: ((_a2 = timeoutParts[1]) !== null && _a2 !== void 0 ? _a2 : 0) | 0
          };
        } else {
          throw new Error("Invalid method config: invalid timeout");
        }
      }
      if ("maxRequestBytes" in obj) {
        if (typeof obj.maxRequestBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result2.maxRequestBytes = obj.maxRequestBytes;
      }
      if ("maxResponseBytes" in obj) {
        if (typeof obj.maxResponseBytes !== "number") {
          throw new Error("Invalid method config: invalid maxRequestBytes");
        }
        result2.maxResponseBytes = obj.maxResponseBytes;
      }
      if ("retryPolicy" in obj) {
        if ("hedgingPolicy" in obj) {
          throw new Error("Invalid method config: retryPolicy and hedgingPolicy cannot both be specified");
        } else {
          result2.retryPolicy = validateRetryPolicy(obj.retryPolicy);
        }
      } else if ("hedgingPolicy" in obj) {
        result2.hedgingPolicy = validateHedgingPolicy(obj.hedgingPolicy);
      }
      return result2;
    }
    __name(validateMethodConfig, "validateMethodConfig");
    function validateRetryThrottling(obj) {
      if (!("maxTokens" in obj) || typeof obj.maxTokens !== "number" || obj.maxTokens <= 0 || obj.maxTokens > 1e3) {
        throw new Error("Invalid retryThrottling: maxTokens must be a number in (0, 1000]");
      }
      if (!("tokenRatio" in obj) || typeof obj.tokenRatio !== "number" || obj.tokenRatio <= 0) {
        throw new Error("Invalid retryThrottling: tokenRatio must be a number greater than 0");
      }
      return {
        maxTokens: +obj.maxTokens.toFixed(3),
        tokenRatio: +obj.tokenRatio.toFixed(3)
      };
    }
    __name(validateRetryThrottling, "validateRetryThrottling");
    function validateLoadBalancingConfig(obj) {
      if (!(typeof obj === "object" && obj !== null)) {
        throw new Error(`Invalid loadBalancingConfig: unexpected type ${typeof obj}`);
      }
      const keys = Object.keys(obj);
      if (keys.length > 1) {
        throw new Error(`Invalid loadBalancingConfig: unexpected multiple keys ${keys}`);
      }
      if (keys.length === 0) {
        throw new Error("Invalid loadBalancingConfig: load balancing policy name required");
      }
      return {
        [keys[0]]: obj[keys[0]]
      };
    }
    __name(validateLoadBalancingConfig, "validateLoadBalancingConfig");
    function validateServiceConfig(obj) {
      const result2 = {
        loadBalancingConfig: [],
        methodConfig: []
      };
      if ("loadBalancingPolicy" in obj) {
        if (typeof obj.loadBalancingPolicy === "string") {
          result2.loadBalancingPolicy = obj.loadBalancingPolicy;
        } else {
          throw new Error("Invalid service config: invalid loadBalancingPolicy");
        }
      }
      if ("loadBalancingConfig" in obj) {
        if (Array.isArray(obj.loadBalancingConfig)) {
          for (const config of obj.loadBalancingConfig) {
            result2.loadBalancingConfig.push(validateLoadBalancingConfig(config));
          }
        } else {
          throw new Error("Invalid service config: invalid loadBalancingConfig");
        }
      }
      if ("methodConfig" in obj) {
        if (Array.isArray(obj.methodConfig)) {
          for (const methodConfig of obj.methodConfig) {
            result2.methodConfig.push(validateMethodConfig(methodConfig));
          }
        }
      }
      if ("retryThrottling" in obj) {
        result2.retryThrottling = validateRetryThrottling(obj.retryThrottling);
      }
      const seenMethodNames = [];
      for (const methodConfig of result2.methodConfig) {
        for (const name of methodConfig.name) {
          for (const seenName of seenMethodNames) {
            if (name.service === seenName.service && name.method === seenName.method) {
              throw new Error(`Invalid service config: duplicate name ${name.service}/${name.method}`);
            }
          }
          seenMethodNames.push(name);
        }
      }
      return result2;
    }
    __name(validateServiceConfig, "validateServiceConfig");
    function validateCanaryConfig(obj) {
      if (!("serviceConfig" in obj)) {
        throw new Error("Invalid service config choice: missing service config");
      }
      const result2 = {
        serviceConfig: validateServiceConfig(obj.serviceConfig)
      };
      if ("clientLanguage" in obj) {
        if (Array.isArray(obj.clientLanguage)) {
          result2.clientLanguage = [];
          for (const lang of obj.clientLanguage) {
            if (typeof lang === "string") {
              result2.clientLanguage.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientLanguage");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientLanguage");
        }
      }
      if ("clientHostname" in obj) {
        if (Array.isArray(obj.clientHostname)) {
          result2.clientHostname = [];
          for (const lang of obj.clientHostname) {
            if (typeof lang === "string") {
              result2.clientHostname.push(lang);
            } else {
              throw new Error("Invalid service config choice: invalid clientHostname");
            }
          }
        } else {
          throw new Error("Invalid service config choice: invalid clientHostname");
        }
      }
      if ("percentage" in obj) {
        if (typeof obj.percentage === "number" && 0 <= obj.percentage && obj.percentage <= 100) {
          result2.percentage = obj.percentage;
        } else {
          throw new Error("Invalid service config choice: invalid percentage");
        }
      }
      const allowedFields = [
        "clientLanguage",
        "percentage",
        "clientHostname",
        "serviceConfig"
      ];
      for (const field in obj) {
        if (!allowedFields.includes(field)) {
          throw new Error(`Invalid service config choice: unexpected field ${field}`);
        }
      }
      return result2;
    }
    __name(validateCanaryConfig, "validateCanaryConfig");
    function validateAndSelectCanaryConfig(obj, percentage) {
      if (!Array.isArray(obj)) {
        throw new Error("Invalid service config list");
      }
      for (const config of obj) {
        const validatedConfig = validateCanaryConfig(config);
        if (typeof validatedConfig.percentage === "number" && percentage > validatedConfig.percentage) {
          continue;
        }
        if (Array.isArray(validatedConfig.clientHostname)) {
          let hostnameMatched = false;
          for (const hostname of validatedConfig.clientHostname) {
            if (hostname === os.hostname()) {
              hostnameMatched = true;
            }
          }
          if (!hostnameMatched) {
            continue;
          }
        }
        if (Array.isArray(validatedConfig.clientLanguage)) {
          let languageMatched = false;
          for (const language of validatedConfig.clientLanguage) {
            if (language === CLIENT_LANGUAGE_STRING) {
              languageMatched = true;
            }
          }
          if (!languageMatched) {
            continue;
          }
        }
        return validatedConfig.serviceConfig;
      }
      throw new Error("No matching service config found");
    }
    __name(validateAndSelectCanaryConfig, "validateAndSelectCanaryConfig");
    function extractAndSelectServiceConfig(txtRecord, percentage) {
      for (const record of txtRecord) {
        if (record.length > 0 && record[0].startsWith("grpc_config=")) {
          const recordString = record.join("").substring("grpc_config=".length);
          const recordJson = JSON.parse(recordString);
          return validateAndSelectCanaryConfig(recordJson, percentage);
        }
      }
      return null;
    }
    __name(extractAndSelectServiceConfig, "extractAndSelectServiceConfig");
  }
});

// node_modules/@grpc/grpc-js/build/src/connectivity-state.js
var require_connectivity_state = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/connectivity-state.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ConnectivityState = void 0;
    var ConnectivityState;
    (function(ConnectivityState2) {
      ConnectivityState2[ConnectivityState2["IDLE"] = 0] = "IDLE";
      ConnectivityState2[ConnectivityState2["CONNECTING"] = 1] = "CONNECTING";
      ConnectivityState2[ConnectivityState2["READY"] = 2] = "READY";
      ConnectivityState2[ConnectivityState2["TRANSIENT_FAILURE"] = 3] = "TRANSIENT_FAILURE";
      ConnectivityState2[ConnectivityState2["SHUTDOWN"] = 4] = "SHUTDOWN";
    })(ConnectivityState || (exports2.ConnectivityState = ConnectivityState = {}));
  }
});

// node_modules/@grpc/grpc-js/build/src/uri-parser.js
var require_uri_parser = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/uri-parser.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.parseUri = parseUri;
    exports2.splitHostPort = splitHostPort;
    exports2.combineHostPort = combineHostPort;
    exports2.uriToString = uriToString;
    var URI_REGEX = /^(?:([A-Za-z0-9+.-]+):)?(?:\/\/([^/]*)\/)?(.+)$/;
    function parseUri(uriString) {
      const parsedUri = URI_REGEX.exec(uriString);
      if (parsedUri === null) {
        return null;
      }
      return {
        scheme: parsedUri[1],
        authority: parsedUri[2],
        path: parsedUri[3]
      };
    }
    __name(parseUri, "parseUri");
    var NUMBER_REGEX = /^\d+$/;
    function splitHostPort(path) {
      if (path.startsWith("[")) {
        const hostEnd = path.indexOf("]");
        if (hostEnd === -1) {
          return null;
        }
        const host = path.substring(1, hostEnd);
        if (host.indexOf(":") === -1) {
          return null;
        }
        if (path.length > hostEnd + 1) {
          if (path[hostEnd + 1] === ":") {
            const portString = path.substring(hostEnd + 2);
            if (NUMBER_REGEX.test(portString)) {
              return {
                host,
                port: +portString
              };
            } else {
              return null;
            }
          } else {
            return null;
          }
        } else {
          return {
            host
          };
        }
      } else {
        const splitPath = path.split(":");
        if (splitPath.length === 2) {
          if (NUMBER_REGEX.test(splitPath[1])) {
            return {
              host: splitPath[0],
              port: +splitPath[1]
            };
          } else {
            return null;
          }
        } else {
          return {
            host: path
          };
        }
      }
    }
    __name(splitHostPort, "splitHostPort");
    function combineHostPort(hostPort) {
      if (hostPort.port === void 0) {
        return hostPort.host;
      } else {
        if (hostPort.host.includes(":")) {
          return `[${hostPort.host}]:${hostPort.port}`;
        } else {
          return `${hostPort.host}:${hostPort.port}`;
        }
      }
    }
    __name(combineHostPort, "combineHostPort");
    function uriToString(uri) {
      let result2 = "";
      if (uri.scheme !== void 0) {
        result2 += uri.scheme + ":";
      }
      if (uri.authority !== void 0) {
        result2 += "//" + uri.authority + "/";
      }
      result2 += uri.path;
      return result2;
    }
    __name(uriToString, "uriToString");
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver.js
var require_resolver = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.registerResolver = registerResolver;
    exports2.registerDefaultScheme = registerDefaultScheme;
    exports2.createResolver = createResolver;
    exports2.getDefaultAuthority = getDefaultAuthority;
    exports2.mapUriDefaultScheme = mapUriDefaultScheme;
    var uri_parser_1 = require_uri_parser();
    var registeredResolvers = {};
    var defaultScheme = null;
    function registerResolver(scheme, resolverClass) {
      registeredResolvers[scheme] = resolverClass;
    }
    __name(registerResolver, "registerResolver");
    function registerDefaultScheme(scheme) {
      defaultScheme = scheme;
    }
    __name(registerDefaultScheme, "registerDefaultScheme");
    function createResolver(target, listener, options) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return new registeredResolvers[target.scheme](target, listener, options);
      } else {
        throw new Error(`No resolver could be created for target ${(0, uri_parser_1.uriToString)(target)}`);
      }
    }
    __name(createResolver, "createResolver");
    function getDefaultAuthority(target) {
      if (target.scheme !== void 0 && target.scheme in registeredResolvers) {
        return registeredResolvers[target.scheme].getDefaultAuthority(target);
      } else {
        throw new Error(`Invalid target ${(0, uri_parser_1.uriToString)(target)}`);
      }
    }
    __name(getDefaultAuthority, "getDefaultAuthority");
    function mapUriDefaultScheme(target) {
      if (target.scheme === void 0 || !(target.scheme in registeredResolvers)) {
        if (defaultScheme !== null) {
          return {
            scheme: defaultScheme,
            authority: void 0,
            path: (0, uri_parser_1.uriToString)(target)
          };
        } else {
          return null;
        }
      }
      return target;
    }
    __name(mapUriDefaultScheme, "mapUriDefaultScheme");
  }
});

// node_modules/@grpc/grpc-js/build/src/picker.js
var require_picker = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/picker.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.QueuePicker = exports2.UnavailablePicker = exports2.PickResultType = void 0;
    var metadata_1 = require_metadata2();
    var constants_1 = require_constants3();
    var PickResultType;
    (function(PickResultType2) {
      PickResultType2[PickResultType2["COMPLETE"] = 0] = "COMPLETE";
      PickResultType2[PickResultType2["QUEUE"] = 1] = "QUEUE";
      PickResultType2[PickResultType2["TRANSIENT_FAILURE"] = 2] = "TRANSIENT_FAILURE";
      PickResultType2[PickResultType2["DROP"] = 3] = "DROP";
    })(PickResultType || (exports2.PickResultType = PickResultType = {}));
    var UnavailablePicker = class UnavailablePicker {
      static {
        __name(this, "UnavailablePicker");
      }
      constructor(status) {
        this.status = Object.assign({
          code: constants_1.Status.UNAVAILABLE,
          details: "No connection established",
          metadata: new metadata_1.Metadata()
        }, status);
      }
      pick(pickArgs) {
        return {
          pickResultType: PickResultType.TRANSIENT_FAILURE,
          subchannel: null,
          status: this.status,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    exports2.UnavailablePicker = UnavailablePicker;
    var QueuePicker = class QueuePicker {
      static {
        __name(this, "QueuePicker");
      }
      // Constructed with a load balancer. Calls exitIdle on it the first time pick is called
      constructor(loadBalancer, childPicker) {
        this.loadBalancer = loadBalancer;
        this.childPicker = childPicker;
        this.calledExitIdle = false;
      }
      pick(pickArgs) {
        if (!this.calledExitIdle) {
          process.nextTick(() => {
            this.loadBalancer.exitIdle();
          });
          this.calledExitIdle = true;
        }
        if (this.childPicker) {
          return this.childPicker.pick(pickArgs);
        } else {
          return {
            pickResultType: PickResultType.QUEUE,
            subchannel: null,
            status: null,
            onCallStarted: null,
            onCallEnded: null
          };
        }
      }
    };
    exports2.QueuePicker = QueuePicker;
  }
});

// node_modules/@grpc/grpc-js/build/src/backoff-timeout.js
var require_backoff_timeout = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/backoff-timeout.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BackoffTimeout = void 0;
    var INITIAL_BACKOFF_MS = 1e3;
    var BACKOFF_MULTIPLIER = 1.6;
    var MAX_BACKOFF_MS = 12e4;
    var BACKOFF_JITTER = 0.2;
    function uniformRandom(min, max) {
      return Math.random() * (max - min) + min;
    }
    __name(uniformRandom, "uniformRandom");
    var BackoffTimeout = class BackoffTimeout {
      static {
        __name(this, "BackoffTimeout");
      }
      constructor(callback, options) {
        this.callback = callback;
        this.initialDelay = INITIAL_BACKOFF_MS;
        this.multiplier = BACKOFF_MULTIPLIER;
        this.maxDelay = MAX_BACKOFF_MS;
        this.jitter = BACKOFF_JITTER;
        this.running = false;
        this.hasRef = true;
        this.startTime = /* @__PURE__ */ new Date();
        this.endTime = /* @__PURE__ */ new Date();
        if (options) {
          if (options.initialDelay) {
            this.initialDelay = options.initialDelay;
          }
          if (options.multiplier) {
            this.multiplier = options.multiplier;
          }
          if (options.jitter) {
            this.jitter = options.jitter;
          }
          if (options.maxDelay) {
            this.maxDelay = options.maxDelay;
          }
        }
        this.nextDelay = this.initialDelay;
        this.timerId = setTimeout(() => {
        }, 0);
        clearTimeout(this.timerId);
      }
      runTimer(delay) {
        var _a2, _b2;
        this.endTime = this.startTime;
        this.endTime.setMilliseconds(this.endTime.getMilliseconds() + this.nextDelay);
        clearTimeout(this.timerId);
        this.timerId = setTimeout(() => {
          this.callback();
          this.running = false;
        }, delay);
        if (!this.hasRef) {
          (_b2 = (_a2 = this.timerId).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        }
      }
      /**
       * Call the callback after the current amount of delay time
       */
      runOnce() {
        this.running = true;
        this.startTime = /* @__PURE__ */ new Date();
        this.runTimer(this.nextDelay);
        const nextBackoff = Math.min(this.nextDelay * this.multiplier, this.maxDelay);
        const jitterMagnitude = nextBackoff * this.jitter;
        this.nextDelay = nextBackoff + uniformRandom(-jitterMagnitude, jitterMagnitude);
      }
      /**
       * Stop the timer. The callback will not be called until `runOnce` is called
       * again.
       */
      stop() {
        clearTimeout(this.timerId);
        this.running = false;
      }
      /**
       * Reset the delay time to its initial value. If the timer is still running,
       * retroactively apply that reset to the current timer.
       */
      reset() {
        this.nextDelay = this.initialDelay;
        if (this.running) {
          const now = /* @__PURE__ */ new Date();
          const newEndTime = this.startTime;
          newEndTime.setMilliseconds(newEndTime.getMilliseconds() + this.nextDelay);
          clearTimeout(this.timerId);
          if (now < newEndTime) {
            this.runTimer(newEndTime.getTime() - now.getTime());
          } else {
            this.running = false;
          }
        }
      }
      /**
       * Check whether the timer is currently running.
       */
      isRunning() {
        return this.running;
      }
      /**
       * Set that while the timer is running, it should keep the Node process
       * running.
       */
      ref() {
        var _a2, _b2;
        this.hasRef = true;
        (_b2 = (_a2 = this.timerId).ref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
      /**
       * Set that while the timer is running, it should not keep the Node process
       * running.
       */
      unref() {
        var _a2, _b2;
        this.hasRef = false;
        (_b2 = (_a2 = this.timerId).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
      /**
       * Get the approximate timestamp of when the timer will fire. Only valid if
       * this.isRunning() is true.
       */
      getEndTime() {
        return this.endTime;
      }
    };
    exports2.BackoffTimeout = BackoffTimeout;
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js
var require_load_balancer_child_handler = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-child-handler.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ChildLoadBalancerHandler = void 0;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var TYPE_NAME = "child_load_balancer_helper";
    var ChildLoadBalancerHandler = class ChildLoadBalancerHandler {
      static {
        __name(this, "ChildLoadBalancerHandler");
      }
      constructor(channelControlHelper, credentials, options) {
        this.channelControlHelper = channelControlHelper;
        this.credentials = credentials;
        this.options = options;
        this.currentChild = null;
        this.pendingChild = null;
        this.latestConfig = null;
        this.ChildPolicyHelper = class {
          constructor(parent) {
            this.parent = parent;
            this.child = null;
          }
          createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride) {
            return this.parent.channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride);
          }
          updateState(connectivityState, picker) {
            var _a2;
            if (this.calledByPendingChild()) {
              if (connectivityState === connectivity_state_1.ConnectivityState.CONNECTING) {
                return;
              }
              (_a2 = this.parent.currentChild) === null || _a2 === void 0 ? void 0 : _a2.destroy();
              this.parent.currentChild = this.parent.pendingChild;
              this.parent.pendingChild = null;
            } else if (!this.calledByCurrentChild()) {
              return;
            }
            this.parent.channelControlHelper.updateState(connectivityState, picker);
          }
          requestReresolution() {
            var _a2;
            const latestChild = (_a2 = this.parent.pendingChild) !== null && _a2 !== void 0 ? _a2 : this.parent.currentChild;
            if (this.child === latestChild) {
              this.parent.channelControlHelper.requestReresolution();
            }
          }
          setChild(newChild) {
            this.child = newChild;
          }
          addChannelzChild(child) {
            this.parent.channelControlHelper.addChannelzChild(child);
          }
          removeChannelzChild(child) {
            this.parent.channelControlHelper.removeChannelzChild(child);
          }
          calledByPendingChild() {
            return this.child === this.parent.pendingChild;
          }
          calledByCurrentChild() {
            return this.child === this.parent.currentChild;
          }
        };
      }
      configUpdateRequiresNewPolicyInstance(oldConfig, newConfig) {
        return oldConfig.getLoadBalancerName() !== newConfig.getLoadBalancerName();
      }
      /**
       * Prerequisites: lbConfig !== null and lbConfig.name is registered
       * @param endpointList
       * @param lbConfig
       * @param attributes
       */
      updateAddressList(endpointList, lbConfig, attributes) {
        let childToUpdate;
        if (this.currentChild === null || this.latestConfig === null || this.configUpdateRequiresNewPolicyInstance(this.latestConfig, lbConfig)) {
          const newHelper = new this.ChildPolicyHelper(this);
          const newChild = (0, load_balancer_1.createLoadBalancer)(lbConfig, newHelper, this.credentials, this.options);
          newHelper.setChild(newChild);
          if (this.currentChild === null) {
            this.currentChild = newChild;
            childToUpdate = this.currentChild;
          } else {
            if (this.pendingChild) {
              this.pendingChild.destroy();
            }
            this.pendingChild = newChild;
            childToUpdate = this.pendingChild;
          }
        } else {
          if (this.pendingChild === null) {
            childToUpdate = this.currentChild;
          } else {
            childToUpdate = this.pendingChild;
          }
        }
        this.latestConfig = lbConfig;
        childToUpdate.updateAddressList(endpointList, lbConfig, attributes);
      }
      exitIdle() {
        if (this.currentChild) {
          this.currentChild.exitIdle();
          if (this.pendingChild) {
            this.pendingChild.exitIdle();
          }
        }
      }
      resetBackoff() {
        if (this.currentChild) {
          this.currentChild.resetBackoff();
          if (this.pendingChild) {
            this.pendingChild.resetBackoff();
          }
        }
      }
      destroy() {
        if (this.currentChild) {
          this.currentChild.destroy();
          this.currentChild = null;
        }
        if (this.pendingChild) {
          this.pendingChild.destroy();
          this.pendingChild = null;
        }
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.ChildLoadBalancerHandler = ChildLoadBalancerHandler;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js
var require_resolving_load_balancer = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-load-balancer.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ResolvingLoadBalancer = void 0;
    var load_balancer_1 = require_load_balancer();
    var service_config_1 = require_service_config();
    var connectivity_state_1 = require_connectivity_state();
    var resolver_1 = require_resolver();
    var picker_1 = require_picker();
    var backoff_timeout_1 = require_backoff_timeout();
    var constants_1 = require_constants3();
    var metadata_1 = require_metadata2();
    var logging = require_logging();
    var constants_2 = require_constants3();
    var uri_parser_1 = require_uri_parser();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var TRACER_NAME = "resolving_load_balancer";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    var NAME_MATCH_LEVEL_ORDER = [
      "SERVICE_AND_METHOD",
      "SERVICE",
      "EMPTY"
    ];
    function hasMatchingName(service, method, methodConfig, matchLevel) {
      for (const name of methodConfig.name) {
        switch (matchLevel) {
          case "EMPTY":
            if (!name.service && !name.method) {
              return true;
            }
            break;
          case "SERVICE":
            if (name.service === service && !name.method) {
              return true;
            }
            break;
          case "SERVICE_AND_METHOD":
            if (name.service === service && name.method === method) {
              return true;
            }
        }
      }
      return false;
    }
    __name(hasMatchingName, "hasMatchingName");
    function findMatchingConfig(service, method, methodConfigs, matchLevel) {
      for (const config of methodConfigs) {
        if (hasMatchingName(service, method, config, matchLevel)) {
          return config;
        }
      }
      return null;
    }
    __name(findMatchingConfig, "findMatchingConfig");
    function getDefaultConfigSelector(serviceConfig) {
      return /* @__PURE__ */ __name(function defaultConfigSelector(methodName, metadata) {
        var _a2, _b2;
        const splitName = methodName.split("/").filter((x) => x.length > 0);
        const service = (_a2 = splitName[0]) !== null && _a2 !== void 0 ? _a2 : "";
        const method = (_b2 = splitName[1]) !== null && _b2 !== void 0 ? _b2 : "";
        if (serviceConfig && serviceConfig.methodConfig) {
          for (const matchLevel of NAME_MATCH_LEVEL_ORDER) {
            const matchingConfig = findMatchingConfig(service, method, serviceConfig.methodConfig, matchLevel);
            if (matchingConfig) {
              return {
                methodConfig: matchingConfig,
                pickInformation: {},
                status: constants_1.Status.OK,
                dynamicFilterFactories: []
              };
            }
          }
        }
        return {
          methodConfig: {
            name: []
          },
          pickInformation: {},
          status: constants_1.Status.OK,
          dynamicFilterFactories: []
        };
      }, "defaultConfigSelector");
    }
    __name(getDefaultConfigSelector, "getDefaultConfigSelector");
    var ResolvingLoadBalancer = class ResolvingLoadBalancer {
      static {
        __name(this, "ResolvingLoadBalancer");
      }
      /**
       * Wrapper class that behaves like a `LoadBalancer` and also handles name
       * resolution internally.
       * @param target The address of the backend to connect to.
       * @param channelControlHelper `ChannelControlHelper` instance provided by
       *     this load balancer's owner.
       * @param defaultServiceConfig The default service configuration to be used
       *     if none is provided by the name resolver. A `null` value indicates
       *     that the default behavior should be the default unconfigured behavior.
       *     In practice, that means using the "pick first" load balancer
       *     implmentation
       */
      constructor(target, channelControlHelper, credentials, channelOptions, onSuccessfulResolution, onFailedResolution) {
        this.target = target;
        this.channelControlHelper = channelControlHelper;
        this.onSuccessfulResolution = onSuccessfulResolution;
        this.onFailedResolution = onFailedResolution;
        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
        if (channelOptions["grpc.service_config"]) {
          this.defaultServiceConfig = (0, service_config_1.validateServiceConfig)(JSON.parse(channelOptions["grpc.service_config"]));
        } else {
          this.defaultServiceConfig = {
            loadBalancingConfig: [],
            methodConfig: []
          };
        }
        this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        this.childLoadBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler({
          createSubchannel: channelControlHelper.createSubchannel.bind(channelControlHelper),
          requestReresolution: /* @__PURE__ */ __name(() => {
            if (this.backoffTimeout.isRunning()) {
              trace("requestReresolution delayed by backoff timer until " + this.backoffTimeout.getEndTime().toISOString());
              this.continueResolving = true;
            } else {
              this.updateResolution();
            }
          }, "requestReresolution"),
          updateState: /* @__PURE__ */ __name((newState, picker) => {
            this.latestChildState = newState;
            this.latestChildPicker = picker;
            this.updateState(newState, picker);
          }, "updateState"),
          addChannelzChild: channelControlHelper.addChannelzChild.bind(channelControlHelper),
          removeChannelzChild: channelControlHelper.removeChannelzChild.bind(channelControlHelper)
        }, credentials, channelOptions);
        this.innerResolver = (0, resolver_1.createResolver)(target, {
          onSuccessfulResolution: /* @__PURE__ */ __name((endpointList, serviceConfig, serviceConfigError, configSelector, attributes) => {
            var _a2;
            this.backoffTimeout.stop();
            this.backoffTimeout.reset();
            let workingServiceConfig = null;
            if (serviceConfig === null) {
              if (serviceConfigError === null) {
                this.previousServiceConfig = null;
                workingServiceConfig = this.defaultServiceConfig;
              } else {
                if (this.previousServiceConfig === null) {
                  this.handleResolutionFailure(serviceConfigError);
                } else {
                  workingServiceConfig = this.previousServiceConfig;
                }
              }
            } else {
              workingServiceConfig = serviceConfig;
              this.previousServiceConfig = serviceConfig;
            }
            const workingConfigList = (_a2 = workingServiceConfig === null || workingServiceConfig === void 0 ? void 0 : workingServiceConfig.loadBalancingConfig) !== null && _a2 !== void 0 ? _a2 : [];
            const loadBalancingConfig = (0, load_balancer_1.selectLbConfigFromList)(workingConfigList, true);
            if (loadBalancingConfig === null) {
              this.handleResolutionFailure({
                code: constants_1.Status.UNAVAILABLE,
                details: "All load balancer options in service config are not compatible",
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.childLoadBalancer.updateAddressList(endpointList, loadBalancingConfig, attributes);
            const finalServiceConfig = workingServiceConfig !== null && workingServiceConfig !== void 0 ? workingServiceConfig : this.defaultServiceConfig;
            this.onSuccessfulResolution(finalServiceConfig, configSelector !== null && configSelector !== void 0 ? configSelector : getDefaultConfigSelector(finalServiceConfig));
          }, "onSuccessfulResolution"),
          onError: /* @__PURE__ */ __name((error) => {
            this.handleResolutionFailure(error);
          }, "onError")
        }, channelOptions);
        const backoffOptions = {
          initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
          maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.updateResolution();
            this.continueResolving = false;
          } else {
            this.updateState(this.latestChildState, this.latestChildPicker);
          }
        }, backoffOptions);
        this.backoffTimeout.unref();
      }
      updateResolution() {
        this.innerResolver.updateResolution();
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE) {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, this.latestChildPicker);
        }
        this.backoffTimeout.runOnce();
      }
      updateState(connectivityState, picker) {
        trace((0, uri_parser_1.uriToString)(this.target) + " " + connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[connectivityState]);
        if (connectivityState === connectivity_state_1.ConnectivityState.IDLE) {
          picker = new picker_1.QueuePicker(this, picker);
        }
        this.currentState = connectivityState;
        this.channelControlHelper.updateState(connectivityState, picker);
      }
      handleResolutionFailure(error) {
        if (this.latestChildState === connectivity_state_1.ConnectivityState.IDLE) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker(error));
          this.onFailedResolution(error);
        }
      }
      exitIdle() {
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE || this.currentState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
          if (this.backoffTimeout.isRunning()) {
            this.continueResolving = true;
          } else {
            this.updateResolution();
          }
        }
        this.childLoadBalancer.exitIdle();
      }
      updateAddressList(endpointList, lbConfig) {
        throw new Error("updateAddressList not supported on ResolvingLoadBalancer");
      }
      resetBackoff() {
        this.backoffTimeout.reset();
        this.childLoadBalancer.resetBackoff();
      }
      destroy() {
        this.childLoadBalancer.destroy();
        this.innerResolver.destroy();
        this.backoffTimeout.reset();
        this.backoffTimeout.stop();
        this.latestChildState = connectivity_state_1.ConnectivityState.IDLE;
        this.latestChildPicker = new picker_1.QueuePicker(this);
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.previousServiceConfig = null;
        this.continueResolving = false;
      }
      getTypeName() {
        return "resolving_load_balancer";
      }
    };
    exports2.ResolvingLoadBalancer = ResolvingLoadBalancer;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel-options.js
var require_channel_options = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel-options.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.recognizedOptions = void 0;
    exports2.channelOptionsEqual = channelOptionsEqual;
    exports2.recognizedOptions = {
      "grpc.ssl_target_name_override": true,
      "grpc.primary_user_agent": true,
      "grpc.secondary_user_agent": true,
      "grpc.default_authority": true,
      "grpc.keepalive_time_ms": true,
      "grpc.keepalive_timeout_ms": true,
      "grpc.keepalive_permit_without_calls": true,
      "grpc.service_config": true,
      "grpc.max_concurrent_streams": true,
      "grpc.initial_reconnect_backoff_ms": true,
      "grpc.max_reconnect_backoff_ms": true,
      "grpc.use_local_subchannel_pool": true,
      "grpc.max_send_message_length": true,
      "grpc.max_receive_message_length": true,
      "grpc.enable_http_proxy": true,
      "grpc.enable_channelz": true,
      "grpc.dns_min_time_between_resolutions_ms": true,
      "grpc.enable_retries": true,
      "grpc.per_rpc_retry_buffer_size": true,
      "grpc.retry_buffer_size": true,
      "grpc.max_connection_age_ms": true,
      "grpc.max_connection_age_grace_ms": true,
      "grpc-node.max_session_memory": true,
      "grpc.service_config_disable_resolution": true,
      "grpc.client_idle_timeout_ms": true,
      "grpc-node.tls_enable_trace": true,
      "grpc.lb.ring_hash.ring_size_cap": true,
      "grpc-node.retry_max_attempts_limit": true
    };
    function channelOptionsEqual(options1, options2) {
      const keys1 = Object.keys(options1).sort();
      const keys2 = Object.keys(options2).sort();
      if (keys1.length !== keys2.length) {
        return false;
      }
      for (let i = 0; i < keys1.length; i += 1) {
        if (keys1[i] !== keys2[i]) {
          return false;
        }
        if (options1[keys1[i]] !== options2[keys2[i]]) {
          return false;
        }
      }
      return true;
    }
    __name(channelOptionsEqual, "channelOptionsEqual");
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-address.js
var require_subchannel_address = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-address.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.EndpointMap = void 0;
    exports2.isTcpSubchannelAddress = isTcpSubchannelAddress;
    exports2.subchannelAddressEqual = subchannelAddressEqual;
    exports2.subchannelAddressToString = subchannelAddressToString;
    exports2.stringToSubchannelAddress = stringToSubchannelAddress;
    exports2.endpointEqual = endpointEqual;
    exports2.endpointToString = endpointToString;
    exports2.endpointHasAddress = endpointHasAddress;
    var net_1 = require("net");
    function isTcpSubchannelAddress(address) {
      return "port" in address;
    }
    __name(isTcpSubchannelAddress, "isTcpSubchannelAddress");
    function subchannelAddressEqual(address1, address2) {
      if (!address1 && !address2) {
        return true;
      }
      if (!address1 || !address2) {
        return false;
      }
      if (isTcpSubchannelAddress(address1)) {
        return isTcpSubchannelAddress(address2) && address1.host === address2.host && address1.port === address2.port;
      } else {
        return !isTcpSubchannelAddress(address2) && address1.path === address2.path;
      }
    }
    __name(subchannelAddressEqual, "subchannelAddressEqual");
    function subchannelAddressToString(address) {
      if (isTcpSubchannelAddress(address)) {
        if ((0, net_1.isIPv6)(address.host)) {
          return "[" + address.host + "]:" + address.port;
        } else {
          return address.host + ":" + address.port;
        }
      } else {
        return address.path;
      }
    }
    __name(subchannelAddressToString, "subchannelAddressToString");
    var DEFAULT_PORT = 443;
    function stringToSubchannelAddress(addressString, port) {
      if ((0, net_1.isIP)(addressString)) {
        return {
          host: addressString,
          port: port !== null && port !== void 0 ? port : DEFAULT_PORT
        };
      } else {
        return {
          path: addressString
        };
      }
    }
    __name(stringToSubchannelAddress, "stringToSubchannelAddress");
    function endpointEqual(endpoint1, endpoint2) {
      if (endpoint1.addresses.length !== endpoint2.addresses.length) {
        return false;
      }
      for (let i = 0; i < endpoint1.addresses.length; i++) {
        if (!subchannelAddressEqual(endpoint1.addresses[i], endpoint2.addresses[i])) {
          return false;
        }
      }
      return true;
    }
    __name(endpointEqual, "endpointEqual");
    function endpointToString(endpoint) {
      return "[" + endpoint.addresses.map(subchannelAddressToString).join(", ") + "]";
    }
    __name(endpointToString, "endpointToString");
    function endpointHasAddress(endpoint, expectedAddress) {
      for (const address of endpoint.addresses) {
        if (subchannelAddressEqual(address, expectedAddress)) {
          return true;
        }
      }
      return false;
    }
    __name(endpointHasAddress, "endpointHasAddress");
    function endpointEqualUnordered(endpoint1, endpoint2) {
      if (endpoint1.addresses.length !== endpoint2.addresses.length) {
        return false;
      }
      for (const address1 of endpoint1.addresses) {
        let matchFound = false;
        for (const address2 of endpoint2.addresses) {
          if (subchannelAddressEqual(address1, address2)) {
            matchFound = true;
            break;
          }
        }
        if (!matchFound) {
          return false;
        }
      }
      return true;
    }
    __name(endpointEqualUnordered, "endpointEqualUnordered");
    var EndpointMap = class EndpointMap {
      static {
        __name(this, "EndpointMap");
      }
      constructor() {
        this.map = /* @__PURE__ */ new Set();
      }
      get size() {
        return this.map.size;
      }
      getForSubchannelAddress(address) {
        for (const entry of this.map) {
          if (endpointHasAddress(entry.key, address)) {
            return entry.value;
          }
        }
        return void 0;
      }
      /**
       * Delete any entries in this map with keys that are not in endpoints
       * @param endpoints
       */
      deleteMissing(endpoints) {
        const removedValues = [];
        for (const entry of this.map) {
          let foundEntry = false;
          for (const endpoint of endpoints) {
            if (endpointEqualUnordered(endpoint, entry.key)) {
              foundEntry = true;
            }
          }
          if (!foundEntry) {
            removedValues.push(entry.value);
            this.map.delete(entry);
          }
        }
        return removedValues;
      }
      get(endpoint) {
        for (const entry of this.map) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            return entry.value;
          }
        }
        return void 0;
      }
      set(endpoint, mapEntry) {
        for (const entry of this.map) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            entry.value = mapEntry;
            return;
          }
        }
        this.map.add({
          key: endpoint,
          value: mapEntry
        });
      }
      delete(endpoint) {
        for (const entry of this.map) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            this.map.delete(entry);
            return;
          }
        }
      }
      has(endpoint) {
        for (const entry of this.map) {
          if (endpointEqualUnordered(endpoint, entry.key)) {
            return true;
          }
        }
        return false;
      }
      clear() {
        this.map.clear();
      }
      *keys() {
        for (const entry of this.map) {
          yield entry.key;
        }
      }
      *values() {
        for (const entry of this.map) {
          yield entry.value;
        }
      }
      *entries() {
        for (const entry of this.map) {
          yield [
            entry.key,
            entry.value
          ];
        }
      }
    };
    exports2.EndpointMap = EndpointMap;
  }
});

// node_modules/@js-sdsl/ordered-map/dist/esm/index.js
var esm_exports = {};
__export(esm_exports, {
  OrderedMap: () => OrderedMap
});
function __extends(e, r) {
  if (typeof r !== "function" && r !== null) throw new TypeError("Class extends value " + String(r) + " is not a constructor or null");
  extendStatics(e, r);
  function __() {
    this.constructor = e;
  }
  __name(__, "__");
  e.prototype = r === null ? Object.create(r) : (__.prototype = r.prototype, new __());
}
function __generator(e, r) {
  var t = {
    label: 0,
    sent: /* @__PURE__ */ __name(function() {
      if (s[0] & 1) throw s[1];
      return s[1];
    }, "sent"),
    trys: [],
    ops: []
  }, i, n, s, h;
  return h = {
    next: verb(0),
    throw: verb(1),
    return: verb(2)
  }, typeof Symbol === "function" && (h[Symbol.iterator] = function() {
    return this;
  }), h;
  function verb(e2) {
    return function(r2) {
      return step([
        e2,
        r2
      ]);
    };
  }
  __name(verb, "verb");
  function step(a) {
    if (i) throw new TypeError("Generator is already executing.");
    while (h && (h = 0, a[0] && (t = 0)), t) try {
      if (i = 1, n && (s = a[0] & 2 ? n["return"] : a[0] ? n["throw"] || ((s = n["return"]) && s.call(n), 0) : n.next) && !(s = s.call(n, a[1])).done) return s;
      if (n = 0, s) a = [
        a[0] & 2,
        s.value
      ];
      switch (a[0]) {
        case 0:
        case 1:
          s = a;
          break;
        case 4:
          t.label++;
          return {
            value: a[1],
            done: false
          };
        case 5:
          t.label++;
          n = a[1];
          a = [
            0
          ];
          continue;
        case 7:
          a = t.ops.pop();
          t.trys.pop();
          continue;
        default:
          if (!(s = t.trys, s = s.length > 0 && s[s.length - 1]) && (a[0] === 6 || a[0] === 2)) {
            t = 0;
            continue;
          }
          if (a[0] === 3 && (!s || a[1] > s[0] && a[1] < s[3])) {
            t.label = a[1];
            break;
          }
          if (a[0] === 6 && t.label < s[1]) {
            t.label = s[1];
            s = a;
            break;
          }
          if (s && t.label < s[2]) {
            t.label = s[2];
            t.ops.push(a);
            break;
          }
          if (s[2]) t.ops.pop();
          t.trys.pop();
          continue;
      }
      a = r.call(e, t);
    } catch (e2) {
      a = [
        6,
        e2
      ];
      n = 0;
    } finally {
      i = s = 0;
    }
    if (a[0] & 5) throw a[1];
    return {
      value: a[0] ? a[1] : void 0,
      done: true
    };
  }
  __name(step, "step");
}
function throwIteratorAccessError() {
  throw new RangeError("Iterator access denied!");
}
var extendStatics, TreeNode, TreeNodeEnableIndex, ContainerIterator, Base, Container, TreeContainer, TreeIterator, OrderedMapIterator, OrderedMap;
var init_esm4 = __esm({
  "node_modules/@js-sdsl/ordered-map/dist/esm/index.js"() {
    "use strict";
    extendStatics = /* @__PURE__ */ __name(function(e, r) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function(e2, r2) {
        e2.__proto__ = r2;
      } || function(e2, r2) {
        for (var t in r2) if (Object.prototype.hasOwnProperty.call(r2, t)) e2[t] = r2[t];
      };
      return extendStatics(e, r);
    }, "extendStatics");
    __name(__extends, "__extends");
    __name(__generator, "__generator");
    TreeNode = function() {
      function TreeNode2(e, r, t) {
        if (t === void 0) {
          t = 1;
        }
        this.t = void 0;
        this.i = void 0;
        this.h = void 0;
        this.u = e;
        this.o = r;
        this.l = t;
      }
      __name(TreeNode2, "TreeNode");
      TreeNode2.prototype.v = function() {
        var e = this;
        var r = e.h.h === e;
        if (r && e.l === 1) {
          e = e.i;
        } else if (e.t) {
          e = e.t;
          while (e.i) {
            e = e.i;
          }
        } else {
          if (r) {
            return e.h;
          }
          var t = e.h;
          while (t.t === e) {
            e = t;
            t = e.h;
          }
          e = t;
        }
        return e;
      };
      TreeNode2.prototype.p = function() {
        var e = this;
        if (e.i) {
          e = e.i;
          while (e.t) {
            e = e.t;
          }
          return e;
        } else {
          var r = e.h;
          while (r.i === e) {
            e = r;
            r = e.h;
          }
          if (e.i !== r) {
            return r;
          } else return e;
        }
      };
      TreeNode2.prototype.T = function() {
        var e = this.h;
        var r = this.i;
        var t = r.t;
        if (e.h === this) e.h = r;
        else if (e.t === this) e.t = r;
        else e.i = r;
        r.h = e;
        r.t = this;
        this.h = r;
        this.i = t;
        if (t) t.h = this;
        return r;
      };
      TreeNode2.prototype.I = function() {
        var e = this.h;
        var r = this.t;
        var t = r.i;
        if (e.h === this) e.h = r;
        else if (e.t === this) e.t = r;
        else e.i = r;
        r.h = e;
        r.i = this;
        this.h = r;
        this.t = t;
        if (t) t.h = this;
        return r;
      };
      return TreeNode2;
    }();
    TreeNodeEnableIndex = function(e) {
      __extends(TreeNodeEnableIndex2, e);
      function TreeNodeEnableIndex2() {
        var r = e !== null && e.apply(this, arguments) || this;
        r.O = 1;
        return r;
      }
      __name(TreeNodeEnableIndex2, "TreeNodeEnableIndex");
      TreeNodeEnableIndex2.prototype.T = function() {
        var r = e.prototype.T.call(this);
        this.M();
        r.M();
        return r;
      };
      TreeNodeEnableIndex2.prototype.I = function() {
        var r = e.prototype.I.call(this);
        this.M();
        r.M();
        return r;
      };
      TreeNodeEnableIndex2.prototype.M = function() {
        this.O = 1;
        if (this.t) {
          this.O += this.t.O;
        }
        if (this.i) {
          this.O += this.i.O;
        }
      };
      return TreeNodeEnableIndex2;
    }(TreeNode);
    ContainerIterator = function() {
      function ContainerIterator2(e) {
        if (e === void 0) {
          e = 0;
        }
        this.iteratorType = e;
      }
      __name(ContainerIterator2, "ContainerIterator");
      ContainerIterator2.prototype.equals = function(e) {
        return this.C === e.C;
      };
      return ContainerIterator2;
    }();
    Base = function() {
      function Base2() {
        this._ = 0;
      }
      __name(Base2, "Base");
      Object.defineProperty(Base2.prototype, "length", {
        get: /* @__PURE__ */ __name(function() {
          return this._;
        }, "get"),
        enumerable: false,
        configurable: true
      });
      Base2.prototype.size = function() {
        return this._;
      };
      Base2.prototype.empty = function() {
        return this._ === 0;
      };
      return Base2;
    }();
    Container = function(e) {
      __extends(Container2, e);
      function Container2() {
        return e !== null && e.apply(this, arguments) || this;
      }
      __name(Container2, "Container");
      return Container2;
    }(Base);
    __name(throwIteratorAccessError, "throwIteratorAccessError");
    TreeContainer = function(e) {
      __extends(TreeContainer2, e);
      function TreeContainer2(r, t) {
        if (r === void 0) {
          r = /* @__PURE__ */ __name(function(e2, r2) {
            if (e2 < r2) return -1;
            if (e2 > r2) return 1;
            return 0;
          }, "r");
        }
        if (t === void 0) {
          t = false;
        }
        var i = e.call(this) || this;
        i.N = void 0;
        i.g = r;
        i.enableIndex = t;
        i.S = t ? TreeNodeEnableIndex : TreeNode;
        i.A = new i.S();
        return i;
      }
      __name(TreeContainer2, "TreeContainer");
      TreeContainer2.prototype.m = function(e2, r) {
        var t = this.A;
        while (e2) {
          var i = this.g(e2.u, r);
          if (i < 0) {
            e2 = e2.i;
          } else if (i > 0) {
            t = e2;
            e2 = e2.t;
          } else return e2;
        }
        return t;
      };
      TreeContainer2.prototype.B = function(e2, r) {
        var t = this.A;
        while (e2) {
          var i = this.g(e2.u, r);
          if (i <= 0) {
            e2 = e2.i;
          } else {
            t = e2;
            e2 = e2.t;
          }
        }
        return t;
      };
      TreeContainer2.prototype.j = function(e2, r) {
        var t = this.A;
        while (e2) {
          var i = this.g(e2.u, r);
          if (i < 0) {
            t = e2;
            e2 = e2.i;
          } else if (i > 0) {
            e2 = e2.t;
          } else return e2;
        }
        return t;
      };
      TreeContainer2.prototype.k = function(e2, r) {
        var t = this.A;
        while (e2) {
          var i = this.g(e2.u, r);
          if (i < 0) {
            t = e2;
            e2 = e2.i;
          } else {
            e2 = e2.t;
          }
        }
        return t;
      };
      TreeContainer2.prototype.R = function(e2) {
        while (true) {
          var r = e2.h;
          if (r === this.A) return;
          if (e2.l === 1) {
            e2.l = 0;
            return;
          }
          if (e2 === r.t) {
            var t = r.i;
            if (t.l === 1) {
              t.l = 0;
              r.l = 1;
              if (r === this.N) {
                this.N = r.T();
              } else r.T();
            } else {
              if (t.i && t.i.l === 1) {
                t.l = r.l;
                r.l = 0;
                t.i.l = 0;
                if (r === this.N) {
                  this.N = r.T();
                } else r.T();
                return;
              } else if (t.t && t.t.l === 1) {
                t.l = 1;
                t.t.l = 0;
                t.I();
              } else {
                t.l = 1;
                e2 = r;
              }
            }
          } else {
            var t = r.t;
            if (t.l === 1) {
              t.l = 0;
              r.l = 1;
              if (r === this.N) {
                this.N = r.I();
              } else r.I();
            } else {
              if (t.t && t.t.l === 1) {
                t.l = r.l;
                r.l = 0;
                t.t.l = 0;
                if (r === this.N) {
                  this.N = r.I();
                } else r.I();
                return;
              } else if (t.i && t.i.l === 1) {
                t.l = 1;
                t.i.l = 0;
                t.T();
              } else {
                t.l = 1;
                e2 = r;
              }
            }
          }
        }
      };
      TreeContainer2.prototype.G = function(e2) {
        if (this._ === 1) {
          this.clear();
          return;
        }
        var r = e2;
        while (r.t || r.i) {
          if (r.i) {
            r = r.i;
            while (r.t) r = r.t;
          } else {
            r = r.t;
          }
          var t = e2.u;
          e2.u = r.u;
          r.u = t;
          var i = e2.o;
          e2.o = r.o;
          r.o = i;
          e2 = r;
        }
        if (this.A.t === r) {
          this.A.t = r.h;
        } else if (this.A.i === r) {
          this.A.i = r.h;
        }
        this.R(r);
        var n = r.h;
        if (r === n.t) {
          n.t = void 0;
        } else n.i = void 0;
        this._ -= 1;
        this.N.l = 0;
        if (this.enableIndex) {
          while (n !== this.A) {
            n.O -= 1;
            n = n.h;
          }
        }
      };
      TreeContainer2.prototype.P = function(e2) {
        var r = typeof e2 === "number" ? e2 : void 0;
        var t = typeof e2 === "function" ? e2 : void 0;
        var i = typeof e2 === "undefined" ? [] : void 0;
        var n = 0;
        var s = this.N;
        var h = [];
        while (h.length || s) {
          if (s) {
            h.push(s);
            s = s.t;
          } else {
            s = h.pop();
            if (n === r) return s;
            i && i.push(s);
            t && t(s, n, this);
            n += 1;
            s = s.i;
          }
        }
        return i;
      };
      TreeContainer2.prototype.q = function(e2) {
        while (true) {
          var r = e2.h;
          if (r.l === 0) return;
          var t = r.h;
          if (r === t.t) {
            var i = t.i;
            if (i && i.l === 1) {
              i.l = r.l = 0;
              if (t === this.N) return;
              t.l = 1;
              e2 = t;
              continue;
            } else if (e2 === r.i) {
              e2.l = 0;
              if (e2.t) {
                e2.t.h = r;
              }
              if (e2.i) {
                e2.i.h = t;
              }
              r.i = e2.t;
              t.t = e2.i;
              e2.t = r;
              e2.i = t;
              if (t === this.N) {
                this.N = e2;
                this.A.h = e2;
              } else {
                var n = t.h;
                if (n.t === t) {
                  n.t = e2;
                } else n.i = e2;
              }
              e2.h = t.h;
              r.h = e2;
              t.h = e2;
              t.l = 1;
            } else {
              r.l = 0;
              if (t === this.N) {
                this.N = t.I();
              } else t.I();
              t.l = 1;
              return;
            }
          } else {
            var i = t.t;
            if (i && i.l === 1) {
              i.l = r.l = 0;
              if (t === this.N) return;
              t.l = 1;
              e2 = t;
              continue;
            } else if (e2 === r.t) {
              e2.l = 0;
              if (e2.t) {
                e2.t.h = t;
              }
              if (e2.i) {
                e2.i.h = r;
              }
              t.i = e2.t;
              r.t = e2.i;
              e2.t = t;
              e2.i = r;
              if (t === this.N) {
                this.N = e2;
                this.A.h = e2;
              } else {
                var n = t.h;
                if (n.t === t) {
                  n.t = e2;
                } else n.i = e2;
              }
              e2.h = t.h;
              r.h = e2;
              t.h = e2;
              t.l = 1;
            } else {
              r.l = 0;
              if (t === this.N) {
                this.N = t.T();
              } else t.T();
              t.l = 1;
              return;
            }
          }
          if (this.enableIndex) {
            r.M();
            t.M();
            e2.M();
          }
          return;
        }
      };
      TreeContainer2.prototype.D = function(e2, r, t) {
        if (this.N === void 0) {
          this._ += 1;
          this.N = new this.S(e2, r, 0);
          this.N.h = this.A;
          this.A.h = this.A.t = this.A.i = this.N;
          return this._;
        }
        var i;
        var n = this.A.t;
        var s = this.g(n.u, e2);
        if (s === 0) {
          n.o = r;
          return this._;
        } else if (s > 0) {
          n.t = new this.S(e2, r);
          n.t.h = n;
          i = n.t;
          this.A.t = i;
        } else {
          var h = this.A.i;
          var a = this.g(h.u, e2);
          if (a === 0) {
            h.o = r;
            return this._;
          } else if (a < 0) {
            h.i = new this.S(e2, r);
            h.i.h = h;
            i = h.i;
            this.A.i = i;
          } else {
            if (t !== void 0) {
              var u = t.C;
              if (u !== this.A) {
                var f = this.g(u.u, e2);
                if (f === 0) {
                  u.o = r;
                  return this._;
                } else if (f > 0) {
                  var o = u.v();
                  var d = this.g(o.u, e2);
                  if (d === 0) {
                    o.o = r;
                    return this._;
                  } else if (d < 0) {
                    i = new this.S(e2, r);
                    if (o.i === void 0) {
                      o.i = i;
                      i.h = o;
                    } else {
                      u.t = i;
                      i.h = u;
                    }
                  }
                }
              }
            }
            if (i === void 0) {
              i = this.N;
              while (true) {
                var c = this.g(i.u, e2);
                if (c > 0) {
                  if (i.t === void 0) {
                    i.t = new this.S(e2, r);
                    i.t.h = i;
                    i = i.t;
                    break;
                  }
                  i = i.t;
                } else if (c < 0) {
                  if (i.i === void 0) {
                    i.i = new this.S(e2, r);
                    i.i.h = i;
                    i = i.i;
                    break;
                  }
                  i = i.i;
                } else {
                  i.o = r;
                  return this._;
                }
              }
            }
          }
        }
        if (this.enableIndex) {
          var l = i.h;
          while (l !== this.A) {
            l.O += 1;
            l = l.h;
          }
        }
        this.q(i);
        this._ += 1;
        return this._;
      };
      TreeContainer2.prototype.F = function(e2, r) {
        while (e2) {
          var t = this.g(e2.u, r);
          if (t < 0) {
            e2 = e2.i;
          } else if (t > 0) {
            e2 = e2.t;
          } else return e2;
        }
        return e2 || this.A;
      };
      TreeContainer2.prototype.clear = function() {
        this._ = 0;
        this.N = void 0;
        this.A.h = void 0;
        this.A.t = this.A.i = void 0;
      };
      TreeContainer2.prototype.updateKeyByIterator = function(e2, r) {
        var t = e2.C;
        if (t === this.A) {
          throwIteratorAccessError();
        }
        if (this._ === 1) {
          t.u = r;
          return true;
        }
        var i = t.p().u;
        if (t === this.A.t) {
          if (this.g(i, r) > 0) {
            t.u = r;
            return true;
          }
          return false;
        }
        var n = t.v().u;
        if (t === this.A.i) {
          if (this.g(n, r) < 0) {
            t.u = r;
            return true;
          }
          return false;
        }
        if (this.g(n, r) >= 0 || this.g(i, r) <= 0) return false;
        t.u = r;
        return true;
      };
      TreeContainer2.prototype.eraseElementByPos = function(e2) {
        if (e2 < 0 || e2 > this._ - 1) {
          throw new RangeError();
        }
        var r = this.P(e2);
        this.G(r);
        return this._;
      };
      TreeContainer2.prototype.eraseElementByKey = function(e2) {
        if (this._ === 0) return false;
        var r = this.F(this.N, e2);
        if (r === this.A) return false;
        this.G(r);
        return true;
      };
      TreeContainer2.prototype.eraseElementByIterator = function(e2) {
        var r = e2.C;
        if (r === this.A) {
          throwIteratorAccessError();
        }
        var t = r.i === void 0;
        var i = e2.iteratorType === 0;
        if (i) {
          if (t) e2.next();
        } else {
          if (!t || r.t === void 0) e2.next();
        }
        this.G(r);
        return e2;
      };
      TreeContainer2.prototype.getHeight = function() {
        if (this._ === 0) return 0;
        function traversal(e2) {
          if (!e2) return 0;
          return Math.max(traversal(e2.t), traversal(e2.i)) + 1;
        }
        __name(traversal, "traversal");
        return traversal(this.N);
      };
      return TreeContainer2;
    }(Container);
    TreeIterator = function(e) {
      __extends(TreeIterator2, e);
      function TreeIterator2(r, t, i) {
        var n = e.call(this, i) || this;
        n.C = r;
        n.A = t;
        if (n.iteratorType === 0) {
          n.pre = function() {
            if (this.C === this.A.t) {
              throwIteratorAccessError();
            }
            this.C = this.C.v();
            return this;
          };
          n.next = function() {
            if (this.C === this.A) {
              throwIteratorAccessError();
            }
            this.C = this.C.p();
            return this;
          };
        } else {
          n.pre = function() {
            if (this.C === this.A.i) {
              throwIteratorAccessError();
            }
            this.C = this.C.p();
            return this;
          };
          n.next = function() {
            if (this.C === this.A) {
              throwIteratorAccessError();
            }
            this.C = this.C.v();
            return this;
          };
        }
        return n;
      }
      __name(TreeIterator2, "TreeIterator");
      Object.defineProperty(TreeIterator2.prototype, "index", {
        get: /* @__PURE__ */ __name(function() {
          var e2 = this.C;
          var r = this.A.h;
          if (e2 === this.A) {
            if (r) {
              return r.O - 1;
            }
            return 0;
          }
          var t = 0;
          if (e2.t) {
            t += e2.t.O;
          }
          while (e2 !== r) {
            var i = e2.h;
            if (e2 === i.i) {
              t += 1;
              if (i.t) {
                t += i.t.O;
              }
            }
            e2 = i;
          }
          return t;
        }, "get"),
        enumerable: false,
        configurable: true
      });
      TreeIterator2.prototype.isAccessible = function() {
        return this.C !== this.A;
      };
      return TreeIterator2;
    }(ContainerIterator);
    OrderedMapIterator = function(e) {
      __extends(OrderedMapIterator2, e);
      function OrderedMapIterator2(r, t, i, n) {
        var s = e.call(this, r, t, n) || this;
        s.container = i;
        return s;
      }
      __name(OrderedMapIterator2, "OrderedMapIterator");
      Object.defineProperty(OrderedMapIterator2.prototype, "pointer", {
        get: /* @__PURE__ */ __name(function() {
          if (this.C === this.A) {
            throwIteratorAccessError();
          }
          var e2 = this;
          return new Proxy([], {
            get: /* @__PURE__ */ __name(function(r, t) {
              if (t === "0") return e2.C.u;
              else if (t === "1") return e2.C.o;
              r[0] = e2.C.u;
              r[1] = e2.C.o;
              return r[t];
            }, "get"),
            set: /* @__PURE__ */ __name(function(r, t, i) {
              if (t !== "1") {
                throw new TypeError("prop must be 1");
              }
              e2.C.o = i;
              return true;
            }, "set")
          });
        }, "get"),
        enumerable: false,
        configurable: true
      });
      OrderedMapIterator2.prototype.copy = function() {
        return new OrderedMapIterator2(this.C, this.A, this.container, this.iteratorType);
      };
      return OrderedMapIterator2;
    }(TreeIterator);
    OrderedMap = function(e) {
      __extends(OrderedMap2, e);
      function OrderedMap2(r, t, i) {
        if (r === void 0) {
          r = [];
        }
        var n = e.call(this, t, i) || this;
        var s = n;
        r.forEach(function(e2) {
          s.setElement(e2[0], e2[1]);
        });
        return n;
      }
      __name(OrderedMap2, "OrderedMap");
      OrderedMap2.prototype.begin = function() {
        return new OrderedMapIterator(this.A.t || this.A, this.A, this);
      };
      OrderedMap2.prototype.end = function() {
        return new OrderedMapIterator(this.A, this.A, this);
      };
      OrderedMap2.prototype.rBegin = function() {
        return new OrderedMapIterator(this.A.i || this.A, this.A, this, 1);
      };
      OrderedMap2.prototype.rEnd = function() {
        return new OrderedMapIterator(this.A, this.A, this, 1);
      };
      OrderedMap2.prototype.front = function() {
        if (this._ === 0) return;
        var e2 = this.A.t;
        return [
          e2.u,
          e2.o
        ];
      };
      OrderedMap2.prototype.back = function() {
        if (this._ === 0) return;
        var e2 = this.A.i;
        return [
          e2.u,
          e2.o
        ];
      };
      OrderedMap2.prototype.lowerBound = function(e2) {
        var r = this.m(this.N, e2);
        return new OrderedMapIterator(r, this.A, this);
      };
      OrderedMap2.prototype.upperBound = function(e2) {
        var r = this.B(this.N, e2);
        return new OrderedMapIterator(r, this.A, this);
      };
      OrderedMap2.prototype.reverseLowerBound = function(e2) {
        var r = this.j(this.N, e2);
        return new OrderedMapIterator(r, this.A, this);
      };
      OrderedMap2.prototype.reverseUpperBound = function(e2) {
        var r = this.k(this.N, e2);
        return new OrderedMapIterator(r, this.A, this);
      };
      OrderedMap2.prototype.forEach = function(e2) {
        this.P(function(r, t, i) {
          e2([
            r.u,
            r.o
          ], t, i);
        });
      };
      OrderedMap2.prototype.setElement = function(e2, r, t) {
        return this.D(e2, r, t);
      };
      OrderedMap2.prototype.getElementByPos = function(e2) {
        if (e2 < 0 || e2 > this._ - 1) {
          throw new RangeError();
        }
        var r = this.P(e2);
        return [
          r.u,
          r.o
        ];
      };
      OrderedMap2.prototype.find = function(e2) {
        var r = this.F(this.N, e2);
        return new OrderedMapIterator(r, this.A, this);
      };
      OrderedMap2.prototype.getElementByKey = function(e2) {
        var r = this.F(this.N, e2);
        return r.o;
      };
      OrderedMap2.prototype.union = function(e2) {
        var r = this;
        e2.forEach(function(e3) {
          r.setElement(e3[0], e3[1]);
        });
        return this._;
      };
      OrderedMap2.prototype[Symbol.iterator] = function() {
        var e2, r, t, i;
        return __generator(this, function(n) {
          switch (n.label) {
            case 0:
              e2 = this._;
              r = this.P();
              t = 0;
              n.label = 1;
            case 1:
              if (!(t < e2)) return [
                3,
                4
              ];
              i = r[t];
              return [
                4,
                [
                  i.u,
                  i.o
                ]
              ];
            case 2:
              n.sent();
              n.label = 3;
            case 3:
              ++t;
              return [
                3,
                1
              ];
            case 4:
              return [
                2
              ];
          }
        });
      };
      return OrderedMap2;
    }(TreeContainer);
  }
});

// node_modules/@grpc/grpc-js/build/src/admin.js
var require_admin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/admin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.registerAdminService = registerAdminService;
    exports2.addAdminServicesToServer = addAdminServicesToServer;
    var registeredAdminServices = [];
    function registerAdminService(getServiceDefinition, getHandlers) {
      registeredAdminServices.push({
        getServiceDefinition,
        getHandlers
      });
    }
    __name(registerAdminService, "registerAdminService");
    function addAdminServicesToServer(server) {
      for (const { getServiceDefinition, getHandlers } of registeredAdminServices) {
        server.addService(getServiceDefinition(), getHandlers());
      }
    }
    __name(addAdminServicesToServer, "addAdminServicesToServer");
  }
});

// node_modules/@grpc/grpc-js/build/src/call.js
var require_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ClientDuplexStreamImpl = exports2.ClientWritableStreamImpl = exports2.ClientReadableStreamImpl = exports2.ClientUnaryCallImpl = void 0;
    exports2.callErrorFromStatus = callErrorFromStatus;
    var events_1 = require("events");
    var stream_1 = require("stream");
    var constants_1 = require_constants3();
    function callErrorFromStatus(status, callerStack) {
      const message = `${status.code} ${constants_1.Status[status.code]}: ${status.details}`;
      const error = new Error(message);
      const stack = `${error.stack}
for call at
${callerStack}`;
      return Object.assign(new Error(message), status, {
        stack
      });
    }
    __name(callErrorFromStatus, "callErrorFromStatus");
    var ClientUnaryCallImpl = class ClientUnaryCallImpl extends events_1.EventEmitter {
      static {
        __name(this, "ClientUnaryCallImpl");
      }
      constructor() {
        super();
      }
      cancel() {
        var _a2;
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.getPeer()) !== null && _b2 !== void 0 ? _b2 : "unknown";
      }
    };
    exports2.ClientUnaryCallImpl = ClientUnaryCallImpl;
    var ClientReadableStreamImpl = class ClientReadableStreamImpl extends stream_1.Readable {
      static {
        __name(this, "ClientReadableStreamImpl");
      }
      constructor(deserialize) {
        super({
          objectMode: true
        });
        this.deserialize = deserialize;
      }
      cancel() {
        var _a2;
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.getPeer()) !== null && _b2 !== void 0 ? _b2 : "unknown";
      }
      _read(_size) {
        var _a2;
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.startRead();
      }
    };
    exports2.ClientReadableStreamImpl = ClientReadableStreamImpl;
    var ClientWritableStreamImpl = class ClientWritableStreamImpl extends stream_1.Writable {
      static {
        __name(this, "ClientWritableStreamImpl");
      }
      constructor(serialize) {
        super({
          objectMode: true
        });
        this.serialize = serialize;
      }
      cancel() {
        var _a2;
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.getPeer()) !== null && _b2 !== void 0 ? _b2 : "unknown";
      }
      _write(chunk, encoding, cb) {
        var _a2;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a2;
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.halfClose();
        cb();
      }
    };
    exports2.ClientWritableStreamImpl = ClientWritableStreamImpl;
    var ClientDuplexStreamImpl = class ClientDuplexStreamImpl extends stream_1.Duplex {
      static {
        __name(this, "ClientDuplexStreamImpl");
      }
      constructor(serialize, deserialize) {
        super({
          objectMode: true
        });
        this.serialize = serialize;
        this.deserialize = deserialize;
      }
      cancel() {
        var _a2;
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled on client");
      }
      getPeer() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.getPeer()) !== null && _b2 !== void 0 ? _b2 : "unknown";
      }
      _read(_size) {
        var _a2;
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.startRead();
      }
      _write(chunk, encoding, cb) {
        var _a2;
        const context = {
          callback: cb
        };
        const flags = Number(encoding);
        if (!Number.isNaN(flags)) {
          context.flags = flags;
        }
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.sendMessageWithContext(context, chunk);
      }
      _final(cb) {
        var _a2;
        (_a2 = this.call) === null || _a2 === void 0 ? void 0 : _a2.halfClose();
        cb();
      }
    };
    exports2.ClientDuplexStreamImpl = ClientDuplexStreamImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-interface.js
var require_call_interface = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.InterceptingListenerImpl = void 0;
    exports2.isInterceptingListener = isInterceptingListener;
    function isInterceptingListener(listener) {
      return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
    }
    __name(isInterceptingListener, "isInterceptingListener");
    var InterceptingListenerImpl = class InterceptingListenerImpl {
      static {
        __name(this, "InterceptingListenerImpl");
      }
      constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.processingMetadata = false;
        this.hasPendingMessage = false;
        this.processingMessage = false;
        this.pendingStatus = null;
      }
      processPendingMessage() {
        if (this.hasPendingMessage) {
          this.nextListener.onReceiveMessage(this.pendingMessage);
          this.pendingMessage = null;
          this.hasPendingMessage = false;
        }
      }
      processPendingStatus() {
        if (this.pendingStatus) {
          this.nextListener.onReceiveStatus(this.pendingStatus);
        }
      }
      onReceiveMetadata(metadata) {
        this.processingMetadata = true;
        this.listener.onReceiveMetadata(metadata, (metadata2) => {
          this.processingMetadata = false;
          this.nextListener.onReceiveMetadata(metadata2);
          this.processPendingMessage();
          this.processPendingStatus();
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      onReceiveMessage(message) {
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessage = msg;
            this.hasPendingMessage = true;
          } else {
            this.nextListener.onReceiveMessage(msg);
            this.processPendingStatus();
          }
        });
      }
      onReceiveStatus(status) {
        this.listener.onReceiveStatus(status, (processedStatus) => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingStatus = processedStatus;
          } else {
            this.nextListener.onReceiveStatus(processedStatus);
          }
        });
      }
    };
    exports2.InterceptingListenerImpl = InterceptingListenerImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/client-interceptors.js
var require_client_interceptors = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client-interceptors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.InterceptingCall = exports2.RequesterBuilder = exports2.ListenerBuilder = exports2.InterceptorConfigurationError = void 0;
    exports2.getInterceptingCall = getInterceptingCall;
    var metadata_1 = require_metadata2();
    var call_interface_1 = require_call_interface();
    var constants_1 = require_constants3();
    var error_1 = require_error();
    var InterceptorConfigurationError = class InterceptorConfigurationError2 extends Error {
      static {
        __name(this, "InterceptorConfigurationError");
      }
      constructor(message) {
        super(message);
        this.name = "InterceptorConfigurationError";
        Error.captureStackTrace(this, InterceptorConfigurationError2);
      }
    };
    exports2.InterceptorConfigurationError = InterceptorConfigurationError;
    var ListenerBuilder = class ListenerBuilder {
      static {
        __name(this, "ListenerBuilder");
      }
      constructor() {
        this.metadata = void 0;
        this.message = void 0;
        this.status = void 0;
      }
      withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
      }
      withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
      }
      withOnReceiveStatus(onReceiveStatus) {
        this.status = onReceiveStatus;
        return this;
      }
      build() {
        return {
          onReceiveMetadata: this.metadata,
          onReceiveMessage: this.message,
          onReceiveStatus: this.status
        };
      }
    };
    exports2.ListenerBuilder = ListenerBuilder;
    var RequesterBuilder = class RequesterBuilder {
      static {
        __name(this, "RequesterBuilder");
      }
      constructor() {
        this.start = void 0;
        this.message = void 0;
        this.halfClose = void 0;
        this.cancel = void 0;
      }
      withStart(start) {
        this.start = start;
        return this;
      }
      withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
      }
      withHalfClose(halfClose) {
        this.halfClose = halfClose;
        return this;
      }
      withCancel(cancel) {
        this.cancel = cancel;
        return this;
      }
      build() {
        return {
          start: this.start,
          sendMessage: this.message,
          halfClose: this.halfClose,
          cancel: this.cancel
        };
      }
    };
    exports2.RequesterBuilder = RequesterBuilder;
    var defaultListener = {
      onReceiveMetadata: /* @__PURE__ */ __name((metadata, next) => {
        next(metadata);
      }, "onReceiveMetadata"),
      onReceiveMessage: /* @__PURE__ */ __name((message, next) => {
        next(message);
      }, "onReceiveMessage"),
      onReceiveStatus: /* @__PURE__ */ __name((status, next) => {
        next(status);
      }, "onReceiveStatus")
    };
    var defaultRequester = {
      start: /* @__PURE__ */ __name((metadata, listener, next) => {
        next(metadata, listener);
      }, "start"),
      sendMessage: /* @__PURE__ */ __name((message, next) => {
        next(message);
      }, "sendMessage"),
      halfClose: /* @__PURE__ */ __name((next) => {
        next();
      }, "halfClose"),
      cancel: /* @__PURE__ */ __name((next) => {
        next();
      }, "cancel")
    };
    var InterceptingCall = class InterceptingCall {
      static {
        __name(this, "InterceptingCall");
      }
      constructor(nextCall, requester) {
        var _a2, _b2, _c2, _d;
        this.nextCall = nextCall;
        this.processingMetadata = false;
        this.pendingMessageContext = null;
        this.processingMessage = false;
        this.pendingHalfClose = false;
        if (requester) {
          this.requester = {
            start: (_a2 = requester.start) !== null && _a2 !== void 0 ? _a2 : defaultRequester.start,
            sendMessage: (_b2 = requester.sendMessage) !== null && _b2 !== void 0 ? _b2 : defaultRequester.sendMessage,
            halfClose: (_c2 = requester.halfClose) !== null && _c2 !== void 0 ? _c2 : defaultRequester.halfClose,
            cancel: (_d = requester.cancel) !== null && _d !== void 0 ? _d : defaultRequester.cancel
          };
        } else {
          this.requester = defaultRequester;
        }
      }
      cancelWithStatus(status, details) {
        this.requester.cancel(() => {
          this.nextCall.cancelWithStatus(status, details);
        });
      }
      getPeer() {
        return this.nextCall.getPeer();
      }
      processPendingMessage() {
        if (this.pendingMessageContext) {
          this.nextCall.sendMessageWithContext(this.pendingMessageContext, this.pendingMessage);
          this.pendingMessageContext = null;
          this.pendingMessage = null;
        }
      }
      processPendingHalfClose() {
        if (this.pendingHalfClose) {
          this.nextCall.halfClose();
        }
      }
      start(metadata, interceptingListener) {
        var _a2, _b2, _c2, _d, _e, _f;
        const fullInterceptingListener = {
          onReceiveMetadata: (_b2 = (_a2 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a2 === void 0 ? void 0 : _a2.bind(interceptingListener)) !== null && _b2 !== void 0 ? _b2 : (metadata2) => {
          },
          onReceiveMessage: (_d = (_c2 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _c2 === void 0 ? void 0 : _c2.bind(interceptingListener)) !== null && _d !== void 0 ? _d : (message) => {
          },
          onReceiveStatus: (_f = (_e = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _e === void 0 ? void 0 : _e.bind(interceptingListener)) !== null && _f !== void 0 ? _f : (status) => {
          }
        };
        this.processingMetadata = true;
        this.requester.start(metadata, fullInterceptingListener, (md, listener) => {
          var _a3, _b3, _c3;
          this.processingMetadata = false;
          let finalInterceptingListener;
          if ((0, call_interface_1.isInterceptingListener)(listener)) {
            finalInterceptingListener = listener;
          } else {
            const fullListener = {
              onReceiveMetadata: (_a3 = listener.onReceiveMetadata) !== null && _a3 !== void 0 ? _a3 : defaultListener.onReceiveMetadata,
              onReceiveMessage: (_b3 = listener.onReceiveMessage) !== null && _b3 !== void 0 ? _b3 : defaultListener.onReceiveMessage,
              onReceiveStatus: (_c3 = listener.onReceiveStatus) !== null && _c3 !== void 0 ? _c3 : defaultListener.onReceiveStatus
            };
            finalInterceptingListener = new call_interface_1.InterceptingListenerImpl(fullListener, fullInterceptingListener);
          }
          this.nextCall.start(md, finalInterceptingListener);
          this.processPendingMessage();
          this.processPendingHalfClose();
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessageWithContext(context, message) {
        this.processingMessage = true;
        this.requester.sendMessage(message, (finalMessage) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessageContext = context;
            this.pendingMessage = message;
          } else {
            this.nextCall.sendMessageWithContext(context, finalMessage);
            this.processPendingHalfClose();
          }
        });
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      startRead() {
        this.nextCall.startRead();
      }
      halfClose() {
        this.requester.halfClose(() => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingHalfClose = true;
          } else {
            this.nextCall.halfClose();
          }
        });
      }
    };
    exports2.InterceptingCall = InterceptingCall;
    function getCall(channel, path, options) {
      var _a2, _b2;
      const deadline = (_a2 = options.deadline) !== null && _a2 !== void 0 ? _a2 : Infinity;
      const host = options.host;
      const parent = (_b2 = options.parent) !== null && _b2 !== void 0 ? _b2 : null;
      const propagateFlags = options.propagate_flags;
      const credentials = options.credentials;
      const call = channel.createCall(path, deadline, host, parent, propagateFlags);
      if (credentials) {
        call.setCredentials(credentials);
      }
      return call;
    }
    __name(getCall, "getCall");
    var BaseInterceptingCall = class BaseInterceptingCall {
      static {
        __name(this, "BaseInterceptingCall");
      }
      constructor(call, methodDefinition) {
        this.call = call;
        this.methodDefinition = methodDefinition;
      }
      cancelWithStatus(status, details) {
        this.call.cancelWithStatus(status, details);
      }
      getPeer() {
        return this.call.getPeer();
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessageWithContext(context, message) {
        let serialized;
        try {
          serialized = this.methodDefinition.requestSerialize(message);
        } catch (e) {
          this.call.cancelWithStatus(constants_1.Status.INTERNAL, `Request message serialization failure: ${(0, error_1.getErrorMessage)(e)}`);
          return;
        }
        this.call.sendMessageWithContext(context, serialized);
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      sendMessage(message) {
        this.sendMessageWithContext({}, message);
      }
      start(metadata, interceptingListener) {
        let readError = null;
        this.call.start(metadata, {
          onReceiveMetadata: /* @__PURE__ */ __name((metadata2) => {
            var _a2;
            (_a2 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMetadata) === null || _a2 === void 0 ? void 0 : _a2.call(interceptingListener, metadata2);
          }, "onReceiveMetadata"),
          onReceiveMessage: /* @__PURE__ */ __name((message) => {
            var _a2;
            let deserialized;
            try {
              deserialized = this.methodDefinition.responseDeserialize(message);
            } catch (e) {
              readError = {
                code: constants_1.Status.INTERNAL,
                details: `Response message parsing error: ${(0, error_1.getErrorMessage)(e)}`,
                metadata: new metadata_1.Metadata()
              };
              this.call.cancelWithStatus(readError.code, readError.details);
              return;
            }
            (_a2 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveMessage) === null || _a2 === void 0 ? void 0 : _a2.call(interceptingListener, deserialized);
          }, "onReceiveMessage"),
          onReceiveStatus: /* @__PURE__ */ __name((status) => {
            var _a2, _b2;
            if (readError) {
              (_a2 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _a2 === void 0 ? void 0 : _a2.call(interceptingListener, readError);
            } else {
              (_b2 = interceptingListener === null || interceptingListener === void 0 ? void 0 : interceptingListener.onReceiveStatus) === null || _b2 === void 0 ? void 0 : _b2.call(interceptingListener, status);
            }
          }, "onReceiveStatus")
        });
      }
      startRead() {
        this.call.startRead();
      }
      halfClose() {
        this.call.halfClose();
      }
    };
    var BaseUnaryInterceptingCall = class BaseUnaryInterceptingCall extends BaseInterceptingCall {
      static {
        __name(this, "BaseUnaryInterceptingCall");
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      constructor(call, methodDefinition) {
        super(call, methodDefinition);
      }
      start(metadata, listener) {
        var _a2, _b2;
        let receivedMessage = false;
        const wrapperListener = {
          onReceiveMetadata: (_b2 = (_a2 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMetadata) === null || _a2 === void 0 ? void 0 : _a2.bind(listener)) !== null && _b2 !== void 0 ? _b2 : (metadata2) => {
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage: /* @__PURE__ */ __name((message) => {
            var _a3;
            receivedMessage = true;
            (_a3 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a3 === void 0 ? void 0 : _a3.call(listener, message);
          }, "onReceiveMessage"),
          onReceiveStatus: /* @__PURE__ */ __name((status) => {
            var _a3, _b3;
            if (!receivedMessage) {
              (_a3 = listener === null || listener === void 0 ? void 0 : listener.onReceiveMessage) === null || _a3 === void 0 ? void 0 : _a3.call(listener, null);
            }
            (_b3 = listener === null || listener === void 0 ? void 0 : listener.onReceiveStatus) === null || _b3 === void 0 ? void 0 : _b3.call(listener, status);
          }, "onReceiveStatus")
        };
        super.start(metadata, wrapperListener);
        this.call.startRead();
      }
    };
    var BaseStreamingInterceptingCall = class BaseStreamingInterceptingCall extends BaseInterceptingCall {
      static {
        __name(this, "BaseStreamingInterceptingCall");
      }
    };
    function getBottomInterceptingCall(channel, options, methodDefinition) {
      const call = getCall(channel, methodDefinition.path, options);
      if (methodDefinition.responseStream) {
        return new BaseStreamingInterceptingCall(call, methodDefinition);
      } else {
        return new BaseUnaryInterceptingCall(call, methodDefinition);
      }
    }
    __name(getBottomInterceptingCall, "getBottomInterceptingCall");
    function getInterceptingCall(interceptorArgs, methodDefinition, options, channel) {
      if (interceptorArgs.clientInterceptors.length > 0 && interceptorArgs.clientInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
      }
      if (interceptorArgs.callInterceptors.length > 0 && interceptorArgs.callInterceptorProviders.length > 0) {
        throw new InterceptorConfigurationError("Both interceptors and interceptor_providers were passed as call options. Only one of these is allowed.");
      }
      let interceptors = [];
      if (interceptorArgs.callInterceptors.length > 0 || interceptorArgs.callInterceptorProviders.length > 0) {
        interceptors = [].concat(interceptorArgs.callInterceptors, interceptorArgs.callInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      } else {
        interceptors = [].concat(interceptorArgs.clientInterceptors, interceptorArgs.clientInterceptorProviders.map((provider) => provider(methodDefinition))).filter((interceptor) => interceptor);
      }
      const interceptorOptions = Object.assign({}, options, {
        method_definition: methodDefinition
      });
      const getCall2 = interceptors.reduceRight((nextCall, nextInterceptor) => {
        return (currentOptions) => nextInterceptor(currentOptions, nextCall);
      }, (finalOptions) => getBottomInterceptingCall(channel, finalOptions, methodDefinition));
      return getCall2(interceptorOptions);
    }
    __name(getInterceptingCall, "getInterceptingCall");
  }
});

// node_modules/@grpc/grpc-js/build/src/client.js
var require_client2 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Client = void 0;
    var call_1 = require_call();
    var channel_1 = require_channel();
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants3();
    var metadata_1 = require_metadata2();
    var client_interceptors_1 = require_client_interceptors();
    var CHANNEL_SYMBOL = Symbol();
    var INTERCEPTOR_SYMBOL = Symbol();
    var INTERCEPTOR_PROVIDER_SYMBOL = Symbol();
    var CALL_INVOCATION_TRANSFORMER_SYMBOL = Symbol();
    function isFunction2(arg) {
      return typeof arg === "function";
    }
    __name(isFunction2, "isFunction");
    function getErrorStackString(error) {
      var _a2;
      return ((_a2 = error.stack) === null || _a2 === void 0 ? void 0 : _a2.split("\n").slice(1).join("\n")) || "no stack trace available";
    }
    __name(getErrorStackString, "getErrorStackString");
    var Client = class Client {
      static {
        __name(this, "Client");
      }
      constructor(address, credentials, options = {}) {
        var _a2, _b2;
        options = Object.assign({}, options);
        this[INTERCEPTOR_SYMBOL] = (_a2 = options.interceptors) !== null && _a2 !== void 0 ? _a2 : [];
        delete options.interceptors;
        this[INTERCEPTOR_PROVIDER_SYMBOL] = (_b2 = options.interceptor_providers) !== null && _b2 !== void 0 ? _b2 : [];
        delete options.interceptor_providers;
        if (this[INTERCEPTOR_SYMBOL].length > 0 && this[INTERCEPTOR_PROVIDER_SYMBOL].length > 0) {
          throw new Error("Both interceptors and interceptor_providers were passed as options to the client constructor. Only one of these is allowed.");
        }
        this[CALL_INVOCATION_TRANSFORMER_SYMBOL] = options.callInvocationTransformer;
        delete options.callInvocationTransformer;
        if (options.channelOverride) {
          this[CHANNEL_SYMBOL] = options.channelOverride;
        } else if (options.channelFactoryOverride) {
          const channelFactoryOverride = options.channelFactoryOverride;
          delete options.channelFactoryOverride;
          this[CHANNEL_SYMBOL] = channelFactoryOverride(address, credentials, options);
        } else {
          this[CHANNEL_SYMBOL] = new channel_1.ChannelImplementation(address, credentials, options);
        }
      }
      close() {
        this[CHANNEL_SYMBOL].close();
      }
      getChannel() {
        return this[CHANNEL_SYMBOL];
      }
      waitForReady(deadline, callback) {
        const checkState = /* @__PURE__ */ __name((err) => {
          if (err) {
            callback(new Error("Failed to connect before the deadline"));
            return;
          }
          let newState;
          try {
            newState = this[CHANNEL_SYMBOL].getConnectivityState(true);
          } catch (e) {
            callback(new Error("The channel has been closed"));
            return;
          }
          if (newState === connectivity_state_1.ConnectivityState.READY) {
            callback();
          } else {
            try {
              this[CHANNEL_SYMBOL].watchConnectivityState(newState, deadline, checkState);
            } catch (e) {
              callback(new Error("The channel has been closed"));
            }
          }
        }, "checkState");
        setImmediate(checkState);
      }
      checkOptionalUnaryResponseArguments(arg1, arg2, arg3) {
        if (isFunction2(arg1)) {
          return {
            metadata: new metadata_1.Metadata(),
            options: {},
            callback: arg1
          };
        } else if (isFunction2(arg2)) {
          if (arg1 instanceof metadata_1.Metadata) {
            return {
              metadata: arg1,
              options: {},
              callback: arg2
            };
          } else {
            return {
              metadata: new metadata_1.Metadata(),
              options: arg1,
              callback: arg2
            };
          }
        } else {
          if (!(arg1 instanceof metadata_1.Metadata && arg2 instanceof Object && isFunction2(arg3))) {
            throw new Error("Incorrect arguments passed");
          }
          return {
            metadata: arg1,
            options: arg2,
            callback: arg3
          };
        }
      }
      makeUnaryRequest(method, serialize, deserialize, argument, metadata, options, callback) {
        var _a2, _b2;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientUnaryCallImpl(),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a2 = callProperties.callOptions.interceptors) !== null && _a2 !== void 0 ? _a2 : [],
          callInterceptorProviders: (_b2 = callProperties.callOptions.interceptor_providers) !== null && _b2 !== void 0 ? _b2 : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        let responseMessage = null;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata: /* @__PURE__ */ __name((metadata2) => {
            emitter.emit("metadata", metadata2);
          }, "onReceiveMetadata"),
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, "Too many responses received");
            }
            responseMessage = message;
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              if (responseMessage === null) {
                const callerStack = getErrorStackString(callerStackError);
                callProperties.callback((0, call_1.callErrorFromStatus)({
                  code: constants_1.Status.UNIMPLEMENTED,
                  details: "No message received",
                  metadata: status.metadata
                }, callerStack));
              } else {
                callProperties.callback(null, responseMessage);
              }
            } else {
              const callerStack = getErrorStackString(callerStackError);
              callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
            }
            callerStackError = null;
            emitter.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return emitter;
      }
      makeClientStreamRequest(method, serialize, deserialize, metadata, options, callback) {
        var _a2, _b2;
        const checkedArguments = this.checkOptionalUnaryResponseArguments(metadata, options, callback);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: false,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientWritableStreamImpl(serialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options,
          callback: checkedArguments.callback
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const emitter = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a2 = callProperties.callOptions.interceptors) !== null && _a2 !== void 0 ? _a2 : [],
          callInterceptorProviders: (_b2 = callProperties.callOptions.interceptor_providers) !== null && _b2 !== void 0 ? _b2 : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        emitter.call = call;
        let responseMessage = null;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata: /* @__PURE__ */ __name((metadata2) => {
            emitter.emit("metadata", metadata2);
          }, "onReceiveMetadata"),
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            if (responseMessage !== null) {
              call.cancelWithStatus(constants_1.Status.UNIMPLEMENTED, "Too many responses received");
            }
            responseMessage = message;
            call.startRead();
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            if (status.code === constants_1.Status.OK) {
              if (responseMessage === null) {
                const callerStack = getErrorStackString(callerStackError);
                callProperties.callback((0, call_1.callErrorFromStatus)({
                  code: constants_1.Status.UNIMPLEMENTED,
                  details: "No message received",
                  metadata: status.metadata
                }, callerStack));
              } else {
                callProperties.callback(null, responseMessage);
              }
            } else {
              const callerStack = getErrorStackString(callerStackError);
              callProperties.callback((0, call_1.callErrorFromStatus)(status, callerStack));
            }
            callerStackError = null;
            emitter.emit("status", status);
          }
        });
        return emitter;
      }
      checkMetadataAndOptions(arg1, arg2) {
        let metadata;
        let options;
        if (arg1 instanceof metadata_1.Metadata) {
          metadata = arg1;
          if (arg2) {
            options = arg2;
          } else {
            options = {};
          }
        } else {
          if (arg1) {
            options = arg1;
          } else {
            options = {};
          }
          metadata = new metadata_1.Metadata();
        }
        return {
          metadata,
          options
        };
      }
      makeServerStreamRequest(method, serialize, deserialize, argument, metadata, options) {
        var _a2, _b2;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
          path: method,
          requestStream: false,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          argument,
          metadata: checkedArguments.metadata,
          call: new call_1.ClientReadableStreamImpl(deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a2 = callProperties.callOptions.interceptors) !== null && _a2 !== void 0 ? _a2 : [],
          callInterceptorProviders: (_b2 = callProperties.callOptions.interceptor_providers) !== null && _b2 !== void 0 ? _b2 : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          // eslint-disable-next-line @typescript-eslint/no-explicit-any
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              const callerStack = getErrorStackString(callerStackError);
              stream.emit("error", (0, call_1.callErrorFromStatus)(status, callerStack));
            }
            callerStackError = null;
            stream.emit("status", status);
          }
        });
        call.sendMessage(argument);
        call.halfClose();
        return stream;
      }
      makeBidiStreamRequest(method, serialize, deserialize, metadata, options) {
        var _a2, _b2;
        const checkedArguments = this.checkMetadataAndOptions(metadata, options);
        const methodDefinition = {
          path: method,
          requestStream: true,
          responseStream: true,
          requestSerialize: serialize,
          responseDeserialize: deserialize
        };
        let callProperties = {
          metadata: checkedArguments.metadata,
          call: new call_1.ClientDuplexStreamImpl(serialize, deserialize),
          channel: this[CHANNEL_SYMBOL],
          methodDefinition,
          callOptions: checkedArguments.options
        };
        if (this[CALL_INVOCATION_TRANSFORMER_SYMBOL]) {
          callProperties = this[CALL_INVOCATION_TRANSFORMER_SYMBOL](callProperties);
        }
        const stream = callProperties.call;
        const interceptorArgs = {
          clientInterceptors: this[INTERCEPTOR_SYMBOL],
          clientInterceptorProviders: this[INTERCEPTOR_PROVIDER_SYMBOL],
          callInterceptors: (_a2 = callProperties.callOptions.interceptors) !== null && _a2 !== void 0 ? _a2 : [],
          callInterceptorProviders: (_b2 = callProperties.callOptions.interceptor_providers) !== null && _b2 !== void 0 ? _b2 : []
        };
        const call = (0, client_interceptors_1.getInterceptingCall)(interceptorArgs, callProperties.methodDefinition, callProperties.callOptions, callProperties.channel);
        stream.call = call;
        let receivedStatus = false;
        let callerStackError = new Error();
        call.start(callProperties.metadata, {
          onReceiveMetadata(metadata2) {
            stream.emit("metadata", metadata2);
          },
          onReceiveMessage(message) {
            stream.push(message);
          },
          onReceiveStatus(status) {
            if (receivedStatus) {
              return;
            }
            receivedStatus = true;
            stream.push(null);
            if (status.code !== constants_1.Status.OK) {
              const callerStack = getErrorStackString(callerStackError);
              stream.emit("error", (0, call_1.callErrorFromStatus)(status, callerStack));
            }
            callerStackError = null;
            stream.emit("status", status);
          }
        });
        return stream;
      }
    };
    exports2.Client = Client;
  }
});

// node_modules/@grpc/grpc-js/build/src/make-client.js
var require_make_client = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/make-client.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.makeClientConstructor = makeClientConstructor;
    exports2.loadPackageDefinition = loadPackageDefinition;
    var client_1 = require_client2();
    var requesterFuncs = {
      unary: client_1.Client.prototype.makeUnaryRequest,
      server_stream: client_1.Client.prototype.makeServerStreamRequest,
      client_stream: client_1.Client.prototype.makeClientStreamRequest,
      bidi: client_1.Client.prototype.makeBidiStreamRequest
    };
    function isPrototypePolluted(key) {
      return [
        "__proto__",
        "prototype",
        "constructor"
      ].includes(key);
    }
    __name(isPrototypePolluted, "isPrototypePolluted");
    function makeClientConstructor(methods, serviceName, classOptions) {
      if (!classOptions) {
        classOptions = {};
      }
      let ServiceClientImpl = class ServiceClientImpl extends client_1.Client {
        static {
          __name(this, "ServiceClientImpl");
        }
      };
      Object.keys(methods).forEach((name) => {
        if (isPrototypePolluted(name)) {
          return;
        }
        const attrs = methods[name];
        let methodType;
        if (typeof name === "string" && name.charAt(0) === "$") {
          throw new Error("Method names cannot start with $");
        }
        if (attrs.requestStream) {
          if (attrs.responseStream) {
            methodType = "bidi";
          } else {
            methodType = "client_stream";
          }
        } else {
          if (attrs.responseStream) {
            methodType = "server_stream";
          } else {
            methodType = "unary";
          }
        }
        const serialize = attrs.requestSerialize;
        const deserialize = attrs.responseDeserialize;
        const methodFunc = partial(requesterFuncs[methodType], attrs.path, serialize, deserialize);
        ServiceClientImpl.prototype[name] = methodFunc;
        Object.assign(ServiceClientImpl.prototype[name], attrs);
        if (attrs.originalName && !isPrototypePolluted(attrs.originalName)) {
          ServiceClientImpl.prototype[attrs.originalName] = ServiceClientImpl.prototype[name];
        }
      });
      ServiceClientImpl.service = methods;
      ServiceClientImpl.serviceName = serviceName;
      return ServiceClientImpl;
    }
    __name(makeClientConstructor, "makeClientConstructor");
    function partial(fn, path, serialize, deserialize) {
      return function(...args) {
        return fn.call(this, path, serialize, deserialize, ...args);
      };
    }
    __name(partial, "partial");
    function isProtobufTypeDefinition(obj) {
      return "format" in obj;
    }
    __name(isProtobufTypeDefinition, "isProtobufTypeDefinition");
    function loadPackageDefinition(packageDef) {
      const result2 = {};
      for (const serviceFqn in packageDef) {
        if (Object.prototype.hasOwnProperty.call(packageDef, serviceFqn)) {
          const service = packageDef[serviceFqn];
          const nameComponents = serviceFqn.split(".");
          if (nameComponents.some((comp) => isPrototypePolluted(comp))) {
            continue;
          }
          const serviceName = nameComponents[nameComponents.length - 1];
          let current = result2;
          for (const packageName of nameComponents.slice(0, -1)) {
            if (!current[packageName]) {
              current[packageName] = {};
            }
            current = current[packageName];
          }
          if (isProtobufTypeDefinition(service)) {
            current[serviceName] = service;
          } else {
            current[serviceName] = makeClientConstructor(service, serviceName, {});
          }
        }
      }
      return result2;
    }
    __name(loadPackageDefinition, "loadPackageDefinition");
  }
});

// node_modules/lodash.camelcase/index.js
var require_lodash = __commonJS({
  "node_modules/lodash.camelcase/index.js"(exports2, module2) {
    "use strict";
    var INFINITY = 1 / 0;
    var symbolTag = "[object Symbol]";
    var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;
    var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;
    var rsAstralRange = "\\ud800-\\udfff";
    var rsComboMarksRange = "\\u0300-\\u036f\\ufe20-\\ufe23";
    var rsComboSymbolsRange = "\\u20d0-\\u20f0";
    var rsDingbatRange = "\\u2700-\\u27bf";
    var rsLowerRange = "a-z\\xdf-\\xf6\\xf8-\\xff";
    var rsMathOpRange = "\\xac\\xb1\\xd7\\xf7";
    var rsNonCharRange = "\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf";
    var rsPunctuationRange = "\\u2000-\\u206f";
    var rsSpaceRange = " \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000";
    var rsUpperRange = "A-Z\\xc0-\\xd6\\xd8-\\xde";
    var rsVarRange = "\\ufe0e\\ufe0f";
    var rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;
    var rsApos = "['\u2019]";
    var rsAstral = "[" + rsAstralRange + "]";
    var rsBreak = "[" + rsBreakRange + "]";
    var rsCombo = "[" + rsComboMarksRange + rsComboSymbolsRange + "]";
    var rsDigits = "\\d+";
    var rsDingbat = "[" + rsDingbatRange + "]";
    var rsLower = "[" + rsLowerRange + "]";
    var rsMisc = "[^" + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + "]";
    var rsFitz = "\\ud83c[\\udffb-\\udfff]";
    var rsModifier = "(?:" + rsCombo + "|" + rsFitz + ")";
    var rsNonAstral = "[^" + rsAstralRange + "]";
    var rsRegional = "(?:\\ud83c[\\udde6-\\uddff]){2}";
    var rsSurrPair = "[\\ud800-\\udbff][\\udc00-\\udfff]";
    var rsUpper = "[" + rsUpperRange + "]";
    var rsZWJ = "\\u200d";
    var rsLowerMisc = "(?:" + rsLower + "|" + rsMisc + ")";
    var rsUpperMisc = "(?:" + rsUpper + "|" + rsMisc + ")";
    var rsOptLowerContr = "(?:" + rsApos + "(?:d|ll|m|re|s|t|ve))?";
    var rsOptUpperContr = "(?:" + rsApos + "(?:D|LL|M|RE|S|T|VE))?";
    var reOptMod = rsModifier + "?";
    var rsOptVar = "[" + rsVarRange + "]?";
    var rsOptJoin = "(?:" + rsZWJ + "(?:" + [
      rsNonAstral,
      rsRegional,
      rsSurrPair
    ].join("|") + ")" + rsOptVar + reOptMod + ")*";
    var rsSeq = rsOptVar + reOptMod + rsOptJoin;
    var rsEmoji = "(?:" + [
      rsDingbat,
      rsRegional,
      rsSurrPair
    ].join("|") + ")" + rsSeq;
    var rsSymbol = "(?:" + [
      rsNonAstral + rsCombo + "?",
      rsCombo,
      rsRegional,
      rsSurrPair,
      rsAstral
    ].join("|") + ")";
    var reApos = RegExp(rsApos, "g");
    var reComboMark = RegExp(rsCombo, "g");
    var reUnicode = RegExp(rsFitz + "(?=" + rsFitz + ")|" + rsSymbol + rsSeq, "g");
    var reUnicodeWord = RegExp([
      rsUpper + "?" + rsLower + "+" + rsOptLowerContr + "(?=" + [
        rsBreak,
        rsUpper,
        "$"
      ].join("|") + ")",
      rsUpperMisc + "+" + rsOptUpperContr + "(?=" + [
        rsBreak,
        rsUpper + rsLowerMisc,
        "$"
      ].join("|") + ")",
      rsUpper + "?" + rsLowerMisc + "+" + rsOptLowerContr,
      rsUpper + "+" + rsOptUpperContr,
      rsDigits,
      rsEmoji
    ].join("|"), "g");
    var reHasUnicode = RegExp("[" + rsZWJ + rsAstralRange + rsComboMarksRange + rsComboSymbolsRange + rsVarRange + "]");
    var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2,}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;
    var deburredLetters = {
      // Latin-1 Supplement block.
      "\xC0": "A",
      "\xC1": "A",
      "\xC2": "A",
      "\xC3": "A",
      "\xC4": "A",
      "\xC5": "A",
      "\xE0": "a",
      "\xE1": "a",
      "\xE2": "a",
      "\xE3": "a",
      "\xE4": "a",
      "\xE5": "a",
      "\xC7": "C",
      "\xE7": "c",
      "\xD0": "D",
      "\xF0": "d",
      "\xC8": "E",
      "\xC9": "E",
      "\xCA": "E",
      "\xCB": "E",
      "\xE8": "e",
      "\xE9": "e",
      "\xEA": "e",
      "\xEB": "e",
      "\xCC": "I",
      "\xCD": "I",
      "\xCE": "I",
      "\xCF": "I",
      "\xEC": "i",
      "\xED": "i",
      "\xEE": "i",
      "\xEF": "i",
      "\xD1": "N",
      "\xF1": "n",
      "\xD2": "O",
      "\xD3": "O",
      "\xD4": "O",
      "\xD5": "O",
      "\xD6": "O",
      "\xD8": "O",
      "\xF2": "o",
      "\xF3": "o",
      "\xF4": "o",
      "\xF5": "o",
      "\xF6": "o",
      "\xF8": "o",
      "\xD9": "U",
      "\xDA": "U",
      "\xDB": "U",
      "\xDC": "U",
      "\xF9": "u",
      "\xFA": "u",
      "\xFB": "u",
      "\xFC": "u",
      "\xDD": "Y",
      "\xFD": "y",
      "\xFF": "y",
      "\xC6": "Ae",
      "\xE6": "ae",
      "\xDE": "Th",
      "\xFE": "th",
      "\xDF": "ss",
      // Latin Extended-A block.
      "\u0100": "A",
      "\u0102": "A",
      "\u0104": "A",
      "\u0101": "a",
      "\u0103": "a",
      "\u0105": "a",
      "\u0106": "C",
      "\u0108": "C",
      "\u010A": "C",
      "\u010C": "C",
      "\u0107": "c",
      "\u0109": "c",
      "\u010B": "c",
      "\u010D": "c",
      "\u010E": "D",
      "\u0110": "D",
      "\u010F": "d",
      "\u0111": "d",
      "\u0112": "E",
      "\u0114": "E",
      "\u0116": "E",
      "\u0118": "E",
      "\u011A": "E",
      "\u0113": "e",
      "\u0115": "e",
      "\u0117": "e",
      "\u0119": "e",
      "\u011B": "e",
      "\u011C": "G",
      "\u011E": "G",
      "\u0120": "G",
      "\u0122": "G",
      "\u011D": "g",
      "\u011F": "g",
      "\u0121": "g",
      "\u0123": "g",
      "\u0124": "H",
      "\u0126": "H",
      "\u0125": "h",
      "\u0127": "h",
      "\u0128": "I",
      "\u012A": "I",
      "\u012C": "I",
      "\u012E": "I",
      "\u0130": "I",
      "\u0129": "i",
      "\u012B": "i",
      "\u012D": "i",
      "\u012F": "i",
      "\u0131": "i",
      "\u0134": "J",
      "\u0135": "j",
      "\u0136": "K",
      "\u0137": "k",
      "\u0138": "k",
      "\u0139": "L",
      "\u013B": "L",
      "\u013D": "L",
      "\u013F": "L",
      "\u0141": "L",
      "\u013A": "l",
      "\u013C": "l",
      "\u013E": "l",
      "\u0140": "l",
      "\u0142": "l",
      "\u0143": "N",
      "\u0145": "N",
      "\u0147": "N",
      "\u014A": "N",
      "\u0144": "n",
      "\u0146": "n",
      "\u0148": "n",
      "\u014B": "n",
      "\u014C": "O",
      "\u014E": "O",
      "\u0150": "O",
      "\u014D": "o",
      "\u014F": "o",
      "\u0151": "o",
      "\u0154": "R",
      "\u0156": "R",
      "\u0158": "R",
      "\u0155": "r",
      "\u0157": "r",
      "\u0159": "r",
      "\u015A": "S",
      "\u015C": "S",
      "\u015E": "S",
      "\u0160": "S",
      "\u015B": "s",
      "\u015D": "s",
      "\u015F": "s",
      "\u0161": "s",
      "\u0162": "T",
      "\u0164": "T",
      "\u0166": "T",
      "\u0163": "t",
      "\u0165": "t",
      "\u0167": "t",
      "\u0168": "U",
      "\u016A": "U",
      "\u016C": "U",
      "\u016E": "U",
      "\u0170": "U",
      "\u0172": "U",
      "\u0169": "u",
      "\u016B": "u",
      "\u016D": "u",
      "\u016F": "u",
      "\u0171": "u",
      "\u0173": "u",
      "\u0174": "W",
      "\u0175": "w",
      "\u0176": "Y",
      "\u0177": "y",
      "\u0178": "Y",
      "\u0179": "Z",
      "\u017B": "Z",
      "\u017D": "Z",
      "\u017A": "z",
      "\u017C": "z",
      "\u017E": "z",
      "\u0132": "IJ",
      "\u0133": "ij",
      "\u0152": "Oe",
      "\u0153": "oe",
      "\u0149": "'n",
      "\u017F": "ss"
    };
    var freeGlobal = typeof global == "object" && global && global.Object === Object && global;
    var freeSelf = typeof self == "object" && self && self.Object === Object && self;
    var root = freeGlobal || freeSelf || Function("return this")();
    function arrayReduce(array, iteratee, accumulator, initAccum) {
      var index = -1, length = array ? array.length : 0;
      if (initAccum && length) {
        accumulator = array[++index];
      }
      while (++index < length) {
        accumulator = iteratee(accumulator, array[index], index, array);
      }
      return accumulator;
    }
    __name(arrayReduce, "arrayReduce");
    function asciiToArray(string) {
      return string.split("");
    }
    __name(asciiToArray, "asciiToArray");
    function asciiWords(string) {
      return string.match(reAsciiWord) || [];
    }
    __name(asciiWords, "asciiWords");
    function basePropertyOf(object) {
      return function(key) {
        return object == null ? void 0 : object[key];
      };
    }
    __name(basePropertyOf, "basePropertyOf");
    var deburrLetter = basePropertyOf(deburredLetters);
    function hasUnicode(string) {
      return reHasUnicode.test(string);
    }
    __name(hasUnicode, "hasUnicode");
    function hasUnicodeWord(string) {
      return reHasUnicodeWord.test(string);
    }
    __name(hasUnicodeWord, "hasUnicodeWord");
    function stringToArray(string) {
      return hasUnicode(string) ? unicodeToArray(string) : asciiToArray(string);
    }
    __name(stringToArray, "stringToArray");
    function unicodeToArray(string) {
      return string.match(reUnicode) || [];
    }
    __name(unicodeToArray, "unicodeToArray");
    function unicodeWords(string) {
      return string.match(reUnicodeWord) || [];
    }
    __name(unicodeWords, "unicodeWords");
    var objectProto = Object.prototype;
    var objectToString = objectProto.toString;
    var Symbol2 = root.Symbol;
    var symbolProto = Symbol2 ? Symbol2.prototype : void 0;
    var symbolToString = symbolProto ? symbolProto.toString : void 0;
    function baseSlice(array, start, end) {
      var index = -1, length = array.length;
      if (start < 0) {
        start = -start > length ? 0 : length + start;
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : end - start >>> 0;
      start >>>= 0;
      var result2 = Array(length);
      while (++index < length) {
        result2[index] = array[index + start];
      }
      return result2;
    }
    __name(baseSlice, "baseSlice");
    function baseToString(value2) {
      if (typeof value2 == "string") {
        return value2;
      }
      if (isSymbol(value2)) {
        return symbolToString ? symbolToString.call(value2) : "";
      }
      var result2 = value2 + "";
      return result2 == "0" && 1 / value2 == -INFINITY ? "-0" : result2;
    }
    __name(baseToString, "baseToString");
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === void 0 ? length : end;
      return !start && end >= length ? array : baseSlice(array, start, end);
    }
    __name(castSlice, "castSlice");
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString2(string);
        var strSymbols = hasUnicode(string) ? stringToArray(string) : void 0;
        var chr = strSymbols ? strSymbols[0] : string.charAt(0);
        var trailing = strSymbols ? castSlice(strSymbols, 1).join("") : string.slice(1);
        return chr[methodName]() + trailing;
      };
    }
    __name(createCaseFirst, "createCaseFirst");
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, "")), callback, "");
      };
    }
    __name(createCompounder, "createCompounder");
    function isObjectLike(value2) {
      return !!value2 && typeof value2 == "object";
    }
    __name(isObjectLike, "isObjectLike");
    function isSymbol(value2) {
      return typeof value2 == "symbol" || isObjectLike(value2) && objectToString.call(value2) == symbolTag;
    }
    __name(isSymbol, "isSymbol");
    function toString2(value2) {
      return value2 == null ? "" : baseToString(value2);
    }
    __name(toString2, "toString");
    var camelCase2 = createCompounder(function(result2, word2, index) {
      word2 = word2.toLowerCase();
      return result2 + (index ? capitalize(word2) : word2);
    });
    function capitalize(string) {
      return upperFirst(toString2(string).toLowerCase());
    }
    __name(capitalize, "capitalize");
    function deburr(string) {
      string = toString2(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, "");
    }
    __name(deburr, "deburr");
    var upperFirst = createCaseFirst("toUpperCase");
    function words(string, pattern, guard) {
      string = toString2(string);
      pattern = guard ? void 0 : pattern;
      if (pattern === void 0) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }
    __name(words, "words");
    module2.exports = camelCase2;
  }
});

// node_modules/@protobufjs/aspromise/index.js
var require_aspromise = __commonJS({
  "node_modules/@protobufjs/aspromise/index.js"(exports2, module2) {
    "use strict";
    module2.exports = asPromise;
    function asPromise(fn, ctx) {
      var params2 = new Array(arguments.length - 1), offset = 0, index = 2, pending = true;
      while (index < arguments.length) params2[offset++] = arguments[index++];
      return new Promise(/* @__PURE__ */ __name(function executor(resolve5, reject) {
        params2[offset] = /* @__PURE__ */ __name(function callback(err) {
          if (pending) {
            pending = false;
            if (err) reject(err);
            else {
              var params3 = new Array(arguments.length - 1), offset2 = 0;
              while (offset2 < params3.length) params3[offset2++] = arguments[offset2];
              resolve5.apply(null, params3);
            }
          }
        }, "callback");
        try {
          fn.apply(ctx || null, params2);
        } catch (err) {
          if (pending) {
            pending = false;
            reject(err);
          }
        }
      }, "executor"));
    }
    __name(asPromise, "asPromise");
  }
});

// node_modules/@protobufjs/base64/index.js
var require_base64 = __commonJS({
  "node_modules/@protobufjs/base64/index.js"(exports2) {
    "use strict";
    var base64 = exports2;
    base64.length = /* @__PURE__ */ __name(function length(string) {
      var p = string.length;
      if (!p) return 0;
      var n = 0;
      while (--p % 4 > 1 && string.charAt(p) === "=") ++n;
      return Math.ceil(string.length * 3) / 4 - n;
    }, "length");
    var b64 = new Array(64);
    var s64 = new Array(123);
    for (i = 0; i < 64; ) s64[b64[i] = i < 26 ? i + 65 : i < 52 ? i + 71 : i < 62 ? i - 4 : i - 59 | 43] = i++;
    var i;
    base64.encode = /* @__PURE__ */ __name(function encode2(buffer, start, end) {
      var parts2 = null, chunk = [];
      var i2 = 0, j = 0, t;
      while (start < end) {
        var b = buffer[start++];
        switch (j) {
          case 0:
            chunk[i2++] = b64[b >> 2];
            t = (b & 3) << 4;
            j = 1;
            break;
          case 1:
            chunk[i2++] = b64[t | b >> 4];
            t = (b & 15) << 2;
            j = 2;
            break;
          case 2:
            chunk[i2++] = b64[t | b >> 6];
            chunk[i2++] = b64[b & 63];
            j = 0;
            break;
        }
        if (i2 > 8191) {
          (parts2 || (parts2 = [])).push(String.fromCharCode.apply(String, chunk));
          i2 = 0;
        }
      }
      if (j) {
        chunk[i2++] = b64[t];
        chunk[i2++] = 61;
        if (j === 1) chunk[i2++] = 61;
      }
      if (parts2) {
        if (i2) parts2.push(String.fromCharCode.apply(String, chunk.slice(0, i2)));
        return parts2.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i2));
    }, "encode");
    var invalidEncoding = "invalid encoding";
    base64.decode = /* @__PURE__ */ __name(function decode2(string, buffer, offset) {
      var start = offset;
      var j = 0, t;
      for (var i2 = 0; i2 < string.length; ) {
        var c = string.charCodeAt(i2++);
        if (c === 61 && j > 1) break;
        if ((c = s64[c]) === void 0) throw Error(invalidEncoding);
        switch (j) {
          case 0:
            t = c;
            j = 1;
            break;
          case 1:
            buffer[offset++] = t << 2 | (c & 48) >> 4;
            t = c;
            j = 2;
            break;
          case 2:
            buffer[offset++] = (t & 15) << 4 | (c & 60) >> 2;
            t = c;
            j = 3;
            break;
          case 3:
            buffer[offset++] = (t & 3) << 6 | c;
            j = 0;
            break;
        }
      }
      if (j === 1) throw Error(invalidEncoding);
      return offset - start;
    }, "decode");
    base64.test = /* @__PURE__ */ __name(function test(string) {
      return /^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$/.test(string);
    }, "test");
  }
});

// node_modules/@protobufjs/eventemitter/index.js
var require_eventemitter = __commonJS({
  "node_modules/@protobufjs/eventemitter/index.js"(exports2, module2) {
    "use strict";
    module2.exports = EventEmitter;
    function EventEmitter() {
      this._listeners = {};
    }
    __name(EventEmitter, "EventEmitter");
    EventEmitter.prototype.on = /* @__PURE__ */ __name(function on2(evt, fn, ctx) {
      (this._listeners[evt] || (this._listeners[evt] = [])).push({
        fn,
        ctx: ctx || this
      });
      return this;
    }, "on");
    EventEmitter.prototype.off = /* @__PURE__ */ __name(function off(evt, fn) {
      if (evt === void 0) this._listeners = {};
      else {
        if (fn === void 0) this._listeners[evt] = [];
        else {
          var listeners = this._listeners[evt];
          for (var i = 0; i < listeners.length; ) if (listeners[i].fn === fn) listeners.splice(i, 1);
          else ++i;
        }
      }
      return this;
    }, "off");
    EventEmitter.prototype.emit = /* @__PURE__ */ __name(function emit(evt) {
      var listeners = this._listeners[evt];
      if (listeners) {
        var args = [], i = 1;
        for (; i < arguments.length; ) args.push(arguments[i++]);
        for (i = 0; i < listeners.length; ) listeners[i].fn.apply(listeners[i++].ctx, args);
      }
      return this;
    }, "emit");
  }
});

// node_modules/@protobufjs/float/index.js
var require_float = __commonJS({
  "node_modules/@protobufjs/float/index.js"(exports2, module2) {
    "use strict";
    module2.exports = factory(factory);
    function factory(exports3) {
      if (typeof Float32Array !== "undefined") (function() {
        var f32 = new Float32Array([
          -0
        ]), f8b = new Uint8Array(f32.buffer), le = f8b[3] === 128;
        function writeFloat_f32_cpy(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
        }
        __name(writeFloat_f32_cpy, "writeFloat_f32_cpy");
        function writeFloat_f32_rev(val, buf, pos) {
          f32[0] = val;
          buf[pos] = f8b[3];
          buf[pos + 1] = f8b[2];
          buf[pos + 2] = f8b[1];
          buf[pos + 3] = f8b[0];
        }
        __name(writeFloat_f32_rev, "writeFloat_f32_rev");
        exports3.writeFloatLE = le ? writeFloat_f32_cpy : writeFloat_f32_rev;
        exports3.writeFloatBE = le ? writeFloat_f32_rev : writeFloat_f32_cpy;
        function readFloat_f32_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          return f32[0];
        }
        __name(readFloat_f32_cpy, "readFloat_f32_cpy");
        function readFloat_f32_rev(buf, pos) {
          f8b[3] = buf[pos];
          f8b[2] = buf[pos + 1];
          f8b[1] = buf[pos + 2];
          f8b[0] = buf[pos + 3];
          return f32[0];
        }
        __name(readFloat_f32_rev, "readFloat_f32_rev");
        exports3.readFloatLE = le ? readFloat_f32_cpy : readFloat_f32_rev;
        exports3.readFloatBE = le ? readFloat_f32_rev : readFloat_f32_cpy;
      })();
      else (function() {
        function writeFloat_ieee754(writeUint, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign) val = -val;
          if (val === 0) writeUint(1 / val > 0 ? (
            /* positive */
            0
          ) : (
            /* negative 0 */
            2147483648
          ), buf, pos);
          else if (isNaN(val)) writeUint(2143289344, buf, pos);
          else if (val > 34028234663852886e22) writeUint((sign << 31 | 2139095040) >>> 0, buf, pos);
          else if (val < 11754943508222875e-54) writeUint((sign << 31 | Math.round(val / 1401298464324817e-60)) >>> 0, buf, pos);
          else {
            var exponent = Math.floor(Math.log(val) / Math.LN2), mantissa = Math.round(val * Math.pow(2, -exponent) * 8388608) & 8388607;
            writeUint((sign << 31 | exponent + 127 << 23 | mantissa) >>> 0, buf, pos);
          }
        }
        __name(writeFloat_ieee754, "writeFloat_ieee754");
        exports3.writeFloatLE = writeFloat_ieee754.bind(null, writeUintLE);
        exports3.writeFloatBE = writeFloat_ieee754.bind(null, writeUintBE);
        function readFloat_ieee754(readUint, buf, pos) {
          var uint = readUint(buf, pos), sign = (uint >> 31) * 2 + 1, exponent = uint >>> 23 & 255, mantissa = uint & 8388607;
          return exponent === 255 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 1401298464324817e-60 * mantissa : sign * Math.pow(2, exponent - 150) * (mantissa + 8388608);
        }
        __name(readFloat_ieee754, "readFloat_ieee754");
        exports3.readFloatLE = readFloat_ieee754.bind(null, readUintLE);
        exports3.readFloatBE = readFloat_ieee754.bind(null, readUintBE);
      })();
      if (typeof Float64Array !== "undefined") (function() {
        var f64 = new Float64Array([
          -0
        ]), f8b = new Uint8Array(f64.buffer), le = f8b[7] === 128;
        function writeDouble_f64_cpy(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[0];
          buf[pos + 1] = f8b[1];
          buf[pos + 2] = f8b[2];
          buf[pos + 3] = f8b[3];
          buf[pos + 4] = f8b[4];
          buf[pos + 5] = f8b[5];
          buf[pos + 6] = f8b[6];
          buf[pos + 7] = f8b[7];
        }
        __name(writeDouble_f64_cpy, "writeDouble_f64_cpy");
        function writeDouble_f64_rev(val, buf, pos) {
          f64[0] = val;
          buf[pos] = f8b[7];
          buf[pos + 1] = f8b[6];
          buf[pos + 2] = f8b[5];
          buf[pos + 3] = f8b[4];
          buf[pos + 4] = f8b[3];
          buf[pos + 5] = f8b[2];
          buf[pos + 6] = f8b[1];
          buf[pos + 7] = f8b[0];
        }
        __name(writeDouble_f64_rev, "writeDouble_f64_rev");
        exports3.writeDoubleLE = le ? writeDouble_f64_cpy : writeDouble_f64_rev;
        exports3.writeDoubleBE = le ? writeDouble_f64_rev : writeDouble_f64_cpy;
        function readDouble_f64_cpy(buf, pos) {
          f8b[0] = buf[pos];
          f8b[1] = buf[pos + 1];
          f8b[2] = buf[pos + 2];
          f8b[3] = buf[pos + 3];
          f8b[4] = buf[pos + 4];
          f8b[5] = buf[pos + 5];
          f8b[6] = buf[pos + 6];
          f8b[7] = buf[pos + 7];
          return f64[0];
        }
        __name(readDouble_f64_cpy, "readDouble_f64_cpy");
        function readDouble_f64_rev(buf, pos) {
          f8b[7] = buf[pos];
          f8b[6] = buf[pos + 1];
          f8b[5] = buf[pos + 2];
          f8b[4] = buf[pos + 3];
          f8b[3] = buf[pos + 4];
          f8b[2] = buf[pos + 5];
          f8b[1] = buf[pos + 6];
          f8b[0] = buf[pos + 7];
          return f64[0];
        }
        __name(readDouble_f64_rev, "readDouble_f64_rev");
        exports3.readDoubleLE = le ? readDouble_f64_cpy : readDouble_f64_rev;
        exports3.readDoubleBE = le ? readDouble_f64_rev : readDouble_f64_cpy;
      })();
      else (function() {
        function writeDouble_ieee754(writeUint, off0, off1, val, buf, pos) {
          var sign = val < 0 ? 1 : 0;
          if (sign) val = -val;
          if (val === 0) {
            writeUint(0, buf, pos + off0);
            writeUint(1 / val > 0 ? (
              /* positive */
              0
            ) : (
              /* negative 0 */
              2147483648
            ), buf, pos + off1);
          } else if (isNaN(val)) {
            writeUint(0, buf, pos + off0);
            writeUint(2146959360, buf, pos + off1);
          } else if (val > 17976931348623157e292) {
            writeUint(0, buf, pos + off0);
            writeUint((sign << 31 | 2146435072) >>> 0, buf, pos + off1);
          } else {
            var mantissa;
            if (val < 22250738585072014e-324) {
              mantissa = val / 5e-324;
              writeUint(mantissa >>> 0, buf, pos + off0);
              writeUint((sign << 31 | mantissa / 4294967296) >>> 0, buf, pos + off1);
            } else {
              var exponent = Math.floor(Math.log(val) / Math.LN2);
              if (exponent === 1024) exponent = 1023;
              mantissa = val * Math.pow(2, -exponent);
              writeUint(mantissa * 4503599627370496 >>> 0, buf, pos + off0);
              writeUint((sign << 31 | exponent + 1023 << 20 | mantissa * 1048576 & 1048575) >>> 0, buf, pos + off1);
            }
          }
        }
        __name(writeDouble_ieee754, "writeDouble_ieee754");
        exports3.writeDoubleLE = writeDouble_ieee754.bind(null, writeUintLE, 0, 4);
        exports3.writeDoubleBE = writeDouble_ieee754.bind(null, writeUintBE, 4, 0);
        function readDouble_ieee754(readUint, off0, off1, buf, pos) {
          var lo = readUint(buf, pos + off0), hi = readUint(buf, pos + off1);
          var sign = (hi >> 31) * 2 + 1, exponent = hi >>> 20 & 2047, mantissa = 4294967296 * (hi & 1048575) + lo;
          return exponent === 2047 ? mantissa ? NaN : sign * Infinity : exponent === 0 ? sign * 5e-324 * mantissa : sign * Math.pow(2, exponent - 1075) * (mantissa + 4503599627370496);
        }
        __name(readDouble_ieee754, "readDouble_ieee754");
        exports3.readDoubleLE = readDouble_ieee754.bind(null, readUintLE, 0, 4);
        exports3.readDoubleBE = readDouble_ieee754.bind(null, readUintBE, 4, 0);
      })();
      return exports3;
    }
    __name(factory, "factory");
    function writeUintLE(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeUintLE, "writeUintLE");
    function writeUintBE(val, buf, pos) {
      buf[pos] = val >>> 24;
      buf[pos + 1] = val >>> 16 & 255;
      buf[pos + 2] = val >>> 8 & 255;
      buf[pos + 3] = val & 255;
    }
    __name(writeUintBE, "writeUintBE");
    function readUintLE(buf, pos) {
      return (buf[pos] | buf[pos + 1] << 8 | buf[pos + 2] << 16 | buf[pos + 3] << 24) >>> 0;
    }
    __name(readUintLE, "readUintLE");
    function readUintBE(buf, pos) {
      return (buf[pos] << 24 | buf[pos + 1] << 16 | buf[pos + 2] << 8 | buf[pos + 3]) >>> 0;
    }
    __name(readUintBE, "readUintBE");
  }
});

// node_modules/@protobufjs/inquire/index.js
var require_inquire = __commonJS({
  "node_modules/@protobufjs/inquire/index.js"(exports, module) {
    "use strict";
    module.exports = inquire;
    function inquire(moduleName) {
      try {
        var mod = eval("quire".replace(/^/, "re"))(moduleName);
        if (mod && (mod.length || Object.keys(mod).length)) return mod;
      } catch (e) {
      }
      return null;
    }
    __name(inquire, "inquire");
  }
});

// node_modules/@protobufjs/utf8/index.js
var require_utf8 = __commonJS({
  "node_modules/@protobufjs/utf8/index.js"(exports2) {
    "use strict";
    var utf8 = exports2;
    utf8.length = /* @__PURE__ */ __name(function utf8_length(string) {
      var len = 0, c = 0;
      for (var i = 0; i < string.length; ++i) {
        c = string.charCodeAt(i);
        if (c < 128) len += 1;
        else if (c < 2048) len += 2;
        else if ((c & 64512) === 55296 && (string.charCodeAt(i + 1) & 64512) === 56320) {
          ++i;
          len += 4;
        } else len += 3;
      }
      return len;
    }, "utf8_length");
    utf8.read = /* @__PURE__ */ __name(function utf8_read(buffer, start, end) {
      var len = end - start;
      if (len < 1) return "";
      var parts2 = null, chunk = [], i = 0, t;
      while (start < end) {
        t = buffer[start++];
        if (t < 128) chunk[i++] = t;
        else if (t > 191 && t < 224) chunk[i++] = (t & 31) << 6 | buffer[start++] & 63;
        else if (t > 239 && t < 365) {
          t = ((t & 7) << 18 | (buffer[start++] & 63) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63) - 65536;
          chunk[i++] = 55296 + (t >> 10);
          chunk[i++] = 56320 + (t & 1023);
        } else chunk[i++] = (t & 15) << 12 | (buffer[start++] & 63) << 6 | buffer[start++] & 63;
        if (i > 8191) {
          (parts2 || (parts2 = [])).push(String.fromCharCode.apply(String, chunk));
          i = 0;
        }
      }
      if (parts2) {
        if (i) parts2.push(String.fromCharCode.apply(String, chunk.slice(0, i)));
        return parts2.join("");
      }
      return String.fromCharCode.apply(String, chunk.slice(0, i));
    }, "utf8_read");
    utf8.write = /* @__PURE__ */ __name(function utf8_write(string, buffer, offset) {
      var start = offset, c1, c2;
      for (var i = 0; i < string.length; ++i) {
        c1 = string.charCodeAt(i);
        if (c1 < 128) {
          buffer[offset++] = c1;
        } else if (c1 < 2048) {
          buffer[offset++] = c1 >> 6 | 192;
          buffer[offset++] = c1 & 63 | 128;
        } else if ((c1 & 64512) === 55296 && ((c2 = string.charCodeAt(i + 1)) & 64512) === 56320) {
          c1 = 65536 + ((c1 & 1023) << 10) + (c2 & 1023);
          ++i;
          buffer[offset++] = c1 >> 18 | 240;
          buffer[offset++] = c1 >> 12 & 63 | 128;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        } else {
          buffer[offset++] = c1 >> 12 | 224;
          buffer[offset++] = c1 >> 6 & 63 | 128;
          buffer[offset++] = c1 & 63 | 128;
        }
      }
      return offset - start;
    }, "utf8_write");
  }
});

// node_modules/@protobufjs/pool/index.js
var require_pool = __commonJS({
  "node_modules/@protobufjs/pool/index.js"(exports2, module2) {
    "use strict";
    module2.exports = pool;
    function pool(alloc, slice, size) {
      var SIZE = size || 8192;
      var MAX = SIZE >>> 1;
      var slab = null;
      var offset = SIZE;
      return /* @__PURE__ */ __name(function pool_alloc(size2) {
        if (size2 < 1 || size2 > MAX) return alloc(size2);
        if (offset + size2 > SIZE) {
          slab = alloc(SIZE);
          offset = 0;
        }
        var buf = slice.call(slab, offset, offset += size2);
        if (offset & 7) offset = (offset | 7) + 1;
        return buf;
      }, "pool_alloc");
    }
    __name(pool, "pool");
  }
});

// node_modules/protobufjs/src/util/longbits.js
var require_longbits = __commonJS({
  "node_modules/protobufjs/src/util/longbits.js"(exports2, module2) {
    "use strict";
    module2.exports = LongBits;
    var util2 = require_minimal();
    function LongBits(lo, hi) {
      this.lo = lo >>> 0;
      this.hi = hi >>> 0;
    }
    __name(LongBits, "LongBits");
    var zero = LongBits.zero = new LongBits(0, 0);
    zero.toNumber = function() {
      return 0;
    };
    zero.zzEncode = zero.zzDecode = function() {
      return this;
    };
    zero.length = function() {
      return 1;
    };
    var zeroHash = LongBits.zeroHash = "\0\0\0\0\0\0\0\0";
    LongBits.fromNumber = /* @__PURE__ */ __name(function fromNumber(value2) {
      if (value2 === 0) return zero;
      var sign = value2 < 0;
      if (sign) value2 = -value2;
      var lo = value2 >>> 0, hi = (value2 - lo) / 4294967296 >>> 0;
      if (sign) {
        hi = ~hi >>> 0;
        lo = ~lo >>> 0;
        if (++lo > 4294967295) {
          lo = 0;
          if (++hi > 4294967295) hi = 0;
        }
      }
      return new LongBits(lo, hi);
    }, "fromNumber");
    LongBits.from = /* @__PURE__ */ __name(function from(value2) {
      if (typeof value2 === "number") return LongBits.fromNumber(value2);
      if (util2.isString(value2)) {
        if (util2.Long) value2 = util2.Long.fromString(value2);
        else return LongBits.fromNumber(parseInt(value2, 10));
      }
      return value2.low || value2.high ? new LongBits(value2.low >>> 0, value2.high >>> 0) : zero;
    }, "from");
    LongBits.prototype.toNumber = /* @__PURE__ */ __name(function toNumber(unsigned) {
      if (!unsigned && this.hi >>> 31) {
        var lo = ~this.lo + 1 >>> 0, hi = ~this.hi >>> 0;
        if (!lo) hi = hi + 1 >>> 0;
        return -(lo + hi * 4294967296);
      }
      return this.lo + this.hi * 4294967296;
    }, "toNumber");
    LongBits.prototype.toLong = /* @__PURE__ */ __name(function toLong(unsigned) {
      return util2.Long ? new util2.Long(this.lo | 0, this.hi | 0, Boolean(unsigned)) : {
        low: this.lo | 0,
        high: this.hi | 0,
        unsigned: Boolean(unsigned)
      };
    }, "toLong");
    var charCodeAt = String.prototype.charCodeAt;
    LongBits.fromHash = /* @__PURE__ */ __name(function fromHash(hash) {
      if (hash === zeroHash) return zero;
      return new LongBits((charCodeAt.call(hash, 0) | charCodeAt.call(hash, 1) << 8 | charCodeAt.call(hash, 2) << 16 | charCodeAt.call(hash, 3) << 24) >>> 0, (charCodeAt.call(hash, 4) | charCodeAt.call(hash, 5) << 8 | charCodeAt.call(hash, 6) << 16 | charCodeAt.call(hash, 7) << 24) >>> 0);
    }, "fromHash");
    LongBits.prototype.toHash = /* @__PURE__ */ __name(function toHash() {
      return String.fromCharCode(this.lo & 255, this.lo >>> 8 & 255, this.lo >>> 16 & 255, this.lo >>> 24, this.hi & 255, this.hi >>> 8 & 255, this.hi >>> 16 & 255, this.hi >>> 24);
    }, "toHash");
    LongBits.prototype.zzEncode = /* @__PURE__ */ __name(function zzEncode() {
      var mask = this.hi >> 31;
      this.hi = ((this.hi << 1 | this.lo >>> 31) ^ mask) >>> 0;
      this.lo = (this.lo << 1 ^ mask) >>> 0;
      return this;
    }, "zzEncode");
    LongBits.prototype.zzDecode = /* @__PURE__ */ __name(function zzDecode() {
      var mask = -(this.lo & 1);
      this.lo = ((this.lo >>> 1 | this.hi << 31) ^ mask) >>> 0;
      this.hi = (this.hi >>> 1 ^ mask) >>> 0;
      return this;
    }, "zzDecode");
    LongBits.prototype.length = /* @__PURE__ */ __name(function length() {
      var part0 = this.lo, part1 = (this.lo >>> 28 | this.hi << 4) >>> 0, part2 = this.hi >>> 24;
      return part2 === 0 ? part1 === 0 ? part0 < 16384 ? part0 < 128 ? 1 : 2 : part0 < 2097152 ? 3 : 4 : part1 < 16384 ? part1 < 128 ? 5 : 6 : part1 < 2097152 ? 7 : 8 : part2 < 128 ? 9 : 10;
    }, "length");
  }
});

// node_modules/protobufjs/src/util/minimal.js
var require_minimal = __commonJS({
  "node_modules/protobufjs/src/util/minimal.js"(exports2) {
    "use strict";
    var util2 = exports2;
    util2.asPromise = require_aspromise();
    util2.base64 = require_base64();
    util2.EventEmitter = require_eventemitter();
    util2.float = require_float();
    util2.inquire = require_inquire();
    util2.utf8 = require_utf8();
    util2.pool = require_pool();
    util2.LongBits = require_longbits();
    util2.isNode = Boolean(typeof global !== "undefined" && global && global.process && global.process.versions && global.process.versions.node);
    util2.global = util2.isNode && global || typeof window !== "undefined" && window || typeof self !== "undefined" && self || exports2;
    util2.emptyArray = Object.freeze ? Object.freeze([]) : (
      /* istanbul ignore next */
      []
    );
    util2.emptyObject = Object.freeze ? Object.freeze({}) : (
      /* istanbul ignore next */
      {}
    );
    util2.isInteger = Number.isInteger || /* istanbul ignore next */
    /* @__PURE__ */ __name(function isInteger(value2) {
      return typeof value2 === "number" && isFinite(value2) && Math.floor(value2) === value2;
    }, "isInteger");
    util2.isString = /* @__PURE__ */ __name(function isString(value2) {
      return typeof value2 === "string" || value2 instanceof String;
    }, "isString");
    util2.isObject = /* @__PURE__ */ __name(function isObject2(value2) {
      return value2 && typeof value2 === "object";
    }, "isObject");
    util2.isset = /**
    * Checks if a property on a message is considered to be present.
    * @param {Object} obj Plain object or message instance
    * @param {string} prop Property name
    * @returns {boolean} `true` if considered to be present, otherwise `false`
    */
    util2.isSet = /* @__PURE__ */ __name(function isSet(obj, prop) {
      var value2 = obj[prop];
      if (value2 != null && obj.hasOwnProperty(prop)) return typeof value2 !== "object" || (Array.isArray(value2) ? value2.length : Object.keys(value2).length) > 0;
      return false;
    }, "isSet");
    util2.Buffer = function() {
      try {
        var Buffer2 = util2.inquire("buffer").Buffer;
        return Buffer2.prototype.utf8Write ? Buffer2 : (
          /* istanbul ignore next */
          null
        );
      } catch (e) {
        return null;
      }
    }();
    util2._Buffer_from = null;
    util2._Buffer_allocUnsafe = null;
    util2.newBuffer = /* @__PURE__ */ __name(function newBuffer(sizeOrArray) {
      return typeof sizeOrArray === "number" ? util2.Buffer ? util2._Buffer_allocUnsafe(sizeOrArray) : new util2.Array(sizeOrArray) : util2.Buffer ? util2._Buffer_from(sizeOrArray) : typeof Uint8Array === "undefined" ? sizeOrArray : new Uint8Array(sizeOrArray);
    }, "newBuffer");
    util2.Array = typeof Uint8Array !== "undefined" ? Uint8Array : Array;
    util2.Long = /* istanbul ignore next */
    util2.global.dcodeIO && /* istanbul ignore next */
    util2.global.dcodeIO.Long || /* istanbul ignore next */
    util2.global.Long || util2.inquire("long");
    util2.key2Re = /^true|false|0|1$/;
    util2.key32Re = /^-?(?:0|[1-9][0-9]*)$/;
    util2.key64Re = /^(?:[\\x00-\\xff]{8}|-?(?:0|[1-9][0-9]*))$/;
    util2.longToHash = /* @__PURE__ */ __name(function longToHash(value2) {
      return value2 ? util2.LongBits.from(value2).toHash() : util2.LongBits.zeroHash;
    }, "longToHash");
    util2.longFromHash = /* @__PURE__ */ __name(function longFromHash(hash, unsigned) {
      var bits = util2.LongBits.fromHash(hash);
      if (util2.Long) return util2.Long.fromBits(bits.lo, bits.hi, unsigned);
      return bits.toNumber(Boolean(unsigned));
    }, "longFromHash");
    function merge(dst, src, ifNotSet) {
      for (var keys = Object.keys(src), i = 0; i < keys.length; ++i) if (dst[keys[i]] === void 0 || !ifNotSet) dst[keys[i]] = src[keys[i]];
      return dst;
    }
    __name(merge, "merge");
    util2.merge = merge;
    util2.lcFirst = /* @__PURE__ */ __name(function lcFirst(str) {
      return str.charAt(0).toLowerCase() + str.substring(1);
    }, "lcFirst");
    function newError(name) {
      function CustomError(message, properties) {
        if (!(this instanceof CustomError)) return new CustomError(message, properties);
        Object.defineProperty(this, "message", {
          get: /* @__PURE__ */ __name(function() {
            return message;
          }, "get")
        });
        if (Error.captureStackTrace) Error.captureStackTrace(this, CustomError);
        else Object.defineProperty(this, "stack", {
          value: new Error().stack || ""
        });
        if (properties) merge(this, properties);
      }
      __name(CustomError, "CustomError");
      CustomError.prototype = Object.create(Error.prototype, {
        constructor: {
          value: CustomError,
          writable: true,
          enumerable: false,
          configurable: true
        },
        name: {
          get: /* @__PURE__ */ __name(function get() {
            return name;
          }, "get"),
          set: void 0,
          enumerable: false,
          // configurable: false would accurately preserve the behavior of
          // the original, but I'm guessing that was not intentional.
          // For an actual error subclass, this property would
          // be configurable.
          configurable: true
        },
        toString: {
          value: /* @__PURE__ */ __name(function value2() {
            return this.name + ": " + this.message;
          }, "value"),
          writable: true,
          enumerable: false,
          configurable: true
        }
      });
      return CustomError;
    }
    __name(newError, "newError");
    util2.newError = newError;
    util2.ProtocolError = newError("ProtocolError");
    util2.oneOfGetter = /* @__PURE__ */ __name(function getOneOf(fieldNames) {
      var fieldMap = {};
      for (var i = 0; i < fieldNames.length; ++i) fieldMap[fieldNames[i]] = 1;
      return function() {
        for (var keys = Object.keys(this), i2 = keys.length - 1; i2 > -1; --i2) if (fieldMap[keys[i2]] === 1 && this[keys[i2]] !== void 0 && this[keys[i2]] !== null) return keys[i2];
      };
    }, "getOneOf");
    util2.oneOfSetter = /* @__PURE__ */ __name(function setOneOf(fieldNames) {
      return function(name) {
        for (var i = 0; i < fieldNames.length; ++i) if (fieldNames[i] !== name) delete this[fieldNames[i]];
      };
    }, "setOneOf");
    util2.toJSONOptions = {
      longs: String,
      enums: String,
      bytes: String,
      json: true
    };
    util2._configure = function() {
      var Buffer2 = util2.Buffer;
      if (!Buffer2) {
        util2._Buffer_from = util2._Buffer_allocUnsafe = null;
        return;
      }
      util2._Buffer_from = Buffer2.from !== Uint8Array.from && Buffer2.from || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_from(value2, encoding) {
        return new Buffer2(value2, encoding);
      }, "Buffer_from");
      util2._Buffer_allocUnsafe = Buffer2.allocUnsafe || /* istanbul ignore next */
      /* @__PURE__ */ __name(function Buffer_allocUnsafe(size) {
        return new Buffer2(size);
      }, "Buffer_allocUnsafe");
    };
  }
});

// node_modules/protobufjs/src/writer.js
var require_writer2 = __commonJS({
  "node_modules/protobufjs/src/writer.js"(exports2, module2) {
    "use strict";
    module2.exports = Writer;
    var util2 = require_minimal();
    var BufferWriter;
    var LongBits = util2.LongBits;
    var base64 = util2.base64;
    var utf8 = util2.utf8;
    function Op(fn, len, val) {
      this.fn = fn;
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(Op, "Op");
    function noop() {
    }
    __name(noop, "noop");
    function State(writer) {
      this.head = writer.head;
      this.tail = writer.tail;
      this.len = writer.len;
      this.next = writer.states;
    }
    __name(State, "State");
    function Writer() {
      this.len = 0;
      this.head = new Op(noop, 0, 0);
      this.tail = this.head;
      this.states = null;
    }
    __name(Writer, "Writer");
    var create = /* @__PURE__ */ __name(function create2() {
      return util2.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup() {
        return (Writer.create = /* @__PURE__ */ __name(function create_buffer() {
          return new BufferWriter();
        }, "create_buffer"))();
      }, "create_buffer_setup") : /* @__PURE__ */ __name(function create_array() {
        return new Writer();
      }, "create_array");
    }, "create");
    Writer.create = create();
    Writer.alloc = /* @__PURE__ */ __name(function alloc(size) {
      return new util2.Array(size);
    }, "alloc");
    if (util2.Array !== Array) Writer.alloc = util2.pool(Writer.alloc, util2.Array.prototype.subarray);
    Writer.prototype._push = /* @__PURE__ */ __name(function push(fn, len, val) {
      this.tail = this.tail.next = new Op(fn, len, val);
      this.len += len;
      return this;
    }, "push");
    function writeByte(val, buf, pos) {
      buf[pos] = val & 255;
    }
    __name(writeByte, "writeByte");
    function writeVarint32(val, buf, pos) {
      while (val > 127) {
        buf[pos++] = val & 127 | 128;
        val >>>= 7;
      }
      buf[pos] = val;
    }
    __name(writeVarint32, "writeVarint32");
    function VarintOp(len, val) {
      this.len = len;
      this.next = void 0;
      this.val = val;
    }
    __name(VarintOp, "VarintOp");
    VarintOp.prototype = Object.create(Op.prototype);
    VarintOp.prototype.fn = writeVarint32;
    Writer.prototype.uint32 = /* @__PURE__ */ __name(function write_uint32(value2) {
      this.len += (this.tail = this.tail.next = new VarintOp((value2 = value2 >>> 0) < 128 ? 1 : value2 < 16384 ? 2 : value2 < 2097152 ? 3 : value2 < 268435456 ? 4 : 5, value2)).len;
      return this;
    }, "write_uint32");
    Writer.prototype.int32 = /* @__PURE__ */ __name(function write_int32(value2) {
      return value2 < 0 ? this._push(writeVarint64, 10, LongBits.fromNumber(value2)) : this.uint32(value2);
    }, "write_int32");
    Writer.prototype.sint32 = /* @__PURE__ */ __name(function write_sint32(value2) {
      return this.uint32((value2 << 1 ^ value2 >> 31) >>> 0);
    }, "write_sint32");
    function writeVarint64(val, buf, pos) {
      while (val.hi) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = (val.lo >>> 7 | val.hi << 25) >>> 0;
        val.hi >>>= 7;
      }
      while (val.lo > 127) {
        buf[pos++] = val.lo & 127 | 128;
        val.lo = val.lo >>> 7;
      }
      buf[pos++] = val.lo;
    }
    __name(writeVarint64, "writeVarint64");
    Writer.prototype.uint64 = /* @__PURE__ */ __name(function write_uint64(value2) {
      var bits = LongBits.from(value2);
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_uint64");
    Writer.prototype.int64 = Writer.prototype.uint64;
    Writer.prototype.sint64 = /* @__PURE__ */ __name(function write_sint64(value2) {
      var bits = LongBits.from(value2).zzEncode();
      return this._push(writeVarint64, bits.length(), bits);
    }, "write_sint64");
    Writer.prototype.bool = /* @__PURE__ */ __name(function write_bool(value2) {
      return this._push(writeByte, 1, value2 ? 1 : 0);
    }, "write_bool");
    function writeFixed32(val, buf, pos) {
      buf[pos] = val & 255;
      buf[pos + 1] = val >>> 8 & 255;
      buf[pos + 2] = val >>> 16 & 255;
      buf[pos + 3] = val >>> 24;
    }
    __name(writeFixed32, "writeFixed32");
    Writer.prototype.fixed32 = /* @__PURE__ */ __name(function write_fixed32(value2) {
      return this._push(writeFixed32, 4, value2 >>> 0);
    }, "write_fixed32");
    Writer.prototype.sfixed32 = Writer.prototype.fixed32;
    Writer.prototype.fixed64 = /* @__PURE__ */ __name(function write_fixed64(value2) {
      var bits = LongBits.from(value2);
      return this._push(writeFixed32, 4, bits.lo)._push(writeFixed32, 4, bits.hi);
    }, "write_fixed64");
    Writer.prototype.sfixed64 = Writer.prototype.fixed64;
    Writer.prototype.float = /* @__PURE__ */ __name(function write_float(value2) {
      return this._push(util2.float.writeFloatLE, 4, value2);
    }, "write_float");
    Writer.prototype.double = /* @__PURE__ */ __name(function write_double(value2) {
      return this._push(util2.float.writeDoubleLE, 8, value2);
    }, "write_double");
    var writeBytes = util2.Array.prototype.set ? /* @__PURE__ */ __name(function writeBytes_set(val, buf, pos) {
      buf.set(val, pos);
    }, "writeBytes_set") : /* @__PURE__ */ __name(function writeBytes_for(val, buf, pos) {
      for (var i = 0; i < val.length; ++i) buf[pos + i] = val[i];
    }, "writeBytes_for");
    Writer.prototype.bytes = /* @__PURE__ */ __name(function write_bytes(value2) {
      var len = value2.length >>> 0;
      if (!len) return this._push(writeByte, 1, 0);
      if (util2.isString(value2)) {
        var buf = Writer.alloc(len = base64.length(value2));
        base64.decode(value2, buf, 0);
        value2 = buf;
      }
      return this.uint32(len)._push(writeBytes, len, value2);
    }, "write_bytes");
    Writer.prototype.string = /* @__PURE__ */ __name(function write_string(value2) {
      var len = utf8.length(value2);
      return len ? this.uint32(len)._push(utf8.write, len, value2) : this._push(writeByte, 1, 0);
    }, "write_string");
    Writer.prototype.fork = /* @__PURE__ */ __name(function fork() {
      this.states = new State(this);
      this.head = this.tail = new Op(noop, 0, 0);
      this.len = 0;
      return this;
    }, "fork");
    Writer.prototype.reset = /* @__PURE__ */ __name(function reset() {
      if (this.states) {
        this.head = this.states.head;
        this.tail = this.states.tail;
        this.len = this.states.len;
        this.states = this.states.next;
      } else {
        this.head = this.tail = new Op(noop, 0, 0);
        this.len = 0;
      }
      return this;
    }, "reset");
    Writer.prototype.ldelim = /* @__PURE__ */ __name(function ldelim() {
      var head = this.head, tail = this.tail, len = this.len;
      this.reset().uint32(len);
      if (len) {
        this.tail.next = head.next;
        this.tail = tail;
        this.len += len;
      }
      return this;
    }, "ldelim");
    Writer.prototype.finish = /* @__PURE__ */ __name(function finish() {
      var head = this.head.next, buf = this.constructor.alloc(this.len), pos = 0;
      while (head) {
        head.fn(head.val, buf, pos);
        pos += head.len;
        head = head.next;
      }
      return buf;
    }, "finish");
    Writer._configure = function(BufferWriter_) {
      BufferWriter = BufferWriter_;
      Writer.create = create();
      BufferWriter._configure();
    };
  }
});

// node_modules/protobufjs/src/writer_buffer.js
var require_writer_buffer = __commonJS({
  "node_modules/protobufjs/src/writer_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferWriter;
    var Writer = require_writer2();
    (BufferWriter.prototype = Object.create(Writer.prototype)).constructor = BufferWriter;
    var util2 = require_minimal();
    function BufferWriter() {
      Writer.call(this);
    }
    __name(BufferWriter, "BufferWriter");
    BufferWriter._configure = function() {
      BufferWriter.alloc = util2._Buffer_allocUnsafe;
      BufferWriter.writeBytesBuffer = util2.Buffer && util2.Buffer.prototype instanceof Uint8Array && util2.Buffer.prototype.set.name === "set" ? /* @__PURE__ */ __name(function writeBytesBuffer_set(val, buf, pos) {
        buf.set(val, pos);
      }, "writeBytesBuffer_set") : /* @__PURE__ */ __name(function writeBytesBuffer_copy(val, buf, pos) {
        if (val.copy) val.copy(buf, pos, 0, val.length);
        else for (var i = 0; i < val.length; ) buf[pos++] = val[i++];
      }, "writeBytesBuffer_copy");
    };
    BufferWriter.prototype.bytes = /* @__PURE__ */ __name(function write_bytes_buffer(value2) {
      if (util2.isString(value2)) value2 = util2._Buffer_from(value2, "base64");
      var len = value2.length >>> 0;
      this.uint32(len);
      if (len) this._push(BufferWriter.writeBytesBuffer, len, value2);
      return this;
    }, "write_bytes_buffer");
    function writeStringBuffer(val, buf, pos) {
      if (val.length < 40) util2.utf8.write(val, buf, pos);
      else if (buf.utf8Write) buf.utf8Write(val, pos);
      else buf.write(val, pos);
    }
    __name(writeStringBuffer, "writeStringBuffer");
    BufferWriter.prototype.string = /* @__PURE__ */ __name(function write_string_buffer(value2) {
      var len = util2.Buffer.byteLength(value2);
      this.uint32(len);
      if (len) this._push(writeStringBuffer, len, value2);
      return this;
    }, "write_string_buffer");
    BufferWriter._configure();
  }
});

// node_modules/protobufjs/src/reader.js
var require_reader2 = __commonJS({
  "node_modules/protobufjs/src/reader.js"(exports2, module2) {
    "use strict";
    module2.exports = Reader;
    var util2 = require_minimal();
    var BufferReader;
    var LongBits = util2.LongBits;
    var utf8 = util2.utf8;
    function indexOutOfRange(reader, writeLength) {
      return RangeError("index out of range: " + reader.pos + " + " + (writeLength || 1) + " > " + reader.len);
    }
    __name(indexOutOfRange, "indexOutOfRange");
    function Reader(buffer) {
      this.buf = buffer;
      this.pos = 0;
      this.len = buffer.length;
    }
    __name(Reader, "Reader");
    var create_array = typeof Uint8Array !== "undefined" ? /* @__PURE__ */ __name(function create_typed_array(buffer) {
      if (buffer instanceof Uint8Array || Array.isArray(buffer)) return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_typed_array") : /* @__PURE__ */ __name(function create_array2(buffer) {
      if (Array.isArray(buffer)) return new Reader(buffer);
      throw Error("illegal buffer");
    }, "create_array");
    var create = /* @__PURE__ */ __name(function create2() {
      return util2.Buffer ? /* @__PURE__ */ __name(function create_buffer_setup(buffer) {
        return (Reader.create = /* @__PURE__ */ __name(function create_buffer(buffer2) {
          return util2.Buffer.isBuffer(buffer2) ? new BufferReader(buffer2) : create_array(buffer2);
        }, "create_buffer"))(buffer);
      }, "create_buffer_setup") : create_array;
    }, "create");
    Reader.create = create();
    Reader.prototype._slice = util2.Array.prototype.subarray || /* istanbul ignore next */
    util2.Array.prototype.slice;
    Reader.prototype.uint32 = (/* @__PURE__ */ __name(function read_uint32_setup() {
      var value2 = 4294967295;
      return /* @__PURE__ */ __name(function read_uint32() {
        value2 = (this.buf[this.pos] & 127) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 7) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 14) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        value2 = (value2 | (this.buf[this.pos] & 127) << 21) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        value2 = (value2 | (this.buf[this.pos] & 15) << 28) >>> 0;
        if (this.buf[this.pos++] < 128) return value2;
        if ((this.pos += 5) > this.len) {
          this.pos = this.len;
          throw indexOutOfRange(this, 10);
        }
        return value2;
      }, "read_uint32");
    }, "read_uint32_setup"))();
    Reader.prototype.int32 = /* @__PURE__ */ __name(function read_int32() {
      return this.uint32() | 0;
    }, "read_int32");
    Reader.prototype.sint32 = /* @__PURE__ */ __name(function read_sint32() {
      var value2 = this.uint32();
      return value2 >>> 1 ^ -(value2 & 1) | 0;
    }, "read_sint32");
    function readLongVarint() {
      var bits = new LongBits(0, 0);
      var i = 0;
      if (this.len - this.pos > 4) {
        for (; i < 4; ++i) {
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128) return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos] & 127) << 28) >>> 0;
        bits.hi = (bits.hi | (this.buf[this.pos] & 127) >> 4) >>> 0;
        if (this.buf[this.pos++] < 128) return bits;
        i = 0;
      } else {
        for (; i < 3; ++i) {
          if (this.pos >= this.len) throw indexOutOfRange(this);
          bits.lo = (bits.lo | (this.buf[this.pos] & 127) << i * 7) >>> 0;
          if (this.buf[this.pos++] < 128) return bits;
        }
        bits.lo = (bits.lo | (this.buf[this.pos++] & 127) << i * 7) >>> 0;
        return bits;
      }
      if (this.len - this.pos > 4) {
        for (; i < 5; ++i) {
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) return bits;
        }
      } else {
        for (; i < 5; ++i) {
          if (this.pos >= this.len) throw indexOutOfRange(this);
          bits.hi = (bits.hi | (this.buf[this.pos] & 127) << i * 7 + 3) >>> 0;
          if (this.buf[this.pos++] < 128) return bits;
        }
      }
      throw Error("invalid varint encoding");
    }
    __name(readLongVarint, "readLongVarint");
    Reader.prototype.bool = /* @__PURE__ */ __name(function read_bool() {
      return this.uint32() !== 0;
    }, "read_bool");
    function readFixed32_end(buf, end) {
      return (buf[end - 4] | buf[end - 3] << 8 | buf[end - 2] << 16 | buf[end - 1] << 24) >>> 0;
    }
    __name(readFixed32_end, "readFixed32_end");
    Reader.prototype.fixed32 = /* @__PURE__ */ __name(function read_fixed32() {
      if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4);
    }, "read_fixed32");
    Reader.prototype.sfixed32 = /* @__PURE__ */ __name(function read_sfixed32() {
      if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
      return readFixed32_end(this.buf, this.pos += 4) | 0;
    }, "read_sfixed32");
    function readFixed64() {
      if (this.pos + 8 > this.len) throw indexOutOfRange(this, 8);
      return new LongBits(readFixed32_end(this.buf, this.pos += 4), readFixed32_end(this.buf, this.pos += 4));
    }
    __name(readFixed64, "readFixed64");
    Reader.prototype.float = /* @__PURE__ */ __name(function read_float() {
      if (this.pos + 4 > this.len) throw indexOutOfRange(this, 4);
      var value2 = util2.float.readFloatLE(this.buf, this.pos);
      this.pos += 4;
      return value2;
    }, "read_float");
    Reader.prototype.double = /* @__PURE__ */ __name(function read_double() {
      if (this.pos + 8 > this.len) throw indexOutOfRange(this, 4);
      var value2 = util2.float.readDoubleLE(this.buf, this.pos);
      this.pos += 8;
      return value2;
    }, "read_double");
    Reader.prototype.bytes = /* @__PURE__ */ __name(function read_bytes() {
      var length = this.uint32(), start = this.pos, end = this.pos + length;
      if (end > this.len) throw indexOutOfRange(this, length);
      this.pos += length;
      if (Array.isArray(this.buf)) return this.buf.slice(start, end);
      if (start === end) {
        var nativeBuffer = util2.Buffer;
        return nativeBuffer ? nativeBuffer.alloc(0) : new this.buf.constructor(0);
      }
      return this._slice.call(this.buf, start, end);
    }, "read_bytes");
    Reader.prototype.string = /* @__PURE__ */ __name(function read_string() {
      var bytes = this.bytes();
      return utf8.read(bytes, 0, bytes.length);
    }, "read_string");
    Reader.prototype.skip = /* @__PURE__ */ __name(function skip(length) {
      if (typeof length === "number") {
        if (this.pos + length > this.len) throw indexOutOfRange(this, length);
        this.pos += length;
      } else {
        do {
          if (this.pos >= this.len) throw indexOutOfRange(this);
        } while (this.buf[this.pos++] & 128);
      }
      return this;
    }, "skip");
    Reader.prototype.skipType = function(wireType) {
      switch (wireType) {
        case 0:
          this.skip();
          break;
        case 1:
          this.skip(8);
          break;
        case 2:
          this.skip(this.uint32());
          break;
        case 3:
          while ((wireType = this.uint32() & 7) !== 4) {
            this.skipType(wireType);
          }
          break;
        case 5:
          this.skip(4);
          break;
        /* istanbul ignore next */
        default:
          throw Error("invalid wire type " + wireType + " at offset " + this.pos);
      }
      return this;
    };
    Reader._configure = function(BufferReader_) {
      BufferReader = BufferReader_;
      Reader.create = create();
      BufferReader._configure();
      var fn = util2.Long ? "toLong" : (
        /* istanbul ignore next */
        "toNumber"
      );
      util2.merge(Reader.prototype, {
        int64: /* @__PURE__ */ __name(function read_int64() {
          return readLongVarint.call(this)[fn](false);
        }, "read_int64"),
        uint64: /* @__PURE__ */ __name(function read_uint64() {
          return readLongVarint.call(this)[fn](true);
        }, "read_uint64"),
        sint64: /* @__PURE__ */ __name(function read_sint64() {
          return readLongVarint.call(this).zzDecode()[fn](false);
        }, "read_sint64"),
        fixed64: /* @__PURE__ */ __name(function read_fixed64() {
          return readFixed64.call(this)[fn](true);
        }, "read_fixed64"),
        sfixed64: /* @__PURE__ */ __name(function read_sfixed64() {
          return readFixed64.call(this)[fn](false);
        }, "read_sfixed64")
      });
    };
  }
});

// node_modules/protobufjs/src/reader_buffer.js
var require_reader_buffer = __commonJS({
  "node_modules/protobufjs/src/reader_buffer.js"(exports2, module2) {
    "use strict";
    module2.exports = BufferReader;
    var Reader = require_reader2();
    (BufferReader.prototype = Object.create(Reader.prototype)).constructor = BufferReader;
    var util2 = require_minimal();
    function BufferReader(buffer) {
      Reader.call(this, buffer);
    }
    __name(BufferReader, "BufferReader");
    BufferReader._configure = function() {
      if (util2.Buffer) BufferReader.prototype._slice = util2.Buffer.prototype.slice;
    };
    BufferReader.prototype.string = /* @__PURE__ */ __name(function read_string_buffer() {
      var len = this.uint32();
      return this.buf.utf8Slice ? this.buf.utf8Slice(this.pos, this.pos = Math.min(this.pos + len, this.len)) : this.buf.toString("utf-8", this.pos, this.pos = Math.min(this.pos + len, this.len));
    }, "read_string_buffer");
    BufferReader._configure();
  }
});

// node_modules/protobufjs/src/rpc/service.js
var require_service2 = __commonJS({
  "node_modules/protobufjs/src/rpc/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var util2 = require_minimal();
    (Service.prototype = Object.create(util2.EventEmitter.prototype)).constructor = Service;
    function Service(rpcImpl, requestDelimited, responseDelimited) {
      if (typeof rpcImpl !== "function") throw TypeError("rpcImpl must be a function");
      util2.EventEmitter.call(this);
      this.rpcImpl = rpcImpl;
      this.requestDelimited = Boolean(requestDelimited);
      this.responseDelimited = Boolean(responseDelimited);
    }
    __name(Service, "Service");
    Service.prototype.rpcCall = /* @__PURE__ */ __name(function rpcCall(method, requestCtor, responseCtor, request, callback) {
      if (!request) throw TypeError("request must be specified");
      var self2 = this;
      if (!callback) return util2.asPromise(rpcCall, self2, method, requestCtor, responseCtor, request);
      if (!self2.rpcImpl) {
        setTimeout(function() {
          callback(Error("already ended"));
        }, 0);
        return void 0;
      }
      try {
        return self2.rpcImpl(method, requestCtor[self2.requestDelimited ? "encodeDelimited" : "encode"](request).finish(), /* @__PURE__ */ __name(function rpcCallback(err, response) {
          if (err) {
            self2.emit("error", err, method);
            return callback(err);
          }
          if (response === null) {
            self2.end(
              /* endedByRPC */
              true
            );
            return void 0;
          }
          if (!(response instanceof responseCtor)) {
            try {
              response = responseCtor[self2.responseDelimited ? "decodeDelimited" : "decode"](response);
            } catch (err2) {
              self2.emit("error", err2, method);
              return callback(err2);
            }
          }
          self2.emit("data", response, method);
          return callback(null, response);
        }, "rpcCallback"));
      } catch (err) {
        self2.emit("error", err, method);
        setTimeout(function() {
          callback(err);
        }, 0);
        return void 0;
      }
    }, "rpcCall");
    Service.prototype.end = /* @__PURE__ */ __name(function end(endedByRPC) {
      if (this.rpcImpl) {
        if (!endedByRPC) this.rpcImpl(null, null, null);
        this.rpcImpl = null;
        this.emit("end").off();
      }
      return this;
    }, "end");
  }
});

// node_modules/protobufjs/src/rpc.js
var require_rpc = __commonJS({
  "node_modules/protobufjs/src/rpc.js"(exports2) {
    "use strict";
    var rpc = exports2;
    rpc.Service = require_service2();
  }
});

// node_modules/protobufjs/src/roots.js
var require_roots = __commonJS({
  "node_modules/protobufjs/src/roots.js"(exports2, module2) {
    "use strict";
    module2.exports = {};
  }
});

// node_modules/protobufjs/src/index-minimal.js
var require_index_minimal = __commonJS({
  "node_modules/protobufjs/src/index-minimal.js"(exports2) {
    "use strict";
    var protobuf = exports2;
    protobuf.build = "minimal";
    protobuf.Writer = require_writer2();
    protobuf.BufferWriter = require_writer_buffer();
    protobuf.Reader = require_reader2();
    protobuf.BufferReader = require_reader_buffer();
    protobuf.util = require_minimal();
    protobuf.rpc = require_rpc();
    protobuf.roots = require_roots();
    protobuf.configure = configure;
    function configure() {
      protobuf.util._configure();
      protobuf.Writer._configure(protobuf.BufferWriter);
      protobuf.Reader._configure(protobuf.BufferReader);
    }
    __name(configure, "configure");
    configure();
  }
});

// node_modules/@protobufjs/codegen/index.js
var require_codegen = __commonJS({
  "node_modules/@protobufjs/codegen/index.js"(exports2, module2) {
    "use strict";
    module2.exports = codegen;
    function codegen(functionParams, functionName) {
      if (typeof functionParams === "string") {
        functionName = functionParams;
        functionParams = void 0;
      }
      var body = [];
      function Codegen(formatStringOrScope) {
        if (typeof formatStringOrScope !== "string") {
          var source = toString2();
          if (codegen.verbose) console.log("codegen: " + source);
          source = "return " + source;
          if (formatStringOrScope) {
            var scopeKeys = Object.keys(formatStringOrScope), scopeParams = new Array(scopeKeys.length + 1), scopeValues = new Array(scopeKeys.length), scopeOffset = 0;
            while (scopeOffset < scopeKeys.length) {
              scopeParams[scopeOffset] = scopeKeys[scopeOffset];
              scopeValues[scopeOffset] = formatStringOrScope[scopeKeys[scopeOffset++]];
            }
            scopeParams[scopeOffset] = source;
            return Function.apply(null, scopeParams).apply(null, scopeValues);
          }
          return Function(source)();
        }
        var formatParams = new Array(arguments.length - 1), formatOffset = 0;
        while (formatOffset < formatParams.length) formatParams[formatOffset] = arguments[++formatOffset];
        formatOffset = 0;
        formatStringOrScope = formatStringOrScope.replace(/%([%dfijs])/g, /* @__PURE__ */ __name(function replace($0, $1) {
          var value2 = formatParams[formatOffset++];
          switch ($1) {
            case "d":
            case "f":
              return String(Number(value2));
            case "i":
              return String(Math.floor(value2));
            case "j":
              return JSON.stringify(value2);
            case "s":
              return String(value2);
          }
          return "%";
        }, "replace"));
        if (formatOffset !== formatParams.length) throw Error("parameter count mismatch");
        body.push(formatStringOrScope);
        return Codegen;
      }
      __name(Codegen, "Codegen");
      function toString2(functionNameOverride) {
        return "function " + (functionNameOverride || functionName || "") + "(" + (functionParams && functionParams.join(",") || "") + "){\n  " + body.join("\n  ") + "\n}";
      }
      __name(toString2, "toString");
      Codegen.toString = toString2;
      return Codegen;
    }
    __name(codegen, "codegen");
    codegen.verbose = false;
  }
});

// node_modules/@protobufjs/fetch/index.js
var require_fetch = __commonJS({
  "node_modules/@protobufjs/fetch/index.js"(exports2, module2) {
    "use strict";
    module2.exports = fetch2;
    var asPromise = require_aspromise();
    var inquire2 = require_inquire();
    var fs = inquire2("fs");
    function fetch2(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = {};
      } else if (!options) options = {};
      if (!callback) return asPromise(fetch2, this, filename, options);
      if (!options.xhr && fs && fs.readFile) return fs.readFile(filename, /* @__PURE__ */ __name(function fetchReadFileCallback(err, contents) {
        return err && typeof XMLHttpRequest !== "undefined" ? fetch2.xhr(filename, options, callback) : err ? callback(err) : callback(null, options.binary ? contents : contents.toString("utf8"));
      }, "fetchReadFileCallback"));
      return fetch2.xhr(filename, options, callback);
    }
    __name(fetch2, "fetch");
    fetch2.xhr = /* @__PURE__ */ __name(function fetch_xhr(filename, options, callback) {
      var xhr = new XMLHttpRequest();
      xhr.onreadystatechange = /* @__PURE__ */ __name(function fetchOnReadyStateChange() {
        if (xhr.readyState !== 4) return void 0;
        if (xhr.status !== 0 && xhr.status !== 200) return callback(Error("status " + xhr.status));
        if (options.binary) {
          var buffer = xhr.response;
          if (!buffer) {
            buffer = [];
            for (var i = 0; i < xhr.responseText.length; ++i) buffer.push(xhr.responseText.charCodeAt(i) & 255);
          }
          return callback(null, typeof Uint8Array !== "undefined" ? new Uint8Array(buffer) : buffer);
        }
        return callback(null, xhr.responseText);
      }, "fetchOnReadyStateChange");
      if (options.binary) {
        if ("overrideMimeType" in xhr) xhr.overrideMimeType("text/plain; charset=x-user-defined");
        xhr.responseType = "arraybuffer";
      }
      xhr.open("GET", filename);
      xhr.send();
    }, "fetch_xhr");
  }
});

// node_modules/@protobufjs/path/index.js
var require_path = __commonJS({
  "node_modules/@protobufjs/path/index.js"(exports2) {
    "use strict";
    var path = exports2;
    var isAbsolute = (
      /**
      * Tests if the specified path is absolute.
      * @param {string} path Path to test
      * @returns {boolean} `true` if path is absolute
      */
      path.isAbsolute = /* @__PURE__ */ __name(function isAbsolute2(path2) {
        return /^(?:\/|\w+:)/.test(path2);
      }, "isAbsolute")
    );
    var normalize2 = (
      /**
      * Normalizes the specified path.
      * @param {string} path Path to normalize
      * @returns {string} Normalized path
      */
      path.normalize = /* @__PURE__ */ __name(function normalize3(path2) {
        path2 = path2.replace(/\\/g, "/").replace(/\/{2,}/g, "/");
        var parts2 = path2.split("/"), absolute = isAbsolute(path2), prefix = "";
        if (absolute) prefix = parts2.shift() + "/";
        for (var i = 0; i < parts2.length; ) {
          if (parts2[i] === "..") {
            if (i > 0 && parts2[i - 1] !== "..") parts2.splice(--i, 2);
            else if (absolute) parts2.splice(i, 1);
            else ++i;
          } else if (parts2[i] === ".") parts2.splice(i, 1);
          else ++i;
        }
        return prefix + parts2.join("/");
      }, "normalize")
    );
    path.resolve = /* @__PURE__ */ __name(function resolve5(originPath, includePath, alreadyNormalized) {
      if (!alreadyNormalized) includePath = normalize2(includePath);
      if (isAbsolute(includePath)) return includePath;
      if (!alreadyNormalized) originPath = normalize2(originPath);
      return (originPath = originPath.replace(/(?:\/|^)[^/]+$/, "")).length ? normalize2(originPath + "/" + includePath) : includePath;
    }, "resolve");
  }
});

// node_modules/protobufjs/src/types.js
var require_types2 = __commonJS({
  "node_modules/protobufjs/src/types.js"(exports2) {
    "use strict";
    var types = exports2;
    var util2 = require_util3();
    var s = [
      "double",
      "float",
      "int32",
      "uint32",
      "sint32",
      "fixed32",
      "sfixed32",
      "int64",
      "uint64",
      "sint64",
      "fixed64",
      "sfixed64",
      "bool",
      "string",
      "bytes"
      // 14
    ];
    function bake(values, offset) {
      var i = 0, o = {};
      offset |= 0;
      while (i < values.length) o[s[i + offset]] = values[i++];
      return o;
    }
    __name(bake, "bake");
    types.basic = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2,
      /* bytes    */
      2
    ]);
    types.defaults = bake([
      /* double   */
      0,
      /* float    */
      0,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      0,
      /* sfixed32 */
      0,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      0,
      /* sfixed64 */
      0,
      /* bool     */
      false,
      /* string   */
      "",
      /* bytes    */
      util2.emptyArray,
      /* message  */
      null
    ]);
    types.long = bake([
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1
    ], 7);
    types.mapKey = bake([
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0,
      /* string   */
      2
    ], 2);
    types.packed = bake([
      /* double   */
      1,
      /* float    */
      5,
      /* int32    */
      0,
      /* uint32   */
      0,
      /* sint32   */
      0,
      /* fixed32  */
      5,
      /* sfixed32 */
      5,
      /* int64    */
      0,
      /* uint64   */
      0,
      /* sint64   */
      0,
      /* fixed64  */
      1,
      /* sfixed64 */
      1,
      /* bool     */
      0
    ]);
  }
});

// node_modules/protobufjs/src/field.js
var require_field = __commonJS({
  "node_modules/protobufjs/src/field.js"(exports2, module2) {
    "use strict";
    module2.exports = Field;
    var ReflectionObject = require_object();
    ((Field.prototype = Object.create(ReflectionObject.prototype)).constructor = Field).className = "Field";
    var Enum = require_enum();
    var types = require_types2();
    var util2 = require_util3();
    var Type;
    var ruleRe = /^required|optional|repeated$/;
    Field.fromJSON = /* @__PURE__ */ __name(function fromJSON(name, json) {
      return new Field(name, json.id, json.type, json.rule, json.extend, json.options, json.comment);
    }, "fromJSON");
    function Field(name, id, type, rule, extend, options, comment) {
      if (util2.isObject(rule)) {
        comment = extend;
        options = rule;
        rule = extend = void 0;
      } else if (util2.isObject(extend)) {
        comment = options;
        options = extend;
        extend = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!util2.isInteger(id) || id < 0) throw TypeError("id must be a non-negative integer");
      if (!util2.isString(type)) throw TypeError("type must be a string");
      if (rule !== void 0 && !ruleRe.test(rule = rule.toString().toLowerCase())) throw TypeError("rule must be a string rule");
      if (extend !== void 0 && !util2.isString(extend)) throw TypeError("extend must be a string");
      if (rule === "proto3_optional") {
        rule = "optional";
      }
      this.rule = rule && rule !== "optional" ? rule : void 0;
      this.type = type;
      this.id = id;
      this.extend = extend || void 0;
      this.required = rule === "required";
      this.optional = !this.required;
      this.repeated = rule === "repeated";
      this.map = false;
      this.message = null;
      this.partOf = null;
      this.typeDefault = null;
      this.defaultValue = null;
      this.long = util2.Long ? types.long[type] !== void 0 : (
        /* istanbul ignore next */
        false
      );
      this.bytes = type === "bytes";
      this.resolvedType = null;
      this.extensionField = null;
      this.declaringField = null;
      this._packed = null;
      this.comment = comment;
    }
    __name(Field, "Field");
    Object.defineProperty(Field.prototype, "packed", {
      get: /* @__PURE__ */ __name(function() {
        if (this._packed === null) this._packed = this.getOption("packed") !== false;
        return this._packed;
      }, "get")
    });
    Field.prototype.setOption = /* @__PURE__ */ __name(function setOption(name, value2, ifNotSet) {
      if (name === "packed") this._packed = null;
      return ReflectionObject.prototype.setOption.call(this, name, value2, ifNotSet);
    }, "setOption");
    Field.prototype.toJSON = /* @__PURE__ */ __name(function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util2.toObject([
        "rule",
        this.rule !== "optional" && this.rule || void 0,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    }, "toJSON");
    Field.prototype.resolve = /* @__PURE__ */ __name(function resolve5() {
      if (this.resolved) return this;
      if ((this.typeDefault = types.defaults[this.type]) === void 0) {
        this.resolvedType = (this.declaringField ? this.declaringField.parent : this.parent).lookupTypeOrEnum(this.type);
        if (this.resolvedType instanceof Type) this.typeDefault = null;
        else this.typeDefault = this.resolvedType.values[Object.keys(this.resolvedType.values)[0]];
      } else if (this.options && this.options.proto3_optional) {
        this.typeDefault = null;
      }
      if (this.options && this.options["default"] != null) {
        this.typeDefault = this.options["default"];
        if (this.resolvedType instanceof Enum && typeof this.typeDefault === "string") this.typeDefault = this.resolvedType.values[this.typeDefault];
      }
      if (this.options) {
        if (this.options.packed === true || this.options.packed !== void 0 && this.resolvedType && !(this.resolvedType instanceof Enum)) delete this.options.packed;
        if (!Object.keys(this.options).length) this.options = void 0;
      }
      if (this.long) {
        this.typeDefault = util2.Long.fromNumber(this.typeDefault, this.type.charAt(0) === "u");
        if (Object.freeze) Object.freeze(this.typeDefault);
      } else if (this.bytes && typeof this.typeDefault === "string") {
        var buf;
        if (util2.base64.test(this.typeDefault)) util2.base64.decode(this.typeDefault, buf = util2.newBuffer(util2.base64.length(this.typeDefault)), 0);
        else util2.utf8.write(this.typeDefault, buf = util2.newBuffer(util2.utf8.length(this.typeDefault)), 0);
        this.typeDefault = buf;
      }
      if (this.map) this.defaultValue = util2.emptyObject;
      else if (this.repeated) this.defaultValue = util2.emptyArray;
      else this.defaultValue = this.typeDefault;
      if (this.parent instanceof Type) this.parent.ctor.prototype[this.name] = this.defaultValue;
      return ReflectionObject.prototype.resolve.call(this);
    }, "resolve");
    Field.d = /* @__PURE__ */ __name(function decorateField(fieldId, fieldType, fieldRule, defaultValue) {
      if (typeof fieldType === "function") fieldType = util2.decorateType(fieldType).name;
      else if (fieldType && typeof fieldType === "object") fieldType = util2.decorateEnum(fieldType).name;
      return /* @__PURE__ */ __name(function fieldDecorator(prototype, fieldName) {
        util2.decorateType(prototype.constructor).add(new Field(fieldName, fieldId, fieldType, fieldRule, {
          "default": defaultValue
        }));
      }, "fieldDecorator");
    }, "decorateField");
    Field._configure = /* @__PURE__ */ __name(function configure(Type_) {
      Type = Type_;
    }, "configure");
  }
});

// node_modules/protobufjs/src/oneof.js
var require_oneof = __commonJS({
  "node_modules/protobufjs/src/oneof.js"(exports2, module2) {
    "use strict";
    module2.exports = OneOf;
    var ReflectionObject = require_object();
    ((OneOf.prototype = Object.create(ReflectionObject.prototype)).constructor = OneOf).className = "OneOf";
    var Field = require_field();
    var util2 = require_util3();
    function OneOf(name, fieldNames, options, comment) {
      if (!Array.isArray(fieldNames)) {
        options = fieldNames;
        fieldNames = void 0;
      }
      ReflectionObject.call(this, name, options);
      if (!(fieldNames === void 0 || Array.isArray(fieldNames))) throw TypeError("fieldNames must be an Array");
      this.oneof = fieldNames || [];
      this.fieldsArray = [];
      this.comment = comment;
    }
    __name(OneOf, "OneOf");
    OneOf.fromJSON = /* @__PURE__ */ __name(function fromJSON(name, json) {
      return new OneOf(name, json.oneof, json.options, json.comment);
    }, "fromJSON");
    OneOf.prototype.toJSON = /* @__PURE__ */ __name(function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util2.toObject([
        "options",
        this.options,
        "oneof",
        this.oneof,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    }, "toJSON");
    function addFieldsToParent(oneof) {
      if (oneof.parent) {
        for (var i = 0; i < oneof.fieldsArray.length; ++i) if (!oneof.fieldsArray[i].parent) oneof.parent.add(oneof.fieldsArray[i]);
      }
    }
    __name(addFieldsToParent, "addFieldsToParent");
    OneOf.prototype.add = /* @__PURE__ */ __name(function add(field) {
      if (!(field instanceof Field)) throw TypeError("field must be a Field");
      if (field.parent && field.parent !== this.parent) field.parent.remove(field);
      this.oneof.push(field.name);
      this.fieldsArray.push(field);
      field.partOf = this;
      addFieldsToParent(this);
      return this;
    }, "add");
    OneOf.prototype.remove = /* @__PURE__ */ __name(function remove(field) {
      if (!(field instanceof Field)) throw TypeError("field must be a Field");
      var index = this.fieldsArray.indexOf(field);
      if (index < 0) throw Error(field + " is not a member of " + this);
      this.fieldsArray.splice(index, 1);
      index = this.oneof.indexOf(field.name);
      if (index > -1) this.oneof.splice(index, 1);
      field.partOf = null;
      return this;
    }, "remove");
    OneOf.prototype.onAdd = /* @__PURE__ */ __name(function onAdd(parent) {
      ReflectionObject.prototype.onAdd.call(this, parent);
      var self2 = this;
      for (var i = 0; i < this.oneof.length; ++i) {
        var field = parent.get(this.oneof[i]);
        if (field && !field.partOf) {
          field.partOf = self2;
          self2.fieldsArray.push(field);
        }
      }
      addFieldsToParent(this);
    }, "onAdd");
    OneOf.prototype.onRemove = /* @__PURE__ */ __name(function onRemove(parent) {
      for (var i = 0, field; i < this.fieldsArray.length; ++i) if ((field = this.fieldsArray[i]).parent) field.parent.remove(field);
      ReflectionObject.prototype.onRemove.call(this, parent);
    }, "onRemove");
    OneOf.d = /* @__PURE__ */ __name(function decorateOneOf() {
      var fieldNames = new Array(arguments.length), index = 0;
      while (index < arguments.length) fieldNames[index] = arguments[index++];
      return /* @__PURE__ */ __name(function oneOfDecorator(prototype, oneofName) {
        util2.decorateType(prototype.constructor).add(new OneOf(oneofName, fieldNames));
        Object.defineProperty(prototype, oneofName, {
          get: util2.oneOfGetter(fieldNames),
          set: util2.oneOfSetter(fieldNames)
        });
      }, "oneOfDecorator");
    }, "decorateOneOf");
  }
});

// node_modules/protobufjs/src/namespace.js
var require_namespace = __commonJS({
  "node_modules/protobufjs/src/namespace.js"(exports2, module2) {
    "use strict";
    module2.exports = Namespace;
    var ReflectionObject = require_object();
    ((Namespace.prototype = Object.create(ReflectionObject.prototype)).constructor = Namespace).className = "Namespace";
    var Field = require_field();
    var util2 = require_util3();
    var OneOf = require_oneof();
    var Type;
    var Service;
    var Enum;
    Namespace.fromJSON = /* @__PURE__ */ __name(function fromJSON(name, json) {
      return new Namespace(name, json.options).addJSON(json.nested);
    }, "fromJSON");
    function arrayToJSON(array, toJSONOptions) {
      if (!(array && array.length)) return void 0;
      var obj = {};
      for (var i = 0; i < array.length; ++i) obj[array[i].name] = array[i].toJSON(toJSONOptions);
      return obj;
    }
    __name(arrayToJSON, "arrayToJSON");
    Namespace.arrayToJSON = arrayToJSON;
    Namespace.isReservedId = /* @__PURE__ */ __name(function isReservedId(reserved, id) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i) if (typeof reserved[i] !== "string" && reserved[i][0] <= id && reserved[i][1] > id) return true;
      }
      return false;
    }, "isReservedId");
    Namespace.isReservedName = /* @__PURE__ */ __name(function isReservedName(reserved, name) {
      if (reserved) {
        for (var i = 0; i < reserved.length; ++i) if (reserved[i] === name) return true;
      }
      return false;
    }, "isReservedName");
    function Namespace(name, options) {
      ReflectionObject.call(this, name, options);
      this.nested = void 0;
      this._nestedArray = null;
    }
    __name(Namespace, "Namespace");
    function clearCache(namespace) {
      namespace._nestedArray = null;
      return namespace;
    }
    __name(clearCache, "clearCache");
    Object.defineProperty(Namespace.prototype, "nestedArray", {
      get: /* @__PURE__ */ __name(function() {
        return this._nestedArray || (this._nestedArray = util2.toArray(this.nested));
      }, "get")
    });
    Namespace.prototype.toJSON = /* @__PURE__ */ __name(function toJSON(toJSONOptions) {
      return util2.toObject([
        "options",
        this.options,
        "nested",
        arrayToJSON(this.nestedArray, toJSONOptions)
      ]);
    }, "toJSON");
    Namespace.prototype.addJSON = /* @__PURE__ */ __name(function addJSON(nestedJson) {
      var ns = this;
      if (nestedJson) {
        for (var names = Object.keys(nestedJson), i = 0, nested; i < names.length; ++i) {
          nested = nestedJson[names[i]];
          ns.add((nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : nested.id !== void 0 ? Field.fromJSON : Namespace.fromJSON)(names[i], nested));
        }
      }
      return this;
    }, "addJSON");
    Namespace.prototype.get = /* @__PURE__ */ __name(function get(name) {
      return this.nested && this.nested[name] || null;
    }, "get");
    Namespace.prototype.getEnum = /* @__PURE__ */ __name(function getEnum(name) {
      if (this.nested && this.nested[name] instanceof Enum) return this.nested[name].values;
      throw Error("no such enum: " + name);
    }, "getEnum");
    Namespace.prototype.add = /* @__PURE__ */ __name(function add(object) {
      if (!(object instanceof Field && object.extend !== void 0 || object instanceof Type || object instanceof OneOf || object instanceof Enum || object instanceof Service || object instanceof Namespace)) throw TypeError("object must be a valid nested object");
      if (!this.nested) this.nested = {};
      else {
        var prev = this.get(object.name);
        if (prev) {
          if (prev instanceof Namespace && object instanceof Namespace && !(prev instanceof Type || prev instanceof Service)) {
            var nested = prev.nestedArray;
            for (var i = 0; i < nested.length; ++i) object.add(nested[i]);
            this.remove(prev);
            if (!this.nested) this.nested = {};
            object.setOptions(prev.options, true);
          } else throw Error("duplicate name '" + object.name + "' in " + this);
        }
      }
      this.nested[object.name] = object;
      object.onAdd(this);
      return clearCache(this);
    }, "add");
    Namespace.prototype.remove = /* @__PURE__ */ __name(function remove(object) {
      if (!(object instanceof ReflectionObject)) throw TypeError("object must be a ReflectionObject");
      if (object.parent !== this) throw Error(object + " is not a member of " + this);
      delete this.nested[object.name];
      if (!Object.keys(this.nested).length) this.nested = void 0;
      object.onRemove(this);
      return clearCache(this);
    }, "remove");
    Namespace.prototype.define = /* @__PURE__ */ __name(function define2(path, json) {
      if (util2.isString(path)) path = path.split(".");
      else if (!Array.isArray(path)) throw TypeError("illegal path");
      if (path && path.length && path[0] === "") throw Error("path must be relative");
      var ptr = this;
      while (path.length > 0) {
        var part = path.shift();
        if (ptr.nested && ptr.nested[part]) {
          ptr = ptr.nested[part];
          if (!(ptr instanceof Namespace)) throw Error("path conflicts with non-namespace objects");
        } else ptr.add(ptr = new Namespace(part));
      }
      if (json) ptr.addJSON(json);
      return ptr;
    }, "define");
    Namespace.prototype.resolveAll = /* @__PURE__ */ __name(function resolveAll() {
      var nested = this.nestedArray, i = 0;
      while (i < nested.length) if (nested[i] instanceof Namespace) nested[i++].resolveAll();
      else nested[i++].resolve();
      return this.resolve();
    }, "resolveAll");
    Namespace.prototype.lookup = /* @__PURE__ */ __name(function lookup2(path, filterTypes, parentAlreadyChecked) {
      if (typeof filterTypes === "boolean") {
        parentAlreadyChecked = filterTypes;
        filterTypes = void 0;
      } else if (filterTypes && !Array.isArray(filterTypes)) filterTypes = [
        filterTypes
      ];
      if (util2.isString(path) && path.length) {
        if (path === ".") return this.root;
        path = path.split(".");
      } else if (!path.length) return this;
      if (path[0] === "") return this.root.lookup(path.slice(1), filterTypes);
      var found = this.get(path[0]);
      if (found) {
        if (path.length === 1) {
          if (!filterTypes || filterTypes.indexOf(found.constructor) > -1) return found;
        } else if (found instanceof Namespace && (found = found.lookup(path.slice(1), filterTypes, true))) return found;
      } else for (var i = 0; i < this.nestedArray.length; ++i) if (this._nestedArray[i] instanceof Namespace && (found = this._nestedArray[i].lookup(path, filterTypes, true))) return found;
      if (this.parent === null || parentAlreadyChecked) return null;
      return this.parent.lookup(path, filterTypes);
    }, "lookup");
    Namespace.prototype.lookupType = /* @__PURE__ */ __name(function lookupType(path) {
      var found = this.lookup(path, [
        Type
      ]);
      if (!found) throw Error("no such type: " + path);
      return found;
    }, "lookupType");
    Namespace.prototype.lookupEnum = /* @__PURE__ */ __name(function lookupEnum(path) {
      var found = this.lookup(path, [
        Enum
      ]);
      if (!found) throw Error("no such Enum '" + path + "' in " + this);
      return found;
    }, "lookupEnum");
    Namespace.prototype.lookupTypeOrEnum = /* @__PURE__ */ __name(function lookupTypeOrEnum(path) {
      var found = this.lookup(path, [
        Type,
        Enum
      ]);
      if (!found) throw Error("no such Type or Enum '" + path + "' in " + this);
      return found;
    }, "lookupTypeOrEnum");
    Namespace.prototype.lookupService = /* @__PURE__ */ __name(function lookupService(path) {
      var found = this.lookup(path, [
        Service
      ]);
      if (!found) throw Error("no such Service '" + path + "' in " + this);
      return found;
    }, "lookupService");
    Namespace._configure = function(Type_, Service_, Enum_) {
      Type = Type_;
      Service = Service_;
      Enum = Enum_;
    };
  }
});

// node_modules/protobufjs/src/mapfield.js
var require_mapfield = __commonJS({
  "node_modules/protobufjs/src/mapfield.js"(exports2, module2) {
    "use strict";
    module2.exports = MapField;
    var Field = require_field();
    ((MapField.prototype = Object.create(Field.prototype)).constructor = MapField).className = "MapField";
    var types = require_types2();
    var util2 = require_util3();
    function MapField(name, id, keyType, type, options, comment) {
      Field.call(this, name, id, type, void 0, void 0, options, comment);
      if (!util2.isString(keyType)) throw TypeError("keyType must be a string");
      this.keyType = keyType;
      this.resolvedKeyType = null;
      this.map = true;
    }
    __name(MapField, "MapField");
    MapField.fromJSON = /* @__PURE__ */ __name(function fromJSON(name, json) {
      return new MapField(name, json.id, json.keyType, json.type, json.options, json.comment);
    }, "fromJSON");
    MapField.prototype.toJSON = /* @__PURE__ */ __name(function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util2.toObject([
        "keyType",
        this.keyType,
        "type",
        this.type,
        "id",
        this.id,
        "extend",
        this.extend,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    }, "toJSON");
    MapField.prototype.resolve = /* @__PURE__ */ __name(function resolve5() {
      if (this.resolved) return this;
      if (types.mapKey[this.keyType] === void 0) throw Error("invalid key type: " + this.keyType);
      return Field.prototype.resolve.call(this);
    }, "resolve");
    MapField.d = /* @__PURE__ */ __name(function decorateMapField(fieldId, fieldKeyType, fieldValueType) {
      if (typeof fieldValueType === "function") fieldValueType = util2.decorateType(fieldValueType).name;
      else if (fieldValueType && typeof fieldValueType === "object") fieldValueType = util2.decorateEnum(fieldValueType).name;
      return /* @__PURE__ */ __name(function mapFieldDecorator(prototype, fieldName) {
        util2.decorateType(prototype.constructor).add(new MapField(fieldName, fieldId, fieldKeyType, fieldValueType));
      }, "mapFieldDecorator");
    }, "decorateMapField");
  }
});

// node_modules/protobufjs/src/method.js
var require_method = __commonJS({
  "node_modules/protobufjs/src/method.js"(exports2, module2) {
    "use strict";
    module2.exports = Method;
    var ReflectionObject = require_object();
    ((Method.prototype = Object.create(ReflectionObject.prototype)).constructor = Method).className = "Method";
    var util2 = require_util3();
    function Method(name, type, requestType, responseType, requestStream, responseStream, options, comment, parsedOptions) {
      if (util2.isObject(requestStream)) {
        options = requestStream;
        requestStream = responseStream = void 0;
      } else if (util2.isObject(responseStream)) {
        options = responseStream;
        responseStream = void 0;
      }
      if (!(type === void 0 || util2.isString(type))) throw TypeError("type must be a string");
      if (!util2.isString(requestType)) throw TypeError("requestType must be a string");
      if (!util2.isString(responseType)) throw TypeError("responseType must be a string");
      ReflectionObject.call(this, name, options);
      this.type = type || "rpc";
      this.requestType = requestType;
      this.requestStream = requestStream ? true : void 0;
      this.responseType = responseType;
      this.responseStream = responseStream ? true : void 0;
      this.resolvedRequestType = null;
      this.resolvedResponseType = null;
      this.comment = comment;
      this.parsedOptions = parsedOptions;
    }
    __name(Method, "Method");
    Method.fromJSON = /* @__PURE__ */ __name(function fromJSON(name, json) {
      return new Method(name, json.type, json.requestType, json.responseType, json.requestStream, json.responseStream, json.options, json.comment, json.parsedOptions);
    }, "fromJSON");
    Method.prototype.toJSON = /* @__PURE__ */ __name(function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util2.toObject([
        "type",
        this.type !== "rpc" && /* istanbul ignore next */
        this.type || void 0,
        "requestType",
        this.requestType,
        "requestStream",
        this.requestStream,
        "responseType",
        this.responseType,
        "responseStream",
        this.responseStream,
        "options",
        this.options,
        "comment",
        keepComments ? this.comment : void 0,
        "parsedOptions",
        this.parsedOptions
      ]);
    }, "toJSON");
    Method.prototype.resolve = /* @__PURE__ */ __name(function resolve5() {
      if (this.resolved) return this;
      this.resolvedRequestType = this.parent.lookupType(this.requestType);
      this.resolvedResponseType = this.parent.lookupType(this.responseType);
      return ReflectionObject.prototype.resolve.call(this);
    }, "resolve");
  }
});

// node_modules/protobufjs/src/service.js
var require_service3 = __commonJS({
  "node_modules/protobufjs/src/service.js"(exports2, module2) {
    "use strict";
    module2.exports = Service;
    var Namespace = require_namespace();
    ((Service.prototype = Object.create(Namespace.prototype)).constructor = Service).className = "Service";
    var Method = require_method();
    var util2 = require_util3();
    var rpc = require_rpc();
    function Service(name, options) {
      Namespace.call(this, name, options);
      this.methods = {};
      this._methodsArray = null;
    }
    __name(Service, "Service");
    Service.fromJSON = /* @__PURE__ */ __name(function fromJSON(name, json) {
      var service = new Service(name, json.options);
      if (json.methods) for (var names = Object.keys(json.methods), i = 0; i < names.length; ++i) service.add(Method.fromJSON(names[i], json.methods[names[i]]));
      if (json.nested) service.addJSON(json.nested);
      service.comment = json.comment;
      return service;
    }, "fromJSON");
    Service.prototype.toJSON = /* @__PURE__ */ __name(function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util2.toObject([
        "options",
        inherited && inherited.options || void 0,
        "methods",
        Namespace.arrayToJSON(this.methodsArray, toJSONOptions) || /* istanbul ignore next */
        {},
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    }, "toJSON");
    Object.defineProperty(Service.prototype, "methodsArray", {
      get: /* @__PURE__ */ __name(function() {
        return this._methodsArray || (this._methodsArray = util2.toArray(this.methods));
      }, "get")
    });
    function clearCache(service) {
      service._methodsArray = null;
      return service;
    }
    __name(clearCache, "clearCache");
    Service.prototype.get = /* @__PURE__ */ __name(function get(name) {
      return this.methods[name] || Namespace.prototype.get.call(this, name);
    }, "get");
    Service.prototype.resolveAll = /* @__PURE__ */ __name(function resolveAll() {
      var methods = this.methodsArray;
      for (var i = 0; i < methods.length; ++i) methods[i].resolve();
      return Namespace.prototype.resolve.call(this);
    }, "resolveAll");
    Service.prototype.add = /* @__PURE__ */ __name(function add(object) {
      if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Method) {
        this.methods[object.name] = object;
        object.parent = this;
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    }, "add");
    Service.prototype.remove = /* @__PURE__ */ __name(function remove(object) {
      if (object instanceof Method) {
        if (this.methods[object.name] !== object) throw Error(object + " is not a member of " + this);
        delete this.methods[object.name];
        object.parent = null;
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    }, "remove");
    Service.prototype.create = /* @__PURE__ */ __name(function create(rpcImpl, requestDelimited, responseDelimited) {
      var rpcService = new rpc.Service(rpcImpl, requestDelimited, responseDelimited);
      for (var i = 0, method; i < /* initializes */
      this.methodsArray.length; ++i) {
        var methodName = util2.lcFirst((method = this._methodsArray[i]).resolve().name).replace(/[^$\w_]/g, "");
        rpcService[methodName] = util2.codegen([
          "r",
          "c"
        ], util2.isReserved(methodName) ? methodName + "_" : methodName)("return this.rpcCall(m,q,s,r,c)")({
          m: method,
          q: method.resolvedRequestType.ctor,
          s: method.resolvedResponseType.ctor
        });
      }
      return rpcService;
    }, "create");
  }
});

// node_modules/protobufjs/src/message.js
var require_message = __commonJS({
  "node_modules/protobufjs/src/message.js"(exports2, module2) {
    "use strict";
    module2.exports = Message;
    var util2 = require_minimal();
    function Message(properties) {
      if (properties) for (var keys = Object.keys(properties), i = 0; i < keys.length; ++i) this[keys[i]] = properties[keys[i]];
    }
    __name(Message, "Message");
    Message.create = /* @__PURE__ */ __name(function create(properties) {
      return this.$type.create(properties);
    }, "create");
    Message.encode = /* @__PURE__ */ __name(function encode2(message, writer) {
      return this.$type.encode(message, writer);
    }, "encode");
    Message.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
      return this.$type.encodeDelimited(message, writer);
    }, "encodeDelimited");
    Message.decode = /* @__PURE__ */ __name(function decode2(reader) {
      return this.$type.decode(reader);
    }, "decode");
    Message.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
      return this.$type.decodeDelimited(reader);
    }, "decodeDelimited");
    Message.verify = /* @__PURE__ */ __name(function verify(message) {
      return this.$type.verify(message);
    }, "verify");
    Message.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
      return this.$type.fromObject(object);
    }, "fromObject");
    Message.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
      return this.$type.toObject(message, options);
    }, "toObject");
    Message.prototype.toJSON = /* @__PURE__ */ __name(function toJSON() {
      return this.$type.toObject(this, util2.toJSONOptions);
    }, "toJSON");
  }
});

// node_modules/protobufjs/src/decoder.js
var require_decoder = __commonJS({
  "node_modules/protobufjs/src/decoder.js"(exports2, module2) {
    "use strict";
    module2.exports = decoder;
    var Enum = require_enum();
    var types = require_types2();
    var util2 = require_util3();
    function missing(field) {
      return "missing required '" + field.name + "'";
    }
    __name(missing, "missing");
    function decoder(mtype) {
      var gen = util2.codegen([
        "r",
        "l"
      ], mtype.name + "$decode")("if(!(r instanceof Reader))")("r=Reader.create(r)")("var c=l===undefined?r.len:r.pos+l,m=new this.ctor" + (mtype.fieldsArray.filter(function(field2) {
        return field2.map;
      }).length ? ",k,value" : ""))("while(r.pos<c){")("var t=r.uint32()");
      if (mtype.group) gen("if((t&7)===4)")("break");
      gen("switch(t>>>3){");
      var i = 0;
      for (; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), type = field.resolvedType instanceof Enum ? "int32" : field.type, ref = "m" + util2.safeProp(field.name);
        gen("case %i: {", field.id);
        if (field.map) {
          gen("if(%s===util.emptyObject)", ref)("%s={}", ref)("var c2 = r.uint32()+r.pos");
          if (types.defaults[field.keyType] !== void 0) gen("k=%j", types.defaults[field.keyType]);
          else gen("k=null");
          if (types.defaults[type] !== void 0) gen("value=%j", types.defaults[type]);
          else gen("value=null");
          gen("while(r.pos<c2){")("var tag2=r.uint32()")("switch(tag2>>>3){")("case 1: k=r.%s(); break", field.keyType)("case 2:");
          if (types.basic[type] === void 0) gen("value=types[%i].decode(r,r.uint32())", i);
          else gen("value=r.%s()", type);
          gen("break")("default:")("r.skipType(tag2&7)")("break")("}")("}");
          if (types.long[field.keyType] !== void 0) gen('%s[typeof k==="object"?util.longToHash(k):k]=value', ref);
          else gen("%s[k]=value", ref);
        } else if (field.repeated) {
          gen("if(!(%s&&%s.length))", ref, ref)("%s=[]", ref);
          if (types.packed[type] !== void 0) gen("if((t&7)===2){")("var c2=r.uint32()+r.pos")("while(r.pos<c2)")("%s.push(r.%s())", ref, type)("}else");
          if (types.basic[type] === void 0) gen(field.resolvedType.group ? "%s.push(types[%i].decode(r))" : "%s.push(types[%i].decode(r,r.uint32()))", ref, i);
          else gen("%s.push(r.%s())", ref, type);
        } else if (types.basic[type] === void 0) gen(field.resolvedType.group ? "%s=types[%i].decode(r)" : "%s=types[%i].decode(r,r.uint32())", ref, i);
        else gen("%s=r.%s()", ref, type);
        gen("break")("}");
      }
      gen("default:")("r.skipType(t&7)")("break")("}")("}");
      for (i = 0; i < mtype._fieldsArray.length; ++i) {
        var rfield = mtype._fieldsArray[i];
        if (rfield.required) gen("if(!m.hasOwnProperty(%j))", rfield.name)("throw util.ProtocolError(%j,{instance:m})", missing(rfield));
      }
      return gen("return m");
    }
    __name(decoder, "decoder");
  }
});

// node_modules/protobufjs/src/verifier.js
var require_verifier = __commonJS({
  "node_modules/protobufjs/src/verifier.js"(exports2, module2) {
    "use strict";
    module2.exports = verifier;
    var Enum = require_enum();
    var util2 = require_util3();
    function invalid(field, expected) {
      return field.name + ": " + expected + (field.repeated && expected !== "array" ? "[]" : field.map && expected !== "object" ? "{k:" + field.keyType + "}" : "") + " expected";
    }
    __name(invalid, "invalid");
    function genVerifyValue(gen, field, fieldIndex, ref) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(%s){", ref)("default:")("return%j", invalid(field, "enum value"));
          for (var keys = Object.keys(field.resolvedType.values), j = 0; j < keys.length; ++j) gen("case %i:", field.resolvedType.values[keys[j]]);
          gen("break")("}");
        } else {
          gen("{")("var e=types[%i].verify(%s);", fieldIndex, ref)("if(e)")("return%j+e", field.name + ".")("}");
        }
      } else {
        switch (field.type) {
          case "int32":
          case "uint32":
          case "sint32":
          case "fixed32":
          case "sfixed32":
            gen("if(!util.isInteger(%s))", ref)("return%j", invalid(field, "integer"));
            break;
          case "int64":
          case "uint64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(!util.isInteger(%s)&&!(%s&&util.isInteger(%s.low)&&util.isInteger(%s.high)))", ref, ref, ref, ref)("return%j", invalid(field, "integer|Long"));
            break;
          case "float":
          case "double":
            gen('if(typeof %s!=="number")', ref)("return%j", invalid(field, "number"));
            break;
          case "bool":
            gen('if(typeof %s!=="boolean")', ref)("return%j", invalid(field, "boolean"));
            break;
          case "string":
            gen("if(!util.isString(%s))", ref)("return%j", invalid(field, "string"));
            break;
          case "bytes":
            gen('if(!(%s&&typeof %s.length==="number"||util.isString(%s)))', ref, ref, ref)("return%j", invalid(field, "buffer"));
            break;
        }
      }
      return gen;
    }
    __name(genVerifyValue, "genVerifyValue");
    function genVerifyKey(gen, field, ref) {
      switch (field.keyType) {
        case "int32":
        case "uint32":
        case "sint32":
        case "fixed32":
        case "sfixed32":
          gen("if(!util.key32Re.test(%s))", ref)("return%j", invalid(field, "integer key"));
          break;
        case "int64":
        case "uint64":
        case "sint64":
        case "fixed64":
        case "sfixed64":
          gen("if(!util.key64Re.test(%s))", ref)("return%j", invalid(field, "integer|Long key"));
          break;
        case "bool":
          gen("if(!util.key2Re.test(%s))", ref)("return%j", invalid(field, "boolean key"));
          break;
      }
      return gen;
    }
    __name(genVerifyKey, "genVerifyKey");
    function verifier(mtype) {
      var gen = util2.codegen([
        "m"
      ], mtype.name + "$verify")('if(typeof m!=="object"||m===null)')("return%j", "object expected");
      var oneofs = mtype.oneofsArray, seenFirstField = {};
      if (oneofs.length) gen("var p={}");
      for (var i = 0; i < /* initializes */
      mtype.fieldsArray.length; ++i) {
        var field = mtype._fieldsArray[i].resolve(), ref = "m" + util2.safeProp(field.name);
        if (field.optional) gen("if(%s!=null&&m.hasOwnProperty(%j)){", ref, field.name);
        if (field.map) {
          gen("if(!util.isObject(%s))", ref)("return%j", invalid(field, "object"))("var k=Object.keys(%s)", ref)("for(var i=0;i<k.length;++i){");
          genVerifyKey(gen, field, "k[i]");
          genVerifyValue(gen, field, i, ref + "[k[i]]")("}");
        } else if (field.repeated) {
          gen("if(!Array.isArray(%s))", ref)("return%j", invalid(field, "array"))("for(var i=0;i<%s.length;++i){", ref);
          genVerifyValue(gen, field, i, ref + "[i]")("}");
        } else {
          if (field.partOf) {
            var oneofProp = util2.safeProp(field.partOf.name);
            if (seenFirstField[field.partOf.name] === 1) gen("if(p%s===1)", oneofProp)("return%j", field.partOf.name + ": multiple values");
            seenFirstField[field.partOf.name] = 1;
            gen("p%s=1", oneofProp);
          }
          genVerifyValue(gen, field, i, ref);
        }
        if (field.optional) gen("}");
      }
      return gen("return null");
    }
    __name(verifier, "verifier");
  }
});

// node_modules/protobufjs/src/converter.js
var require_converter = __commonJS({
  "node_modules/protobufjs/src/converter.js"(exports2) {
    "use strict";
    var converter = exports2;
    var Enum = require_enum();
    var util2 = require_util3();
    function genValuePartial_fromObject(gen, field, fieldIndex, prop) {
      var defaultAlreadyEmitted = false;
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) {
          gen("switch(d%s){", prop);
          for (var values = field.resolvedType.values, keys = Object.keys(values), i = 0; i < keys.length; ++i) {
            if (values[keys[i]] === field.typeDefault && !defaultAlreadyEmitted) {
              gen("default:")('if(typeof(d%s)==="number"){m%s=d%s;break}', prop, prop, prop);
              if (!field.repeated) gen("break");
              defaultAlreadyEmitted = true;
            }
            gen("case%j:", keys[i])("case %i:", values[keys[i]])("m%s=%j", prop, values[keys[i]])("break");
          }
          gen("}");
        } else gen('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s=types[%i].fromObject(d%s)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("m%s=Number(d%s)", prop, prop);
            break;
          case "uint32":
          case "fixed32":
            gen("m%s=d%s>>>0", prop, prop);
            break;
          case "int32":
          case "sint32":
          case "sfixed32":
            gen("m%s=d%s|0", prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          // eslint-disable-next-line no-fallthrough
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen("if(util.Long)")("(m%s=util.Long.fromValue(d%s)).unsigned=%j", prop, prop, isUnsigned)('else if(typeof d%s==="string")', prop)("m%s=parseInt(d%s,10)", prop, prop)('else if(typeof d%s==="number")', prop)("m%s=d%s", prop, prop)('else if(typeof d%s==="object")', prop)("m%s=new util.LongBits(d%s.low>>>0,d%s.high>>>0).toNumber(%s)", prop, prop, prop, isUnsigned ? "true" : "");
            break;
          case "bytes":
            gen('if(typeof d%s==="string")', prop)("util.base64.decode(d%s,m%s=util.newBuffer(util.base64.length(d%s)),0)", prop, prop, prop)("else if(d%s.length >= 0)", prop)("m%s=d%s", prop, prop);
            break;
          case "string":
            gen("m%s=String(d%s)", prop, prop);
            break;
          case "bool":
            gen("m%s=Boolean(d%s)", prop, prop);
            break;
        }
      }
      return gen;
    }
    __name(genValuePartial_fromObject, "genValuePartial_fromObject");
    converter.fromObject = /* @__PURE__ */ __name(function fromObject(mtype) {
      var fields = mtype.fieldsArray;
      var gen = util2.codegen([
        "d"
      ], mtype.name + "$fromObject")("if(d instanceof this.ctor)")("return d");
      if (!fields.length) return gen("return new this.ctor");
      gen("var m=new this.ctor");
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), prop = util2.safeProp(field.name);
        if (field.map) {
          gen("if(d%s){", prop)('if(typeof d%s!=="object")', prop)("throw TypeError(%j)", field.fullName + ": object expected")("m%s={}", prop)("for(var ks=Object.keys(d%s),i=0;i<ks.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[ks[i]]"
          )("}")("}");
        } else if (field.repeated) {
          gen("if(d%s){", prop)("if(!Array.isArray(d%s))", prop)("throw TypeError(%j)", field.fullName + ": array expected")("m%s=[]", prop)("for(var i=0;i<d%s.length;++i){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop + "[i]"
          )("}")("}");
        } else {
          if (!(field.resolvedType instanceof Enum)) gen("if(d%s!=null){", prop);
          genValuePartial_fromObject(
            gen,
            field,
            /* not sorted */
            i,
            prop
          );
          if (!(field.resolvedType instanceof Enum)) gen("}");
        }
      }
      return gen("return m");
    }, "fromObject");
    function genValuePartial_toObject(gen, field, fieldIndex, prop) {
      if (field.resolvedType) {
        if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?(types[%i].values[m%s]===undefined?m%s:types[%i].values[m%s]):m%s", prop, fieldIndex, prop, prop, fieldIndex, prop, prop);
        else gen("d%s=types[%i].toObject(m%s,o)", prop, fieldIndex, prop);
      } else {
        var isUnsigned = false;
        switch (field.type) {
          case "double":
          case "float":
            gen("d%s=o.json&&!isFinite(m%s)?String(m%s):m%s", prop, prop, prop, prop);
            break;
          case "uint64":
            isUnsigned = true;
          // eslint-disable-next-line no-fallthrough
          case "int64":
          case "sint64":
          case "fixed64":
          case "sfixed64":
            gen('if(typeof m%s==="number")', prop)("d%s=o.longs===String?String(m%s):m%s", prop, prop, prop)("else")("d%s=o.longs===String?util.Long.prototype.toString.call(m%s):o.longs===Number?new util.LongBits(m%s.low>>>0,m%s.high>>>0).toNumber(%s):m%s", prop, prop, prop, prop, isUnsigned ? "true" : "", prop);
            break;
          case "bytes":
            gen("d%s=o.bytes===String?util.base64.encode(m%s,0,m%s.length):o.bytes===Array?Array.prototype.slice.call(m%s):m%s", prop, prop, prop, prop, prop);
            break;
          default:
            gen("d%s=m%s", prop, prop);
            break;
        }
      }
      return gen;
    }
    __name(genValuePartial_toObject, "genValuePartial_toObject");
    converter.toObject = /* @__PURE__ */ __name(function toObject(mtype) {
      var fields = mtype.fieldsArray.slice().sort(util2.compareFieldsById);
      if (!fields.length) return util2.codegen()("return {}");
      var gen = util2.codegen([
        "m",
        "o"
      ], mtype.name + "$toObject")("if(!o)")("o={}")("var d={}");
      var repeatedFields = [], mapFields = [], normalFields = [], i = 0;
      for (; i < fields.length; ++i) if (!fields[i].partOf) (fields[i].resolve().repeated ? repeatedFields : fields[i].map ? mapFields : normalFields).push(fields[i]);
      if (repeatedFields.length) {
        gen("if(o.arrays||o.defaults){");
        for (i = 0; i < repeatedFields.length; ++i) gen("d%s=[]", util2.safeProp(repeatedFields[i].name));
        gen("}");
      }
      if (mapFields.length) {
        gen("if(o.objects||o.defaults){");
        for (i = 0; i < mapFields.length; ++i) gen("d%s={}", util2.safeProp(mapFields[i].name));
        gen("}");
      }
      if (normalFields.length) {
        gen("if(o.defaults){");
        for (i = 0; i < normalFields.length; ++i) {
          var field = normalFields[i], prop = util2.safeProp(field.name);
          if (field.resolvedType instanceof Enum) gen("d%s=o.enums===String?%j:%j", prop, field.resolvedType.valuesById[field.typeDefault], field.typeDefault);
          else if (field.long) gen("if(util.Long){")("var n=new util.Long(%i,%i,%j)", field.typeDefault.low, field.typeDefault.high, field.typeDefault.unsigned)("d%s=o.longs===String?n.toString():o.longs===Number?n.toNumber():n", prop)("}else")("d%s=o.longs===String?%j:%i", prop, field.typeDefault.toString(), field.typeDefault.toNumber());
          else if (field.bytes) {
            var arrayDefault = "[" + Array.prototype.slice.call(field.typeDefault).join(",") + "]";
            gen("if(o.bytes===String)d%s=%j", prop, String.fromCharCode.apply(String, field.typeDefault))("else{")("d%s=%s", prop, arrayDefault)("if(o.bytes!==Array)d%s=util.newBuffer(d%s)", prop, prop)("}");
          } else gen("d%s=%j", prop, field.typeDefault);
        }
        gen("}");
      }
      var hasKs2 = false;
      for (i = 0; i < fields.length; ++i) {
        var field = fields[i], index = mtype._fieldsArray.indexOf(field), prop = util2.safeProp(field.name);
        if (field.map) {
          if (!hasKs2) {
            hasKs2 = true;
            gen("var ks2");
          }
          gen("if(m%s&&(ks2=Object.keys(m%s)).length){", prop, prop)("d%s={}", prop)("for(var j=0;j<ks2.length;++j){");
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[ks2[j]]"
          )("}");
        } else if (field.repeated) {
          gen("if(m%s&&m%s.length){", prop, prop)("d%s=[]", prop)("for(var j=0;j<m%s.length;++j){", prop);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop + "[j]"
          )("}");
        } else {
          gen("if(m%s!=null&&m.hasOwnProperty(%j)){", prop, field.name);
          genValuePartial_toObject(
            gen,
            field,
            /* sorted */
            index,
            prop
          );
          if (field.partOf) gen("if(o.oneofs)")("d%s=%j", util2.safeProp(field.partOf.name), field.name);
        }
        gen("}");
      }
      return gen("return d");
    }, "toObject");
  }
});

// node_modules/protobufjs/src/wrappers.js
var require_wrappers = __commonJS({
  "node_modules/protobufjs/src/wrappers.js"(exports2) {
    "use strict";
    var wrappers = exports2;
    var Message = require_message();
    wrappers[".google.protobuf.Any"] = {
      fromObject: /* @__PURE__ */ __name(function(object) {
        if (object && object["@type"]) {
          var name = object["@type"].substring(object["@type"].lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type) {
            var type_url = object["@type"].charAt(0) === "." ? object["@type"].slice(1) : object["@type"];
            if (type_url.indexOf("/") === -1) {
              type_url = "/" + type_url;
            }
            return this.create({
              type_url,
              value: type.encode(type.fromObject(object)).finish()
            });
          }
        }
        return this.fromObject(object);
      }, "fromObject"),
      toObject: /* @__PURE__ */ __name(function(message, options) {
        var googleApi = "type.googleapis.com/";
        var prefix = "";
        var name = "";
        if (options && options.json && message.type_url && message.value) {
          name = message.type_url.substring(message.type_url.lastIndexOf("/") + 1);
          prefix = message.type_url.substring(0, message.type_url.lastIndexOf("/") + 1);
          var type = this.lookup(name);
          if (type) message = type.decode(message.value);
        }
        if (!(message instanceof this.ctor) && message instanceof Message) {
          var object = message.$type.toObject(message, options);
          var messageName = message.$type.fullName[0] === "." ? message.$type.fullName.slice(1) : message.$type.fullName;
          if (prefix === "") {
            prefix = googleApi;
          }
          name = prefix + messageName;
          object["@type"] = name;
          return object;
        }
        return this.toObject(message, options);
      }, "toObject")
    };
  }
});

// node_modules/protobufjs/src/type.js
var require_type = __commonJS({
  "node_modules/protobufjs/src/type.js"(exports2, module2) {
    "use strict";
    module2.exports = Type;
    var Namespace = require_namespace();
    ((Type.prototype = Object.create(Namespace.prototype)).constructor = Type).className = "Type";
    var Enum = require_enum();
    var OneOf = require_oneof();
    var Field = require_field();
    var MapField = require_mapfield();
    var Service = require_service3();
    var Message = require_message();
    var Reader = require_reader2();
    var Writer = require_writer2();
    var util2 = require_util3();
    var encoder = require_encoder();
    var decoder = require_decoder();
    var verifier = require_verifier();
    var converter = require_converter();
    var wrappers = require_wrappers();
    function Type(name, options) {
      Namespace.call(this, name, options);
      this.fields = {};
      this.oneofs = void 0;
      this.extensions = void 0;
      this.reserved = void 0;
      this.group = void 0;
      this._fieldsById = null;
      this._fieldsArray = null;
      this._oneofsArray = null;
      this._ctor = null;
    }
    __name(Type, "Type");
    Object.defineProperties(Type.prototype, {
      /**
       * Message fields by id.
       * @name Type#fieldsById
       * @type {Object.<number,Field>}
       * @readonly
       */
      fieldsById: {
        get: /* @__PURE__ */ __name(function() {
          if (this._fieldsById) return this._fieldsById;
          this._fieldsById = {};
          for (var names = Object.keys(this.fields), i = 0; i < names.length; ++i) {
            var field = this.fields[names[i]], id = field.id;
            if (this._fieldsById[id]) throw Error("duplicate id " + id + " in " + this);
            this._fieldsById[id] = field;
          }
          return this._fieldsById;
        }, "get")
      },
      /**
       * Fields of this message as an array for iteration.
       * @name Type#fieldsArray
       * @type {Field[]}
       * @readonly
       */
      fieldsArray: {
        get: /* @__PURE__ */ __name(function() {
          return this._fieldsArray || (this._fieldsArray = util2.toArray(this.fields));
        }, "get")
      },
      /**
       * Oneofs of this message as an array for iteration.
       * @name Type#oneofsArray
       * @type {OneOf[]}
       * @readonly
       */
      oneofsArray: {
        get: /* @__PURE__ */ __name(function() {
          return this._oneofsArray || (this._oneofsArray = util2.toArray(this.oneofs));
        }, "get")
      },
      /**
       * The registered constructor, if any registered, otherwise a generic constructor.
       * Assigning a function replaces the internal constructor. If the function does not extend {@link Message} yet, its prototype will be setup accordingly and static methods will be populated. If it already extends {@link Message}, it will just replace the internal constructor.
       * @name Type#ctor
       * @type {Constructor<{}>}
       */
      ctor: {
        get: /* @__PURE__ */ __name(function() {
          return this._ctor || (this.ctor = Type.generateConstructor(this)());
        }, "get"),
        set: /* @__PURE__ */ __name(function(ctor) {
          var prototype = ctor.prototype;
          if (!(prototype instanceof Message)) {
            (ctor.prototype = new Message()).constructor = ctor;
            util2.merge(ctor.prototype, prototype);
          }
          ctor.$type = ctor.prototype.$type = this;
          util2.merge(ctor, Message, true);
          this._ctor = ctor;
          var i = 0;
          for (; i < /* initializes */
          this.fieldsArray.length; ++i) this._fieldsArray[i].resolve();
          var ctorProperties = {};
          for (i = 0; i < /* initializes */
          this.oneofsArray.length; ++i) ctorProperties[this._oneofsArray[i].resolve().name] = {
            get: util2.oneOfGetter(this._oneofsArray[i].oneof),
            set: util2.oneOfSetter(this._oneofsArray[i].oneof)
          };
          if (i) Object.defineProperties(ctor.prototype, ctorProperties);
        }, "set")
      }
    });
    Type.generateConstructor = /* @__PURE__ */ __name(function generateConstructor(mtype) {
      var gen = util2.codegen([
        "p"
      ], mtype.name);
      for (var i = 0, field; i < mtype.fieldsArray.length; ++i) if ((field = mtype._fieldsArray[i]).map) gen("this%s={}", util2.safeProp(field.name));
      else if (field.repeated) gen("this%s=[]", util2.safeProp(field.name));
      return gen("if(p)for(var ks=Object.keys(p),i=0;i<ks.length;++i)if(p[ks[i]]!=null)")("this[ks[i]]=p[ks[i]]");
    }, "generateConstructor");
    function clearCache(type) {
      type._fieldsById = type._fieldsArray = type._oneofsArray = null;
      delete type.encode;
      delete type.decode;
      delete type.verify;
      return type;
    }
    __name(clearCache, "clearCache");
    Type.fromJSON = /* @__PURE__ */ __name(function fromJSON(name, json) {
      var type = new Type(name, json.options);
      type.extensions = json.extensions;
      type.reserved = json.reserved;
      var names = Object.keys(json.fields), i = 0;
      for (; i < names.length; ++i) type.add((typeof json.fields[names[i]].keyType !== "undefined" ? MapField.fromJSON : Field.fromJSON)(names[i], json.fields[names[i]]));
      if (json.oneofs) for (names = Object.keys(json.oneofs), i = 0; i < names.length; ++i) type.add(OneOf.fromJSON(names[i], json.oneofs[names[i]]));
      if (json.nested) for (names = Object.keys(json.nested), i = 0; i < names.length; ++i) {
        var nested = json.nested[names[i]];
        type.add((nested.id !== void 0 ? Field.fromJSON : nested.fields !== void 0 ? Type.fromJSON : nested.values !== void 0 ? Enum.fromJSON : nested.methods !== void 0 ? Service.fromJSON : Namespace.fromJSON)(names[i], nested));
      }
      if (json.extensions && json.extensions.length) type.extensions = json.extensions;
      if (json.reserved && json.reserved.length) type.reserved = json.reserved;
      if (json.group) type.group = true;
      if (json.comment) type.comment = json.comment;
      return type;
    }, "fromJSON");
    Type.prototype.toJSON = /* @__PURE__ */ __name(function toJSON(toJSONOptions) {
      var inherited = Namespace.prototype.toJSON.call(this, toJSONOptions);
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util2.toObject([
        "options",
        inherited && inherited.options || void 0,
        "oneofs",
        Namespace.arrayToJSON(this.oneofsArray, toJSONOptions),
        "fields",
        Namespace.arrayToJSON(this.fieldsArray.filter(function(obj) {
          return !obj.declaringField;
        }), toJSONOptions) || {},
        "extensions",
        this.extensions && this.extensions.length ? this.extensions : void 0,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "group",
        this.group || void 0,
        "nested",
        inherited && inherited.nested || void 0,
        "comment",
        keepComments ? this.comment : void 0
      ]);
    }, "toJSON");
    Type.prototype.resolveAll = /* @__PURE__ */ __name(function resolveAll() {
      var fields = this.fieldsArray, i = 0;
      while (i < fields.length) fields[i++].resolve();
      var oneofs = this.oneofsArray;
      i = 0;
      while (i < oneofs.length) oneofs[i++].resolve();
      return Namespace.prototype.resolveAll.call(this);
    }, "resolveAll");
    Type.prototype.get = /* @__PURE__ */ __name(function get(name) {
      return this.fields[name] || this.oneofs && this.oneofs[name] || this.nested && this.nested[name] || null;
    }, "get");
    Type.prototype.add = /* @__PURE__ */ __name(function add(object) {
      if (this.get(object.name)) throw Error("duplicate name '" + object.name + "' in " + this);
      if (object instanceof Field && object.extend === void 0) {
        if (this._fieldsById ? (
          /* istanbul ignore next */
          this._fieldsById[object.id]
        ) : this.fieldsById[object.id]) throw Error("duplicate id " + object.id + " in " + this);
        if (this.isReservedId(object.id)) throw Error("id " + object.id + " is reserved in " + this);
        if (this.isReservedName(object.name)) throw Error("name '" + object.name + "' is reserved in " + this);
        if (object.parent) object.parent.remove(object);
        this.fields[object.name] = object;
        object.message = this;
        object.onAdd(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs) this.oneofs = {};
        this.oneofs[object.name] = object;
        object.onAdd(this);
        return clearCache(this);
      }
      return Namespace.prototype.add.call(this, object);
    }, "add");
    Type.prototype.remove = /* @__PURE__ */ __name(function remove(object) {
      if (object instanceof Field && object.extend === void 0) {
        if (!this.fields || this.fields[object.name] !== object) throw Error(object + " is not a member of " + this);
        delete this.fields[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      if (object instanceof OneOf) {
        if (!this.oneofs || this.oneofs[object.name] !== object) throw Error(object + " is not a member of " + this);
        delete this.oneofs[object.name];
        object.parent = null;
        object.onRemove(this);
        return clearCache(this);
      }
      return Namespace.prototype.remove.call(this, object);
    }, "remove");
    Type.prototype.isReservedId = /* @__PURE__ */ __name(function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    }, "isReservedId");
    Type.prototype.isReservedName = /* @__PURE__ */ __name(function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    }, "isReservedName");
    Type.prototype.create = /* @__PURE__ */ __name(function create(properties) {
      return new this.ctor(properties);
    }, "create");
    Type.prototype.setup = /* @__PURE__ */ __name(function setup() {
      var fullName = this.fullName, types = [];
      for (var i = 0; i < /* initializes */
      this.fieldsArray.length; ++i) types.push(this._fieldsArray[i].resolve().resolvedType);
      this.encode = encoder(this)({
        Writer,
        types,
        util: util2
      });
      this.decode = decoder(this)({
        Reader,
        types,
        util: util2
      });
      this.verify = verifier(this)({
        types,
        util: util2
      });
      this.fromObject = converter.fromObject(this)({
        types,
        util: util2
      });
      this.toObject = converter.toObject(this)({
        types,
        util: util2
      });
      var wrapper = wrappers[fullName];
      if (wrapper) {
        var originalThis = Object.create(this);
        originalThis.fromObject = this.fromObject;
        this.fromObject = wrapper.fromObject.bind(originalThis);
        originalThis.toObject = this.toObject;
        this.toObject = wrapper.toObject.bind(originalThis);
      }
      return this;
    }, "setup");
    Type.prototype.encode = /* @__PURE__ */ __name(function encode_setup(message, writer) {
      return this.setup().encode(message, writer);
    }, "encode_setup");
    Type.prototype.encodeDelimited = /* @__PURE__ */ __name(function encodeDelimited(message, writer) {
      return this.encode(message, writer && writer.len ? writer.fork() : writer).ldelim();
    }, "encodeDelimited");
    Type.prototype.decode = /* @__PURE__ */ __name(function decode_setup(reader, length) {
      return this.setup().decode(reader, length);
    }, "decode_setup");
    Type.prototype.decodeDelimited = /* @__PURE__ */ __name(function decodeDelimited(reader) {
      if (!(reader instanceof Reader)) reader = Reader.create(reader);
      return this.decode(reader, reader.uint32());
    }, "decodeDelimited");
    Type.prototype.verify = /* @__PURE__ */ __name(function verify_setup(message) {
      return this.setup().verify(message);
    }, "verify_setup");
    Type.prototype.fromObject = /* @__PURE__ */ __name(function fromObject(object) {
      return this.setup().fromObject(object);
    }, "fromObject");
    Type.prototype.toObject = /* @__PURE__ */ __name(function toObject(message, options) {
      return this.setup().toObject(message, options);
    }, "toObject");
    Type.d = /* @__PURE__ */ __name(function decorateType(typeName) {
      return /* @__PURE__ */ __name(function typeDecorator(target) {
        util2.decorateType(target, typeName);
      }, "typeDecorator");
    }, "decorateType");
  }
});

// node_modules/protobufjs/src/root.js
var require_root = __commonJS({
  "node_modules/protobufjs/src/root.js"(exports2, module2) {
    "use strict";
    module2.exports = Root;
    var Namespace = require_namespace();
    ((Root.prototype = Object.create(Namespace.prototype)).constructor = Root).className = "Root";
    var Field = require_field();
    var Enum = require_enum();
    var OneOf = require_oneof();
    var util2 = require_util3();
    var Type;
    var parse5;
    var common;
    function Root(options) {
      Namespace.call(this, "", options);
      this.deferred = [];
      this.files = [];
    }
    __name(Root, "Root");
    Root.fromJSON = /* @__PURE__ */ __name(function fromJSON(json, root) {
      if (!root) root = new Root();
      if (json.options) root.setOptions(json.options);
      return root.addJSON(json.nested);
    }, "fromJSON");
    Root.prototype.resolvePath = util2.path.resolve;
    Root.prototype.fetch = util2.fetch;
    function SYNC() {
    }
    __name(SYNC, "SYNC");
    Root.prototype.load = /* @__PURE__ */ __name(function load(filename, options, callback) {
      if (typeof options === "function") {
        callback = options;
        options = void 0;
      }
      var self2 = this;
      if (!callback) return util2.asPromise(load, self2, filename, options);
      var sync = callback === SYNC;
      function finish(err, root) {
        if (!callback) return;
        if (sync) throw err;
        var cb = callback;
        callback = null;
        cb(err, root);
      }
      __name(finish, "finish");
      function getBundledFileName(filename2) {
        var idx = filename2.lastIndexOf("google/protobuf/");
        if (idx > -1) {
          var altname = filename2.substring(idx);
          if (altname in common) return altname;
        }
        return null;
      }
      __name(getBundledFileName, "getBundledFileName");
      function process2(filename2, source) {
        try {
          if (util2.isString(source) && source.charAt(0) === "{") source = JSON.parse(source);
          if (!util2.isString(source)) self2.setOptions(source.options).addJSON(source.nested);
          else {
            parse5.filename = filename2;
            var parsed = parse5(source, self2, options), resolved2, i2 = 0;
            if (parsed.imports) {
              for (; i2 < parsed.imports.length; ++i2) if (resolved2 = getBundledFileName(parsed.imports[i2]) || self2.resolvePath(filename2, parsed.imports[i2])) fetch2(resolved2);
            }
            if (parsed.weakImports) {
              for (i2 = 0; i2 < parsed.weakImports.length; ++i2) if (resolved2 = getBundledFileName(parsed.weakImports[i2]) || self2.resolvePath(filename2, parsed.weakImports[i2])) fetch2(resolved2, true);
            }
          }
        } catch (err) {
          finish(err);
        }
        if (!sync && !queued) finish(null, self2);
      }
      __name(process2, "process");
      function fetch2(filename2, weak) {
        filename2 = getBundledFileName(filename2) || filename2;
        if (self2.files.indexOf(filename2) > -1) return;
        self2.files.push(filename2);
        if (filename2 in common) {
          if (sync) process2(filename2, common[filename2]);
          else {
            ++queued;
            setTimeout(function() {
              --queued;
              process2(filename2, common[filename2]);
            });
          }
          return;
        }
        if (sync) {
          var source;
          try {
            source = util2.fs.readFileSync(filename2).toString("utf8");
          } catch (err) {
            if (!weak) finish(err);
            return;
          }
          process2(filename2, source);
        } else {
          ++queued;
          self2.fetch(filename2, function(err, source2) {
            --queued;
            if (!callback) return;
            if (err) {
              if (!weak) finish(err);
              else if (!queued) finish(null, self2);
              return;
            }
            process2(filename2, source2);
          });
        }
      }
      __name(fetch2, "fetch");
      var queued = 0;
      if (util2.isString(filename)) filename = [
        filename
      ];
      for (var i = 0, resolved; i < filename.length; ++i) if (resolved = self2.resolvePath("", filename[i])) fetch2(resolved);
      if (sync) return self2;
      if (!queued) finish(null, self2);
      return void 0;
    }, "load");
    Root.prototype.loadSync = /* @__PURE__ */ __name(function loadSync(filename, options) {
      if (!util2.isNode) throw Error("not supported");
      return this.load(filename, options, SYNC);
    }, "loadSync");
    Root.prototype.resolveAll = /* @__PURE__ */ __name(function resolveAll() {
      if (this.deferred.length) throw Error("unresolvable extensions: " + this.deferred.map(function(field) {
        return "'extend " + field.extend + "' in " + field.parent.fullName;
      }).join(", "));
      return Namespace.prototype.resolveAll.call(this);
    }, "resolveAll");
    var exposeRe = /^[A-Z]/;
    function tryHandleExtension(root, field) {
      var extendedType = field.parent.lookup(field.extend);
      if (extendedType) {
        var sisterField = new Field(field.fullName, field.id, field.type, field.rule, void 0, field.options);
        if (extendedType.get(sisterField.name)) {
          return true;
        }
        sisterField.declaringField = field;
        field.extensionField = sisterField;
        extendedType.add(sisterField);
        return true;
      }
      return false;
    }
    __name(tryHandleExtension, "tryHandleExtension");
    Root.prototype._handleAdd = /* @__PURE__ */ __name(function _handleAdd(object) {
      if (object instanceof Field) {
        if (
          /* an extension field (implies not part of a oneof) */
          object.extend !== void 0 && /* not already handled */
          !object.extensionField
        ) {
          if (!tryHandleExtension(this, object)) this.deferred.push(object);
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name)) object.parent[object.name] = object.values;
      } else if (!(object instanceof OneOf)) {
        if (object instanceof Type) for (var i = 0; i < this.deferred.length; ) if (tryHandleExtension(this, this.deferred[i])) this.deferred.splice(i, 1);
        else ++i;
        for (var j = 0; j < /* initializes */
        object.nestedArray.length; ++j) this._handleAdd(object._nestedArray[j]);
        if (exposeRe.test(object.name)) object.parent[object.name] = object;
      }
    }, "_handleAdd");
    Root.prototype._handleRemove = /* @__PURE__ */ __name(function _handleRemove(object) {
      if (object instanceof Field) {
        if (
          /* an extension field */
          object.extend !== void 0
        ) {
          if (
            /* already handled */
            object.extensionField
          ) {
            object.extensionField.parent.remove(object.extensionField);
            object.extensionField = null;
          } else {
            var index = this.deferred.indexOf(object);
            if (index > -1) this.deferred.splice(index, 1);
          }
        }
      } else if (object instanceof Enum) {
        if (exposeRe.test(object.name)) delete object.parent[object.name];
      } else if (object instanceof Namespace) {
        for (var i = 0; i < /* initializes */
        object.nestedArray.length; ++i) this._handleRemove(object._nestedArray[i]);
        if (exposeRe.test(object.name)) delete object.parent[object.name];
      }
    }, "_handleRemove");
    Root._configure = function(Type_, parse_, common_) {
      Type = Type_;
      parse5 = parse_;
      common = common_;
    };
  }
});

// node_modules/protobufjs/src/util.js
var require_util3 = __commonJS({
  "node_modules/protobufjs/src/util.js"(exports2, module2) {
    "use strict";
    var util2 = module2.exports = require_minimal();
    var roots = require_roots();
    var Type;
    var Enum;
    util2.codegen = require_codegen();
    util2.fetch = require_fetch();
    util2.path = require_path();
    util2.fs = util2.inquire("fs");
    util2.toArray = /* @__PURE__ */ __name(function toArray(object) {
      if (object) {
        var keys = Object.keys(object), array = new Array(keys.length), index = 0;
        while (index < keys.length) array[index] = object[keys[index++]];
        return array;
      }
      return [];
    }, "toArray");
    util2.toObject = /* @__PURE__ */ __name(function toObject(array) {
      var object = {}, index = 0;
      while (index < array.length) {
        var key = array[index++], val = array[index++];
        if (val !== void 0) object[key] = val;
      }
      return object;
    }, "toObject");
    var safePropBackslashRe = /\\/g;
    var safePropQuoteRe = /"/g;
    util2.isReserved = /* @__PURE__ */ __name(function isReserved(name) {
      return /^(?:do|if|in|for|let|new|try|var|case|else|enum|eval|false|null|this|true|void|with|break|catch|class|const|super|throw|while|yield|delete|export|import|public|return|static|switch|typeof|default|extends|finally|package|private|continue|debugger|function|arguments|interface|protected|implements|instanceof)$/.test(name);
    }, "isReserved");
    util2.safeProp = /* @__PURE__ */ __name(function safeProp(prop) {
      if (!/^[$\w_]+$/.test(prop) || util2.isReserved(prop)) return '["' + prop.replace(safePropBackslashRe, "\\\\").replace(safePropQuoteRe, '\\"') + '"]';
      return "." + prop;
    }, "safeProp");
    util2.ucFirst = /* @__PURE__ */ __name(function ucFirst(str) {
      return str.charAt(0).toUpperCase() + str.substring(1);
    }, "ucFirst");
    var camelCaseRe = /_([a-z])/g;
    util2.camelCase = /* @__PURE__ */ __name(function camelCase2(str) {
      return str.substring(0, 1) + str.substring(1).replace(camelCaseRe, function($0, $1) {
        return $1.toUpperCase();
      });
    }, "camelCase");
    util2.compareFieldsById = /* @__PURE__ */ __name(function compareFieldsById(a, b) {
      return a.id - b.id;
    }, "compareFieldsById");
    util2.decorateType = /* @__PURE__ */ __name(function decorateType(ctor, typeName) {
      if (ctor.$type) {
        if (typeName && ctor.$type.name !== typeName) {
          util2.decorateRoot.remove(ctor.$type);
          ctor.$type.name = typeName;
          util2.decorateRoot.add(ctor.$type);
        }
        return ctor.$type;
      }
      if (!Type) Type = require_type();
      var type = new Type(typeName || ctor.name);
      util2.decorateRoot.add(type);
      type.ctor = ctor;
      Object.defineProperty(ctor, "$type", {
        value: type,
        enumerable: false
      });
      Object.defineProperty(ctor.prototype, "$type", {
        value: type,
        enumerable: false
      });
      return type;
    }, "decorateType");
    var decorateEnumIndex = 0;
    util2.decorateEnum = /* @__PURE__ */ __name(function decorateEnum(object) {
      if (object.$type) return object.$type;
      if (!Enum) Enum = require_enum();
      var enm = new Enum("Enum" + decorateEnumIndex++, object);
      util2.decorateRoot.add(enm);
      Object.defineProperty(object, "$type", {
        value: enm,
        enumerable: false
      });
      return enm;
    }, "decorateEnum");
    util2.setProperty = /* @__PURE__ */ __name(function setProperty(dst, path, value2) {
      function setProp(dst2, path2, value3) {
        var part = path2.shift();
        if (part === "__proto__" || part === "prototype") {
          return dst2;
        }
        if (path2.length > 0) {
          dst2[part] = setProp(dst2[part] || {}, path2, value3);
        } else {
          var prevValue = dst2[part];
          if (prevValue) value3 = [].concat(prevValue).concat(value3);
          dst2[part] = value3;
        }
        return dst2;
      }
      __name(setProp, "setProp");
      if (typeof dst !== "object") throw TypeError("dst must be an object");
      if (!path) throw TypeError("path must be specified");
      path = path.split(".");
      return setProp(dst, path, value2);
    }, "setProperty");
    Object.defineProperty(util2, "decorateRoot", {
      get: /* @__PURE__ */ __name(function() {
        return roots["decorated"] || (roots["decorated"] = new (require_root())());
      }, "get")
    });
  }
});

// node_modules/protobufjs/src/object.js
var require_object = __commonJS({
  "node_modules/protobufjs/src/object.js"(exports2, module2) {
    "use strict";
    module2.exports = ReflectionObject;
    ReflectionObject.className = "ReflectionObject";
    var util2 = require_util3();
    var Root;
    function ReflectionObject(name, options) {
      if (!util2.isString(name)) throw TypeError("name must be a string");
      if (options && !util2.isObject(options)) throw TypeError("options must be an object");
      this.options = options;
      this.parsedOptions = null;
      this.name = name;
      this.parent = null;
      this.resolved = false;
      this.comment = null;
      this.filename = null;
    }
    __name(ReflectionObject, "ReflectionObject");
    Object.defineProperties(ReflectionObject.prototype, {
      /**
       * Reference to the root namespace.
       * @name ReflectionObject#root
       * @type {Root}
       * @readonly
       */
      root: {
        get: /* @__PURE__ */ __name(function() {
          var ptr = this;
          while (ptr.parent !== null) ptr = ptr.parent;
          return ptr;
        }, "get")
      },
      /**
       * Full name including leading dot.
       * @name ReflectionObject#fullName
       * @type {string}
       * @readonly
       */
      fullName: {
        get: /* @__PURE__ */ __name(function() {
          var path = [
            this.name
          ], ptr = this.parent;
          while (ptr) {
            path.unshift(ptr.name);
            ptr = ptr.parent;
          }
          return path.join(".");
        }, "get")
      }
    });
    ReflectionObject.prototype.toJSON = /* istanbul ignore next */
    /* @__PURE__ */ __name(function toJSON() {
      throw Error();
    }, "toJSON");
    ReflectionObject.prototype.onAdd = /* @__PURE__ */ __name(function onAdd(parent) {
      if (this.parent && this.parent !== parent) this.parent.remove(this);
      this.parent = parent;
      this.resolved = false;
      var root = parent.root;
      if (root instanceof Root) root._handleAdd(this);
    }, "onAdd");
    ReflectionObject.prototype.onRemove = /* @__PURE__ */ __name(function onRemove(parent) {
      var root = parent.root;
      if (root instanceof Root) root._handleRemove(this);
      this.parent = null;
      this.resolved = false;
    }, "onRemove");
    ReflectionObject.prototype.resolve = /* @__PURE__ */ __name(function resolve5() {
      if (this.resolved) return this;
      if (this.root instanceof Root) this.resolved = true;
      return this;
    }, "resolve");
    ReflectionObject.prototype.getOption = /* @__PURE__ */ __name(function getOption(name) {
      if (this.options) return this.options[name];
      return void 0;
    }, "getOption");
    ReflectionObject.prototype.setOption = /* @__PURE__ */ __name(function setOption(name, value2, ifNotSet) {
      if (!ifNotSet || !this.options || this.options[name] === void 0) (this.options || (this.options = {}))[name] = value2;
      return this;
    }, "setOption");
    ReflectionObject.prototype.setParsedOption = /* @__PURE__ */ __name(function setParsedOption(name, value2, propName) {
      if (!this.parsedOptions) {
        this.parsedOptions = [];
      }
      var parsedOptions = this.parsedOptions;
      if (propName) {
        var opt = parsedOptions.find(function(opt2) {
          return Object.prototype.hasOwnProperty.call(opt2, name);
        });
        if (opt) {
          var newValue = opt[name];
          util2.setProperty(newValue, propName, value2);
        } else {
          opt = {};
          opt[name] = util2.setProperty({}, propName, value2);
          parsedOptions.push(opt);
        }
      } else {
        var newOpt = {};
        newOpt[name] = value2;
        parsedOptions.push(newOpt);
      }
      return this;
    }, "setParsedOption");
    ReflectionObject.prototype.setOptions = /* @__PURE__ */ __name(function setOptions(options, ifNotSet) {
      if (options) for (var keys = Object.keys(options), i = 0; i < keys.length; ++i) this.setOption(keys[i], options[keys[i]], ifNotSet);
      return this;
    }, "setOptions");
    ReflectionObject.prototype.toString = /* @__PURE__ */ __name(function toString2() {
      var className = this.constructor.className, fullName = this.fullName;
      if (fullName.length) return className + " " + fullName;
      return className;
    }, "toString");
    ReflectionObject._configure = function(Root_) {
      Root = Root_;
    };
  }
});

// node_modules/protobufjs/src/enum.js
var require_enum = __commonJS({
  "node_modules/protobufjs/src/enum.js"(exports2, module2) {
    "use strict";
    module2.exports = Enum;
    var ReflectionObject = require_object();
    ((Enum.prototype = Object.create(ReflectionObject.prototype)).constructor = Enum).className = "Enum";
    var Namespace = require_namespace();
    var util2 = require_util3();
    function Enum(name, values, options, comment, comments, valuesOptions) {
      ReflectionObject.call(this, name, options);
      if (values && typeof values !== "object") throw TypeError("values must be an object");
      this.valuesById = {};
      this.values = Object.create(this.valuesById);
      this.comment = comment;
      this.comments = comments || {};
      this.valuesOptions = valuesOptions;
      this.reserved = void 0;
      if (values) {
        for (var keys = Object.keys(values), i = 0; i < keys.length; ++i) if (typeof values[keys[i]] === "number") this.valuesById[this.values[keys[i]] = values[keys[i]]] = keys[i];
      }
    }
    __name(Enum, "Enum");
    Enum.fromJSON = /* @__PURE__ */ __name(function fromJSON(name, json) {
      var enm = new Enum(name, json.values, json.options, json.comment, json.comments);
      enm.reserved = json.reserved;
      return enm;
    }, "fromJSON");
    Enum.prototype.toJSON = /* @__PURE__ */ __name(function toJSON(toJSONOptions) {
      var keepComments = toJSONOptions ? Boolean(toJSONOptions.keepComments) : false;
      return util2.toObject([
        "options",
        this.options,
        "valuesOptions",
        this.valuesOptions,
        "values",
        this.values,
        "reserved",
        this.reserved && this.reserved.length ? this.reserved : void 0,
        "comment",
        keepComments ? this.comment : void 0,
        "comments",
        keepComments ? this.comments : void 0
      ]);
    }, "toJSON");
    Enum.prototype.add = /* @__PURE__ */ __name(function add(name, id, comment, options) {
      if (!util2.isString(name)) throw TypeError("name must be a string");
      if (!util2.isInteger(id)) throw TypeError("id must be an integer");
      if (this.values[name] !== void 0) throw Error("duplicate name '" + name + "' in " + this);
      if (this.isReservedId(id)) throw Error("id " + id + " is reserved in " + this);
      if (this.isReservedName(name)) throw Error("name '" + name + "' is reserved in " + this);
      if (this.valuesById[id] !== void 0) {
        if (!(this.options && this.options.allow_alias)) throw Error("duplicate id " + id + " in " + this);
        this.values[name] = id;
      } else this.valuesById[this.values[name] = id] = name;
      if (options) {
        if (this.valuesOptions === void 0) this.valuesOptions = {};
        this.valuesOptions[name] = options || null;
      }
      this.comments[name] = comment || null;
      return this;
    }, "add");
    Enum.prototype.remove = /* @__PURE__ */ __name(function remove(name) {
      if (!util2.isString(name)) throw TypeError("name must be a string");
      var val = this.values[name];
      if (val == null) throw Error("name '" + name + "' does not exist in " + this);
      delete this.valuesById[val];
      delete this.values[name];
      delete this.comments[name];
      if (this.valuesOptions) delete this.valuesOptions[name];
      return this;
    }, "remove");
    Enum.prototype.isReservedId = /* @__PURE__ */ __name(function isReservedId(id) {
      return Namespace.isReservedId(this.reserved, id);
    }, "isReservedId");
    Enum.prototype.isReservedName = /* @__PURE__ */ __name(function isReservedName(name) {
      return Namespace.isReservedName(this.reserved, name);
    }, "isReservedName");
  }
});

// node_modules/protobufjs/src/encoder.js
var require_encoder = __commonJS({
  "node_modules/protobufjs/src/encoder.js"(exports2, module2) {
    "use strict";
    module2.exports = encoder;
    var Enum = require_enum();
    var types = require_types2();
    var util2 = require_util3();
    function genTypePartial(gen, field, fieldIndex, ref) {
      return field.resolvedType.group ? gen("types[%i].encode(%s,w.uint32(%i)).uint32(%i)", fieldIndex, ref, (field.id << 3 | 3) >>> 0, (field.id << 3 | 4) >>> 0) : gen("types[%i].encode(%s,w.uint32(%i).fork()).ldelim()", fieldIndex, ref, (field.id << 3 | 2) >>> 0);
    }
    __name(genTypePartial, "genTypePartial");
    function encoder(mtype) {
      var gen = util2.codegen([
        "m",
        "w"
      ], mtype.name + "$encode")("if(!w)")("w=Writer.create()");
      var i, ref;
      var fields = (
        /* initializes */
        mtype.fieldsArray.slice().sort(util2.compareFieldsById)
      );
      for (var i = 0; i < fields.length; ++i) {
        var field = fields[i].resolve(), index = mtype._fieldsArray.indexOf(field), type = field.resolvedType instanceof Enum ? "int32" : field.type, wireType = types.basic[type];
        ref = "m" + util2.safeProp(field.name);
        if (field.map) {
          gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j)){", ref, field.name)("for(var ks=Object.keys(%s),i=0;i<ks.length;++i){", ref)("w.uint32(%i).fork().uint32(%i).%s(ks[i])", (field.id << 3 | 2) >>> 0, 8 | types.mapKey[field.keyType], field.keyType);
          if (wireType === void 0) gen("types[%i].encode(%s[ks[i]],w.uint32(18).fork()).ldelim().ldelim()", index, ref);
          else gen(".uint32(%i).%s(%s[ks[i]]).ldelim()", 16 | wireType, type, ref);
          gen("}")("}");
        } else if (field.repeated) {
          gen("if(%s!=null&&%s.length){", ref, ref);
          if (field.packed && types.packed[type] !== void 0) {
            gen("w.uint32(%i).fork()", (field.id << 3 | 2) >>> 0)("for(var i=0;i<%s.length;++i)", ref)("w.%s(%s[i])", type, ref)("w.ldelim()");
          } else {
            gen("for(var i=0;i<%s.length;++i)", ref);
            if (wireType === void 0) genTypePartial(gen, field, index, ref + "[i]");
            else gen("w.uint32(%i).%s(%s[i])", (field.id << 3 | wireType) >>> 0, type, ref);
          }
          gen("}");
        } else {
          if (field.optional) gen("if(%s!=null&&Object.hasOwnProperty.call(m,%j))", ref, field.name);
          if (wireType === void 0) genTypePartial(gen, field, index, ref);
          else gen("w.uint32(%i).%s(%s)", (field.id << 3 | wireType) >>> 0, type, ref);
        }
      }
      return gen("return w");
    }
    __name(encoder, "encoder");
  }
});

// node_modules/protobufjs/src/index-light.js
var require_index_light = __commonJS({
  "node_modules/protobufjs/src/index-light.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_minimal();
    protobuf.build = "light";
    function load(filename, root, callback) {
      if (typeof root === "function") {
        callback = root;
        root = new protobuf.Root();
      } else if (!root) root = new protobuf.Root();
      return root.load(filename, callback);
    }
    __name(load, "load");
    protobuf.load = load;
    function loadSync(filename, root) {
      if (!root) root = new protobuf.Root();
      return root.loadSync(filename);
    }
    __name(loadSync, "loadSync");
    protobuf.loadSync = loadSync;
    protobuf.encoder = require_encoder();
    protobuf.decoder = require_decoder();
    protobuf.verifier = require_verifier();
    protobuf.converter = require_converter();
    protobuf.ReflectionObject = require_object();
    protobuf.Namespace = require_namespace();
    protobuf.Root = require_root();
    protobuf.Enum = require_enum();
    protobuf.Type = require_type();
    protobuf.Field = require_field();
    protobuf.OneOf = require_oneof();
    protobuf.MapField = require_mapfield();
    protobuf.Service = require_service3();
    protobuf.Method = require_method();
    protobuf.Message = require_message();
    protobuf.wrappers = require_wrappers();
    protobuf.types = require_types2();
    protobuf.util = require_util3();
    protobuf.ReflectionObject._configure(protobuf.Root);
    protobuf.Namespace._configure(protobuf.Type, protobuf.Service, protobuf.Enum);
    protobuf.Root._configure(protobuf.Type);
    protobuf.Field._configure(protobuf.Type);
  }
});

// node_modules/protobufjs/src/tokenize.js
var require_tokenize = __commonJS({
  "node_modules/protobufjs/src/tokenize.js"(exports2, module2) {
    "use strict";
    module2.exports = tokenize;
    var delimRe = /[\s{}=;:[\],'"()<>]/g;
    var stringDoubleRe = /(?:"([^"\\]*(?:\\.[^"\\]*)*)")/g;
    var stringSingleRe = /(?:'([^'\\]*(?:\\.[^'\\]*)*)')/g;
    var setCommentRe = /^ *[*/]+ */;
    var setCommentAltRe = /^\s*\*?\/*/;
    var setCommentSplitRe = /\n/g;
    var whitespaceRe = /\s/;
    var unescapeRe = /\\(.?)/g;
    var unescapeMap = {
      "0": "\0",
      "r": "\r",
      "n": "\n",
      "t": "	"
    };
    function unescape2(str) {
      return str.replace(unescapeRe, function($0, $1) {
        switch ($1) {
          case "\\":
          case "":
            return $1;
          default:
            return unescapeMap[$1] || "";
        }
      });
    }
    __name(unescape2, "unescape");
    tokenize.unescape = unescape2;
    function tokenize(source, alternateCommentMode) {
      source = source.toString();
      var offset = 0, length = source.length, line = 1, lastCommentLine = 0, comments = {};
      var stack = [];
      var stringDelim = null;
      function illegal(subject) {
        return Error("illegal " + subject + " (line " + line + ")");
      }
      __name(illegal, "illegal");
      function readString() {
        var re2 = stringDelim === "'" ? stringSingleRe : stringDoubleRe;
        re2.lastIndex = offset - 1;
        var match = re2.exec(source);
        if (!match) throw illegal("string");
        offset = re2.lastIndex;
        push(stringDelim);
        stringDelim = null;
        return unescape2(match[1]);
      }
      __name(readString, "readString");
      function charAt(pos) {
        return source.charAt(pos);
      }
      __name(charAt, "charAt");
      function setComment(start, end, isLeading) {
        var comment = {
          type: source.charAt(start++),
          lineEmpty: false,
          leading: isLeading
        };
        var lookback;
        if (alternateCommentMode) {
          lookback = 2;
        } else {
          lookback = 3;
        }
        var commentOffset = start - lookback, c;
        do {
          if (--commentOffset < 0 || (c = source.charAt(commentOffset)) === "\n") {
            comment.lineEmpty = true;
            break;
          }
        } while (c === " " || c === "	");
        var lines = source.substring(start, end).split(setCommentSplitRe);
        for (var i = 0; i < lines.length; ++i) lines[i] = lines[i].replace(alternateCommentMode ? setCommentAltRe : setCommentRe, "").trim();
        comment.text = lines.join("\n").trim();
        comments[line] = comment;
        lastCommentLine = line;
      }
      __name(setComment, "setComment");
      function isDoubleSlashCommentLine(startOffset) {
        var endOffset = findEndOfLine(startOffset);
        var lineText = source.substring(startOffset, endOffset);
        var isComment = /^\s*\/\//.test(lineText);
        return isComment;
      }
      __name(isDoubleSlashCommentLine, "isDoubleSlashCommentLine");
      function findEndOfLine(cursor) {
        var endOffset = cursor;
        while (endOffset < length && charAt(endOffset) !== "\n") {
          endOffset++;
        }
        return endOffset;
      }
      __name(findEndOfLine, "findEndOfLine");
      function next() {
        if (stack.length > 0) return stack.shift();
        if (stringDelim) return readString();
        var repeat, prev, curr, start, isDoc, isLeadingComment = offset === 0;
        do {
          if (offset === length) return null;
          repeat = false;
          while (whitespaceRe.test(curr = charAt(offset))) {
            if (curr === "\n") {
              isLeadingComment = true;
              ++line;
            }
            if (++offset === length) return null;
          }
          if (charAt(offset) === "/") {
            if (++offset === length) {
              throw illegal("comment");
            }
            if (charAt(offset) === "/") {
              if (!alternateCommentMode) {
                isDoc = charAt(start = offset + 1) === "/";
                while (charAt(++offset) !== "\n") {
                  if (offset === length) {
                    return null;
                  }
                }
                ++offset;
                if (isDoc) {
                  setComment(start, offset - 1, isLeadingComment);
                  isLeadingComment = true;
                }
                ++line;
                repeat = true;
              } else {
                start = offset;
                isDoc = false;
                if (isDoubleSlashCommentLine(offset - 1)) {
                  isDoc = true;
                  do {
                    offset = findEndOfLine(offset);
                    if (offset === length) {
                      break;
                    }
                    offset++;
                    if (!isLeadingComment) {
                      break;
                    }
                  } while (isDoubleSlashCommentLine(offset));
                } else {
                  offset = Math.min(length, findEndOfLine(offset) + 1);
                }
                if (isDoc) {
                  setComment(start, offset, isLeadingComment);
                  isLeadingComment = true;
                }
                line++;
                repeat = true;
              }
            } else if ((curr = charAt(offset)) === "*") {
              start = offset + 1;
              isDoc = alternateCommentMode || charAt(start) === "*";
              do {
                if (curr === "\n") {
                  ++line;
                }
                if (++offset === length) {
                  throw illegal("comment");
                }
                prev = curr;
                curr = charAt(offset);
              } while (prev !== "*" || curr !== "/");
              ++offset;
              if (isDoc) {
                setComment(start, offset - 2, isLeadingComment);
                isLeadingComment = true;
              }
              repeat = true;
            } else {
              return "/";
            }
          }
        } while (repeat);
        var end = offset;
        delimRe.lastIndex = 0;
        var delim = delimRe.test(charAt(end++));
        if (!delim) while (end < length && !delimRe.test(charAt(end))) ++end;
        var token2 = source.substring(offset, offset = end);
        if (token2 === '"' || token2 === "'") stringDelim = token2;
        return token2;
      }
      __name(next, "next");
      function push(token2) {
        stack.push(token2);
      }
      __name(push, "push");
      function peek() {
        if (!stack.length) {
          var token2 = next();
          if (token2 === null) return null;
          push(token2);
        }
        return stack[0];
      }
      __name(peek, "peek");
      function skip(expected, optional) {
        var actual = peek(), equals = actual === expected;
        if (equals) {
          next();
          return true;
        }
        if (!optional) throw illegal("token '" + actual + "', '" + expected + "' expected");
        return false;
      }
      __name(skip, "skip");
      function cmnt(trailingLine) {
        var ret = null;
        var comment;
        if (trailingLine === void 0) {
          comment = comments[line - 1];
          delete comments[line - 1];
          if (comment && (alternateCommentMode || comment.type === "*" || comment.lineEmpty)) {
            ret = comment.leading ? comment.text : null;
          }
        } else {
          if (lastCommentLine < trailingLine) {
            peek();
          }
          comment = comments[trailingLine];
          delete comments[trailingLine];
          if (comment && !comment.lineEmpty && (alternateCommentMode || comment.type === "/")) {
            ret = comment.leading ? null : comment.text;
          }
        }
        return ret;
      }
      __name(cmnt, "cmnt");
      return Object.defineProperty({
        next,
        peek,
        push,
        skip,
        cmnt
      }, "line", {
        get: /* @__PURE__ */ __name(function() {
          return line;
        }, "get")
      });
    }
    __name(tokenize, "tokenize");
  }
});

// node_modules/protobufjs/src/parse.js
var require_parse = __commonJS({
  "node_modules/protobufjs/src/parse.js"(exports2, module2) {
    "use strict";
    module2.exports = parse5;
    parse5.filename = null;
    parse5.defaults = {
      keepCase: false
    };
    var tokenize = require_tokenize();
    var Root = require_root();
    var Type = require_type();
    var Field = require_field();
    var MapField = require_mapfield();
    var OneOf = require_oneof();
    var Enum = require_enum();
    var Service = require_service3();
    var Method = require_method();
    var types = require_types2();
    var util2 = require_util3();
    var base10Re = /^[1-9][0-9]*$/;
    var base10NegRe = /^-?[1-9][0-9]*$/;
    var base16Re = /^0[x][0-9a-fA-F]+$/;
    var base16NegRe = /^-?0[x][0-9a-fA-F]+$/;
    var base8Re = /^0[0-7]+$/;
    var base8NegRe = /^-?0[0-7]+$/;
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    var nameRe = /^[a-zA-Z_][a-zA-Z_0-9]*$/;
    var typeRefRe = /^(?:\.?[a-zA-Z_][a-zA-Z_0-9]*)(?:\.[a-zA-Z_][a-zA-Z_0-9]*)*$/;
    var fqTypeRefRe = /^(?:\.[a-zA-Z_][a-zA-Z_0-9]*)+$/;
    function parse5(source, root, options) {
      if (!(root instanceof Root)) {
        options = root;
        root = new Root();
      }
      if (!options) options = parse5.defaults;
      var preferTrailingComment = options.preferTrailingComment || false;
      var tn = tokenize(source, options.alternateCommentMode || false), next = tn.next, push = tn.push, peek = tn.peek, skip = tn.skip, cmnt = tn.cmnt;
      var head = true, pkg, imports, weakImports, syntax, isProto3 = false;
      var ptr = root;
      var applyCase = options.keepCase ? function(name) {
        return name;
      } : util2.camelCase;
      function illegal(token3, name, insideTryCatch) {
        var filename = parse5.filename;
        if (!insideTryCatch) parse5.filename = null;
        return Error("illegal " + (name || "token") + " '" + token3 + "' (" + (filename ? filename + ", " : "") + "line " + tn.line + ")");
      }
      __name(illegal, "illegal");
      function readString() {
        var values = [], token3;
        do {
          if ((token3 = next()) !== '"' && token3 !== "'") throw illegal(token3);
          values.push(next());
          skip(token3);
          token3 = peek();
        } while (token3 === '"' || token3 === "'");
        return values.join("");
      }
      __name(readString, "readString");
      function readValue(acceptTypeRef) {
        var token3 = next();
        switch (token3) {
          case "'":
          case '"':
            push(token3);
            return readString();
          case "true":
          case "TRUE":
            return true;
          case "false":
          case "FALSE":
            return false;
        }
        try {
          return parseNumber(
            token3,
            /* insideTryCatch */
            true
          );
        } catch (e) {
          if (acceptTypeRef && typeRefRe.test(token3)) return token3;
          throw illegal(token3, "value");
        }
      }
      __name(readValue, "readValue");
      function readRanges(target, acceptStrings) {
        var token3, start;
        do {
          if (acceptStrings && ((token3 = peek()) === '"' || token3 === "'")) target.push(readString());
          else target.push([
            start = parseId(next()),
            skip("to", true) ? parseId(next()) : start
          ]);
        } while (skip(",", true));
        var dummy = {
          options: void 0
        };
        dummy.setOption = function(name, value2) {
          if (this.options === void 0) this.options = {};
          this.options[name] = value2;
        };
        ifBlock(dummy, /* @__PURE__ */ __name(function parseRange_block(token4) {
          if (token4 === "option") {
            parseOption(dummy, token4);
            skip(";");
          } else throw illegal(token4);
        }, "parseRange_block"), /* @__PURE__ */ __name(function parseRange_line() {
          parseInlineOptions(dummy);
        }, "parseRange_line"));
      }
      __name(readRanges, "readRanges");
      function parseNumber(token3, insideTryCatch) {
        var sign = 1;
        if (token3.charAt(0) === "-") {
          sign = -1;
          token3 = token3.substring(1);
        }
        switch (token3) {
          case "inf":
          case "INF":
          case "Inf":
            return sign * Infinity;
          case "nan":
          case "NAN":
          case "Nan":
          case "NaN":
            return NaN;
          case "0":
            return 0;
        }
        if (base10Re.test(token3)) return sign * parseInt(token3, 10);
        if (base16Re.test(token3)) return sign * parseInt(token3, 16);
        if (base8Re.test(token3)) return sign * parseInt(token3, 8);
        if (numberRe.test(token3)) return sign * parseFloat(token3);
        throw illegal(token3, "number", insideTryCatch);
      }
      __name(parseNumber, "parseNumber");
      function parseId(token3, acceptNegative) {
        switch (token3) {
          case "max":
          case "MAX":
          case "Max":
            return 536870911;
          case "0":
            return 0;
        }
        if (!acceptNegative && token3.charAt(0) === "-") throw illegal(token3, "id");
        if (base10NegRe.test(token3)) return parseInt(token3, 10);
        if (base16NegRe.test(token3)) return parseInt(token3, 16);
        if (base8NegRe.test(token3)) return parseInt(token3, 8);
        throw illegal(token3, "id");
      }
      __name(parseId, "parseId");
      function parsePackage() {
        if (pkg !== void 0) throw illegal("package");
        pkg = next();
        if (!typeRefRe.test(pkg)) throw illegal(pkg, "name");
        ptr = ptr.define(pkg);
        skip(";");
      }
      __name(parsePackage, "parsePackage");
      function parseImport() {
        var token3 = peek();
        var whichImports;
        switch (token3) {
          case "weak":
            whichImports = weakImports || (weakImports = []);
            next();
            break;
          case "public":
            next();
          // eslint-disable-next-line no-fallthrough
          default:
            whichImports = imports || (imports = []);
            break;
        }
        token3 = readString();
        skip(";");
        whichImports.push(token3);
      }
      __name(parseImport, "parseImport");
      function parseSyntax() {
        skip("=");
        syntax = readString();
        isProto3 = syntax === "proto3";
        if (!isProto3 && syntax !== "proto2") throw illegal(syntax, "syntax");
        root.setOption("syntax", syntax);
        skip(";");
      }
      __name(parseSyntax, "parseSyntax");
      function parseCommon(parent, token3) {
        switch (token3) {
          case "option":
            parseOption(parent, token3);
            skip(";");
            return true;
          case "message":
            parseType(parent, token3);
            return true;
          case "enum":
            parseEnum(parent, token3);
            return true;
          case "service":
            parseService(parent, token3);
            return true;
          case "extend":
            parseExtension(parent, token3);
            return true;
        }
        return false;
      }
      __name(parseCommon, "parseCommon");
      function ifBlock(obj, fnIf, fnElse) {
        var trailingLine = tn.line;
        if (obj) {
          if (typeof obj.comment !== "string") {
            obj.comment = cmnt();
          }
          obj.filename = parse5.filename;
        }
        if (skip("{", true)) {
          var token3;
          while ((token3 = next()) !== "}") fnIf(token3);
          skip(";", true);
        } else {
          if (fnElse) fnElse();
          skip(";");
          if (obj && (typeof obj.comment !== "string" || preferTrailingComment)) obj.comment = cmnt(trailingLine) || obj.comment;
        }
      }
      __name(ifBlock, "ifBlock");
      function parseType(parent, token3) {
        if (!nameRe.test(token3 = next())) throw illegal(token3, "type name");
        var type = new Type(token3);
        ifBlock(type, /* @__PURE__ */ __name(function parseType_block(token4) {
          if (parseCommon(type, token4)) return;
          switch (token4) {
            case "map":
              parseMapField(type, token4);
              break;
            case "required":
            case "repeated":
              parseField(type, token4);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "oneof":
              parseOneOf(type, token4);
              break;
            case "extensions":
              readRanges(type.extensions || (type.extensions = []));
              break;
            case "reserved":
              readRanges(type.reserved || (type.reserved = []), true);
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token4)) throw illegal(token4);
              push(token4);
              parseField(type, "optional");
              break;
          }
        }, "parseType_block"));
        parent.add(type);
      }
      __name(parseType, "parseType");
      function parseField(parent, rule, extend) {
        var type = next();
        if (type === "group") {
          parseGroup(parent, rule);
          return;
        }
        while (type.endsWith(".") || peek().startsWith(".")) {
          type += next();
        }
        if (!typeRefRe.test(type)) throw illegal(type, "type");
        var name = next();
        if (!nameRe.test(name)) throw illegal(name, "name");
        name = applyCase(name);
        skip("=");
        var field = new Field(name, parseId(next()), type, rule, extend);
        ifBlock(field, /* @__PURE__ */ __name(function parseField_block(token3) {
          if (token3 === "option") {
            parseOption(field, token3);
            skip(";");
          } else throw illegal(token3);
        }, "parseField_block"), /* @__PURE__ */ __name(function parseField_line() {
          parseInlineOptions(field);
        }, "parseField_line"));
        if (rule === "proto3_optional") {
          var oneof = new OneOf("_" + name);
          field.setOption("proto3_optional", true);
          oneof.add(field);
          parent.add(oneof);
        } else {
          parent.add(field);
        }
        if (!isProto3 && field.repeated && (types.packed[type] !== void 0 || types.basic[type] === void 0)) field.setOption(
          "packed",
          false,
          /* ifNotSet */
          true
        );
      }
      __name(parseField, "parseField");
      function parseGroup(parent, rule) {
        var name = next();
        if (!nameRe.test(name)) throw illegal(name, "name");
        var fieldName = util2.lcFirst(name);
        if (name === fieldName) name = util2.ucFirst(name);
        skip("=");
        var id = parseId(next());
        var type = new Type(name);
        type.group = true;
        var field = new Field(fieldName, id, name, rule);
        field.filename = parse5.filename;
        ifBlock(type, /* @__PURE__ */ __name(function parseGroup_block(token3) {
          switch (token3) {
            case "option":
              parseOption(type, token3);
              skip(";");
              break;
            case "required":
            case "repeated":
              parseField(type, token3);
              break;
            case "optional":
              if (isProto3) {
                parseField(type, "proto3_optional");
              } else {
                parseField(type, "optional");
              }
              break;
            case "message":
              parseType(type, token3);
              break;
            case "enum":
              parseEnum(type, token3);
              break;
            /* istanbul ignore next */
            default:
              throw illegal(token3);
          }
        }, "parseGroup_block"));
        parent.add(type).add(field);
      }
      __name(parseGroup, "parseGroup");
      function parseMapField(parent) {
        skip("<");
        var keyType = next();
        if (types.mapKey[keyType] === void 0) throw illegal(keyType, "type");
        skip(",");
        var valueType = next();
        if (!typeRefRe.test(valueType)) throw illegal(valueType, "type");
        skip(">");
        var name = next();
        if (!nameRe.test(name)) throw illegal(name, "name");
        skip("=");
        var field = new MapField(applyCase(name), parseId(next()), keyType, valueType);
        ifBlock(field, /* @__PURE__ */ __name(function parseMapField_block(token3) {
          if (token3 === "option") {
            parseOption(field, token3);
            skip(";");
          } else throw illegal(token3);
        }, "parseMapField_block"), /* @__PURE__ */ __name(function parseMapField_line() {
          parseInlineOptions(field);
        }, "parseMapField_line"));
        parent.add(field);
      }
      __name(parseMapField, "parseMapField");
      function parseOneOf(parent, token3) {
        if (!nameRe.test(token3 = next())) throw illegal(token3, "name");
        var oneof = new OneOf(applyCase(token3));
        ifBlock(oneof, /* @__PURE__ */ __name(function parseOneOf_block(token4) {
          if (token4 === "option") {
            parseOption(oneof, token4);
            skip(";");
          } else {
            push(token4);
            parseField(oneof, "optional");
          }
        }, "parseOneOf_block"));
        parent.add(oneof);
      }
      __name(parseOneOf, "parseOneOf");
      function parseEnum(parent, token3) {
        if (!nameRe.test(token3 = next())) throw illegal(token3, "name");
        var enm = new Enum(token3);
        ifBlock(enm, /* @__PURE__ */ __name(function parseEnum_block(token4) {
          switch (token4) {
            case "option":
              parseOption(enm, token4);
              skip(";");
              break;
            case "reserved":
              readRanges(enm.reserved || (enm.reserved = []), true);
              break;
            default:
              parseEnumValue(enm, token4);
          }
        }, "parseEnum_block"));
        parent.add(enm);
      }
      __name(parseEnum, "parseEnum");
      function parseEnumValue(parent, token3) {
        if (!nameRe.test(token3)) throw illegal(token3, "name");
        skip("=");
        var value2 = parseId(next(), true), dummy = {
          options: void 0
        };
        dummy.setOption = function(name, value3) {
          if (this.options === void 0) this.options = {};
          this.options[name] = value3;
        };
        ifBlock(dummy, /* @__PURE__ */ __name(function parseEnumValue_block(token4) {
          if (token4 === "option") {
            parseOption(dummy, token4);
            skip(";");
          } else throw illegal(token4);
        }, "parseEnumValue_block"), /* @__PURE__ */ __name(function parseEnumValue_line() {
          parseInlineOptions(dummy);
        }, "parseEnumValue_line"));
        parent.add(token3, value2, dummy.comment, dummy.options);
      }
      __name(parseEnumValue, "parseEnumValue");
      function parseOption(parent, token3) {
        var isCustom = skip("(", true);
        if (!typeRefRe.test(token3 = next())) throw illegal(token3, "name");
        var name = token3;
        var option = name;
        var propName;
        if (isCustom) {
          skip(")");
          name = "(" + name + ")";
          option = name;
          token3 = peek();
          if (fqTypeRefRe.test(token3)) {
            propName = token3.slice(1);
            name += token3;
            next();
          }
        }
        skip("=");
        var optionValue = parseOptionValue(parent, name);
        setParsedOption(parent, option, optionValue, propName);
      }
      __name(parseOption, "parseOption");
      function parseOptionValue(parent, name) {
        if (skip("{", true)) {
          var objectResult = {};
          while (!skip("}", true)) {
            if (!nameRe.test(token2 = next())) {
              throw illegal(token2, "name");
            }
            if (token2 === null) {
              throw illegal(token2, "end of input");
            }
            var value2;
            var propName = token2;
            skip(":", true);
            if (peek() === "{") value2 = parseOptionValue(parent, name + "." + token2);
            else if (peek() === "[") {
              value2 = [];
              var lastValue;
              if (skip("[", true)) {
                do {
                  lastValue = readValue(true);
                  value2.push(lastValue);
                } while (skip(",", true));
                skip("]");
                if (typeof lastValue !== "undefined") {
                  setOption(parent, name + "." + token2, lastValue);
                }
              }
            } else {
              value2 = readValue(true);
              setOption(parent, name + "." + token2, value2);
            }
            var prevValue = objectResult[propName];
            if (prevValue) value2 = [].concat(prevValue).concat(value2);
            objectResult[propName] = value2;
            skip(",", true);
            skip(";", true);
          }
          return objectResult;
        }
        var simpleValue = readValue(true);
        setOption(parent, name, simpleValue);
        return simpleValue;
      }
      __name(parseOptionValue, "parseOptionValue");
      function setOption(parent, name, value2) {
        if (parent.setOption) parent.setOption(name, value2);
      }
      __name(setOption, "setOption");
      function setParsedOption(parent, name, value2, propName) {
        if (parent.setParsedOption) parent.setParsedOption(name, value2, propName);
      }
      __name(setParsedOption, "setParsedOption");
      function parseInlineOptions(parent) {
        if (skip("[", true)) {
          do {
            parseOption(parent, "option");
          } while (skip(",", true));
          skip("]");
        }
        return parent;
      }
      __name(parseInlineOptions, "parseInlineOptions");
      function parseService(parent, token3) {
        if (!nameRe.test(token3 = next())) throw illegal(token3, "service name");
        var service = new Service(token3);
        ifBlock(service, /* @__PURE__ */ __name(function parseService_block(token4) {
          if (parseCommon(service, token4)) return;
          if (token4 === "rpc") parseMethod(service, token4);
          else throw illegal(token4);
        }, "parseService_block"));
        parent.add(service);
      }
      __name(parseService, "parseService");
      function parseMethod(parent, token3) {
        var commentText = cmnt();
        var type = token3;
        if (!nameRe.test(token3 = next())) throw illegal(token3, "name");
        var name = token3, requestType, requestStream, responseType, responseStream;
        skip("(");
        if (skip("stream", true)) requestStream = true;
        if (!typeRefRe.test(token3 = next())) throw illegal(token3);
        requestType = token3;
        skip(")");
        skip("returns");
        skip("(");
        if (skip("stream", true)) responseStream = true;
        if (!typeRefRe.test(token3 = next())) throw illegal(token3);
        responseType = token3;
        skip(")");
        var method = new Method(name, type, requestType, responseType, requestStream, responseStream);
        method.comment = commentText;
        ifBlock(method, /* @__PURE__ */ __name(function parseMethod_block(token4) {
          if (token4 === "option") {
            parseOption(method, token4);
            skip(";");
          } else throw illegal(token4);
        }, "parseMethod_block"));
        parent.add(method);
      }
      __name(parseMethod, "parseMethod");
      function parseExtension(parent, token3) {
        if (!typeRefRe.test(token3 = next())) throw illegal(token3, "reference");
        var reference = token3;
        ifBlock(null, /* @__PURE__ */ __name(function parseExtension_block(token4) {
          switch (token4) {
            case "required":
            case "repeated":
              parseField(parent, token4, reference);
              break;
            case "optional":
              if (isProto3) {
                parseField(parent, "proto3_optional", reference);
              } else {
                parseField(parent, "optional", reference);
              }
              break;
            default:
              if (!isProto3 || !typeRefRe.test(token4)) throw illegal(token4);
              push(token4);
              parseField(parent, "optional", reference);
              break;
          }
        }, "parseExtension_block"));
      }
      __name(parseExtension, "parseExtension");
      var token2;
      while ((token2 = next()) !== null) {
        switch (token2) {
          case "package":
            if (!head) throw illegal(token2);
            parsePackage();
            break;
          case "import":
            if (!head) throw illegal(token2);
            parseImport();
            break;
          case "syntax":
            if (!head) throw illegal(token2);
            parseSyntax();
            break;
          case "option":
            parseOption(ptr, token2);
            skip(";");
            break;
          default:
            if (parseCommon(ptr, token2)) {
              head = false;
              continue;
            }
            throw illegal(token2);
        }
      }
      parse5.filename = null;
      return {
        "package": pkg,
        "imports": imports,
        weakImports,
        syntax,
        root
      };
    }
    __name(parse5, "parse");
  }
});

// node_modules/protobufjs/src/common.js
var require_common6 = __commonJS({
  "node_modules/protobufjs/src/common.js"(exports2, module2) {
    "use strict";
    module2.exports = common;
    var commonRe = /\/|\./;
    function common(name, json) {
      if (!commonRe.test(name)) {
        name = "google/protobuf/" + name + ".proto";
        json = {
          nested: {
            google: {
              nested: {
                protobuf: {
                  nested: json
                }
              }
            }
          }
        };
      }
      common[name] = json;
    }
    __name(common, "common");
    common("any", {
      /**
       * Properties of a google.protobuf.Any message.
       * @interface IAny
       * @type {Object}
       * @property {string} [typeUrl]
       * @property {Uint8Array} [bytes]
       * @memberof common
       */
      Any: {
        fields: {
          type_url: {
            type: "string",
            id: 1
          },
          value: {
            type: "bytes",
            id: 2
          }
        }
      }
    });
    var timeType;
    common("duration", {
      /**
       * Properties of a google.protobuf.Duration message.
       * @interface IDuration
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Duration: timeType = {
        fields: {
          seconds: {
            type: "int64",
            id: 1
          },
          nanos: {
            type: "int32",
            id: 2
          }
        }
      }
    });
    common("timestamp", {
      /**
       * Properties of a google.protobuf.Timestamp message.
       * @interface ITimestamp
       * @type {Object}
       * @property {number|Long} [seconds]
       * @property {number} [nanos]
       * @memberof common
       */
      Timestamp: timeType
    });
    common("empty", {
      /**
       * Properties of a google.protobuf.Empty message.
       * @interface IEmpty
       * @memberof common
       */
      Empty: {
        fields: {}
      }
    });
    common("struct", {
      /**
       * Properties of a google.protobuf.Struct message.
       * @interface IStruct
       * @type {Object}
       * @property {Object.<string,IValue>} [fields]
       * @memberof common
       */
      Struct: {
        fields: {
          fields: {
            keyType: "string",
            type: "Value",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Value message.
       * @interface IValue
       * @type {Object}
       * @property {string} [kind]
       * @property {0} [nullValue]
       * @property {number} [numberValue]
       * @property {string} [stringValue]
       * @property {boolean} [boolValue]
       * @property {IStruct} [structValue]
       * @property {IListValue} [listValue]
       * @memberof common
       */
      Value: {
        oneofs: {
          kind: {
            oneof: [
              "nullValue",
              "numberValue",
              "stringValue",
              "boolValue",
              "structValue",
              "listValue"
            ]
          }
        },
        fields: {
          nullValue: {
            type: "NullValue",
            id: 1
          },
          numberValue: {
            type: "double",
            id: 2
          },
          stringValue: {
            type: "string",
            id: 3
          },
          boolValue: {
            type: "bool",
            id: 4
          },
          structValue: {
            type: "Struct",
            id: 5
          },
          listValue: {
            type: "ListValue",
            id: 6
          }
        }
      },
      NullValue: {
        values: {
          NULL_VALUE: 0
        }
      },
      /**
       * Properties of a google.protobuf.ListValue message.
       * @interface IListValue
       * @type {Object}
       * @property {Array.<IValue>} [values]
       * @memberof common
       */
      ListValue: {
        fields: {
          values: {
            rule: "repeated",
            type: "Value",
            id: 1
          }
        }
      }
    });
    common("wrappers", {
      /**
       * Properties of a google.protobuf.DoubleValue message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      DoubleValue: {
        fields: {
          value: {
            type: "double",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.FloatValue message.
       * @interface IFloatValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FloatValue: {
        fields: {
          value: {
            type: "float",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int64Value message.
       * @interface IInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      Int64Value: {
        fields: {
          value: {
            type: "int64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt64Value message.
       * @interface IUInt64Value
       * @type {Object}
       * @property {number|Long} [value]
       * @memberof common
       */
      UInt64Value: {
        fields: {
          value: {
            type: "uint64",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.Int32Value message.
       * @interface IInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      Int32Value: {
        fields: {
          value: {
            type: "int32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.UInt32Value message.
       * @interface IUInt32Value
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      UInt32Value: {
        fields: {
          value: {
            type: "uint32",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BoolValue message.
       * @interface IBoolValue
       * @type {Object}
       * @property {boolean} [value]
       * @memberof common
       */
      BoolValue: {
        fields: {
          value: {
            type: "bool",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.StringValue message.
       * @interface IStringValue
       * @type {Object}
       * @property {string} [value]
       * @memberof common
       */
      StringValue: {
        fields: {
          value: {
            type: "string",
            id: 1
          }
        }
      },
      /**
       * Properties of a google.protobuf.BytesValue message.
       * @interface IBytesValue
       * @type {Object}
       * @property {Uint8Array} [value]
       * @memberof common
       */
      BytesValue: {
        fields: {
          value: {
            type: "bytes",
            id: 1
          }
        }
      }
    });
    common("field_mask", {
      /**
       * Properties of a google.protobuf.FieldMask message.
       * @interface IDoubleValue
       * @type {Object}
       * @property {number} [value]
       * @memberof common
       */
      FieldMask: {
        fields: {
          paths: {
            rule: "repeated",
            type: "string",
            id: 1
          }
        }
      }
    });
    common.get = /* @__PURE__ */ __name(function get(file) {
      return common[file] || null;
    }, "get");
  }
});

// node_modules/protobufjs/src/index.js
var require_src5 = __commonJS({
  "node_modules/protobufjs/src/index.js"(exports2, module2) {
    "use strict";
    var protobuf = module2.exports = require_index_light();
    protobuf.build = "full";
    protobuf.tokenize = require_tokenize();
    protobuf.parse = require_parse();
    protobuf.common = require_common6();
    protobuf.Root._configure(protobuf.Type, protobuf.parse, protobuf.common);
  }
});

// node_modules/protobufjs/index.js
var require_protobufjs = __commonJS({
  "node_modules/protobufjs/index.js"(exports2, module2) {
    "use strict";
    module2.exports = require_src5();
  }
});

// node_modules/protobufjs/google/protobuf/descriptor.json
var require_descriptor = __commonJS({
  "node_modules/protobufjs/google/protobuf/descriptor.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                FileDescriptorSet: {
                  fields: {
                    file: {
                      rule: "repeated",
                      type: "FileDescriptorProto",
                      id: 1
                    }
                  }
                },
                FileDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    package: {
                      type: "string",
                      id: 2
                    },
                    dependency: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    publicDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 10,
                      options: {
                        packed: false
                      }
                    },
                    weakDependency: {
                      rule: "repeated",
                      type: "int32",
                      id: 11,
                      options: {
                        packed: false
                      }
                    },
                    messageType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 4
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 5
                    },
                    service: {
                      rule: "repeated",
                      type: "ServiceDescriptorProto",
                      id: 6
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 7
                    },
                    options: {
                      type: "FileOptions",
                      id: 8
                    },
                    sourceCodeInfo: {
                      type: "SourceCodeInfo",
                      id: 9
                    },
                    syntax: {
                      type: "string",
                      id: 12
                    }
                  }
                },
                DescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    field: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 2
                    },
                    extension: {
                      rule: "repeated",
                      type: "FieldDescriptorProto",
                      id: 6
                    },
                    nestedType: {
                      rule: "repeated",
                      type: "DescriptorProto",
                      id: 3
                    },
                    enumType: {
                      rule: "repeated",
                      type: "EnumDescriptorProto",
                      id: 4
                    },
                    extensionRange: {
                      rule: "repeated",
                      type: "ExtensionRange",
                      id: 5
                    },
                    oneofDecl: {
                      rule: "repeated",
                      type: "OneofDescriptorProto",
                      id: 8
                    },
                    options: {
                      type: "MessageOptions",
                      id: 7
                    },
                    reservedRange: {
                      rule: "repeated",
                      type: "ReservedRange",
                      id: 9
                    },
                    reservedName: {
                      rule: "repeated",
                      type: "string",
                      id: 10
                    }
                  },
                  nested: {
                    ExtensionRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    },
                    ReservedRange: {
                      fields: {
                        start: {
                          type: "int32",
                          id: 1
                        },
                        end: {
                          type: "int32",
                          id: 2
                        }
                      }
                    }
                  }
                },
                FieldDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    label: {
                      type: "Label",
                      id: 4
                    },
                    type: {
                      type: "Type",
                      id: 5
                    },
                    typeName: {
                      type: "string",
                      id: 6
                    },
                    extendee: {
                      type: "string",
                      id: 2
                    },
                    defaultValue: {
                      type: "string",
                      id: 7
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    options: {
                      type: "FieldOptions",
                      id: 8
                    }
                  },
                  nested: {
                    Type: {
                      values: {
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Label: {
                      values: {
                        LABEL_OPTIONAL: 1,
                        LABEL_REQUIRED: 2,
                        LABEL_REPEATED: 3
                      }
                    }
                  }
                },
                OneofDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    options: {
                      type: "OneofOptions",
                      id: 2
                    }
                  }
                },
                EnumDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      rule: "repeated",
                      type: "EnumValueDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "EnumOptions",
                      id: 3
                    }
                  }
                },
                EnumValueDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      type: "EnumValueOptions",
                      id: 3
                    }
                  }
                },
                ServiceDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    method: {
                      rule: "repeated",
                      type: "MethodDescriptorProto",
                      id: 2
                    },
                    options: {
                      type: "ServiceOptions",
                      id: 3
                    }
                  }
                },
                MethodDescriptorProto: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    inputType: {
                      type: "string",
                      id: 2
                    },
                    outputType: {
                      type: "string",
                      id: 3
                    },
                    options: {
                      type: "MethodOptions",
                      id: 4
                    },
                    clientStreaming: {
                      type: "bool",
                      id: 5
                    },
                    serverStreaming: {
                      type: "bool",
                      id: 6
                    }
                  }
                },
                FileOptions: {
                  fields: {
                    javaPackage: {
                      type: "string",
                      id: 1
                    },
                    javaOuterClassname: {
                      type: "string",
                      id: 8
                    },
                    javaMultipleFiles: {
                      type: "bool",
                      id: 10
                    },
                    javaGenerateEqualsAndHash: {
                      type: "bool",
                      id: 20,
                      options: {
                        deprecated: true
                      }
                    },
                    javaStringCheckUtf8: {
                      type: "bool",
                      id: 27
                    },
                    optimizeFor: {
                      type: "OptimizeMode",
                      id: 9,
                      options: {
                        default: "SPEED"
                      }
                    },
                    goPackage: {
                      type: "string",
                      id: 11
                    },
                    ccGenericServices: {
                      type: "bool",
                      id: 16
                    },
                    javaGenericServices: {
                      type: "bool",
                      id: 17
                    },
                    pyGenericServices: {
                      type: "bool",
                      id: 18
                    },
                    deprecated: {
                      type: "bool",
                      id: 23
                    },
                    ccEnableArenas: {
                      type: "bool",
                      id: 31
                    },
                    objcClassPrefix: {
                      type: "string",
                      id: 36
                    },
                    csharpNamespace: {
                      type: "string",
                      id: 37
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      38,
                      38
                    ]
                  ],
                  nested: {
                    OptimizeMode: {
                      values: {
                        SPEED: 1,
                        CODE_SIZE: 2,
                        LITE_RUNTIME: 3
                      }
                    }
                  }
                },
                MessageOptions: {
                  fields: {
                    messageSetWireFormat: {
                      type: "bool",
                      id: 1
                    },
                    noStandardDescriptorAccessor: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    mapEntry: {
                      type: "bool",
                      id: 7
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      8,
                      8
                    ]
                  ]
                },
                FieldOptions: {
                  fields: {
                    ctype: {
                      type: "CType",
                      id: 1,
                      options: {
                        default: "STRING"
                      }
                    },
                    packed: {
                      type: "bool",
                      id: 2
                    },
                    jstype: {
                      type: "JSType",
                      id: 6,
                      options: {
                        default: "JS_NORMAL"
                      }
                    },
                    lazy: {
                      type: "bool",
                      id: 5
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    weak: {
                      type: "bool",
                      id: 10
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ],
                  reserved: [
                    [
                      4,
                      4
                    ]
                  ],
                  nested: {
                    CType: {
                      values: {
                        STRING: 0,
                        CORD: 1,
                        STRING_PIECE: 2
                      }
                    },
                    JSType: {
                      values: {
                        JS_NORMAL: 0,
                        JS_STRING: 1,
                        JS_NUMBER: 2
                      }
                    }
                  }
                },
                OneofOptions: {
                  fields: {
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumOptions: {
                  fields: {
                    allowAlias: {
                      type: "bool",
                      id: 2
                    },
                    deprecated: {
                      type: "bool",
                      id: 3
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                EnumValueOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 1
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                ServiceOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                MethodOptions: {
                  fields: {
                    deprecated: {
                      type: "bool",
                      id: 33
                    },
                    uninterpretedOption: {
                      rule: "repeated",
                      type: "UninterpretedOption",
                      id: 999
                    }
                  },
                  extensions: [
                    [
                      1e3,
                      536870911
                    ]
                  ]
                },
                UninterpretedOption: {
                  fields: {
                    name: {
                      rule: "repeated",
                      type: "NamePart",
                      id: 2
                    },
                    identifierValue: {
                      type: "string",
                      id: 3
                    },
                    positiveIntValue: {
                      type: "uint64",
                      id: 4
                    },
                    negativeIntValue: {
                      type: "int64",
                      id: 5
                    },
                    doubleValue: {
                      type: "double",
                      id: 6
                    },
                    stringValue: {
                      type: "bytes",
                      id: 7
                    },
                    aggregateValue: {
                      type: "string",
                      id: 8
                    }
                  },
                  nested: {
                    NamePart: {
                      fields: {
                        namePart: {
                          rule: "required",
                          type: "string",
                          id: 1
                        },
                        isExtension: {
                          rule: "required",
                          type: "bool",
                          id: 2
                        }
                      }
                    }
                  }
                },
                SourceCodeInfo: {
                  fields: {
                    location: {
                      rule: "repeated",
                      type: "Location",
                      id: 1
                    }
                  },
                  nested: {
                    Location: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        span: {
                          rule: "repeated",
                          type: "int32",
                          id: 2
                        },
                        leadingComments: {
                          type: "string",
                          id: 3
                        },
                        trailingComments: {
                          type: "string",
                          id: 4
                        },
                        leadingDetachedComments: {
                          rule: "repeated",
                          type: "string",
                          id: 6
                        }
                      }
                    }
                  }
                },
                GeneratedCodeInfo: {
                  fields: {
                    annotation: {
                      rule: "repeated",
                      type: "Annotation",
                      id: 1
                    }
                  },
                  nested: {
                    Annotation: {
                      fields: {
                        path: {
                          rule: "repeated",
                          type: "int32",
                          id: 1
                        },
                        sourceFile: {
                          type: "string",
                          id: 2
                        },
                        begin: {
                          type: "int32",
                          id: 3
                        },
                        end: {
                          type: "int32",
                          id: 4
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/ext/descriptor/index.js
var require_descriptor2 = __commonJS({
  "node_modules/protobufjs/ext/descriptor/index.js"(exports2, module2) {
    "use strict";
    var $protobuf = require_protobufjs();
    module2.exports = exports2 = $protobuf.descriptor = $protobuf.Root.fromJSON(require_descriptor()).lookup(".google.protobuf");
    var Namespace = $protobuf.Namespace;
    var Root = $protobuf.Root;
    var Enum = $protobuf.Enum;
    var Type = $protobuf.Type;
    var Field = $protobuf.Field;
    var MapField = $protobuf.MapField;
    var OneOf = $protobuf.OneOf;
    var Service = $protobuf.Service;
    var Method = $protobuf.Method;
    Root.fromDescriptor = /* @__PURE__ */ __name(function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number") descriptor = exports2.FileDescriptorSet.decode(descriptor);
      var root = new Root();
      if (descriptor.file) {
        var fileDescriptor, filePackage;
        for (var j = 0, i; j < descriptor.file.length; ++j) {
          filePackage = root;
          if ((fileDescriptor = descriptor.file[j])["package"] && fileDescriptor["package"].length) filePackage = root.define(fileDescriptor["package"]);
          if (fileDescriptor.name && fileDescriptor.name.length) root.files.push(filePackage.filename = fileDescriptor.name);
          if (fileDescriptor.messageType) for (i = 0; i < fileDescriptor.messageType.length; ++i) filePackage.add(Type.fromDescriptor(fileDescriptor.messageType[i], fileDescriptor.syntax));
          if (fileDescriptor.enumType) for (i = 0; i < fileDescriptor.enumType.length; ++i) filePackage.add(Enum.fromDescriptor(fileDescriptor.enumType[i]));
          if (fileDescriptor.extension) for (i = 0; i < fileDescriptor.extension.length; ++i) filePackage.add(Field.fromDescriptor(fileDescriptor.extension[i]));
          if (fileDescriptor.service) for (i = 0; i < fileDescriptor.service.length; ++i) filePackage.add(Service.fromDescriptor(fileDescriptor.service[i]));
          var opts = fromDescriptorOptions(fileDescriptor.options, exports2.FileOptions);
          if (opts) {
            var ks = Object.keys(opts);
            for (i = 0; i < ks.length; ++i) filePackage.setOption(ks[i], opts[ks[i]]);
          }
        }
      }
      return root;
    }, "fromDescriptor");
    Root.prototype.toDescriptor = /* @__PURE__ */ __name(function toDescriptor(syntax) {
      var set = exports2.FileDescriptorSet.create();
      Root_toDescriptorRecursive(this, set.file, syntax);
      return set;
    }, "toDescriptor");
    function Root_toDescriptorRecursive(ns, files, syntax) {
      var file = exports2.FileDescriptorProto.create({
        name: ns.filename || (ns.fullName.substring(1).replace(/\./g, "_") || "root") + ".proto"
      });
      if (syntax) file.syntax = syntax;
      if (!(ns instanceof Root)) file["package"] = ns.fullName.substring(1);
      for (var i = 0, nested; i < ns.nestedArray.length; ++i) if ((nested = ns._nestedArray[i]) instanceof Type) file.messageType.push(nested.toDescriptor(syntax));
      else if (nested instanceof Enum) file.enumType.push(nested.toDescriptor());
      else if (nested instanceof Field) file.extension.push(nested.toDescriptor(syntax));
      else if (nested instanceof Service) file.service.push(nested.toDescriptor());
      else if (nested instanceof /* plain */
      Namespace) Root_toDescriptorRecursive(nested, files, syntax);
      file.options = toDescriptorOptions(ns.options, exports2.FileOptions);
      if (file.messageType.length + file.enumType.length + file.extension.length + file.service.length) files.push(file);
    }
    __name(Root_toDescriptorRecursive, "Root_toDescriptorRecursive");
    var unnamedMessageIndex = 0;
    Type.fromDescriptor = /* @__PURE__ */ __name(function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number") descriptor = exports2.DescriptorProto.decode(descriptor);
      var type = new Type(descriptor.name.length ? descriptor.name : "Type" + unnamedMessageIndex++, fromDescriptorOptions(descriptor.options, exports2.MessageOptions)), i;
      if (descriptor.oneofDecl) for (i = 0; i < descriptor.oneofDecl.length; ++i) type.add(OneOf.fromDescriptor(descriptor.oneofDecl[i]));
      if (descriptor.field) for (i = 0; i < descriptor.field.length; ++i) {
        var field = Field.fromDescriptor(descriptor.field[i], syntax);
        type.add(field);
        if (descriptor.field[i].hasOwnProperty("oneofIndex")) type.oneofsArray[descriptor.field[i].oneofIndex].add(field);
      }
      if (descriptor.extension) for (i = 0; i < descriptor.extension.length; ++i) type.add(Field.fromDescriptor(descriptor.extension[i], syntax));
      if (descriptor.nestedType) for (i = 0; i < descriptor.nestedType.length; ++i) {
        type.add(Type.fromDescriptor(descriptor.nestedType[i], syntax));
        if (descriptor.nestedType[i].options && descriptor.nestedType[i].options.mapEntry) type.setOption("map_entry", true);
      }
      if (descriptor.enumType) for (i = 0; i < descriptor.enumType.length; ++i) type.add(Enum.fromDescriptor(descriptor.enumType[i]));
      if (descriptor.extensionRange && descriptor.extensionRange.length) {
        type.extensions = [];
        for (i = 0; i < descriptor.extensionRange.length; ++i) type.extensions.push([
          descriptor.extensionRange[i].start,
          descriptor.extensionRange[i].end
        ]);
      }
      if (descriptor.reservedRange && descriptor.reservedRange.length || descriptor.reservedName && descriptor.reservedName.length) {
        type.reserved = [];
        if (descriptor.reservedRange) for (i = 0; i < descriptor.reservedRange.length; ++i) type.reserved.push([
          descriptor.reservedRange[i].start,
          descriptor.reservedRange[i].end
        ]);
        if (descriptor.reservedName) for (i = 0; i < descriptor.reservedName.length; ++i) type.reserved.push(descriptor.reservedName[i]);
      }
      return type;
    }, "fromDescriptor");
    Type.prototype.toDescriptor = /* @__PURE__ */ __name(function toDescriptor(syntax) {
      var descriptor = exports2.DescriptorProto.create({
        name: this.name
      }), i;
      for (i = 0; i < this.fieldsArray.length; ++i) {
        var fieldDescriptor;
        descriptor.field.push(fieldDescriptor = this._fieldsArray[i].toDescriptor(syntax));
        if (this._fieldsArray[i] instanceof MapField) {
          var keyType = toDescriptorType(this._fieldsArray[i].keyType, this._fieldsArray[i].resolvedKeyType), valueType = toDescriptorType(this._fieldsArray[i].type, this._fieldsArray[i].resolvedType), valueTypeName = valueType === /* type */
          11 || valueType === /* enum */
          14 ? this._fieldsArray[i].resolvedType && shortname(this.parent, this._fieldsArray[i].resolvedType) || this._fieldsArray[i].type : void 0;
          descriptor.nestedType.push(exports2.DescriptorProto.create({
            name: fieldDescriptor.typeName,
            field: [
              exports2.FieldDescriptorProto.create({
                name: "key",
                number: 1,
                label: 1,
                type: keyType
              }),
              exports2.FieldDescriptorProto.create({
                name: "value",
                number: 2,
                label: 1,
                type: valueType,
                typeName: valueTypeName
              })
            ],
            options: exports2.MessageOptions.create({
              mapEntry: true
            })
          }));
        }
      }
      for (i = 0; i < this.oneofsArray.length; ++i) descriptor.oneofDecl.push(this._oneofsArray[i].toDescriptor());
      for (i = 0; i < this.nestedArray.length; ++i) {
        if (this._nestedArray[i] instanceof Field) descriptor.field.push(this._nestedArray[i].toDescriptor(syntax));
        else if (this._nestedArray[i] instanceof Type) descriptor.nestedType.push(this._nestedArray[i].toDescriptor(syntax));
        else if (this._nestedArray[i] instanceof Enum) descriptor.enumType.push(this._nestedArray[i].toDescriptor());
      }
      if (this.extensions) for (i = 0; i < this.extensions.length; ++i) descriptor.extensionRange.push(exports2.DescriptorProto.ExtensionRange.create({
        start: this.extensions[i][0],
        end: this.extensions[i][1]
      }));
      if (this.reserved) for (i = 0; i < this.reserved.length; ++i) if (typeof this.reserved[i] === "string") descriptor.reservedName.push(this.reserved[i]);
      else descriptor.reservedRange.push(exports2.DescriptorProto.ReservedRange.create({
        start: this.reserved[i][0],
        end: this.reserved[i][1]
      }));
      descriptor.options = toDescriptorOptions(this.options, exports2.MessageOptions);
      return descriptor;
    }, "toDescriptor");
    var numberRe = /^(?![eE])[0-9]*(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?$/;
    Field.fromDescriptor = /* @__PURE__ */ __name(function fromDescriptor(descriptor, syntax) {
      if (typeof descriptor.length === "number") descriptor = exports2.DescriptorProto.decode(descriptor);
      if (typeof descriptor.number !== "number") throw Error("missing field id");
      var fieldType;
      if (descriptor.typeName && descriptor.typeName.length) fieldType = descriptor.typeName;
      else fieldType = fromDescriptorType(descriptor.type);
      var fieldRule;
      switch (descriptor.label) {
        // 0 is reserved for errors
        case 1:
          fieldRule = void 0;
          break;
        case 2:
          fieldRule = "required";
          break;
        case 3:
          fieldRule = "repeated";
          break;
        default:
          throw Error("illegal label: " + descriptor.label);
      }
      var extendee = descriptor.extendee;
      if (descriptor.extendee !== void 0) {
        extendee = extendee.length ? extendee : void 0;
      }
      var field = new Field(descriptor.name.length ? descriptor.name : "field" + descriptor.number, descriptor.number, fieldType, fieldRule, extendee);
      field.options = fromDescriptorOptions(descriptor.options, exports2.FieldOptions);
      if (descriptor.defaultValue && descriptor.defaultValue.length) {
        var defaultValue = descriptor.defaultValue;
        switch (defaultValue) {
          case "true":
          case "TRUE":
            defaultValue = true;
            break;
          case "false":
          case "FALSE":
            defaultValue = false;
            break;
          default:
            var match = numberRe.exec(defaultValue);
            if (match) defaultValue = parseInt(defaultValue);
            break;
        }
        field.setOption("default", defaultValue);
      }
      if (packableDescriptorType(descriptor.type)) {
        if (syntax === "proto3") {
          if (descriptor.options && !descriptor.options.packed) field.setOption("packed", false);
        } else if (!(descriptor.options && descriptor.options.packed)) field.setOption("packed", false);
      }
      return field;
    }, "fromDescriptor");
    Field.prototype.toDescriptor = /* @__PURE__ */ __name(function toDescriptor(syntax) {
      var descriptor = exports2.FieldDescriptorProto.create({
        name: this.name,
        number: this.id
      });
      if (this.map) {
        descriptor.type = 11;
        descriptor.typeName = $protobuf.util.ucFirst(this.name);
        descriptor.label = 3;
      } else {
        switch (descriptor.type = toDescriptorType(this.type, this.resolve().resolvedType)) {
          case 10:
          case 11:
          case 14:
            descriptor.typeName = this.resolvedType ? shortname(this.parent, this.resolvedType) : this.type;
            break;
        }
        switch (this.rule) {
          case "repeated":
            descriptor.label = 3;
            break;
          case "required":
            descriptor.label = 2;
            break;
          default:
            descriptor.label = 1;
            break;
        }
      }
      descriptor.extendee = this.extensionField ? this.extensionField.parent.fullName : this.extend;
      if (this.partOf) {
        if ((descriptor.oneofIndex = this.parent.oneofsArray.indexOf(this.partOf)) < 0) throw Error("missing oneof");
      }
      if (this.options) {
        descriptor.options = toDescriptorOptions(this.options, exports2.FieldOptions);
        if (this.options["default"] != null) descriptor.defaultValue = String(this.options["default"]);
      }
      if (syntax === "proto3") {
        if (!this.packed) (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = false;
      } else if (this.packed) (descriptor.options || (descriptor.options = exports2.FieldOptions.create())).packed = true;
      return descriptor;
    }, "toDescriptor");
    var unnamedEnumIndex = 0;
    Enum.fromDescriptor = /* @__PURE__ */ __name(function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number") descriptor = exports2.EnumDescriptorProto.decode(descriptor);
      var values = {};
      if (descriptor.value) for (var i = 0; i < descriptor.value.length; ++i) {
        var name = descriptor.value[i].name, value2 = descriptor.value[i].number || 0;
        values[name && name.length ? name : "NAME" + value2] = value2;
      }
      return new Enum(descriptor.name && descriptor.name.length ? descriptor.name : "Enum" + unnamedEnumIndex++, values, fromDescriptorOptions(descriptor.options, exports2.EnumOptions));
    }, "fromDescriptor");
    Enum.prototype.toDescriptor = /* @__PURE__ */ __name(function toDescriptor() {
      var values = [];
      for (var i = 0, ks = Object.keys(this.values); i < ks.length; ++i) values.push(exports2.EnumValueDescriptorProto.create({
        name: ks[i],
        number: this.values[ks[i]]
      }));
      return exports2.EnumDescriptorProto.create({
        name: this.name,
        value: values,
        options: toDescriptorOptions(this.options, exports2.EnumOptions)
      });
    }, "toDescriptor");
    var unnamedOneofIndex = 0;
    OneOf.fromDescriptor = /* @__PURE__ */ __name(function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number") descriptor = exports2.OneofDescriptorProto.decode(descriptor);
      return new OneOf(
        // unnamedOneOfIndex is global, not per type, because we have no ref to a type here
        descriptor.name && descriptor.name.length ? descriptor.name : "oneof" + unnamedOneofIndex++
      );
    }, "fromDescriptor");
    OneOf.prototype.toDescriptor = /* @__PURE__ */ __name(function toDescriptor() {
      return exports2.OneofDescriptorProto.create({
        name: this.name
      });
    }, "toDescriptor");
    var unnamedServiceIndex = 0;
    Service.fromDescriptor = /* @__PURE__ */ __name(function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number") descriptor = exports2.ServiceDescriptorProto.decode(descriptor);
      var service = new Service(descriptor.name && descriptor.name.length ? descriptor.name : "Service" + unnamedServiceIndex++, fromDescriptorOptions(descriptor.options, exports2.ServiceOptions));
      if (descriptor.method) for (var i = 0; i < descriptor.method.length; ++i) service.add(Method.fromDescriptor(descriptor.method[i]));
      return service;
    }, "fromDescriptor");
    Service.prototype.toDescriptor = /* @__PURE__ */ __name(function toDescriptor() {
      var methods = [];
      for (var i = 0; i < this.methodsArray.length; ++i) methods.push(this._methodsArray[i].toDescriptor());
      return exports2.ServiceDescriptorProto.create({
        name: this.name,
        method: methods,
        options: toDescriptorOptions(this.options, exports2.ServiceOptions)
      });
    }, "toDescriptor");
    var unnamedMethodIndex = 0;
    Method.fromDescriptor = /* @__PURE__ */ __name(function fromDescriptor(descriptor) {
      if (typeof descriptor.length === "number") descriptor = exports2.MethodDescriptorProto.decode(descriptor);
      return new Method(
        // unnamedMethodIndex is global, not per service, because we have no ref to a service here
        descriptor.name && descriptor.name.length ? descriptor.name : "Method" + unnamedMethodIndex++,
        "rpc",
        descriptor.inputType,
        descriptor.outputType,
        Boolean(descriptor.clientStreaming),
        Boolean(descriptor.serverStreaming),
        fromDescriptorOptions(descriptor.options, exports2.MethodOptions)
      );
    }, "fromDescriptor");
    Method.prototype.toDescriptor = /* @__PURE__ */ __name(function toDescriptor() {
      return exports2.MethodDescriptorProto.create({
        name: this.name,
        inputType: this.resolvedRequestType ? this.resolvedRequestType.fullName : this.requestType,
        outputType: this.resolvedResponseType ? this.resolvedResponseType.fullName : this.responseType,
        clientStreaming: this.requestStream,
        serverStreaming: this.responseStream,
        options: toDescriptorOptions(this.options, exports2.MethodOptions)
      });
    }, "toDescriptor");
    function fromDescriptorType(type) {
      switch (type) {
        // 0 is reserved for errors
        case 1:
          return "double";
        case 2:
          return "float";
        case 3:
          return "int64";
        case 4:
          return "uint64";
        case 5:
          return "int32";
        case 6:
          return "fixed64";
        case 7:
          return "fixed32";
        case 8:
          return "bool";
        case 9:
          return "string";
        case 12:
          return "bytes";
        case 13:
          return "uint32";
        case 15:
          return "sfixed32";
        case 16:
          return "sfixed64";
        case 17:
          return "sint32";
        case 18:
          return "sint64";
      }
      throw Error("illegal type: " + type);
    }
    __name(fromDescriptorType, "fromDescriptorType");
    function packableDescriptorType(type) {
      switch (type) {
        case 1:
        case 2:
        case 3:
        case 4:
        case 5:
        case 6:
        case 7:
        case 8:
        case 13:
        case 14:
        case 15:
        case 16:
        case 17:
        case 18:
          return true;
      }
      return false;
    }
    __name(packableDescriptorType, "packableDescriptorType");
    function toDescriptorType(type, resolvedType) {
      switch (type) {
        // 0 is reserved for errors
        case "double":
          return 1;
        case "float":
          return 2;
        case "int64":
          return 3;
        case "uint64":
          return 4;
        case "int32":
          return 5;
        case "fixed64":
          return 6;
        case "fixed32":
          return 7;
        case "bool":
          return 8;
        case "string":
          return 9;
        case "bytes":
          return 12;
        case "uint32":
          return 13;
        case "sfixed32":
          return 15;
        case "sfixed64":
          return 16;
        case "sint32":
          return 17;
        case "sint64":
          return 18;
      }
      if (resolvedType instanceof Enum) return 14;
      if (resolvedType instanceof Type) return resolvedType.group ? 10 : 11;
      throw Error("illegal type: " + type);
    }
    __name(toDescriptorType, "toDescriptorType");
    function fromDescriptorOptions(options, type) {
      if (!options) return void 0;
      var out = [];
      for (var i = 0, field, key, val; i < type.fieldsArray.length; ++i) if ((key = (field = type._fieldsArray[i]).name) !== "uninterpretedOption") {
        if (options.hasOwnProperty(key)) {
          val = options[key];
          if (field.resolvedType instanceof Enum && typeof val === "number" && field.resolvedType.valuesById[val] !== void 0) val = field.resolvedType.valuesById[val];
          out.push(underScore(key), val);
        }
      }
      return out.length ? $protobuf.util.toObject(out) : void 0;
    }
    __name(fromDescriptorOptions, "fromDescriptorOptions");
    function toDescriptorOptions(options, type) {
      if (!options) return void 0;
      var out = [];
      for (var i = 0, ks = Object.keys(options), key, val; i < ks.length; ++i) {
        val = options[key = ks[i]];
        if (key === "default") continue;
        var field = type.fields[key];
        if (!field && !(field = type.fields[key = $protobuf.util.camelCase(key)])) continue;
        out.push(key, val);
      }
      return out.length ? type.fromObject($protobuf.util.toObject(out)) : void 0;
    }
    __name(toDescriptorOptions, "toDescriptorOptions");
    function shortname(from, to) {
      var fromPath = from.fullName.split("."), toPath = to.fullName.split("."), i = 0, j = 0, k = toPath.length - 1;
      if (!(from instanceof Root) && to instanceof Namespace) while (i < fromPath.length && j < k && fromPath[i] === toPath[j]) {
        var other = to.lookup(fromPath[i++], true);
        if (other !== null && other !== to) break;
        ++j;
      }
      else for (; i < fromPath.length && j < k && fromPath[i] === toPath[j]; ++i, ++j) ;
      return toPath.slice(j).join(".");
    }
    __name(shortname, "shortname");
    function underScore(str) {
      return str.substring(0, 1) + str.substring(1).replace(/([A-Z])(?=[a-z]|$)/g, function($0, $1) {
        return "_" + $1.toLowerCase();
      });
    }
    __name(underScore, "underScore");
  }
});

// node_modules/protobufjs/google/protobuf/api.json
var require_api = __commonJS({
  "node_modules/protobufjs/google/protobuf/api.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Api: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    methods: {
                      rule: "repeated",
                      type: "Method",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    version: {
                      type: "string",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    mixins: {
                      rule: "repeated",
                      type: "Mixin",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Method: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    requestTypeUrl: {
                      type: "string",
                      id: 2
                    },
                    requestStreaming: {
                      type: "bool",
                      id: 3
                    },
                    responseTypeUrl: {
                      type: "string",
                      id: 4
                    },
                    responseStreaming: {
                      type: "bool",
                      id: 5
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 6
                    },
                    syntax: {
                      type: "Syntax",
                      id: 7
                    }
                  }
                },
                Mixin: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    root: {
                      type: "string",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/source_context.json
var require_source_context = __commonJS({
  "node_modules/protobufjs/google/protobuf/source_context.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/protobufjs/google/protobuf/type.json
var require_type2 = __commonJS({
  "node_modules/protobufjs/google/protobuf/type.json"(exports2, module2) {
    module2.exports = {
      nested: {
        google: {
          nested: {
            protobuf: {
              nested: {
                Type: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    fields: {
                      rule: "repeated",
                      type: "Field",
                      id: 2
                    },
                    oneofs: {
                      rule: "repeated",
                      type: "string",
                      id: 3
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 4
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 5
                    },
                    syntax: {
                      type: "Syntax",
                      id: 6
                    }
                  }
                },
                Field: {
                  fields: {
                    kind: {
                      type: "Kind",
                      id: 1
                    },
                    cardinality: {
                      type: "Cardinality",
                      id: 2
                    },
                    number: {
                      type: "int32",
                      id: 3
                    },
                    name: {
                      type: "string",
                      id: 4
                    },
                    typeUrl: {
                      type: "string",
                      id: 6
                    },
                    oneofIndex: {
                      type: "int32",
                      id: 7
                    },
                    packed: {
                      type: "bool",
                      id: 8
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 9
                    },
                    jsonName: {
                      type: "string",
                      id: 10
                    },
                    defaultValue: {
                      type: "string",
                      id: 11
                    }
                  },
                  nested: {
                    Kind: {
                      values: {
                        TYPE_UNKNOWN: 0,
                        TYPE_DOUBLE: 1,
                        TYPE_FLOAT: 2,
                        TYPE_INT64: 3,
                        TYPE_UINT64: 4,
                        TYPE_INT32: 5,
                        TYPE_FIXED64: 6,
                        TYPE_FIXED32: 7,
                        TYPE_BOOL: 8,
                        TYPE_STRING: 9,
                        TYPE_GROUP: 10,
                        TYPE_MESSAGE: 11,
                        TYPE_BYTES: 12,
                        TYPE_UINT32: 13,
                        TYPE_ENUM: 14,
                        TYPE_SFIXED32: 15,
                        TYPE_SFIXED64: 16,
                        TYPE_SINT32: 17,
                        TYPE_SINT64: 18
                      }
                    },
                    Cardinality: {
                      values: {
                        CARDINALITY_UNKNOWN: 0,
                        CARDINALITY_OPTIONAL: 1,
                        CARDINALITY_REQUIRED: 2,
                        CARDINALITY_REPEATED: 3
                      }
                    }
                  }
                },
                Enum: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    enumvalue: {
                      rule: "repeated",
                      type: "EnumValue",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    },
                    sourceContext: {
                      type: "SourceContext",
                      id: 4
                    },
                    syntax: {
                      type: "Syntax",
                      id: 5
                    }
                  }
                },
                EnumValue: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    number: {
                      type: "int32",
                      id: 2
                    },
                    options: {
                      rule: "repeated",
                      type: "Option",
                      id: 3
                    }
                  }
                },
                Option: {
                  fields: {
                    name: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "Any",
                      id: 2
                    }
                  }
                },
                Syntax: {
                  values: {
                    SYNTAX_PROTO2: 0,
                    SYNTAX_PROTO3: 1
                  }
                },
                Any: {
                  fields: {
                    type_url: {
                      type: "string",
                      id: 1
                    },
                    value: {
                      type: "bytes",
                      id: 2
                    }
                  }
                },
                SourceContext: {
                  fields: {
                    fileName: {
                      type: "string",
                      id: 1
                    }
                  }
                }
              }
            }
          }
        }
      }
    };
  }
});

// node_modules/@grpc/proto-loader/build/src/util.js
var require_util4 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/util.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.addCommonProtos = exports2.loadProtosWithOptionsSync = exports2.loadProtosWithOptions = void 0;
    var fs = require("fs");
    var path = require("path");
    var Protobuf = require_protobufjs();
    function addIncludePathResolver(root, includePaths) {
      const originalResolvePath = root.resolvePath;
      root.resolvePath = (origin, target) => {
        if (path.isAbsolute(target)) {
          return target;
        }
        for (const directory of includePaths) {
          const fullPath = path.join(directory, target);
          try {
            fs.accessSync(fullPath, fs.constants.R_OK);
            return fullPath;
          } catch (err) {
            continue;
          }
        }
        process.emitWarning(`${target} not found in any of the include paths ${includePaths}`);
        return originalResolvePath(origin, target);
      };
    }
    __name(addIncludePathResolver, "addIncludePathResolver");
    async function loadProtosWithOptions(filename, options) {
      const root = new Protobuf.Root();
      options = options || {};
      if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
          return Promise.reject(new Error("The includeDirs option must be an array"));
        }
        addIncludePathResolver(root, options.includeDirs);
      }
      const loadedRoot = await root.load(filename, options);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    __name(loadProtosWithOptions, "loadProtosWithOptions");
    exports2.loadProtosWithOptions = loadProtosWithOptions;
    function loadProtosWithOptionsSync(filename, options) {
      const root = new Protobuf.Root();
      options = options || {};
      if (!!options.includeDirs) {
        if (!Array.isArray(options.includeDirs)) {
          throw new Error("The includeDirs option must be an array");
        }
        addIncludePathResolver(root, options.includeDirs);
      }
      const loadedRoot = root.loadSync(filename, options);
      loadedRoot.resolveAll();
      return loadedRoot;
    }
    __name(loadProtosWithOptionsSync, "loadProtosWithOptionsSync");
    exports2.loadProtosWithOptionsSync = loadProtosWithOptionsSync;
    function addCommonProtos() {
      const apiDescriptor = require_api();
      const descriptorDescriptor = require_descriptor();
      const sourceContextDescriptor = require_source_context();
      const typeDescriptor = require_type2();
      Protobuf.common("api", apiDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("descriptor", descriptorDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("source_context", sourceContextDescriptor.nested.google.nested.protobuf.nested);
      Protobuf.common("type", typeDescriptor.nested.google.nested.protobuf.nested);
    }
    __name(addCommonProtos, "addCommonProtos");
    exports2.addCommonProtos = addCommonProtos;
  }
});

// node_modules/long/umd/index.js
var require_umd = __commonJS({
  "node_modules/long/umd/index.js"(exports2, module2) {
    "use strict";
    (function(global2, factory) {
      function unwrapDefault(exports1) {
        return "default" in exports1 ? exports1.default : exports1;
      }
      __name(unwrapDefault, "unwrapDefault");
      if (typeof define === "function" && define.amd) {
        define([], function() {
          var exports1 = {};
          factory(exports1);
          return unwrapDefault(exports1);
        });
      } else if (typeof exports2 === "object") {
        factory(exports2);
        if (typeof module2 === "object") module2.exports = unwrapDefault(exports2);
      } else {
        (function() {
          var exports1 = {};
          factory(exports1);
          global2.Long = unwrapDefault(exports1);
        })();
      }
    })(typeof globalThis !== "undefined" ? globalThis : typeof self !== "undefined" ? self : exports2, function(_exports) {
      "use strict";
      Object.defineProperty(_exports, "__esModule", {
        value: true
      });
      _exports.default = void 0;
      var wasm = null;
      try {
        wasm = new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([
          // \0asm
          0,
          97,
          115,
          109,
          // version 1
          1,
          0,
          0,
          0,
          // section "type"
          1,
          13,
          2,
          // 0, () => i32
          96,
          0,
          1,
          127,
          // 1, (i32, i32, i32, i32) => i32
          96,
          4,
          127,
          127,
          127,
          127,
          1,
          127,
          // section "function"
          3,
          7,
          6,
          // 0, type 0
          0,
          // 1, type 1
          1,
          // 2, type 1
          1,
          // 3, type 1
          1,
          // 4, type 1
          1,
          // 5, type 1
          1,
          // section "global"
          6,
          6,
          1,
          // 0, "high", mutable i32
          127,
          1,
          65,
          0,
          11,
          // section "export"
          7,
          50,
          6,
          // 0, "mul"
          3,
          109,
          117,
          108,
          0,
          1,
          // 1, "div_s"
          5,
          100,
          105,
          118,
          95,
          115,
          0,
          2,
          // 2, "div_u"
          5,
          100,
          105,
          118,
          95,
          117,
          0,
          3,
          // 3, "rem_s"
          5,
          114,
          101,
          109,
          95,
          115,
          0,
          4,
          // 4, "rem_u"
          5,
          114,
          101,
          109,
          95,
          117,
          0,
          5,
          // 5, "get_high"
          8,
          103,
          101,
          116,
          95,
          104,
          105,
          103,
          104,
          0,
          0,
          // section "code"
          10,
          191,
          1,
          6,
          // 0, "get_high"
          4,
          0,
          35,
          0,
          11,
          // 1, "mul"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          126,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 2, "div_s"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          127,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 3, "div_u"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          128,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 4, "rem_s"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          129,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11,
          // 5, "rem_u"
          36,
          1,
          1,
          126,
          32,
          0,
          173,
          32,
          1,
          173,
          66,
          32,
          134,
          132,
          32,
          2,
          173,
          32,
          3,
          173,
          66,
          32,
          134,
          132,
          130,
          34,
          4,
          66,
          32,
          135,
          167,
          36,
          0,
          32,
          4,
          167,
          11
        ])), {}).exports;
      } catch {
      }
      function Long(low, high, unsigned) {
        this.low = low | 0;
        this.high = high | 0;
        this.unsigned = !!unsigned;
      }
      __name(Long, "Long");
      Long.prototype.__isLong__;
      Object.defineProperty(Long.prototype, "__isLong__", {
        value: true
      });
      function isLong(obj) {
        return (obj && obj["__isLong__"]) === true;
      }
      __name(isLong, "isLong");
      function ctz32(value2) {
        var c = Math.clz32(value2 & -value2);
        return value2 ? 31 - c : c;
      }
      __name(ctz32, "ctz32");
      Long.isLong = isLong;
      var INT_CACHE = {};
      var UINT_CACHE = {};
      function fromInt(value2, unsigned) {
        var obj, cachedObj, cache2;
        if (unsigned) {
          value2 >>>= 0;
          if (cache2 = 0 <= value2 && value2 < 256) {
            cachedObj = UINT_CACHE[value2];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value2, 0, true);
          if (cache2) UINT_CACHE[value2] = obj;
          return obj;
        } else {
          value2 |= 0;
          if (cache2 = -128 <= value2 && value2 < 128) {
            cachedObj = INT_CACHE[value2];
            if (cachedObj) return cachedObj;
          }
          obj = fromBits(value2, value2 < 0 ? -1 : 0, false);
          if (cache2) INT_CACHE[value2] = obj;
          return obj;
        }
      }
      __name(fromInt, "fromInt");
      Long.fromInt = fromInt;
      function fromNumber(value2, unsigned) {
        if (isNaN(value2)) return unsigned ? UZERO : ZERO;
        if (unsigned) {
          if (value2 < 0) return UZERO;
          if (value2 >= TWO_PWR_64_DBL) return MAX_UNSIGNED_VALUE;
        } else {
          if (value2 <= -TWO_PWR_63_DBL) return MIN_VALUE;
          if (value2 + 1 >= TWO_PWR_63_DBL) return MAX_VALUE;
        }
        if (value2 < 0) return fromNumber(-value2, unsigned).neg();
        return fromBits(value2 % TWO_PWR_32_DBL | 0, value2 / TWO_PWR_32_DBL | 0, unsigned);
      }
      __name(fromNumber, "fromNumber");
      Long.fromNumber = fromNumber;
      function fromBits(lowBits, highBits, unsigned) {
        return new Long(lowBits, highBits, unsigned);
      }
      __name(fromBits, "fromBits");
      Long.fromBits = fromBits;
      var pow_dbl = Math.pow;
      function fromString(str, unsigned, radix) {
        if (str.length === 0) throw Error("empty string");
        if (typeof unsigned === "number") {
          radix = unsigned;
          unsigned = false;
        } else {
          unsigned = !!unsigned;
        }
        if (str === "NaN" || str === "Infinity" || str === "+Infinity" || str === "-Infinity") return unsigned ? UZERO : ZERO;
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        var p;
        if ((p = str.indexOf("-")) > 0) throw Error("interior hyphen");
        else if (p === 0) {
          return fromString(str.substring(1), unsigned, radix).neg();
        }
        var radixToPower = fromNumber(pow_dbl(radix, 8));
        var result2 = ZERO;
        for (var i = 0; i < str.length; i += 8) {
          var size = Math.min(8, str.length - i), value2 = parseInt(str.substring(i, i + size), radix);
          if (size < 8) {
            var power = fromNumber(pow_dbl(radix, size));
            result2 = result2.mul(power).add(fromNumber(value2));
          } else {
            result2 = result2.mul(radixToPower);
            result2 = result2.add(fromNumber(value2));
          }
        }
        result2.unsigned = unsigned;
        return result2;
      }
      __name(fromString, "fromString");
      Long.fromString = fromString;
      function fromValue(val, unsigned) {
        if (typeof val === "number") return fromNumber(val, unsigned);
        if (typeof val === "string") return fromString(val, unsigned);
        return fromBits(val.low, val.high, typeof unsigned === "boolean" ? unsigned : val.unsigned);
      }
      __name(fromValue, "fromValue");
      Long.fromValue = fromValue;
      var TWO_PWR_16_DBL = 1 << 16;
      var TWO_PWR_24_DBL = 1 << 24;
      var TWO_PWR_32_DBL = TWO_PWR_16_DBL * TWO_PWR_16_DBL;
      var TWO_PWR_64_DBL = TWO_PWR_32_DBL * TWO_PWR_32_DBL;
      var TWO_PWR_63_DBL = TWO_PWR_64_DBL / 2;
      var TWO_PWR_24 = fromInt(TWO_PWR_24_DBL);
      var ZERO = fromInt(0);
      Long.ZERO = ZERO;
      var UZERO = fromInt(0, true);
      Long.UZERO = UZERO;
      var ONE = fromInt(1);
      Long.ONE = ONE;
      var UONE = fromInt(1, true);
      Long.UONE = UONE;
      var NEG_ONE = fromInt(-1);
      Long.NEG_ONE = NEG_ONE;
      var MAX_VALUE = fromBits(4294967295 | 0, 2147483647 | 0, false);
      Long.MAX_VALUE = MAX_VALUE;
      var MAX_UNSIGNED_VALUE = fromBits(4294967295 | 0, 4294967295 | 0, true);
      Long.MAX_UNSIGNED_VALUE = MAX_UNSIGNED_VALUE;
      var MIN_VALUE = fromBits(0, 2147483648 | 0, false);
      Long.MIN_VALUE = MIN_VALUE;
      var LongPrototype = Long.prototype;
      LongPrototype.toInt = /* @__PURE__ */ __name(function toInt() {
        return this.unsigned ? this.low >>> 0 : this.low;
      }, "toInt");
      LongPrototype.toNumber = /* @__PURE__ */ __name(function toNumber() {
        if (this.unsigned) return (this.high >>> 0) * TWO_PWR_32_DBL + (this.low >>> 0);
        return this.high * TWO_PWR_32_DBL + (this.low >>> 0);
      }, "toNumber");
      LongPrototype.toString = /* @__PURE__ */ __name(function toString2(radix) {
        radix = radix || 10;
        if (radix < 2 || 36 < radix) throw RangeError("radix");
        if (this.isZero()) return "0";
        if (this.isNegative()) {
          if (this.eq(MIN_VALUE)) {
            var radixLong = fromNumber(radix), div = this.div(radixLong), rem1 = div.mul(radixLong).sub(this);
            return div.toString(radix) + rem1.toInt().toString(radix);
          } else return "-" + this.neg().toString(radix);
        }
        var radixToPower = fromNumber(pow_dbl(radix, 6), this.unsigned), rem = this;
        var result2 = "";
        while (true) {
          var remDiv = rem.div(radixToPower), intval = rem.sub(remDiv.mul(radixToPower)).toInt() >>> 0, digits = intval.toString(radix);
          rem = remDiv;
          if (rem.isZero()) return digits + result2;
          else {
            while (digits.length < 6) digits = "0" + digits;
            result2 = "" + digits + result2;
          }
        }
      }, "toString");
      LongPrototype.getHighBits = /* @__PURE__ */ __name(function getHighBits() {
        return this.high;
      }, "getHighBits");
      LongPrototype.getHighBitsUnsigned = /* @__PURE__ */ __name(function getHighBitsUnsigned() {
        return this.high >>> 0;
      }, "getHighBitsUnsigned");
      LongPrototype.getLowBits = /* @__PURE__ */ __name(function getLowBits() {
        return this.low;
      }, "getLowBits");
      LongPrototype.getLowBitsUnsigned = /* @__PURE__ */ __name(function getLowBitsUnsigned() {
        return this.low >>> 0;
      }, "getLowBitsUnsigned");
      LongPrototype.getNumBitsAbs = /* @__PURE__ */ __name(function getNumBitsAbs() {
        if (this.isNegative())
          return this.eq(MIN_VALUE) ? 64 : this.neg().getNumBitsAbs();
        var val = this.high != 0 ? this.high : this.low;
        for (var bit = 31; bit > 0; bit--) if ((val & 1 << bit) != 0) break;
        return this.high != 0 ? bit + 33 : bit + 1;
      }, "getNumBitsAbs");
      LongPrototype.isSafeInteger = /* @__PURE__ */ __name(function isSafeInteger() {
        var top11Bits = this.high >> 21;
        if (!top11Bits) return true;
        if (this.unsigned) return false;
        return top11Bits === -1 && !(this.low === 0 && this.high === -2097152);
      }, "isSafeInteger");
      LongPrototype.isZero = /* @__PURE__ */ __name(function isZero() {
        return this.high === 0 && this.low === 0;
      }, "isZero");
      LongPrototype.eqz = LongPrototype.isZero;
      LongPrototype.isNegative = /* @__PURE__ */ __name(function isNegative() {
        return !this.unsigned && this.high < 0;
      }, "isNegative");
      LongPrototype.isPositive = /* @__PURE__ */ __name(function isPositive() {
        return this.unsigned || this.high >= 0;
      }, "isPositive");
      LongPrototype.isOdd = /* @__PURE__ */ __name(function isOdd() {
        return (this.low & 1) === 1;
      }, "isOdd");
      LongPrototype.isEven = /* @__PURE__ */ __name(function isEven() {
        return (this.low & 1) === 0;
      }, "isEven");
      LongPrototype.equals = /* @__PURE__ */ __name(function equals(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.unsigned !== other.unsigned && this.high >>> 31 === 1 && other.high >>> 31 === 1) return false;
        return this.high === other.high && this.low === other.low;
      }, "equals");
      LongPrototype.eq = LongPrototype.equals;
      LongPrototype.notEquals = /* @__PURE__ */ __name(function notEquals(other) {
        return !this.eq(
          /* validates */
          other
        );
      }, "notEquals");
      LongPrototype.neq = LongPrototype.notEquals;
      LongPrototype.ne = LongPrototype.notEquals;
      LongPrototype.lessThan = /* @__PURE__ */ __name(function lessThan(other) {
        return this.comp(
          /* validates */
          other
        ) < 0;
      }, "lessThan");
      LongPrototype.lt = LongPrototype.lessThan;
      LongPrototype.lessThanOrEqual = /* @__PURE__ */ __name(function lessThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) <= 0;
      }, "lessThanOrEqual");
      LongPrototype.lte = LongPrototype.lessThanOrEqual;
      LongPrototype.le = LongPrototype.lessThanOrEqual;
      LongPrototype.greaterThan = /* @__PURE__ */ __name(function greaterThan(other) {
        return this.comp(
          /* validates */
          other
        ) > 0;
      }, "greaterThan");
      LongPrototype.gt = LongPrototype.greaterThan;
      LongPrototype.greaterThanOrEqual = /* @__PURE__ */ __name(function greaterThanOrEqual(other) {
        return this.comp(
          /* validates */
          other
        ) >= 0;
      }, "greaterThanOrEqual");
      LongPrototype.gte = LongPrototype.greaterThanOrEqual;
      LongPrototype.ge = LongPrototype.greaterThanOrEqual;
      LongPrototype.compare = /* @__PURE__ */ __name(function compare(other) {
        if (!isLong(other)) other = fromValue(other);
        if (this.eq(other)) return 0;
        var thisNeg = this.isNegative(), otherNeg = other.isNegative();
        if (thisNeg && !otherNeg) return -1;
        if (!thisNeg && otherNeg) return 1;
        if (!this.unsigned) return this.sub(other).isNegative() ? -1 : 1;
        return other.high >>> 0 > this.high >>> 0 || other.high === this.high && other.low >>> 0 > this.low >>> 0 ? -1 : 1;
      }, "compare");
      LongPrototype.comp = LongPrototype.compare;
      LongPrototype.negate = /* @__PURE__ */ __name(function negate() {
        if (!this.unsigned && this.eq(MIN_VALUE)) return MIN_VALUE;
        return this.not().add(ONE);
      }, "negate");
      LongPrototype.neg = LongPrototype.negate;
      LongPrototype.add = /* @__PURE__ */ __name(function add(addend) {
        if (!isLong(addend)) addend = fromValue(addend);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = addend.high >>> 16;
        var b32 = addend.high & 65535;
        var b16 = addend.low >>> 16;
        var b00 = addend.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 + b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 + b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 + b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 + b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      }, "add");
      LongPrototype.subtract = /* @__PURE__ */ __name(function subtract(subtrahend) {
        if (!isLong(subtrahend)) subtrahend = fromValue(subtrahend);
        return this.add(subtrahend.neg());
      }, "subtract");
      LongPrototype.sub = LongPrototype.subtract;
      LongPrototype.multiply = /* @__PURE__ */ __name(function multiply(multiplier) {
        if (this.isZero()) return this;
        if (!isLong(multiplier)) multiplier = fromValue(multiplier);
        if (wasm) {
          var low = wasm["mul"](this.low, this.high, multiplier.low, multiplier.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (multiplier.isZero()) return this.unsigned ? UZERO : ZERO;
        if (this.eq(MIN_VALUE)) return multiplier.isOdd() ? MIN_VALUE : ZERO;
        if (multiplier.eq(MIN_VALUE)) return this.isOdd() ? MIN_VALUE : ZERO;
        if (this.isNegative()) {
          if (multiplier.isNegative()) return this.neg().mul(multiplier.neg());
          else return this.neg().mul(multiplier).neg();
        } else if (multiplier.isNegative()) return this.mul(multiplier.neg()).neg();
        if (this.lt(TWO_PWR_24) && multiplier.lt(TWO_PWR_24)) return fromNumber(this.toNumber() * multiplier.toNumber(), this.unsigned);
        var a48 = this.high >>> 16;
        var a32 = this.high & 65535;
        var a16 = this.low >>> 16;
        var a00 = this.low & 65535;
        var b48 = multiplier.high >>> 16;
        var b32 = multiplier.high & 65535;
        var b16 = multiplier.low >>> 16;
        var b00 = multiplier.low & 65535;
        var c48 = 0, c32 = 0, c16 = 0, c00 = 0;
        c00 += a00 * b00;
        c16 += c00 >>> 16;
        c00 &= 65535;
        c16 += a16 * b00;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c16 += a00 * b16;
        c32 += c16 >>> 16;
        c16 &= 65535;
        c32 += a32 * b00;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a16 * b16;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c32 += a00 * b32;
        c48 += c32 >>> 16;
        c32 &= 65535;
        c48 += a48 * b00 + a32 * b16 + a16 * b32 + a00 * b48;
        c48 &= 65535;
        return fromBits(c16 << 16 | c00, c48 << 16 | c32, this.unsigned);
      }, "multiply");
      LongPrototype.mul = LongPrototype.multiply;
      LongPrototype.divide = /* @__PURE__ */ __name(function divide(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (divisor.isZero()) throw Error("division by zero");
        if (wasm) {
          if (!this.unsigned && this.high === -2147483648 && divisor.low === -1 && divisor.high === -1) {
            return this;
          }
          var low = (this.unsigned ? wasm["div_u"] : wasm["div_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        if (this.isZero()) return this.unsigned ? UZERO : ZERO;
        var approx, rem, res;
        if (!this.unsigned) {
          if (this.eq(MIN_VALUE)) {
            if (divisor.eq(ONE) || divisor.eq(NEG_ONE)) return MIN_VALUE;
            else if (divisor.eq(MIN_VALUE)) return ONE;
            else {
              var halfThis = this.shr(1);
              approx = halfThis.div(divisor).shl(1);
              if (approx.eq(ZERO)) {
                return divisor.isNegative() ? ONE : NEG_ONE;
              } else {
                rem = this.sub(divisor.mul(approx));
                res = approx.add(rem.div(divisor));
                return res;
              }
            }
          } else if (divisor.eq(MIN_VALUE)) return this.unsigned ? UZERO : ZERO;
          if (this.isNegative()) {
            if (divisor.isNegative()) return this.neg().div(divisor.neg());
            return this.neg().div(divisor).neg();
          } else if (divisor.isNegative()) return this.div(divisor.neg()).neg();
          res = ZERO;
        } else {
          if (!divisor.unsigned) divisor = divisor.toUnsigned();
          if (divisor.gt(this)) return UZERO;
          if (divisor.gt(this.shru(1)))
            return UONE;
          res = UZERO;
        }
        rem = this;
        while (rem.gte(divisor)) {
          approx = Math.max(1, Math.floor(rem.toNumber() / divisor.toNumber()));
          var log2 = Math.ceil(Math.log(approx) / Math.LN2), delta = log2 <= 48 ? 1 : pow_dbl(2, log2 - 48), approxRes = fromNumber(approx), approxRem = approxRes.mul(divisor);
          while (approxRem.isNegative() || approxRem.gt(rem)) {
            approx -= delta;
            approxRes = fromNumber(approx, this.unsigned);
            approxRem = approxRes.mul(divisor);
          }
          if (approxRes.isZero()) approxRes = ONE;
          res = res.add(approxRes);
          rem = rem.sub(approxRem);
        }
        return res;
      }, "divide");
      LongPrototype.div = LongPrototype.divide;
      LongPrototype.modulo = /* @__PURE__ */ __name(function modulo(divisor) {
        if (!isLong(divisor)) divisor = fromValue(divisor);
        if (wasm) {
          var low = (this.unsigned ? wasm["rem_u"] : wasm["rem_s"])(this.low, this.high, divisor.low, divisor.high);
          return fromBits(low, wasm["get_high"](), this.unsigned);
        }
        return this.sub(this.div(divisor).mul(divisor));
      }, "modulo");
      LongPrototype.mod = LongPrototype.modulo;
      LongPrototype.rem = LongPrototype.modulo;
      LongPrototype.not = /* @__PURE__ */ __name(function not() {
        return fromBits(~this.low, ~this.high, this.unsigned);
      }, "not");
      LongPrototype.countLeadingZeros = /* @__PURE__ */ __name(function countLeadingZeros() {
        return this.high ? Math.clz32(this.high) : Math.clz32(this.low) + 32;
      }, "countLeadingZeros");
      LongPrototype.clz = LongPrototype.countLeadingZeros;
      LongPrototype.countTrailingZeros = /* @__PURE__ */ __name(function countTrailingZeros() {
        return this.low ? ctz32(this.low) : ctz32(this.high) + 32;
      }, "countTrailingZeros");
      LongPrototype.ctz = LongPrototype.countTrailingZeros;
      LongPrototype.and = /* @__PURE__ */ __name(function and(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low & other.low, this.high & other.high, this.unsigned);
      }, "and");
      LongPrototype.or = /* @__PURE__ */ __name(function or(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low | other.low, this.high | other.high, this.unsigned);
      }, "or");
      LongPrototype.xor = /* @__PURE__ */ __name(function xor(other) {
        if (!isLong(other)) other = fromValue(other);
        return fromBits(this.low ^ other.low, this.high ^ other.high, this.unsigned);
      }, "xor");
      LongPrototype.shiftLeft = /* @__PURE__ */ __name(function shiftLeft(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low << numBits, this.high << numBits | this.low >>> 32 - numBits, this.unsigned);
        else return fromBits(0, this.low << numBits - 32, this.unsigned);
      }, "shiftLeft");
      LongPrototype.shl = LongPrototype.shiftLeft;
      LongPrototype.shiftRight = /* @__PURE__ */ __name(function shiftRight(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        else if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >> numBits, this.unsigned);
        else return fromBits(this.high >> numBits - 32, this.high >= 0 ? 0 : -1, this.unsigned);
      }, "shiftRight");
      LongPrototype.shr = LongPrototype.shiftRight;
      LongPrototype.shiftRightUnsigned = /* @__PURE__ */ __name(function shiftRightUnsigned(numBits) {
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits < 32) return fromBits(this.low >>> numBits | this.high << 32 - numBits, this.high >>> numBits, this.unsigned);
        if (numBits === 32) return fromBits(this.high, 0, this.unsigned);
        return fromBits(this.high >>> numBits - 32, 0, this.unsigned);
      }, "shiftRightUnsigned");
      LongPrototype.shru = LongPrototype.shiftRightUnsigned;
      LongPrototype.shr_u = LongPrototype.shiftRightUnsigned;
      LongPrototype.rotateLeft = /* @__PURE__ */ __name(function rotateLeft(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.low << numBits | this.high >>> b, this.high << numBits | this.low >>> b, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.high << numBits | this.low >>> b, this.low << numBits | this.high >>> b, this.unsigned);
      }, "rotateLeft");
      LongPrototype.rotl = LongPrototype.rotateLeft;
      LongPrototype.rotateRight = /* @__PURE__ */ __name(function rotateRight(numBits) {
        var b;
        if (isLong(numBits)) numBits = numBits.toInt();
        if ((numBits &= 63) === 0) return this;
        if (numBits === 32) return fromBits(this.high, this.low, this.unsigned);
        if (numBits < 32) {
          b = 32 - numBits;
          return fromBits(this.high << b | this.low >>> numBits, this.low << b | this.high >>> numBits, this.unsigned);
        }
        numBits -= 32;
        b = 32 - numBits;
        return fromBits(this.low << b | this.high >>> numBits, this.high << b | this.low >>> numBits, this.unsigned);
      }, "rotateRight");
      LongPrototype.rotr = LongPrototype.rotateRight;
      LongPrototype.toSigned = /* @__PURE__ */ __name(function toSigned() {
        if (!this.unsigned) return this;
        return fromBits(this.low, this.high, false);
      }, "toSigned");
      LongPrototype.toUnsigned = /* @__PURE__ */ __name(function toUnsigned() {
        if (this.unsigned) return this;
        return fromBits(this.low, this.high, true);
      }, "toUnsigned");
      LongPrototype.toBytes = /* @__PURE__ */ __name(function toBytes(le) {
        return le ? this.toBytesLE() : this.toBytesBE();
      }, "toBytes");
      LongPrototype.toBytesLE = /* @__PURE__ */ __name(function toBytesLE() {
        var hi = this.high, lo = this.low;
        return [
          lo & 255,
          lo >>> 8 & 255,
          lo >>> 16 & 255,
          lo >>> 24,
          hi & 255,
          hi >>> 8 & 255,
          hi >>> 16 & 255,
          hi >>> 24
        ];
      }, "toBytesLE");
      LongPrototype.toBytesBE = /* @__PURE__ */ __name(function toBytesBE() {
        var hi = this.high, lo = this.low;
        return [
          hi >>> 24,
          hi >>> 16 & 255,
          hi >>> 8 & 255,
          hi & 255,
          lo >>> 24,
          lo >>> 16 & 255,
          lo >>> 8 & 255,
          lo & 255
        ];
      }, "toBytesBE");
      Long.fromBytes = /* @__PURE__ */ __name(function fromBytes(bytes, unsigned, le) {
        return le ? Long.fromBytesLE(bytes, unsigned) : Long.fromBytesBE(bytes, unsigned);
      }, "fromBytes");
      Long.fromBytesLE = /* @__PURE__ */ __name(function fromBytesLE(bytes, unsigned) {
        return new Long(bytes[0] | bytes[1] << 8 | bytes[2] << 16 | bytes[3] << 24, bytes[4] | bytes[5] << 8 | bytes[6] << 16 | bytes[7] << 24, unsigned);
      }, "fromBytesLE");
      Long.fromBytesBE = /* @__PURE__ */ __name(function fromBytesBE(bytes, unsigned) {
        return new Long(bytes[4] << 24 | bytes[5] << 16 | bytes[6] << 8 | bytes[7], bytes[0] << 24 | bytes[1] << 16 | bytes[2] << 8 | bytes[3], unsigned);
      }, "fromBytesBE");
      if (typeof BigInt === "function") {
        Long.fromBigInt = /* @__PURE__ */ __name(function fromBigInt1(value2, unsigned) {
          var lowBits = Number(BigInt.asIntN(32, value2));
          var highBits = Number(BigInt.asIntN(32, value2 >> BigInt(32)));
          return fromBits(lowBits, highBits, unsigned);
        }, "fromBigInt1");
        Long.fromValue = /* @__PURE__ */ __name(function fromValueWithBigInt(value2, unsigned) {
          if (typeof value2 === "bigint") return fromBigInt(value2, unsigned);
          return fromValue(value2, unsigned);
        }, "fromValueWithBigInt");
        LongPrototype.toBigInt = /* @__PURE__ */ __name(function toBigInt() {
          var lowBigInt = BigInt(this.low >>> 0);
          var highBigInt = BigInt(this.unsigned ? this.high >>> 0 : this.high);
          return highBigInt << BigInt(32) | lowBigInt;
        }, "toBigInt");
      }
      var _default = _exports.default = Long;
    });
  }
});

// node_modules/@grpc/proto-loader/build/src/index.js
var require_src6 = __commonJS({
  "node_modules/@grpc/proto-loader/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.loadFileDescriptorSetFromObject = exports2.loadFileDescriptorSetFromBuffer = exports2.fromJSON = exports2.loadSync = exports2.load = exports2.IdempotencyLevel = exports2.isAnyExtension = exports2.Long = void 0;
    var camelCase2 = require_lodash();
    var Protobuf = require_protobufjs();
    var descriptor = require_descriptor2();
    var util_1 = require_util4();
    var Long = require_umd();
    exports2.Long = Long;
    function isAnyExtension(obj) {
      return "@type" in obj && typeof obj["@type"] === "string";
    }
    __name(isAnyExtension, "isAnyExtension");
    exports2.isAnyExtension = isAnyExtension;
    var IdempotencyLevel;
    (function(IdempotencyLevel2) {
      IdempotencyLevel2["IDEMPOTENCY_UNKNOWN"] = "IDEMPOTENCY_UNKNOWN";
      IdempotencyLevel2["NO_SIDE_EFFECTS"] = "NO_SIDE_EFFECTS";
      IdempotencyLevel2["IDEMPOTENT"] = "IDEMPOTENT";
    })(IdempotencyLevel = exports2.IdempotencyLevel || (exports2.IdempotencyLevel = {}));
    var descriptorOptions = {
      longs: String,
      enums: String,
      bytes: String,
      defaults: true,
      oneofs: true,
      json: true
    };
    function joinName(baseName, name) {
      if (baseName === "") {
        return name;
      } else {
        return baseName + "." + name;
      }
    }
    __name(joinName, "joinName");
    function isHandledReflectionObject(obj) {
      return obj instanceof Protobuf.Service || obj instanceof Protobuf.Type || obj instanceof Protobuf.Enum;
    }
    __name(isHandledReflectionObject, "isHandledReflectionObject");
    function isNamespaceBase(obj) {
      return obj instanceof Protobuf.Namespace || obj instanceof Protobuf.Root;
    }
    __name(isNamespaceBase, "isNamespaceBase");
    function getAllHandledReflectionObjects(obj, parentName) {
      const objName = joinName(parentName, obj.name);
      if (isHandledReflectionObject(obj)) {
        return [
          [
            objName,
            obj
          ]
        ];
      } else {
        if (isNamespaceBase(obj) && typeof obj.nested !== "undefined") {
          return Object.keys(obj.nested).map((name) => {
            return getAllHandledReflectionObjects(obj.nested[name], objName);
          }).reduce((accumulator, currentValue) => accumulator.concat(currentValue), []);
        }
      }
      return [];
    }
    __name(getAllHandledReflectionObjects, "getAllHandledReflectionObjects");
    function createDeserializer(cls, options) {
      return /* @__PURE__ */ __name(function deserialize(argBuf) {
        return cls.toObject(cls.decode(argBuf), options);
      }, "deserialize");
    }
    __name(createDeserializer, "createDeserializer");
    function createSerializer(cls) {
      return /* @__PURE__ */ __name(function serialize(arg) {
        if (Array.isArray(arg)) {
          throw new Error(`Failed to serialize message: expected object with ${cls.name} structure, got array instead`);
        }
        const message = cls.fromObject(arg);
        return cls.encode(message).finish();
      }, "serialize");
    }
    __name(createSerializer, "createSerializer");
    function mapMethodOptions(options) {
      return (options || []).reduce((obj, item) => {
        for (const [key, value2] of Object.entries(item)) {
          switch (key) {
            case "uninterpreted_option":
              obj.uninterpreted_option.push(item.uninterpreted_option);
              break;
            default:
              obj[key] = value2;
          }
        }
        return obj;
      }, {
        deprecated: false,
        idempotency_level: IdempotencyLevel.IDEMPOTENCY_UNKNOWN,
        uninterpreted_option: []
      });
    }
    __name(mapMethodOptions, "mapMethodOptions");
    function createMethodDefinition(method, serviceName, options, fileDescriptors) {
      const requestType = method.resolvedRequestType;
      const responseType = method.resolvedResponseType;
      return {
        path: "/" + serviceName + "/" + method.name,
        requestStream: !!method.requestStream,
        responseStream: !!method.responseStream,
        requestSerialize: createSerializer(requestType),
        requestDeserialize: createDeserializer(requestType, options),
        responseSerialize: createSerializer(responseType),
        responseDeserialize: createDeserializer(responseType, options),
        // TODO(murgatroid99): Find a better way to handle this
        originalName: camelCase2(method.name),
        requestType: createMessageDefinition(requestType, fileDescriptors),
        responseType: createMessageDefinition(responseType, fileDescriptors),
        options: mapMethodOptions(method.parsedOptions)
      };
    }
    __name(createMethodDefinition, "createMethodDefinition");
    function createServiceDefinition(service, name, options, fileDescriptors) {
      const def = {};
      for (const method of service.methodsArray) {
        def[method.name] = createMethodDefinition(method, name, options, fileDescriptors);
      }
      return def;
    }
    __name(createServiceDefinition, "createServiceDefinition");
    function createMessageDefinition(message, fileDescriptors) {
      const messageDescriptor = message.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 DescriptorProto",
        type: messageDescriptor.$type.toObject(messageDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    __name(createMessageDefinition, "createMessageDefinition");
    function createEnumDefinition(enumType2, fileDescriptors) {
      const enumDescriptor = enumType2.toDescriptor("proto3");
      return {
        format: "Protocol Buffer 3 EnumDescriptorProto",
        type: enumDescriptor.$type.toObject(enumDescriptor, descriptorOptions),
        fileDescriptorProtos: fileDescriptors
      };
    }
    __name(createEnumDefinition, "createEnumDefinition");
    function createDefinition(obj, name, options, fileDescriptors) {
      if (obj instanceof Protobuf.Service) {
        return createServiceDefinition(obj, name, options, fileDescriptors);
      } else if (obj instanceof Protobuf.Type) {
        return createMessageDefinition(obj, fileDescriptors);
      } else if (obj instanceof Protobuf.Enum) {
        return createEnumDefinition(obj, fileDescriptors);
      } else {
        throw new Error("Type mismatch in reflection object handling");
      }
    }
    __name(createDefinition, "createDefinition");
    function createPackageDefinition(root, options) {
      const def = {};
      root.resolveAll();
      const descriptorList = root.toDescriptor("proto3").file;
      const bufferList = descriptorList.map((value2) => Buffer.from(descriptor.FileDescriptorProto.encode(value2).finish()));
      for (const [name, obj] of getAllHandledReflectionObjects(root, "")) {
        def[name] = createDefinition(obj, name, options, bufferList);
      }
      return def;
    }
    __name(createPackageDefinition, "createPackageDefinition");
    function createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options) {
      options = options || {};
      const root = Protobuf.Root.fromDescriptor(decodedDescriptorSet);
      root.resolveAll();
      return createPackageDefinition(root, options);
    }
    __name(createPackageDefinitionFromDescriptorSet, "createPackageDefinitionFromDescriptorSet");
    function load(filename, options) {
      return (0, util_1.loadProtosWithOptions)(filename, options).then((loadedRoot) => {
        return createPackageDefinition(loadedRoot, options);
      });
    }
    __name(load, "load");
    exports2.load = load;
    function loadSync(filename, options) {
      const loadedRoot = (0, util_1.loadProtosWithOptionsSync)(filename, options);
      return createPackageDefinition(loadedRoot, options);
    }
    __name(loadSync, "loadSync");
    exports2.loadSync = loadSync;
    function fromJSON(json, options) {
      options = options || {};
      const loadedRoot = Protobuf.Root.fromJSON(json);
      loadedRoot.resolveAll();
      return createPackageDefinition(loadedRoot, options);
    }
    __name(fromJSON, "fromJSON");
    exports2.fromJSON = fromJSON;
    function loadFileDescriptorSetFromBuffer(descriptorSet, options) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.decode(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
    }
    __name(loadFileDescriptorSetFromBuffer, "loadFileDescriptorSetFromBuffer");
    exports2.loadFileDescriptorSetFromBuffer = loadFileDescriptorSetFromBuffer;
    function loadFileDescriptorSetFromObject(descriptorSet, options) {
      const decodedDescriptorSet = descriptor.FileDescriptorSet.fromObject(descriptorSet);
      return createPackageDefinitionFromDescriptorSet(decodedDescriptorSet, options);
    }
    __name(loadFileDescriptorSetFromObject, "loadFileDescriptorSetFromObject");
    exports2.loadFileDescriptorSetFromObject = loadFileDescriptorSetFromObject;
    (0, util_1.addCommonProtos)();
  }
});

// node_modules/@grpc/grpc-js/build/src/channelz.js
var require_channelz = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channelz.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.registerChannelzSocket = exports2.registerChannelzServer = exports2.registerChannelzSubchannel = exports2.registerChannelzChannel = exports2.ChannelzCallTrackerStub = exports2.ChannelzCallTracker = exports2.ChannelzChildrenTrackerStub = exports2.ChannelzChildrenTracker = exports2.ChannelzTrace = exports2.ChannelzTraceStub = void 0;
    exports2.unregisterChannelzRef = unregisterChannelzRef;
    exports2.getChannelzHandlers = getChannelzHandlers;
    exports2.getChannelzServiceDefinition = getChannelzServiceDefinition;
    exports2.setup = setup;
    var net_1 = require("net");
    var ordered_map_1 = (init_esm4(), __toCommonJS(esm_exports));
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants3();
    var subchannel_address_1 = require_subchannel_address();
    var admin_1 = require_admin();
    var make_client_1 = require_make_client();
    function channelRefToMessage(ref) {
      return {
        channel_id: ref.id,
        name: ref.name
      };
    }
    __name(channelRefToMessage, "channelRefToMessage");
    function subchannelRefToMessage(ref) {
      return {
        subchannel_id: ref.id,
        name: ref.name
      };
    }
    __name(subchannelRefToMessage, "subchannelRefToMessage");
    function serverRefToMessage(ref) {
      return {
        server_id: ref.id
      };
    }
    __name(serverRefToMessage, "serverRefToMessage");
    function socketRefToMessage(ref) {
      return {
        socket_id: ref.id,
        name: ref.name
      };
    }
    __name(socketRefToMessage, "socketRefToMessage");
    var TARGET_RETAINED_TRACES = 32;
    var DEFAULT_MAX_RESULTS = 100;
    var ChannelzTraceStub = class ChannelzTraceStub {
      static {
        __name(this, "ChannelzTraceStub");
      }
      constructor() {
        this.events = [];
        this.creationTimestamp = /* @__PURE__ */ new Date();
        this.eventsLogged = 0;
      }
      addTrace() {
      }
      getTraceMessage() {
        return {
          creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
          num_events_logged: this.eventsLogged,
          events: []
        };
      }
    };
    exports2.ChannelzTraceStub = ChannelzTraceStub;
    var ChannelzTrace = class ChannelzTrace {
      static {
        __name(this, "ChannelzTrace");
      }
      constructor() {
        this.events = [];
        this.eventsLogged = 0;
        this.creationTimestamp = /* @__PURE__ */ new Date();
      }
      addTrace(severity, description, child) {
        const timestamp = /* @__PURE__ */ new Date();
        this.events.push({
          description,
          severity,
          timestamp,
          childChannel: (child === null || child === void 0 ? void 0 : child.kind) === "channel" ? child : void 0,
          childSubchannel: (child === null || child === void 0 ? void 0 : child.kind) === "subchannel" ? child : void 0
        });
        if (this.events.length >= TARGET_RETAINED_TRACES * 2) {
          this.events = this.events.slice(TARGET_RETAINED_TRACES);
        }
        this.eventsLogged += 1;
      }
      getTraceMessage() {
        return {
          creation_timestamp: dateToProtoTimestamp(this.creationTimestamp),
          num_events_logged: this.eventsLogged,
          events: this.events.map((event) => {
            return {
              description: event.description,
              severity: event.severity,
              timestamp: dateToProtoTimestamp(event.timestamp),
              channel_ref: event.childChannel ? channelRefToMessage(event.childChannel) : null,
              subchannel_ref: event.childSubchannel ? subchannelRefToMessage(event.childSubchannel) : null
            };
          })
        };
      }
    };
    exports2.ChannelzTrace = ChannelzTrace;
    var ChannelzChildrenTracker = class ChannelzChildrenTracker {
      static {
        __name(this, "ChannelzChildrenTracker");
      }
      constructor() {
        this.channelChildren = new ordered_map_1.OrderedMap();
        this.subchannelChildren = new ordered_map_1.OrderedMap();
        this.socketChildren = new ordered_map_1.OrderedMap();
        this.trackerMap = {
          [
            "channel"
            /* EntityTypes.channel */
          ]: this.channelChildren,
          [
            "subchannel"
            /* EntityTypes.subchannel */
          ]: this.subchannelChildren,
          [
            "socket"
            /* EntityTypes.socket */
          ]: this.socketChildren
        };
      }
      refChild(child) {
        const tracker = this.trackerMap[child.kind];
        const trackedChild = tracker.find(child.id);
        if (trackedChild.equals(tracker.end())) {
          tracker.setElement(child.id, {
            ref: child,
            count: 1
          }, trackedChild);
        } else {
          trackedChild.pointer[1].count += 1;
        }
      }
      unrefChild(child) {
        const tracker = this.trackerMap[child.kind];
        const trackedChild = tracker.getElementByKey(child.id);
        if (trackedChild !== void 0) {
          trackedChild.count -= 1;
          if (trackedChild.count === 0) {
            tracker.eraseElementByKey(child.id);
          }
        }
      }
      getChildLists() {
        return {
          channels: this.channelChildren,
          subchannels: this.subchannelChildren,
          sockets: this.socketChildren
        };
      }
    };
    exports2.ChannelzChildrenTracker = ChannelzChildrenTracker;
    var ChannelzChildrenTrackerStub = class ChannelzChildrenTrackerStub extends ChannelzChildrenTracker {
      static {
        __name(this, "ChannelzChildrenTrackerStub");
      }
      refChild() {
      }
      unrefChild() {
      }
    };
    exports2.ChannelzChildrenTrackerStub = ChannelzChildrenTrackerStub;
    var ChannelzCallTracker = class ChannelzCallTracker {
      static {
        __name(this, "ChannelzCallTracker");
      }
      constructor() {
        this.callsStarted = 0;
        this.callsSucceeded = 0;
        this.callsFailed = 0;
        this.lastCallStartedTimestamp = null;
      }
      addCallStarted() {
        this.callsStarted += 1;
        this.lastCallStartedTimestamp = /* @__PURE__ */ new Date();
      }
      addCallSucceeded() {
        this.callsSucceeded += 1;
      }
      addCallFailed() {
        this.callsFailed += 1;
      }
    };
    exports2.ChannelzCallTracker = ChannelzCallTracker;
    var ChannelzCallTrackerStub = class ChannelzCallTrackerStub extends ChannelzCallTracker {
      static {
        __name(this, "ChannelzCallTrackerStub");
      }
      addCallStarted() {
      }
      addCallSucceeded() {
      }
      addCallFailed() {
      }
    };
    exports2.ChannelzCallTrackerStub = ChannelzCallTrackerStub;
    var entityMaps = {
      [
        "channel"
        /* EntityTypes.channel */
      ]: new ordered_map_1.OrderedMap(),
      [
        "subchannel"
        /* EntityTypes.subchannel */
      ]: new ordered_map_1.OrderedMap(),
      [
        "server"
        /* EntityTypes.server */
      ]: new ordered_map_1.OrderedMap(),
      [
        "socket"
        /* EntityTypes.socket */
      ]: new ordered_map_1.OrderedMap()
    };
    var generateRegisterFn = /* @__PURE__ */ __name((kind) => {
      let nextId = 1;
      function getNextId() {
        return nextId++;
      }
      __name(getNextId, "getNextId");
      const entityMap = entityMaps[kind];
      return (name, getInfo, channelzEnabled) => {
        const id = getNextId();
        const ref = {
          id,
          name,
          kind
        };
        if (channelzEnabled) {
          entityMap.setElement(id, {
            ref,
            getInfo
          });
        }
        return ref;
      };
    }, "generateRegisterFn");
    exports2.registerChannelzChannel = generateRegisterFn(
      "channel"
      /* EntityTypes.channel */
    );
    exports2.registerChannelzSubchannel = generateRegisterFn(
      "subchannel"
      /* EntityTypes.subchannel */
    );
    exports2.registerChannelzServer = generateRegisterFn(
      "server"
      /* EntityTypes.server */
    );
    exports2.registerChannelzSocket = generateRegisterFn(
      "socket"
      /* EntityTypes.socket */
    );
    function unregisterChannelzRef(ref) {
      entityMaps[ref.kind].eraseElementByKey(ref.id);
    }
    __name(unregisterChannelzRef, "unregisterChannelzRef");
    function parseIPv6Section(addressSection) {
      const numberValue = Number.parseInt(addressSection, 16);
      return [
        numberValue / 256 | 0,
        numberValue % 256
      ];
    }
    __name(parseIPv6Section, "parseIPv6Section");
    function parseIPv6Chunk(addressChunk) {
      if (addressChunk === "") {
        return [];
      }
      const bytePairs = addressChunk.split(":").map((section) => parseIPv6Section(section));
      const result2 = [];
      return result2.concat(...bytePairs);
    }
    __name(parseIPv6Chunk, "parseIPv6Chunk");
    function ipAddressStringToBuffer(ipAddress) {
      if ((0, net_1.isIPv4)(ipAddress)) {
        return Buffer.from(Uint8Array.from(ipAddress.split(".").map((segment) => Number.parseInt(segment))));
      } else if ((0, net_1.isIPv6)(ipAddress)) {
        let leftSection;
        let rightSection;
        const doubleColonIndex = ipAddress.indexOf("::");
        if (doubleColonIndex === -1) {
          leftSection = ipAddress;
          rightSection = "";
        } else {
          leftSection = ipAddress.substring(0, doubleColonIndex);
          rightSection = ipAddress.substring(doubleColonIndex + 2);
        }
        const leftBuffer = Buffer.from(parseIPv6Chunk(leftSection));
        const rightBuffer = Buffer.from(parseIPv6Chunk(rightSection));
        const middleBuffer = Buffer.alloc(16 - leftBuffer.length - rightBuffer.length, 0);
        return Buffer.concat([
          leftBuffer,
          middleBuffer,
          rightBuffer
        ]);
      } else {
        return null;
      }
    }
    __name(ipAddressStringToBuffer, "ipAddressStringToBuffer");
    function connectivityStateToMessage(state) {
      switch (state) {
        case connectivity_state_1.ConnectivityState.CONNECTING:
          return {
            state: "CONNECTING"
          };
        case connectivity_state_1.ConnectivityState.IDLE:
          return {
            state: "IDLE"
          };
        case connectivity_state_1.ConnectivityState.READY:
          return {
            state: "READY"
          };
        case connectivity_state_1.ConnectivityState.SHUTDOWN:
          return {
            state: "SHUTDOWN"
          };
        case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
          return {
            state: "TRANSIENT_FAILURE"
          };
        default:
          return {
            state: "UNKNOWN"
          };
      }
    }
    __name(connectivityStateToMessage, "connectivityStateToMessage");
    function dateToProtoTimestamp(date) {
      if (!date) {
        return null;
      }
      const millisSinceEpoch = date.getTime();
      return {
        seconds: millisSinceEpoch / 1e3 | 0,
        nanos: millisSinceEpoch % 1e3 * 1e6
      };
    }
    __name(dateToProtoTimestamp, "dateToProtoTimestamp");
    function getChannelMessage(channelEntry) {
      const resolvedInfo = channelEntry.getInfo();
      const channelRef = [];
      const subchannelRef = [];
      resolvedInfo.children.channels.forEach((el) => {
        channelRef.push(channelRefToMessage(el[1].ref));
      });
      resolvedInfo.children.subchannels.forEach((el) => {
        subchannelRef.push(subchannelRefToMessage(el[1].ref));
      });
      return {
        ref: channelRefToMessage(channelEntry.ref),
        data: {
          target: resolvedInfo.target,
          state: connectivityStateToMessage(resolvedInfo.state),
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        channel_ref: channelRef,
        subchannel_ref: subchannelRef
      };
    }
    __name(getChannelMessage, "getChannelMessage");
    function GetChannel(call, callback) {
      const channelId = parseInt(call.request.channel_id, 10);
      const channelEntry = entityMaps[
        "channel"
        /* EntityTypes.channel */
      ].getElementByKey(channelId);
      if (channelEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No channel data found for id " + channelId
        });
        return;
      }
      callback(null, {
        channel: getChannelMessage(channelEntry)
      });
    }
    __name(GetChannel, "GetChannel");
    function GetTopChannels(call, callback) {
      const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
      const resultList = [];
      const startId = parseInt(call.request.start_channel_id, 10);
      const channelEntries = entityMaps[
        "channel"
        /* EntityTypes.channel */
      ];
      let i;
      for (i = channelEntries.lowerBound(startId); !i.equals(channelEntries.end()) && resultList.length < maxResults; i = i.next()) {
        resultList.push(getChannelMessage(i.pointer[1]));
      }
      callback(null, {
        channel: resultList,
        end: i.equals(channelEntries.end())
      });
    }
    __name(GetTopChannels, "GetTopChannels");
    function getServerMessage(serverEntry) {
      const resolvedInfo = serverEntry.getInfo();
      const listenSocket = [];
      resolvedInfo.listenerChildren.sockets.forEach((el) => {
        listenSocket.push(socketRefToMessage(el[1].ref));
      });
      return {
        ref: serverRefToMessage(serverEntry.ref),
        data: {
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        listen_socket: listenSocket
      };
    }
    __name(getServerMessage, "getServerMessage");
    function GetServer(call, callback) {
      const serverId = parseInt(call.request.server_id, 10);
      const serverEntries = entityMaps[
        "server"
        /* EntityTypes.server */
      ];
      const serverEntry = serverEntries.getElementByKey(serverId);
      if (serverEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No server data found for id " + serverId
        });
        return;
      }
      callback(null, {
        server: getServerMessage(serverEntry)
      });
    }
    __name(GetServer, "GetServer");
    function GetServers(call, callback) {
      const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
      const startId = parseInt(call.request.start_server_id, 10);
      const serverEntries = entityMaps[
        "server"
        /* EntityTypes.server */
      ];
      const resultList = [];
      let i;
      for (i = serverEntries.lowerBound(startId); !i.equals(serverEntries.end()) && resultList.length < maxResults; i = i.next()) {
        resultList.push(getServerMessage(i.pointer[1]));
      }
      callback(null, {
        server: resultList,
        end: i.equals(serverEntries.end())
      });
    }
    __name(GetServers, "GetServers");
    function GetSubchannel(call, callback) {
      const subchannelId = parseInt(call.request.subchannel_id, 10);
      const subchannelEntry = entityMaps[
        "subchannel"
        /* EntityTypes.subchannel */
      ].getElementByKey(subchannelId);
      if (subchannelEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No subchannel data found for id " + subchannelId
        });
        return;
      }
      const resolvedInfo = subchannelEntry.getInfo();
      const listenSocket = [];
      resolvedInfo.children.sockets.forEach((el) => {
        listenSocket.push(socketRefToMessage(el[1].ref));
      });
      const subchannelMessage = {
        ref: subchannelRefToMessage(subchannelEntry.ref),
        data: {
          target: resolvedInfo.target,
          state: connectivityStateToMessage(resolvedInfo.state),
          calls_started: resolvedInfo.callTracker.callsStarted,
          calls_succeeded: resolvedInfo.callTracker.callsSucceeded,
          calls_failed: resolvedInfo.callTracker.callsFailed,
          last_call_started_timestamp: dateToProtoTimestamp(resolvedInfo.callTracker.lastCallStartedTimestamp),
          trace: resolvedInfo.trace.getTraceMessage()
        },
        socket_ref: listenSocket
      };
      callback(null, {
        subchannel: subchannelMessage
      });
    }
    __name(GetSubchannel, "GetSubchannel");
    function subchannelAddressToAddressMessage(subchannelAddress) {
      var _a2;
      if ((0, subchannel_address_1.isTcpSubchannelAddress)(subchannelAddress)) {
        return {
          address: "tcpip_address",
          tcpip_address: {
            ip_address: (_a2 = ipAddressStringToBuffer(subchannelAddress.host)) !== null && _a2 !== void 0 ? _a2 : void 0,
            port: subchannelAddress.port
          }
        };
      } else {
        return {
          address: "uds_address",
          uds_address: {
            filename: subchannelAddress.path
          }
        };
      }
    }
    __name(subchannelAddressToAddressMessage, "subchannelAddressToAddressMessage");
    function GetSocket(call, callback) {
      var _a2, _b2, _c2, _d, _e;
      const socketId = parseInt(call.request.socket_id, 10);
      const socketEntry = entityMaps[
        "socket"
        /* EntityTypes.socket */
      ].getElementByKey(socketId);
      if (socketEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No socket data found for id " + socketId
        });
        return;
      }
      const resolvedInfo = socketEntry.getInfo();
      const securityMessage = resolvedInfo.security ? {
        model: "tls",
        tls: {
          cipher_suite: resolvedInfo.security.cipherSuiteStandardName ? "standard_name" : "other_name",
          standard_name: (_a2 = resolvedInfo.security.cipherSuiteStandardName) !== null && _a2 !== void 0 ? _a2 : void 0,
          other_name: (_b2 = resolvedInfo.security.cipherSuiteOtherName) !== null && _b2 !== void 0 ? _b2 : void 0,
          local_certificate: (_c2 = resolvedInfo.security.localCertificate) !== null && _c2 !== void 0 ? _c2 : void 0,
          remote_certificate: (_d = resolvedInfo.security.remoteCertificate) !== null && _d !== void 0 ? _d : void 0
        }
      } : null;
      const socketMessage = {
        ref: socketRefToMessage(socketEntry.ref),
        local: resolvedInfo.localAddress ? subchannelAddressToAddressMessage(resolvedInfo.localAddress) : null,
        remote: resolvedInfo.remoteAddress ? subchannelAddressToAddressMessage(resolvedInfo.remoteAddress) : null,
        remote_name: (_e = resolvedInfo.remoteName) !== null && _e !== void 0 ? _e : void 0,
        security: securityMessage,
        data: {
          keep_alives_sent: resolvedInfo.keepAlivesSent,
          streams_started: resolvedInfo.streamsStarted,
          streams_succeeded: resolvedInfo.streamsSucceeded,
          streams_failed: resolvedInfo.streamsFailed,
          last_local_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastLocalStreamCreatedTimestamp),
          last_remote_stream_created_timestamp: dateToProtoTimestamp(resolvedInfo.lastRemoteStreamCreatedTimestamp),
          messages_received: resolvedInfo.messagesReceived,
          messages_sent: resolvedInfo.messagesSent,
          last_message_received_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageReceivedTimestamp),
          last_message_sent_timestamp: dateToProtoTimestamp(resolvedInfo.lastMessageSentTimestamp),
          local_flow_control_window: resolvedInfo.localFlowControlWindow ? {
            value: resolvedInfo.localFlowControlWindow
          } : null,
          remote_flow_control_window: resolvedInfo.remoteFlowControlWindow ? {
            value: resolvedInfo.remoteFlowControlWindow
          } : null
        }
      };
      callback(null, {
        socket: socketMessage
      });
    }
    __name(GetSocket, "GetSocket");
    function GetServerSockets(call, callback) {
      const serverId = parseInt(call.request.server_id, 10);
      const serverEntry = entityMaps[
        "server"
        /* EntityTypes.server */
      ].getElementByKey(serverId);
      if (serverEntry === void 0) {
        callback({
          code: constants_1.Status.NOT_FOUND,
          details: "No server data found for id " + serverId
        });
        return;
      }
      const startId = parseInt(call.request.start_socket_id, 10);
      const maxResults = parseInt(call.request.max_results, 10) || DEFAULT_MAX_RESULTS;
      const resolvedInfo = serverEntry.getInfo();
      const allSockets = resolvedInfo.sessionChildren.sockets;
      const resultList = [];
      let i;
      for (i = allSockets.lowerBound(startId); !i.equals(allSockets.end()) && resultList.length < maxResults; i = i.next()) {
        resultList.push(socketRefToMessage(i.pointer[1].ref));
      }
      callback(null, {
        socket_ref: resultList,
        end: i.equals(allSockets.end())
      });
    }
    __name(GetServerSockets, "GetServerSockets");
    function getChannelzHandlers() {
      return {
        GetChannel,
        GetTopChannels,
        GetServer,
        GetServers,
        GetSubchannel,
        GetSocket,
        GetServerSockets
      };
    }
    __name(getChannelzHandlers, "getChannelzHandlers");
    var loadedChannelzDefinition = null;
    function getChannelzServiceDefinition() {
      if (loadedChannelzDefinition) {
        return loadedChannelzDefinition;
      }
      const loaderLoadSync = require_src6().loadSync;
      const loadedProto = loaderLoadSync("channelz.proto", {
        keepCase: true,
        longs: String,
        enums: String,
        defaults: true,
        oneofs: true,
        includeDirs: [
          `${__dirname}/../../proto`
        ]
      });
      const channelzGrpcObject = (0, make_client_1.loadPackageDefinition)(loadedProto);
      loadedChannelzDefinition = channelzGrpcObject.grpc.channelz.v1.Channelz.service;
      return loadedChannelzDefinition;
    }
    __name(getChannelzServiceDefinition, "getChannelzServiceDefinition");
    function setup() {
      (0, admin_1.registerAdminService)(getChannelzServiceDefinition, getChannelzHandlers);
    }
    __name(setup, "setup");
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel.js
var require_subchannel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Subchannel = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var backoff_timeout_1 = require_backoff_timeout();
    var logging = require_logging();
    var constants_1 = require_constants3();
    var uri_parser_1 = require_uri_parser();
    var subchannel_address_1 = require_subchannel_address();
    var channelz_1 = require_channelz();
    var TRACER_NAME = "subchannel";
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var Subchannel = class Subchannel {
      static {
        __name(this, "Subchannel");
      }
      /**
       * A class representing a connection to a single backend.
       * @param channelTarget The target string for the channel as a whole
       * @param subchannelAddress The address for the backend that this subchannel
       *     will connect to
       * @param options The channel options, plus any specific subchannel options
       *     for this subchannel
       * @param credentials The channel credentials used to establish this
       *     connection
       */
      constructor(channelTarget, subchannelAddress, options, credentials, connector) {
        var _a2;
        this.channelTarget = channelTarget;
        this.subchannelAddress = subchannelAddress;
        this.options = options;
        this.credentials = credentials;
        this.connector = connector;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.transport = null;
        this.continueConnecting = false;
        this.stateListeners = /* @__PURE__ */ new Set();
        this.refcount = 0;
        this.channelzEnabled = true;
        const backoffOptions = {
          initialDelay: options["grpc.initial_reconnect_backoff_ms"],
          maxDelay: options["grpc.max_reconnect_backoff_ms"]
        };
        this.backoffTimeout = new backoff_timeout_1.BackoffTimeout(() => {
          this.handleBackoffTimer();
        }, backoffOptions);
        this.backoffTimeout.unref();
        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
        this.keepaliveTime = (_a2 = options["grpc.keepalive_time_ms"]) !== null && _a2 !== void 0 ? _a2 : -1;
        if (options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
          this.channelzTrace = new channelz_1.ChannelzTraceStub();
          this.callTracker = new channelz_1.ChannelzCallTrackerStub();
          this.childrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
          this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
        } else {
          this.channelzTrace = new channelz_1.ChannelzTrace();
          this.callTracker = new channelz_1.ChannelzCallTracker();
          this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
          this.streamTracker = new channelz_1.ChannelzCallTracker();
        }
        this.channelzRef = (0, channelz_1.registerChannelzSubchannel)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        this.channelzTrace.addTrace("CT_INFO", "Subchannel created");
        this.trace("Subchannel constructed with options " + JSON.stringify(options, void 0, 2));
        credentials._ref();
      }
      getChannelzInfo() {
        return {
          state: this.connectivityState,
          trace: this.channelzTrace,
          callTracker: this.callTracker,
          children: this.childrenTracker.getChildLists(),
          target: this.subchannelAddressString
        };
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      refTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "subchannel_refcount", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      handleBackoffTimer() {
        if (this.continueConnecting) {
          this.transitionToState([
            connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE
          ], connectivity_state_1.ConnectivityState.CONNECTING);
        } else {
          this.transitionToState([
            connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE
          ], connectivity_state_1.ConnectivityState.IDLE);
        }
      }
      /**
       * Start a backoff timer with the current nextBackoff timeout
       */
      startBackoff() {
        this.backoffTimeout.runOnce();
      }
      stopBackoff() {
        this.backoffTimeout.stop();
        this.backoffTimeout.reset();
      }
      startConnectingInternal() {
        let options = this.options;
        if (options["grpc.keepalive_time_ms"]) {
          const adjustedKeepaliveTime = Math.min(this.keepaliveTime, KEEPALIVE_MAX_TIME_MS);
          options = Object.assign(Object.assign({}, options), {
            "grpc.keepalive_time_ms": adjustedKeepaliveTime
          });
        }
        this.connector.connect(this.subchannelAddress, this.credentials, options).then((transport) => {
          if (this.transitionToState([
            connectivity_state_1.ConnectivityState.CONNECTING
          ], connectivity_state_1.ConnectivityState.READY)) {
            this.transport = transport;
            if (this.channelzEnabled) {
              this.childrenTracker.refChild(transport.getChannelzRef());
            }
            transport.addDisconnectListener((tooManyPings) => {
              this.transitionToState([
                connectivity_state_1.ConnectivityState.READY
              ], connectivity_state_1.ConnectivityState.IDLE);
              if (tooManyPings && this.keepaliveTime > 0) {
                this.keepaliveTime *= 2;
                logging.log(constants_1.LogVerbosity.ERROR, `Connection to ${(0, uri_parser_1.uriToString)(this.channelTarget)} at ${this.subchannelAddressString} rejected by server because of excess pings. Increasing ping interval to ${this.keepaliveTime} ms`);
              }
            });
          } else {
            transport.shutdown();
          }
        }, (error) => {
          this.transitionToState([
            connectivity_state_1.ConnectivityState.CONNECTING
          ], connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, `${error}`);
        });
      }
      /**
       * Initiate a state transition from any element of oldStates to the new
       * state. If the current connectivityState is not in oldStates, do nothing.
       * @param oldStates The set of states to transition from
       * @param newState The state to transition to
       * @returns True if the state changed, false otherwise
       */
      transitionToState(oldStates, newState, errorMessage) {
        var _a2, _b2;
        if (oldStates.indexOf(this.connectivityState) === -1) {
          return false;
        }
        if (errorMessage) {
          this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState] + ' with error "' + errorMessage + '"');
        } else {
          this.trace(connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        }
        if (this.channelzEnabled) {
          this.channelzTrace.addTrace("CT_INFO", "Connectivity state change to " + connectivity_state_1.ConnectivityState[newState]);
        }
        const previousState = this.connectivityState;
        this.connectivityState = newState;
        switch (newState) {
          case connectivity_state_1.ConnectivityState.READY:
            this.stopBackoff();
            break;
          case connectivity_state_1.ConnectivityState.CONNECTING:
            this.startBackoff();
            this.startConnectingInternal();
            this.continueConnecting = false;
            break;
          case connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE:
            if (this.channelzEnabled && this.transport) {
              this.childrenTracker.unrefChild(this.transport.getChannelzRef());
            }
            (_a2 = this.transport) === null || _a2 === void 0 ? void 0 : _a2.shutdown();
            this.transport = null;
            if (!this.backoffTimeout.isRunning()) {
              process.nextTick(() => {
                this.handleBackoffTimer();
              });
            }
            break;
          case connectivity_state_1.ConnectivityState.IDLE:
            if (this.channelzEnabled && this.transport) {
              this.childrenTracker.unrefChild(this.transport.getChannelzRef());
            }
            (_b2 = this.transport) === null || _b2 === void 0 ? void 0 : _b2.shutdown();
            this.transport = null;
            break;
          default:
            throw new Error(`Invalid state: unknown ConnectivityState ${newState}`);
        }
        for (const listener of this.stateListeners) {
          listener(this, previousState, newState, this.keepaliveTime, errorMessage);
        }
        return true;
      }
      ref() {
        this.refTrace("refcount " + this.refcount + " -> " + (this.refcount + 1));
        this.refcount += 1;
      }
      unref() {
        this.refTrace("refcount " + this.refcount + " -> " + (this.refcount - 1));
        this.refcount -= 1;
        if (this.refcount === 0) {
          this.channelzTrace.addTrace("CT_INFO", "Shutting down");
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
          this.credentials._unref();
          process.nextTick(() => {
            this.transitionToState([
              connectivity_state_1.ConnectivityState.CONNECTING,
              connectivity_state_1.ConnectivityState.READY
            ], connectivity_state_1.ConnectivityState.IDLE);
          });
        }
      }
      unrefIfOneRef() {
        if (this.refcount === 1) {
          this.unref();
          return true;
        }
        return false;
      }
      createCall(metadata, host, method, listener) {
        if (!this.transport) {
          throw new Error("Cannot create call, subchannel not READY");
        }
        let statsTracker;
        if (this.channelzEnabled) {
          this.callTracker.addCallStarted();
          this.streamTracker.addCallStarted();
          statsTracker = {
            onCallEnd: /* @__PURE__ */ __name((status) => {
              if (status.code === constants_1.Status.OK) {
                this.callTracker.addCallSucceeded();
              } else {
                this.callTracker.addCallFailed();
              }
            }, "onCallEnd")
          };
        } else {
          statsTracker = {};
        }
        return this.transport.createCall(metadata, host, method, listener, statsTracker);
      }
      /**
       * If the subchannel is currently IDLE, start connecting and switch to the
       * CONNECTING state. If the subchannel is current in TRANSIENT_FAILURE,
       * the next time it would transition to IDLE, start connecting again instead.
       * Otherwise, do nothing.
       */
      startConnecting() {
        process.nextTick(() => {
          if (!this.transitionToState([
            connectivity_state_1.ConnectivityState.IDLE
          ], connectivity_state_1.ConnectivityState.CONNECTING)) {
            if (this.connectivityState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
              this.continueConnecting = true;
            }
          }
        });
      }
      /**
       * Get the subchannel's current connectivity state.
       */
      getConnectivityState() {
        return this.connectivityState;
      }
      /**
       * Add a listener function to be called whenever the subchannel's
       * connectivity state changes.
       * @param listener
       */
      addConnectivityStateListener(listener) {
        this.stateListeners.add(listener);
      }
      /**
       * Remove a listener previously added with `addConnectivityStateListener`
       * @param listener A reference to a function previously passed to
       *     `addConnectivityStateListener`
       */
      removeConnectivityStateListener(listener) {
        this.stateListeners.delete(listener);
      }
      /**
       * Reset the backoff timeout, and immediately start connecting if in backoff.
       */
      resetBackoff() {
        process.nextTick(() => {
          this.backoffTimeout.reset();
          this.transitionToState([
            connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE
          ], connectivity_state_1.ConnectivityState.CONNECTING);
        });
      }
      getAddress() {
        return this.subchannelAddressString;
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      isHealthy() {
        return true;
      }
      addHealthStateWatcher(listener) {
      }
      removeHealthStateWatcher(listener) {
      }
      getRealSubchannel() {
        return this;
      }
      realSubchannelEquals(other) {
        return other.getRealSubchannel() === this;
      }
      throttleKeepalive(newKeepaliveTime) {
        if (newKeepaliveTime > this.keepaliveTime) {
          this.keepaliveTime = newKeepaliveTime;
        }
      }
    };
    exports2.Subchannel = Subchannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/environment.js
var require_environment = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/environment.js"(exports2) {
    "use strict";
    var _a2;
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = void 0;
    exports2.GRPC_NODE_USE_ALTERNATIVE_RESOLVER = ((_a2 = process.env.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) !== null && _a2 !== void 0 ? _a2 : "false") === "true";
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-dns.js
var require_resolver_dns = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-dns.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.DEFAULT_PORT = void 0;
    exports2.setup = setup;
    var resolver_1 = require_resolver();
    var dns_1 = require("dns");
    var service_config_1 = require_service_config();
    var constants_1 = require_constants3();
    var metadata_1 = require_metadata2();
    var logging = require_logging();
    var constants_2 = require_constants3();
    var uri_parser_1 = require_uri_parser();
    var net_1 = require("net");
    var backoff_timeout_1 = require_backoff_timeout();
    var environment_1 = require_environment();
    var TRACER_NAME = "dns_resolver";
    function trace(text) {
      logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    exports2.DEFAULT_PORT = 443;
    var DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS = 3e4;
    var DnsResolver = class DnsResolver {
      static {
        __name(this, "DnsResolver");
      }
      constructor(target, listener, channelOptions) {
        var _a2, _b2, _c2;
        this.target = target;
        this.listener = listener;
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        this.continueResolving = false;
        this.isNextResolutionTimerRunning = false;
        this.isServiceConfigEnabled = true;
        this.returnedIpResult = false;
        this.alternativeResolver = new dns_1.promises.Resolver();
        trace("Resolver constructed for target " + (0, uri_parser_1.uriToString)(target));
        if (target.authority) {
          this.alternativeResolver.setServers([
            target.authority
          ]);
        }
        const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
        if (hostPort === null) {
          this.ipResult = null;
          this.dnsHostname = null;
          this.port = null;
        } else {
          if ((0, net_1.isIPv4)(hostPort.host) || (0, net_1.isIPv6)(hostPort.host)) {
            this.ipResult = [
              {
                addresses: [
                  {
                    host: hostPort.host,
                    port: (_a2 = hostPort.port) !== null && _a2 !== void 0 ? _a2 : exports2.DEFAULT_PORT
                  }
                ]
              }
            ];
            this.dnsHostname = null;
            this.port = null;
          } else {
            this.ipResult = null;
            this.dnsHostname = hostPort.host;
            this.port = (_b2 = hostPort.port) !== null && _b2 !== void 0 ? _b2 : exports2.DEFAULT_PORT;
          }
        }
        this.percentage = Math.random() * 100;
        if (channelOptions["grpc.service_config_disable_resolution"] === 1) {
          this.isServiceConfigEnabled = false;
        }
        this.defaultResolutionError = {
          code: constants_1.Status.UNAVAILABLE,
          details: `Name resolution failed for target ${(0, uri_parser_1.uriToString)(this.target)}`,
          metadata: new metadata_1.Metadata()
        };
        const backoffOptions = {
          initialDelay: channelOptions["grpc.initial_reconnect_backoff_ms"],
          maxDelay: channelOptions["grpc.max_reconnect_backoff_ms"]
        };
        this.backoff = new backoff_timeout_1.BackoffTimeout(() => {
          if (this.continueResolving) {
            this.startResolutionWithBackoff();
          }
        }, backoffOptions);
        this.backoff.unref();
        this.minTimeBetweenResolutionsMs = (_c2 = channelOptions["grpc.dns_min_time_between_resolutions_ms"]) !== null && _c2 !== void 0 ? _c2 : DEFAULT_MIN_TIME_BETWEEN_RESOLUTIONS_MS;
        this.nextResolutionTimer = setTimeout(() => {
        }, 0);
        clearTimeout(this.nextResolutionTimer);
      }
      /**
       * If the target is an IP address, just provide that address as a result.
       * Otherwise, initiate A, AAAA, and TXT lookups
       */
      startResolution() {
        if (this.ipResult !== null) {
          if (!this.returnedIpResult) {
            trace("Returning IP address for target " + (0, uri_parser_1.uriToString)(this.target));
            setImmediate(() => {
              this.listener.onSuccessfulResolution(this.ipResult, null, null, null, {});
            });
            this.returnedIpResult = true;
          }
          this.backoff.stop();
          this.backoff.reset();
          this.stopNextResolutionTimer();
          return;
        }
        if (this.dnsHostname === null) {
          trace("Failed to parse DNS address " + (0, uri_parser_1.uriToString)(this.target));
          setImmediate(() => {
            this.listener.onError({
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse DNS address ${(0, uri_parser_1.uriToString)(this.target)}`,
              metadata: new metadata_1.Metadata()
            });
          });
          this.stopNextResolutionTimer();
        } else {
          if (this.pendingLookupPromise !== null) {
            return;
          }
          trace("Looking up DNS hostname " + this.dnsHostname);
          this.latestLookupResult = null;
          const hostname = this.dnsHostname;
          this.pendingLookupPromise = this.lookup(hostname);
          this.pendingLookupPromise.then((addressList) => {
            if (this.pendingLookupPromise === null) {
              return;
            }
            this.pendingLookupPromise = null;
            this.backoff.reset();
            this.backoff.stop();
            this.latestLookupResult = addressList.map((address) => ({
              addresses: [
                address
              ]
            }));
            const allAddressesString = "[" + addressList.map((addr) => addr.host + ":" + addr.port).join(",") + "]";
            trace("Resolved addresses for target " + (0, uri_parser_1.uriToString)(this.target) + ": " + allAddressesString);
            if (this.latestLookupResult.length === 0) {
              this.listener.onError(this.defaultResolutionError);
              return;
            }
            this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
          }, (err) => {
            if (this.pendingLookupPromise === null) {
              return;
            }
            trace("Resolution error for target " + (0, uri_parser_1.uriToString)(this.target) + ": " + err.message);
            this.pendingLookupPromise = null;
            this.stopNextResolutionTimer();
            this.listener.onError(this.defaultResolutionError);
          });
          if (this.isServiceConfigEnabled && this.pendingTxtPromise === null) {
            this.pendingTxtPromise = this.resolveTxt(hostname);
            this.pendingTxtPromise.then((txtRecord) => {
              if (this.pendingTxtPromise === null) {
                return;
              }
              this.pendingTxtPromise = null;
              try {
                this.latestServiceConfig = (0, service_config_1.extractAndSelectServiceConfig)(txtRecord, this.percentage);
              } catch (err) {
                this.latestServiceConfigError = {
                  code: constants_1.Status.UNAVAILABLE,
                  details: `Parsing service config failed with error ${err.message}`,
                  metadata: new metadata_1.Metadata()
                };
              }
              if (this.latestLookupResult !== null) {
                this.listener.onSuccessfulResolution(this.latestLookupResult, this.latestServiceConfig, this.latestServiceConfigError, null, {});
              }
            }, (err) => {
            });
          }
        }
      }
      async lookup(hostname) {
        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
          trace("Using alternative DNS resolver.");
          const records = await Promise.allSettled([
            this.alternativeResolver.resolve4(hostname),
            this.alternativeResolver.resolve6(hostname)
          ]);
          if (records.every((result2) => result2.status === "rejected")) {
            throw new Error(records[0].reason);
          }
          return records.reduce((acc, result2) => {
            return result2.status === "fulfilled" ? [
              ...acc,
              ...result2.value
            ] : acc;
          }, []).map((addr) => ({
            host: addr,
            port: +this.port
          }));
        }
        const addressList = await dns_1.promises.lookup(hostname, {
          all: true
        });
        return addressList.map((addr) => ({
          host: addr.address,
          port: +this.port
        }));
      }
      async resolveTxt(hostname) {
        if (environment_1.GRPC_NODE_USE_ALTERNATIVE_RESOLVER) {
          trace("Using alternative DNS resolver.");
          return this.alternativeResolver.resolveTxt(hostname);
        }
        return dns_1.promises.resolveTxt(hostname);
      }
      startNextResolutionTimer() {
        var _a2, _b2;
        clearTimeout(this.nextResolutionTimer);
        this.nextResolutionTimer = setTimeout(() => {
          this.stopNextResolutionTimer();
          if (this.continueResolving) {
            this.startResolutionWithBackoff();
          }
        }, this.minTimeBetweenResolutionsMs);
        (_b2 = (_a2 = this.nextResolutionTimer).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        this.isNextResolutionTimerRunning = true;
      }
      stopNextResolutionTimer() {
        clearTimeout(this.nextResolutionTimer);
        this.isNextResolutionTimerRunning = false;
      }
      startResolutionWithBackoff() {
        if (this.pendingLookupPromise === null) {
          this.continueResolving = false;
          this.backoff.runOnce();
          this.startNextResolutionTimer();
          this.startResolution();
        }
      }
      updateResolution() {
        if (this.pendingLookupPromise === null) {
          if (this.isNextResolutionTimerRunning || this.backoff.isRunning()) {
            if (this.isNextResolutionTimerRunning) {
              trace('resolution update delayed by "min time between resolutions" rate limit');
            } else {
              trace("resolution update delayed by backoff timer until " + this.backoff.getEndTime().toISOString());
            }
            this.continueResolving = true;
          } else {
            this.startResolutionWithBackoff();
          }
        }
      }
      /**
       * Reset the resolver to the same state it had when it was created. In-flight
       * DNS requests cannot be cancelled, but they are discarded and their results
       * will be ignored.
       */
      destroy() {
        this.continueResolving = false;
        this.backoff.reset();
        this.backoff.stop();
        this.stopNextResolutionTimer();
        this.pendingLookupPromise = null;
        this.pendingTxtPromise = null;
        this.latestLookupResult = null;
        this.latestServiceConfig = null;
        this.latestServiceConfigError = null;
        this.returnedIpResult = false;
      }
      /**
       * Get the default authority for the given target. For IP targets, that is
       * the IP address. For DNS targets, it is the hostname.
       * @param target
       */
      static getDefaultAuthority(target) {
        return target.path;
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)("dns", DnsResolver);
      (0, resolver_1.registerDefaultScheme)("dns");
    }
    __name(setup, "setup");
  }
});

// node_modules/@grpc/grpc-js/build/src/http_proxy.js
var require_http_proxy = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/http_proxy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.mapProxyName = mapProxyName;
    exports2.getProxiedConnection = getProxiedConnection;
    var logging_1 = require_logging();
    var constants_1 = require_constants3();
    var resolver_1 = require_resolver();
    var http = require("http");
    var tls = require("tls");
    var logging = require_logging();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var url_1 = require("url");
    var resolver_dns_1 = require_resolver_dns();
    var TRACER_NAME = "proxy";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    function getProxyInfo() {
      let proxyEnv = "";
      let envVar = "";
      if (process.env.grpc_proxy) {
        envVar = "grpc_proxy";
        proxyEnv = process.env.grpc_proxy;
      } else if (process.env.https_proxy) {
        envVar = "https_proxy";
        proxyEnv = process.env.https_proxy;
      } else if (process.env.http_proxy) {
        envVar = "http_proxy";
        proxyEnv = process.env.http_proxy;
      } else {
        return {};
      }
      let proxyUrl;
      try {
        proxyUrl = new url_1.URL(proxyEnv);
      } catch (e) {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `cannot parse value of "${envVar}" env var`);
        return {};
      }
      if (proxyUrl.protocol !== "http:") {
        (0, logging_1.log)(constants_1.LogVerbosity.ERROR, `"${proxyUrl.protocol}" scheme not supported in proxy URI`);
        return {};
      }
      let userCred = null;
      if (proxyUrl.username) {
        if (proxyUrl.password) {
          (0, logging_1.log)(constants_1.LogVerbosity.INFO, "userinfo found in proxy URI");
          userCred = decodeURIComponent(`${proxyUrl.username}:${proxyUrl.password}`);
        } else {
          userCred = proxyUrl.username;
        }
      }
      const hostname = proxyUrl.hostname;
      let port = proxyUrl.port;
      if (port === "") {
        port = "80";
      }
      const result2 = {
        address: `${hostname}:${port}`
      };
      if (userCred) {
        result2.creds = userCred;
      }
      trace("Proxy server " + result2.address + " set by environment variable " + envVar);
      return result2;
    }
    __name(getProxyInfo, "getProxyInfo");
    function getNoProxyHostList() {
      let noProxyStr = process.env.no_grpc_proxy;
      let envVar = "no_grpc_proxy";
      if (!noProxyStr) {
        noProxyStr = process.env.no_proxy;
        envVar = "no_proxy";
      }
      if (noProxyStr) {
        trace("No proxy server list set by environment variable " + envVar);
        return noProxyStr.split(",");
      } else {
        return [];
      }
    }
    __name(getNoProxyHostList, "getNoProxyHostList");
    function mapProxyName(target, options) {
      var _a2;
      const noProxyResult = {
        target,
        extraOptions: {}
      };
      if (((_a2 = options["grpc.enable_http_proxy"]) !== null && _a2 !== void 0 ? _a2 : 1) === 0) {
        return noProxyResult;
      }
      if (target.scheme === "unix") {
        return noProxyResult;
      }
      const proxyInfo = getProxyInfo();
      if (!proxyInfo.address) {
        return noProxyResult;
      }
      const hostPort = (0, uri_parser_1.splitHostPort)(target.path);
      if (!hostPort) {
        return noProxyResult;
      }
      const serverHost = hostPort.host;
      for (const host of getNoProxyHostList()) {
        if (host === serverHost) {
          trace("Not using proxy for target in no_proxy list: " + (0, uri_parser_1.uriToString)(target));
          return noProxyResult;
        }
      }
      const extraOptions = {
        "grpc.http_connect_target": (0, uri_parser_1.uriToString)(target)
      };
      if (proxyInfo.creds) {
        extraOptions["grpc.http_connect_creds"] = proxyInfo.creds;
      }
      return {
        target: {
          scheme: "dns",
          path: proxyInfo.address
        },
        extraOptions
      };
    }
    __name(mapProxyName, "mapProxyName");
    function getProxiedConnection(address, channelOptions, connectionOptions) {
      var _a2;
      if (!("grpc.http_connect_target" in channelOptions)) {
        return Promise.resolve({});
      }
      const realTarget = channelOptions["grpc.http_connect_target"];
      const parsedTarget = (0, uri_parser_1.parseUri)(realTarget);
      if (parsedTarget === null) {
        return Promise.resolve({});
      }
      const splitHostPost = (0, uri_parser_1.splitHostPort)(parsedTarget.path);
      if (splitHostPost === null) {
        return Promise.resolve({});
      }
      const hostPort = `${splitHostPost.host}:${(_a2 = splitHostPost.port) !== null && _a2 !== void 0 ? _a2 : resolver_dns_1.DEFAULT_PORT}`;
      const options = {
        method: "CONNECT",
        path: hostPort
      };
      const headers = {
        Host: hostPort
      };
      if ((0, subchannel_address_1.isTcpSubchannelAddress)(address)) {
        options.host = address.host;
        options.port = address.port;
      } else {
        options.socketPath = address.path;
      }
      if ("grpc.http_connect_creds" in channelOptions) {
        headers["Proxy-Authorization"] = "Basic " + Buffer.from(channelOptions["grpc.http_connect_creds"]).toString("base64");
      }
      options.headers = headers;
      const proxyAddressString = (0, subchannel_address_1.subchannelAddressToString)(address);
      trace("Using proxy " + proxyAddressString + " to connect to " + options.path);
      return new Promise((resolve5, reject) => {
        const request = http.request(options);
        request.once("connect", (res, socket, head) => {
          var _a3;
          request.removeAllListeners();
          socket.removeAllListeners();
          if (res.statusCode === 200) {
            trace("Successfully connected to " + options.path + " through proxy " + proxyAddressString);
            if (head.length > 0) {
              socket.unshift(head);
            }
            if ("secureContext" in connectionOptions) {
              const targetPath = (0, resolver_1.getDefaultAuthority)(parsedTarget);
              const hostPort2 = (0, uri_parser_1.splitHostPort)(targetPath);
              const remoteHost = (_a3 = hostPort2 === null || hostPort2 === void 0 ? void 0 : hostPort2.host) !== null && _a3 !== void 0 ? _a3 : targetPath;
              const cts = tls.connect(Object.assign({
                host: remoteHost,
                servername: remoteHost,
                socket
              }, connectionOptions), () => {
                trace("Successfully established a TLS connection to " + options.path + " through proxy " + proxyAddressString);
                resolve5({
                  socket: cts,
                  realTarget: parsedTarget
                });
              });
              cts.on("error", (error) => {
                trace("Failed to establish a TLS connection to " + options.path + " through proxy " + proxyAddressString + " with error " + error.message);
                reject();
              });
            } else {
              trace("Successfully established a plaintext connection to " + options.path + " through proxy " + proxyAddressString);
              resolve5({
                socket,
                realTarget: parsedTarget
              });
            }
          } else {
            (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to connect to " + options.path + " through proxy " + proxyAddressString + " with status " + res.statusCode);
            reject();
          }
        });
        request.once("error", (err) => {
          request.removeAllListeners();
          (0, logging_1.log)(constants_1.LogVerbosity.ERROR, "Failed to connect to proxy " + proxyAddressString + " with error " + err.message);
          reject();
        });
        request.end();
      });
    }
    __name(getProxiedConnection, "getProxiedConnection");
  }
});

// node_modules/@grpc/grpc-js/build/src/stream-decoder.js
var require_stream_decoder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/stream-decoder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.StreamDecoder = void 0;
    var ReadState;
    (function(ReadState2) {
      ReadState2[ReadState2["NO_DATA"] = 0] = "NO_DATA";
      ReadState2[ReadState2["READING_SIZE"] = 1] = "READING_SIZE";
      ReadState2[ReadState2["READING_MESSAGE"] = 2] = "READING_MESSAGE";
    })(ReadState || (ReadState = {}));
    var StreamDecoder = class StreamDecoder {
      static {
        __name(this, "StreamDecoder");
      }
      constructor(maxReadMessageLength) {
        this.maxReadMessageLength = maxReadMessageLength;
        this.readState = ReadState.NO_DATA;
        this.readCompressFlag = Buffer.alloc(1);
        this.readPartialSize = Buffer.alloc(4);
        this.readSizeRemaining = 4;
        this.readMessageSize = 0;
        this.readPartialMessage = [];
        this.readMessageRemaining = 0;
      }
      write(data) {
        let readHead = 0;
        let toRead;
        const result2 = [];
        while (readHead < data.length) {
          switch (this.readState) {
            case ReadState.NO_DATA:
              this.readCompressFlag = data.slice(readHead, readHead + 1);
              readHead += 1;
              this.readState = ReadState.READING_SIZE;
              this.readPartialSize.fill(0);
              this.readSizeRemaining = 4;
              this.readMessageSize = 0;
              this.readMessageRemaining = 0;
              this.readPartialMessage = [];
              break;
            case ReadState.READING_SIZE:
              toRead = Math.min(data.length - readHead, this.readSizeRemaining);
              data.copy(this.readPartialSize, 4 - this.readSizeRemaining, readHead, readHead + toRead);
              this.readSizeRemaining -= toRead;
              readHead += toRead;
              if (this.readSizeRemaining === 0) {
                this.readMessageSize = this.readPartialSize.readUInt32BE(0);
                if (this.maxReadMessageLength !== -1 && this.readMessageSize > this.maxReadMessageLength) {
                  throw new Error(`Received message larger than max (${this.readMessageSize} vs ${this.maxReadMessageLength})`);
                }
                this.readMessageRemaining = this.readMessageSize;
                if (this.readMessageRemaining > 0) {
                  this.readState = ReadState.READING_MESSAGE;
                } else {
                  const message = Buffer.concat([
                    this.readCompressFlag,
                    this.readPartialSize
                  ], 5);
                  this.readState = ReadState.NO_DATA;
                  result2.push(message);
                }
              }
              break;
            case ReadState.READING_MESSAGE:
              toRead = Math.min(data.length - readHead, this.readMessageRemaining);
              this.readPartialMessage.push(data.slice(readHead, readHead + toRead));
              this.readMessageRemaining -= toRead;
              readHead += toRead;
              if (this.readMessageRemaining === 0) {
                const framedMessageBuffers = [
                  this.readCompressFlag,
                  this.readPartialSize
                ].concat(this.readPartialMessage);
                const framedMessage = Buffer.concat(framedMessageBuffers, this.readMessageSize + 5);
                this.readState = ReadState.NO_DATA;
                result2.push(framedMessage);
              }
              break;
            default:
              throw new Error("Unexpected read state");
          }
        }
        return result2;
      }
    };
    exports2.StreamDecoder = StreamDecoder;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-call.js
var require_subchannel_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Http2SubchannelCall = void 0;
    var http2 = require("http2");
    var os = require("os");
    var constants_1 = require_constants3();
    var metadata_1 = require_metadata2();
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var constants_2 = require_constants3();
    var TRACER_NAME = "subchannel_call";
    function getSystemErrorName(errno) {
      for (const [name, num] of Object.entries(os.constants.errno)) {
        if (num === errno) {
          return name;
        }
      }
      return "Unknown system error " + errno;
    }
    __name(getSystemErrorName, "getSystemErrorName");
    function mapHttpStatusCode(code) {
      const details = `Received HTTP status code ${code}`;
      let mappedStatusCode;
      switch (code) {
        // TODO(murgatroid99): handle 100 and 101
        case 400:
          mappedStatusCode = constants_1.Status.INTERNAL;
          break;
        case 401:
          mappedStatusCode = constants_1.Status.UNAUTHENTICATED;
          break;
        case 403:
          mappedStatusCode = constants_1.Status.PERMISSION_DENIED;
          break;
        case 404:
          mappedStatusCode = constants_1.Status.UNIMPLEMENTED;
          break;
        case 429:
        case 502:
        case 503:
        case 504:
          mappedStatusCode = constants_1.Status.UNAVAILABLE;
          break;
        default:
          mappedStatusCode = constants_1.Status.UNKNOWN;
      }
      return {
        code: mappedStatusCode,
        details,
        metadata: new metadata_1.Metadata()
      };
    }
    __name(mapHttpStatusCode, "mapHttpStatusCode");
    var Http2SubchannelCall = class Http2SubchannelCall {
      static {
        __name(this, "Http2SubchannelCall");
      }
      constructor(http2Stream, callEventTracker, listener, transport, callId) {
        var _a2;
        this.http2Stream = http2Stream;
        this.callEventTracker = callEventTracker;
        this.listener = listener;
        this.transport = transport;
        this.callId = callId;
        this.isReadFilterPending = false;
        this.isPushPending = false;
        this.canPush = false;
        this.readsClosed = false;
        this.statusOutput = false;
        this.unpushedReadMessages = [];
        this.finalStatus = null;
        this.internalError = null;
        this.serverEndedCall = false;
        this.connectionDropped = false;
        const maxReceiveMessageLength = (_a2 = transport.getOptions()["grpc.max_receive_message_length"]) !== null && _a2 !== void 0 ? _a2 : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.decoder = new stream_decoder_1.StreamDecoder(maxReceiveMessageLength);
        http2Stream.on("response", (headers, flags) => {
          let headersString = "";
          for (const header of Object.keys(headers)) {
            headersString += "		" + header + ": " + headers[header] + "\n";
          }
          this.trace("Received server headers:\n" + headersString);
          this.httpStatusCode = headers[":status"];
          if (flags & http2.constants.NGHTTP2_FLAG_END_STREAM) {
            this.handleTrailers(headers);
          } else {
            let metadata;
            try {
              metadata = metadata_1.Metadata.fromHttp2Headers(headers);
            } catch (error) {
              this.endCall({
                code: constants_1.Status.UNKNOWN,
                details: error.message,
                metadata: new metadata_1.Metadata()
              });
              return;
            }
            this.listener.onReceiveMetadata(metadata);
          }
        });
        http2Stream.on("trailers", (headers) => {
          this.handleTrailers(headers);
        });
        http2Stream.on("data", (data) => {
          if (this.statusOutput) {
            return;
          }
          this.trace("receive HTTP/2 data frame of length " + data.length);
          let messages;
          try {
            messages = this.decoder.write(data);
          } catch (e) {
            if (this.httpStatusCode !== void 0 && this.httpStatusCode !== 200) {
              const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
              this.cancelWithStatus(mappedStatus.code, mappedStatus.details);
            } else {
              this.cancelWithStatus(constants_1.Status.RESOURCE_EXHAUSTED, e.message);
            }
            return;
          }
          for (const message of messages) {
            this.trace("parsed message of length " + message.length);
            this.callEventTracker.addMessageReceived();
            this.tryPush(message);
          }
        });
        http2Stream.on("end", () => {
          this.readsClosed = true;
          this.maybeOutputStatus();
        });
        http2Stream.on("close", () => {
          this.serverEndedCall = true;
          process.nextTick(() => {
            var _a3;
            this.trace("HTTP/2 stream closed with code " + http2Stream.rstCode);
            if (((_a3 = this.finalStatus) === null || _a3 === void 0 ? void 0 : _a3.code) === constants_1.Status.OK) {
              return;
            }
            let code;
            let details = "";
            switch (http2Stream.rstCode) {
              case http2.constants.NGHTTP2_NO_ERROR:
                if (this.finalStatus !== null) {
                  return;
                }
                if (this.httpStatusCode && this.httpStatusCode !== 200) {
                  const mappedStatus = mapHttpStatusCode(this.httpStatusCode);
                  code = mappedStatus.code;
                  details = mappedStatus.details;
                } else {
                  code = constants_1.Status.INTERNAL;
                  details = `Received RST_STREAM with code ${http2Stream.rstCode} (Call ended without gRPC status)`;
                }
                break;
              case http2.constants.NGHTTP2_REFUSED_STREAM:
                code = constants_1.Status.UNAVAILABLE;
                details = "Stream refused by server";
                break;
              case http2.constants.NGHTTP2_CANCEL:
                if (this.connectionDropped) {
                  code = constants_1.Status.UNAVAILABLE;
                  details = "Connection dropped";
                } else {
                  code = constants_1.Status.CANCELLED;
                  details = "Call cancelled";
                }
                break;
              case http2.constants.NGHTTP2_ENHANCE_YOUR_CALM:
                code = constants_1.Status.RESOURCE_EXHAUSTED;
                details = "Bandwidth exhausted or memory limit exceeded";
                break;
              case http2.constants.NGHTTP2_INADEQUATE_SECURITY:
                code = constants_1.Status.PERMISSION_DENIED;
                details = "Protocol not secure enough";
                break;
              case http2.constants.NGHTTP2_INTERNAL_ERROR:
                code = constants_1.Status.INTERNAL;
                if (this.internalError === null) {
                  details = `Received RST_STREAM with code ${http2Stream.rstCode} (Internal server error)`;
                } else {
                  if (this.internalError.code === "ECONNRESET" || this.internalError.code === "ETIMEDOUT") {
                    code = constants_1.Status.UNAVAILABLE;
                    details = this.internalError.message;
                  } else {
                    details = `Received RST_STREAM with code ${http2Stream.rstCode} triggered by internal client error: ${this.internalError.message}`;
                  }
                }
                break;
              default:
                code = constants_1.Status.INTERNAL;
                details = `Received RST_STREAM with code ${http2Stream.rstCode}`;
            }
            this.endCall({
              code,
              details,
              metadata: new metadata_1.Metadata(),
              rstCode: http2Stream.rstCode
            });
          });
        });
        http2Stream.on("error", (err) => {
          if (err.code !== "ERR_HTTP2_STREAM_ERROR") {
            this.trace("Node error event: message=" + err.message + " code=" + err.code + " errno=" + getSystemErrorName(err.errno) + " syscall=" + err.syscall);
            this.internalError = err;
          }
          this.callEventTracker.onStreamEnd(false);
        });
      }
      getDeadlineInfo() {
        return [
          `remote_addr=${this.getPeer()}`
        ];
      }
      onDisconnect() {
        this.connectionDropped = true;
        setImmediate(() => {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: "Connection dropped",
            metadata: new metadata_1.Metadata()
          });
        });
      }
      outputStatus() {
        if (!this.statusOutput) {
          this.statusOutput = true;
          this.trace("ended with status: code=" + this.finalStatus.code + ' details="' + this.finalStatus.details + '"');
          this.callEventTracker.onCallEnd(this.finalStatus);
          process.nextTick(() => {
            this.listener.onReceiveStatus(this.finalStatus);
          });
          this.http2Stream.resume();
        }
      }
      trace(text) {
        logging.trace(constants_2.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callId + "] " + text);
      }
      /**
       * On first call, emits a 'status' event with the given StatusObject.
       * Subsequent calls are no-ops.
       * @param status The status of the call.
       */
      endCall(status) {
        if (this.finalStatus === null || this.finalStatus.code === constants_1.Status.OK) {
          this.finalStatus = status;
          this.maybeOutputStatus();
        }
        this.destroyHttp2Stream();
      }
      maybeOutputStatus() {
        if (this.finalStatus !== null) {
          if (this.finalStatus.code !== constants_1.Status.OK || this.readsClosed && this.unpushedReadMessages.length === 0 && !this.isReadFilterPending && !this.isPushPending) {
            this.outputStatus();
          }
        }
      }
      push(message) {
        this.trace("pushing to reader message of length " + (message instanceof Buffer ? message.length : null));
        this.canPush = false;
        this.isPushPending = true;
        process.nextTick(() => {
          this.isPushPending = false;
          if (this.statusOutput) {
            return;
          }
          this.listener.onReceiveMessage(message);
          this.maybeOutputStatus();
        });
      }
      tryPush(messageBytes) {
        if (this.canPush) {
          this.http2Stream.pause();
          this.push(messageBytes);
        } else {
          this.trace("unpushedReadMessages.push message of length " + messageBytes.length);
          this.unpushedReadMessages.push(messageBytes);
        }
      }
      handleTrailers(headers) {
        this.serverEndedCall = true;
        this.callEventTracker.onStreamEnd(true);
        let headersString = "";
        for (const header of Object.keys(headers)) {
          headersString += "		" + header + ": " + headers[header] + "\n";
        }
        this.trace("Received server trailers:\n" + headersString);
        let metadata;
        try {
          metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        } catch (e) {
          metadata = new metadata_1.Metadata();
        }
        const metadataMap = metadata.getMap();
        let status;
        if (typeof metadataMap["grpc-status"] === "string") {
          const receivedStatus = Number(metadataMap["grpc-status"]);
          this.trace("received status code " + receivedStatus + " from server");
          metadata.remove("grpc-status");
          let details = "";
          if (typeof metadataMap["grpc-message"] === "string") {
            try {
              details = decodeURI(metadataMap["grpc-message"]);
            } catch (e) {
              details = metadataMap["grpc-message"];
            }
            metadata.remove("grpc-message");
            this.trace('received status details string "' + details + '" from server');
          }
          status = {
            code: receivedStatus,
            details,
            metadata
          };
        } else if (this.httpStatusCode) {
          status = mapHttpStatusCode(this.httpStatusCode);
          status.metadata = metadata;
        } else {
          status = {
            code: constants_1.Status.UNKNOWN,
            details: "No status information received",
            metadata
          };
        }
        this.endCall(status);
      }
      destroyHttp2Stream() {
        var _a2;
        if (this.http2Stream.destroyed) {
          return;
        }
        if (this.serverEndedCall) {
          this.http2Stream.end();
        } else {
          let code;
          if (((_a2 = this.finalStatus) === null || _a2 === void 0 ? void 0 : _a2.code) === constants_1.Status.OK) {
            code = http2.constants.NGHTTP2_NO_ERROR;
          } else {
            code = http2.constants.NGHTTP2_CANCEL;
          }
          this.trace("close http2 stream with code " + code);
          this.http2Stream.close(code);
        }
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.endCall({
          code: status,
          details,
          metadata: new metadata_1.Metadata()
        });
      }
      getStatus() {
        return this.finalStatus;
      }
      getPeer() {
        return this.transport.getPeerName();
      }
      getCallNumber() {
        return this.callId;
      }
      startRead() {
        if (this.finalStatus !== null && this.finalStatus.code !== constants_1.Status.OK) {
          this.readsClosed = true;
          this.maybeOutputStatus();
          return;
        }
        this.canPush = true;
        if (this.unpushedReadMessages.length > 0) {
          const nextMessage = this.unpushedReadMessages.shift();
          this.push(nextMessage);
          return;
        }
        this.http2Stream.resume();
      }
      sendMessageWithContext(context, message) {
        this.trace("write() called with message of length " + message.length);
        const cb = /* @__PURE__ */ __name((error) => {
          process.nextTick(() => {
            var _a2;
            let code = constants_1.Status.UNAVAILABLE;
            if ((error === null || error === void 0 ? void 0 : error.code) === "ERR_STREAM_WRITE_AFTER_END") {
              code = constants_1.Status.INTERNAL;
            }
            if (error) {
              this.cancelWithStatus(code, `Write error: ${error.message}`);
            }
            (_a2 = context.callback) === null || _a2 === void 0 ? void 0 : _a2.call(context);
          });
        }, "cb");
        this.trace("sending data chunk of length " + message.length);
        this.callEventTracker.addMessageSent();
        try {
          this.http2Stream.write(message, cb);
        } catch (error) {
          this.endCall({
            code: constants_1.Status.UNAVAILABLE,
            details: `Write failed with error ${error.message}`,
            metadata: new metadata_1.Metadata()
          });
        }
      }
      halfClose() {
        this.trace("end() called");
        this.trace("calling end() on HTTP/2 stream");
        this.http2Stream.end();
      }
    };
    exports2.Http2SubchannelCall = Http2SubchannelCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/call-number.js
var require_call_number = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/call-number.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.getNextCallNumber = getNextCallNumber;
    var nextCallNumber = 0;
    function getNextCallNumber() {
      return nextCallNumber++;
    }
    __name(getNextCallNumber, "getNextCallNumber");
  }
});

// node_modules/@grpc/grpc-js/build/src/transport.js
var require_transport = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/transport.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Http2SubchannelConnector = void 0;
    var http2 = require("http2");
    var tls_1 = require("tls");
    var channelz_1 = require_channelz();
    var constants_1 = require_constants3();
    var http_proxy_1 = require_http_proxy();
    var logging = require_logging();
    var resolver_1 = require_resolver();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var net = require("net");
    var subchannel_call_1 = require_subchannel_call();
    var call_number_1 = require_call_number();
    var TRACER_NAME = "transport";
    var FLOW_CONTROL_TRACER_NAME = "transport_flowctrl";
    var clientVersion = require_package4().version;
    var { HTTP2_HEADER_AUTHORITY, HTTP2_HEADER_CONTENT_TYPE, HTTP2_HEADER_METHOD, HTTP2_HEADER_PATH, HTTP2_HEADER_TE, HTTP2_HEADER_USER_AGENT } = http2.constants;
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var tooManyPingsData = Buffer.from("too_many_pings", "ascii");
    var Http2Transport = class Http2Transport {
      static {
        __name(this, "Http2Transport");
      }
      constructor(session, subchannelAddress, options, remoteName) {
        this.session = session;
        this.options = options;
        this.remoteName = remoteName;
        this.keepaliveTimer = null;
        this.pendingSendKeepalivePing = false;
        this.activeCalls = /* @__PURE__ */ new Set();
        this.disconnectListeners = [];
        this.disconnectHandled = false;
        this.channelzEnabled = true;
        this.keepalivesSent = 0;
        this.messagesSent = 0;
        this.messagesReceived = 0;
        this.lastMessageSentTimestamp = null;
        this.lastMessageReceivedTimestamp = null;
        this.subchannelAddressString = (0, subchannel_address_1.subchannelAddressToString)(subchannelAddress);
        if (options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
          this.streamTracker = new channelz_1.ChannelzCallTrackerStub();
        } else {
          this.streamTracker = new channelz_1.ChannelzCallTracker();
        }
        this.channelzRef = (0, channelz_1.registerChannelzSocket)(this.subchannelAddressString, () => this.getChannelzInfo(), this.channelzEnabled);
        this.userAgent = [
          options["grpc.primary_user_agent"],
          `grpc-node-js/${clientVersion}`,
          options["grpc.secondary_user_agent"]
        ].filter((e) => e).join(" ");
        if ("grpc.keepalive_time_ms" in options) {
          this.keepaliveTimeMs = options["grpc.keepalive_time_ms"];
        } else {
          this.keepaliveTimeMs = -1;
        }
        if ("grpc.keepalive_timeout_ms" in options) {
          this.keepaliveTimeoutMs = options["grpc.keepalive_timeout_ms"];
        } else {
          this.keepaliveTimeoutMs = KEEPALIVE_TIMEOUT_MS;
        }
        if ("grpc.keepalive_permit_without_calls" in options) {
          this.keepaliveWithoutCalls = options["grpc.keepalive_permit_without_calls"] === 1;
        } else {
          this.keepaliveWithoutCalls = false;
        }
        session.once("close", () => {
          this.trace("session closed");
          this.handleDisconnect();
        });
        session.once("goaway", (errorCode, lastStreamID, opaqueData) => {
          let tooManyPings = false;
          if (errorCode === http2.constants.NGHTTP2_ENHANCE_YOUR_CALM && opaqueData && opaqueData.equals(tooManyPingsData)) {
            tooManyPings = true;
          }
          this.trace("connection closed by GOAWAY with code " + errorCode + " and data " + (opaqueData === null || opaqueData === void 0 ? void 0 : opaqueData.toString()));
          this.reportDisconnectToOwner(tooManyPings);
        });
        session.once("error", (error) => {
          this.trace("connection closed with error " + error.message);
          this.handleDisconnect();
        });
        session.socket.once("close", () => {
          this.trace("connection closed");
          this.handleDisconnect();
        });
        if (logging.isTracerEnabled(TRACER_NAME)) {
          session.on("remoteSettings", (settings) => {
            this.trace("new settings received" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
          });
          session.on("localSettings", (settings) => {
            this.trace("local settings acknowledged by remote" + (this.session !== session ? " on the old connection" : "") + ": " + JSON.stringify(settings));
          });
        }
        if (this.keepaliveWithoutCalls) {
          this.maybeStartKeepalivePingTimer();
        }
      }
      getChannelzInfo() {
        var _a2, _b2, _c2;
        const sessionSocket = this.session.socket;
        const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
        const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;
        let tlsInfo;
        if (this.session.encrypted) {
          const tlsSocket = sessionSocket;
          const cipherInfo = tlsSocket.getCipher();
          const certificate = tlsSocket.getCertificate();
          const peerCertificate = tlsSocket.getPeerCertificate();
          tlsInfo = {
            cipherSuiteStandardName: (_a2 = cipherInfo.standardName) !== null && _a2 !== void 0 ? _a2 : null,
            cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
            localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
            remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
          };
        } else {
          tlsInfo = null;
        }
        const socketInfo = {
          remoteAddress,
          localAddress,
          security: tlsInfo,
          remoteName: this.remoteName,
          streamsStarted: this.streamTracker.callsStarted,
          streamsSucceeded: this.streamTracker.callsSucceeded,
          streamsFailed: this.streamTracker.callsFailed,
          messagesSent: this.messagesSent,
          messagesReceived: this.messagesReceived,
          keepAlivesSent: this.keepalivesSent,
          lastLocalStreamCreatedTimestamp: this.streamTracker.lastCallStartedTimestamp,
          lastRemoteStreamCreatedTimestamp: null,
          lastMessageSentTimestamp: this.lastMessageSentTimestamp,
          lastMessageReceivedTimestamp: this.lastMessageReceivedTimestamp,
          localFlowControlWindow: (_b2 = this.session.state.localWindowSize) !== null && _b2 !== void 0 ? _b2 : null,
          remoteFlowControlWindow: (_c2 = this.session.state.remoteWindowSize) !== null && _c2 !== void 0 ? _c2 : null
        };
        return socketInfo;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      keepaliveTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      flowControlTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, FLOW_CONTROL_TRACER_NAME, "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      internalsTrace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, "transport_internals", "(" + this.channelzRef.id + ") " + this.subchannelAddressString + " " + text);
      }
      /**
       * Indicate to the owner of this object that this transport should no longer
       * be used. That happens if the connection drops, or if the server sends a
       * GOAWAY.
       * @param tooManyPings If true, this was triggered by a GOAWAY with data
       * indicating that the session was closed becaues the client sent too many
       * pings.
       * @returns
       */
      reportDisconnectToOwner(tooManyPings) {
        if (this.disconnectHandled) {
          return;
        }
        this.disconnectHandled = true;
        this.disconnectListeners.forEach((listener) => listener(tooManyPings));
      }
      /**
       * Handle connection drops, but not GOAWAYs.
       */
      handleDisconnect() {
        this.clearKeepaliveTimeout();
        this.reportDisconnectToOwner(false);
        for (const call of this.activeCalls) {
          call.onDisconnect();
        }
        setImmediate(() => {
          this.session.destroy();
        });
      }
      addDisconnectListener(listener) {
        this.disconnectListeners.push(listener);
      }
      canSendPing() {
        return !this.session.destroyed && this.keepaliveTimeMs > 0 && (this.keepaliveWithoutCalls || this.activeCalls.size > 0);
      }
      maybeSendPing() {
        var _a2, _b2;
        if (!this.canSendPing()) {
          this.pendingSendKeepalivePing = true;
          return;
        }
        if (this.keepaliveTimer) {
          console.error("keepaliveTimeout is not null");
          return;
        }
        if (this.channelzEnabled) {
          this.keepalivesSent += 1;
        }
        this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
        this.keepaliveTimer = setTimeout(() => {
          this.keepaliveTimer = null;
          this.keepaliveTrace("Ping timeout passed without response");
          this.handleDisconnect();
        }, this.keepaliveTimeoutMs);
        (_b2 = (_a2 = this.keepaliveTimer).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        let pingSendError = "";
        try {
          const pingSentSuccessfully = this.session.ping((err, duration, payload) => {
            this.clearKeepaliveTimeout();
            if (err) {
              this.keepaliveTrace("Ping failed with error " + err.message);
              this.handleDisconnect();
            } else {
              this.keepaliveTrace("Received ping response");
              this.maybeStartKeepalivePingTimer();
            }
          });
          if (!pingSentSuccessfully) {
            pingSendError = "Ping returned false";
          }
        } catch (e) {
          pingSendError = (e instanceof Error ? e.message : "") || "Unknown error";
        }
        if (pingSendError) {
          this.keepaliveTrace("Ping send failed: " + pingSendError);
          this.handleDisconnect();
        }
      }
      /**
       * Starts the keepalive ping timer if appropriate. If the timer already ran
       * out while there were no active requests, instead send a ping immediately.
       * If the ping timer is already running or a ping is currently in flight,
       * instead do nothing and wait for them to resolve.
       */
      maybeStartKeepalivePingTimer() {
        var _a2, _b2;
        if (!this.canSendPing()) {
          return;
        }
        if (this.pendingSendKeepalivePing) {
          this.pendingSendKeepalivePing = false;
          this.maybeSendPing();
        } else if (!this.keepaliveTimer) {
          this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
          this.keepaliveTimer = setTimeout(() => {
            this.keepaliveTimer = null;
            this.maybeSendPing();
          }, this.keepaliveTimeMs);
          (_b2 = (_a2 = this.keepaliveTimer).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        }
      }
      /**
       * Clears whichever keepalive timeout is currently active, if any.
       */
      clearKeepaliveTimeout() {
        if (this.keepaliveTimer) {
          clearTimeout(this.keepaliveTimer);
          this.keepaliveTimer = null;
        }
      }
      removeActiveCall(call) {
        this.activeCalls.delete(call);
        if (this.activeCalls.size === 0) {
          this.session.unref();
        }
      }
      addActiveCall(call) {
        this.activeCalls.add(call);
        if (this.activeCalls.size === 1) {
          this.session.ref();
          if (!this.keepaliveWithoutCalls) {
            this.maybeStartKeepalivePingTimer();
          }
        }
      }
      createCall(metadata, host, method, listener, subchannelCallStatsTracker) {
        const headers = metadata.toHttp2Headers();
        headers[HTTP2_HEADER_AUTHORITY] = host;
        headers[HTTP2_HEADER_USER_AGENT] = this.userAgent;
        headers[HTTP2_HEADER_CONTENT_TYPE] = "application/grpc";
        headers[HTTP2_HEADER_METHOD] = "POST";
        headers[HTTP2_HEADER_PATH] = method;
        headers[HTTP2_HEADER_TE] = "trailers";
        let http2Stream;
        try {
          http2Stream = this.session.request(headers);
        } catch (e) {
          this.handleDisconnect();
          throw e;
        }
        this.flowControlTrace("local window size: " + this.session.state.localWindowSize + " remote window size: " + this.session.state.remoteWindowSize);
        this.internalsTrace("session.closed=" + this.session.closed + " session.destroyed=" + this.session.destroyed + " session.socket.destroyed=" + this.session.socket.destroyed);
        let eventTracker;
        let call;
        if (this.channelzEnabled) {
          this.streamTracker.addCallStarted();
          eventTracker = {
            addMessageSent: /* @__PURE__ */ __name(() => {
              var _a2;
              this.messagesSent += 1;
              this.lastMessageSentTimestamp = /* @__PURE__ */ new Date();
              (_a2 = subchannelCallStatsTracker.addMessageSent) === null || _a2 === void 0 ? void 0 : _a2.call(subchannelCallStatsTracker);
            }, "addMessageSent"),
            addMessageReceived: /* @__PURE__ */ __name(() => {
              var _a2;
              this.messagesReceived += 1;
              this.lastMessageReceivedTimestamp = /* @__PURE__ */ new Date();
              (_a2 = subchannelCallStatsTracker.addMessageReceived) === null || _a2 === void 0 ? void 0 : _a2.call(subchannelCallStatsTracker);
            }, "addMessageReceived"),
            onCallEnd: /* @__PURE__ */ __name((status) => {
              var _a2;
              (_a2 = subchannelCallStatsTracker.onCallEnd) === null || _a2 === void 0 ? void 0 : _a2.call(subchannelCallStatsTracker, status);
              this.removeActiveCall(call);
            }, "onCallEnd"),
            onStreamEnd: /* @__PURE__ */ __name((success) => {
              var _a2;
              if (success) {
                this.streamTracker.addCallSucceeded();
              } else {
                this.streamTracker.addCallFailed();
              }
              (_a2 = subchannelCallStatsTracker.onStreamEnd) === null || _a2 === void 0 ? void 0 : _a2.call(subchannelCallStatsTracker, success);
            }, "onStreamEnd")
          };
        } else {
          eventTracker = {
            addMessageSent: /* @__PURE__ */ __name(() => {
              var _a2;
              (_a2 = subchannelCallStatsTracker.addMessageSent) === null || _a2 === void 0 ? void 0 : _a2.call(subchannelCallStatsTracker);
            }, "addMessageSent"),
            addMessageReceived: /* @__PURE__ */ __name(() => {
              var _a2;
              (_a2 = subchannelCallStatsTracker.addMessageReceived) === null || _a2 === void 0 ? void 0 : _a2.call(subchannelCallStatsTracker);
            }, "addMessageReceived"),
            onCallEnd: /* @__PURE__ */ __name((status) => {
              var _a2;
              (_a2 = subchannelCallStatsTracker.onCallEnd) === null || _a2 === void 0 ? void 0 : _a2.call(subchannelCallStatsTracker, status);
              this.removeActiveCall(call);
            }, "onCallEnd"),
            onStreamEnd: /* @__PURE__ */ __name((success) => {
              var _a2;
              (_a2 = subchannelCallStatsTracker.onStreamEnd) === null || _a2 === void 0 ? void 0 : _a2.call(subchannelCallStatsTracker, success);
            }, "onStreamEnd")
          };
        }
        call = new subchannel_call_1.Http2SubchannelCall(http2Stream, eventTracker, listener, this, (0, call_number_1.getNextCallNumber)());
        this.addActiveCall(call);
        return call;
      }
      getChannelzRef() {
        return this.channelzRef;
      }
      getPeerName() {
        return this.subchannelAddressString;
      }
      getOptions() {
        return this.options;
      }
      shutdown() {
        this.session.close();
        (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
      }
    };
    var Http2SubchannelConnector = class Http2SubchannelConnector {
      static {
        __name(this, "Http2SubchannelConnector");
      }
      constructor(channelTarget) {
        this.channelTarget = channelTarget;
        this.session = null;
        this.isShutdown = false;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, (0, uri_parser_1.uriToString)(this.channelTarget) + " " + text);
      }
      createSession(address, credentials, options, proxyConnectionResult) {
        if (this.isShutdown) {
          return Promise.reject();
        }
        return new Promise((resolve5, reject) => {
          var _a2, _b2, _c2, _d;
          let remoteName;
          if (proxyConnectionResult.realTarget) {
            remoteName = (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget);
            this.trace("creating HTTP/2 session through proxy to " + (0, uri_parser_1.uriToString)(proxyConnectionResult.realTarget));
          } else {
            remoteName = null;
            this.trace("creating HTTP/2 session to " + (0, subchannel_address_1.subchannelAddressToString)(address));
          }
          const targetAuthority = (0, resolver_1.getDefaultAuthority)((_a2 = proxyConnectionResult.realTarget) !== null && _a2 !== void 0 ? _a2 : this.channelTarget);
          let connectionOptions = credentials._getConnectionOptions();
          if (!connectionOptions) {
            reject("Credentials not loaded");
            return;
          }
          connectionOptions.maxSendHeaderBlockLength = Number.MAX_SAFE_INTEGER;
          if ("grpc-node.max_session_memory" in options) {
            connectionOptions.maxSessionMemory = options["grpc-node.max_session_memory"];
          } else {
            connectionOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
          }
          let addressScheme = "http://";
          if ("secureContext" in connectionOptions) {
            addressScheme = "https://";
            if (options["grpc.ssl_target_name_override"]) {
              const sslTargetNameOverride = options["grpc.ssl_target_name_override"];
              const originalCheckServerIdentity = (_b2 = connectionOptions.checkServerIdentity) !== null && _b2 !== void 0 ? _b2 : tls_1.checkServerIdentity;
              connectionOptions.checkServerIdentity = (host, cert) => {
                return originalCheckServerIdentity(sslTargetNameOverride, cert);
              };
              connectionOptions.servername = sslTargetNameOverride;
            } else {
              const authorityHostname = (_d = (_c2 = (0, uri_parser_1.splitHostPort)(targetAuthority)) === null || _c2 === void 0 ? void 0 : _c2.host) !== null && _d !== void 0 ? _d : "localhost";
              connectionOptions.servername = authorityHostname;
            }
            if (proxyConnectionResult.socket) {
              connectionOptions.createConnection = (authority, option) => {
                return proxyConnectionResult.socket;
              };
            }
          } else {
            connectionOptions.createConnection = (authority, option) => {
              if (proxyConnectionResult.socket) {
                return proxyConnectionResult.socket;
              } else {
                return net.connect(address);
              }
            };
          }
          connectionOptions = Object.assign(Object.assign(Object.assign({}, connectionOptions), address), {
            enableTrace: options["grpc-node.tls_enable_trace"] === 1
          });
          const session = http2.connect(addressScheme + targetAuthority, connectionOptions);
          this.session = session;
          let errorMessage = "Failed to connect";
          let reportedError = false;
          session.unref();
          session.once("connect", () => {
            session.removeAllListeners();
            resolve5(new Http2Transport(session, address, options, remoteName));
            this.session = null;
          });
          session.once("close", () => {
            this.session = null;
            setImmediate(() => {
              if (!reportedError) {
                reportedError = true;
                reject(`${errorMessage} (${(/* @__PURE__ */ new Date()).toISOString()})`);
              }
            });
          });
          session.once("error", (error) => {
            errorMessage = error.message;
            this.trace("connection failed with error " + errorMessage);
            if (!reportedError) {
              reportedError = true;
              reject(`${errorMessage} (${(/* @__PURE__ */ new Date()).toISOString()})`);
            }
          });
        });
      }
      connect(address, credentials, options) {
        var _a2, _b2, _c2;
        if (this.isShutdown) {
          return Promise.reject();
        }
        const connectionOptions = credentials._getConnectionOptions();
        if (!connectionOptions) {
          return Promise.reject("Credentials not loaded");
        }
        if ("secureContext" in connectionOptions) {
          connectionOptions.ALPNProtocols = [
            "h2"
          ];
          if (options["grpc.ssl_target_name_override"]) {
            const sslTargetNameOverride = options["grpc.ssl_target_name_override"];
            const originalCheckServerIdentity = (_a2 = connectionOptions.checkServerIdentity) !== null && _a2 !== void 0 ? _a2 : tls_1.checkServerIdentity;
            connectionOptions.checkServerIdentity = (host, cert) => {
              return originalCheckServerIdentity(sslTargetNameOverride, cert);
            };
            connectionOptions.servername = sslTargetNameOverride;
          } else {
            if ("grpc.http_connect_target" in options) {
              const targetPath = (0, resolver_1.getDefaultAuthority)((_b2 = (0, uri_parser_1.parseUri)(options["grpc.http_connect_target"])) !== null && _b2 !== void 0 ? _b2 : {
                path: "localhost"
              });
              const hostPort = (0, uri_parser_1.splitHostPort)(targetPath);
              connectionOptions.servername = (_c2 = hostPort === null || hostPort === void 0 ? void 0 : hostPort.host) !== null && _c2 !== void 0 ? _c2 : targetPath;
            }
          }
          if (options["grpc-node.tls_enable_trace"]) {
            connectionOptions.enableTrace = true;
          }
        }
        return (0, http_proxy_1.getProxiedConnection)(address, options, connectionOptions).then((result2) => this.createSession(address, credentials, options, result2));
      }
      shutdown() {
        var _a2;
        this.isShutdown = true;
        (_a2 = this.session) === null || _a2 === void 0 ? void 0 : _a2.close();
        this.session = null;
      }
    };
    exports2.Http2SubchannelConnector = Http2SubchannelConnector;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-pool.js
var require_subchannel_pool = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-pool.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.SubchannelPool = void 0;
    exports2.getSubchannelPool = getSubchannelPool;
    var channel_options_1 = require_channel_options();
    var subchannel_1 = require_subchannel();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var transport_1 = require_transport();
    var REF_CHECK_INTERVAL = 1e4;
    var SubchannelPool = class SubchannelPool {
      static {
        __name(this, "SubchannelPool");
      }
      /**
       * A pool of subchannels use for making connections. Subchannels with the
       * exact same parameters will be reused.
       */
      constructor() {
        this.pool = /* @__PURE__ */ Object.create(null);
        this.cleanupTimer = null;
      }
      /**
       * Unrefs all unused subchannels and cancels the cleanup task if all
       * subchannels have been unrefed.
       */
      unrefUnusedSubchannels() {
        let allSubchannelsUnrefed = true;
        for (const channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          const refedSubchannels = subchannelObjArray.filter((value2) => !value2.subchannel.unrefIfOneRef());
          if (refedSubchannels.length > 0) {
            allSubchannelsUnrefed = false;
          }
          this.pool[channelTarget] = refedSubchannels;
        }
        if (allSubchannelsUnrefed && this.cleanupTimer !== null) {
          clearInterval(this.cleanupTimer);
          this.cleanupTimer = null;
        }
      }
      /**
       * Ensures that the cleanup task is spawned.
       */
      ensureCleanupTask() {
        var _a2, _b2;
        if (this.cleanupTimer === null) {
          this.cleanupTimer = setInterval(() => {
            this.unrefUnusedSubchannels();
          }, REF_CHECK_INTERVAL);
          (_b2 = (_a2 = this.cleanupTimer).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        }
      }
      /**
       * Get a subchannel if one already exists with exactly matching parameters.
       * Otherwise, create and save a subchannel with those parameters.
       * @param channelTarget
       * @param subchannelTarget
       * @param channelArguments
       * @param channelCredentials
       */
      getOrCreateSubchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials) {
        this.ensureCleanupTask();
        const channelTarget = (0, uri_parser_1.uriToString)(channelTargetUri);
        if (channelTarget in this.pool) {
          const subchannelObjArray = this.pool[channelTarget];
          for (const subchannelObj of subchannelObjArray) {
            if ((0, subchannel_address_1.subchannelAddressEqual)(subchannelTarget, subchannelObj.subchannelAddress) && (0, channel_options_1.channelOptionsEqual)(channelArguments, subchannelObj.channelArguments) && channelCredentials._equals(subchannelObj.channelCredentials)) {
              return subchannelObj.subchannel;
            }
          }
        }
        const subchannel = new subchannel_1.Subchannel(channelTargetUri, subchannelTarget, channelArguments, channelCredentials, new transport_1.Http2SubchannelConnector(channelTargetUri));
        if (!(channelTarget in this.pool)) {
          this.pool[channelTarget] = [];
        }
        this.pool[channelTarget].push({
          subchannelAddress: subchannelTarget,
          channelArguments,
          channelCredentials,
          subchannel
        });
        subchannel.ref();
        return subchannel;
      }
    };
    exports2.SubchannelPool = SubchannelPool;
    var globalSubchannelPool = new SubchannelPool();
    function getSubchannelPool(global2) {
      if (global2) {
        return globalSubchannelPool;
      } else {
        return new SubchannelPool();
      }
    }
    __name(getSubchannelPool, "getSubchannelPool");
  }
});

// node_modules/@grpc/grpc-js/build/src/filter-stack.js
var require_filter_stack = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter-stack.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FilterStackFactory = exports2.FilterStack = void 0;
    var FilterStack = class FilterStack {
      static {
        __name(this, "FilterStack");
      }
      constructor(filters) {
        this.filters = filters;
      }
      sendMetadata(metadata) {
        let result2 = metadata;
        for (let i = 0; i < this.filters.length; i++) {
          result2 = this.filters[i].sendMetadata(result2);
        }
        return result2;
      }
      receiveMetadata(metadata) {
        let result2 = metadata;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result2 = this.filters[i].receiveMetadata(result2);
        }
        return result2;
      }
      sendMessage(message) {
        let result2 = message;
        for (let i = 0; i < this.filters.length; i++) {
          result2 = this.filters[i].sendMessage(result2);
        }
        return result2;
      }
      receiveMessage(message) {
        let result2 = message;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result2 = this.filters[i].receiveMessage(result2);
        }
        return result2;
      }
      receiveTrailers(status) {
        let result2 = status;
        for (let i = this.filters.length - 1; i >= 0; i--) {
          result2 = this.filters[i].receiveTrailers(result2);
        }
        return result2;
      }
      push(filters) {
        this.filters.unshift(...filters);
      }
      getFilters() {
        return this.filters;
      }
    };
    exports2.FilterStack = FilterStack;
    var FilterStackFactory = class FilterStackFactory2 {
      static {
        __name(this, "FilterStackFactory");
      }
      constructor(factories) {
        this.factories = factories;
      }
      push(filterFactories) {
        this.factories.unshift(...filterFactories);
      }
      clone() {
        return new FilterStackFactory2([
          ...this.factories
        ]);
      }
      createFilter() {
        return new FilterStack(this.factories.map((factory) => factory.createFilter()));
      }
    };
    exports2.FilterStackFactory = FilterStackFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-algorithms.js
var require_compression_algorithms = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-algorithms.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CompressionAlgorithms = void 0;
    var CompressionAlgorithms;
    (function(CompressionAlgorithms2) {
      CompressionAlgorithms2[CompressionAlgorithms2["identity"] = 0] = "identity";
      CompressionAlgorithms2[CompressionAlgorithms2["deflate"] = 1] = "deflate";
      CompressionAlgorithms2[CompressionAlgorithms2["gzip"] = 2] = "gzip";
    })(CompressionAlgorithms || (exports2.CompressionAlgorithms = CompressionAlgorithms = {}));
  }
});

// node_modules/@grpc/grpc-js/build/src/filter.js
var require_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BaseFilter = void 0;
    var BaseFilter = class BaseFilter {
      static {
        __name(this, "BaseFilter");
      }
      async sendMetadata(metadata) {
        return metadata;
      }
      receiveMetadata(metadata) {
        return metadata;
      }
      async sendMessage(message) {
        return message;
      }
      async receiveMessage(message) {
        return message;
      }
      receiveTrailers(status) {
        return status;
      }
    };
    exports2.BaseFilter = BaseFilter;
  }
});

// node_modules/@grpc/grpc-js/build/src/compression-filter.js
var require_compression_filter = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/compression-filter.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.CompressionFilterFactory = exports2.CompressionFilter = void 0;
    var zlib = require("zlib");
    var compression_algorithms_1 = require_compression_algorithms();
    var constants_1 = require_constants3();
    var filter_1 = require_filter();
    var logging = require_logging();
    var isCompressionAlgorithmKey = /* @__PURE__ */ __name((key) => {
      return typeof key === "number" && typeof compression_algorithms_1.CompressionAlgorithms[key] === "string";
    }, "isCompressionAlgorithmKey");
    var CompressionHandler = class CompressionHandler {
      static {
        __name(this, "CompressionHandler");
      }
      /**
       * @param message Raw uncompressed message bytes
       * @param compress Indicates whether the message should be compressed
       * @return Framed message, compressed if applicable
       */
      async writeMessage(message, compress) {
        let messageBuffer = message;
        if (compress) {
          messageBuffer = await this.compressMessage(messageBuffer);
        }
        const output = Buffer.allocUnsafe(messageBuffer.length + 5);
        output.writeUInt8(compress ? 1 : 0, 0);
        output.writeUInt32BE(messageBuffer.length, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      /**
       * @param data Framed message, possibly compressed
       * @return Uncompressed message
       */
      async readMessage(data) {
        const compressed = data.readUInt8(0) === 1;
        let messageBuffer = data.slice(5);
        if (compressed) {
          messageBuffer = await this.decompressMessage(messageBuffer);
        }
        return messageBuffer;
      }
    };
    var IdentityHandler = class IdentityHandler extends CompressionHandler {
      static {
        __name(this, "IdentityHandler");
      }
      async compressMessage(message) {
        return message;
      }
      async writeMessage(message, compress) {
        const output = Buffer.allocUnsafe(message.length + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(message.length, 1);
        message.copy(output, 5);
        return output;
      }
      decompressMessage(message) {
        return Promise.reject(new Error('Received compressed message but "grpc-encoding" header was identity'));
      }
    };
    var DeflateHandler = class DeflateHandler extends CompressionHandler {
      static {
        __name(this, "DeflateHandler");
      }
      constructor(maxRecvMessageLength) {
        super();
        this.maxRecvMessageLength = maxRecvMessageLength;
      }
      compressMessage(message) {
        return new Promise((resolve5, reject) => {
          zlib.deflate(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve5(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve5, reject) => {
          let totalLength2 = 0;
          const messageParts = [];
          const decompresser = zlib.createInflate();
          decompresser.on("data", (chunk) => {
            messageParts.push(chunk);
            totalLength2 += chunk.byteLength;
            if (this.maxRecvMessageLength !== -1 && totalLength2 > this.maxRecvMessageLength) {
              decompresser.destroy();
              reject({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
              });
            }
          });
          decompresser.on("end", () => {
            resolve5(Buffer.concat(messageParts));
          });
          decompresser.write(message);
          decompresser.end();
        });
      }
    };
    var GzipHandler = class GzipHandler extends CompressionHandler {
      static {
        __name(this, "GzipHandler");
      }
      constructor(maxRecvMessageLength) {
        super();
        this.maxRecvMessageLength = maxRecvMessageLength;
      }
      compressMessage(message) {
        return new Promise((resolve5, reject) => {
          zlib.gzip(message, (err, output) => {
            if (err) {
              reject(err);
            } else {
              resolve5(output);
            }
          });
        });
      }
      decompressMessage(message) {
        return new Promise((resolve5, reject) => {
          let totalLength2 = 0;
          const messageParts = [];
          const decompresser = zlib.createGunzip();
          decompresser.on("data", (chunk) => {
            messageParts.push(chunk);
            totalLength2 += chunk.byteLength;
            if (this.maxRecvMessageLength !== -1 && totalLength2 > this.maxRecvMessageLength) {
              decompresser.destroy();
              reject({
                code: constants_1.Status.RESOURCE_EXHAUSTED,
                details: `Received message that decompresses to a size larger than ${this.maxRecvMessageLength}`
              });
            }
          });
          decompresser.on("end", () => {
            resolve5(Buffer.concat(messageParts));
          });
          decompresser.write(message);
          decompresser.end();
        });
      }
    };
    var UnknownHandler = class UnknownHandler extends CompressionHandler {
      static {
        __name(this, "UnknownHandler");
      }
      constructor(compressionName) {
        super();
        this.compressionName = compressionName;
      }
      compressMessage(message) {
        return Promise.reject(new Error(`Received message compressed with unsupported compression method ${this.compressionName}`));
      }
      decompressMessage(message) {
        return Promise.reject(new Error(`Compression method not supported: ${this.compressionName}`));
      }
    };
    function getCompressionHandler(compressionName, maxReceiveMessageSize) {
      switch (compressionName) {
        case "identity":
          return new IdentityHandler();
        case "deflate":
          return new DeflateHandler(maxReceiveMessageSize);
        case "gzip":
          return new GzipHandler(maxReceiveMessageSize);
        default:
          return new UnknownHandler(compressionName);
      }
    }
    __name(getCompressionHandler, "getCompressionHandler");
    var CompressionFilter = class CompressionFilter extends filter_1.BaseFilter {
      static {
        __name(this, "CompressionFilter");
      }
      constructor(channelOptions, sharedFilterConfig) {
        var _a2, _b2, _c2;
        super();
        this.sharedFilterConfig = sharedFilterConfig;
        this.sendCompression = new IdentityHandler();
        this.receiveCompression = new IdentityHandler();
        this.currentCompressionAlgorithm = "identity";
        const compressionAlgorithmKey = channelOptions["grpc.default_compression_algorithm"];
        this.maxReceiveMessageLength = (_a2 = channelOptions["grpc.max_receive_message_length"]) !== null && _a2 !== void 0 ? _a2 : constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.maxSendMessageLength = (_b2 = channelOptions["grpc.max_send_message_length"]) !== null && _b2 !== void 0 ? _b2 : constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        if (compressionAlgorithmKey !== void 0) {
          if (isCompressionAlgorithmKey(compressionAlgorithmKey)) {
            const clientSelectedEncoding = compression_algorithms_1.CompressionAlgorithms[compressionAlgorithmKey];
            const serverSupportedEncodings = (_c2 = sharedFilterConfig.serverSupportedEncodingHeader) === null || _c2 === void 0 ? void 0 : _c2.split(",");
            if (!serverSupportedEncodings || serverSupportedEncodings.includes(clientSelectedEncoding)) {
              this.currentCompressionAlgorithm = clientSelectedEncoding;
              this.sendCompression = getCompressionHandler(this.currentCompressionAlgorithm, -1);
            }
          } else {
            logging.log(constants_1.LogVerbosity.ERROR, `Invalid value provided for grpc.default_compression_algorithm option: ${compressionAlgorithmKey}`);
          }
        }
      }
      async sendMetadata(metadata) {
        const headers = await metadata;
        headers.set("grpc-accept-encoding", "identity,deflate,gzip");
        headers.set("accept-encoding", "identity");
        if (this.currentCompressionAlgorithm === "identity") {
          headers.remove("grpc-encoding");
        } else {
          headers.set("grpc-encoding", this.currentCompressionAlgorithm);
        }
        return headers;
      }
      receiveMetadata(metadata) {
        const receiveEncoding = metadata.get("grpc-encoding");
        if (receiveEncoding.length > 0) {
          const encoding = receiveEncoding[0];
          if (typeof encoding === "string") {
            this.receiveCompression = getCompressionHandler(encoding, this.maxReceiveMessageLength);
          }
        }
        metadata.remove("grpc-encoding");
        const serverSupportedEncodingsHeader = metadata.get("grpc-accept-encoding")[0];
        if (serverSupportedEncodingsHeader) {
          this.sharedFilterConfig.serverSupportedEncodingHeader = serverSupportedEncodingsHeader;
          const serverSupportedEncodings = serverSupportedEncodingsHeader.split(",");
          if (!serverSupportedEncodings.includes(this.currentCompressionAlgorithm)) {
            this.sendCompression = new IdentityHandler();
            this.currentCompressionAlgorithm = "identity";
          }
        }
        metadata.remove("grpc-accept-encoding");
        return metadata;
      }
      async sendMessage(message) {
        var _a2;
        const resolvedMessage = await message;
        if (this.maxSendMessageLength !== -1 && resolvedMessage.message.length > this.maxSendMessageLength) {
          throw {
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: `Attempted to send message with a size larger than ${this.maxSendMessageLength}`
          };
        }
        let compress;
        if (this.sendCompression instanceof IdentityHandler) {
          compress = false;
        } else {
          compress = (((_a2 = resolvedMessage.flags) !== null && _a2 !== void 0 ? _a2 : 0) & 2) === 0;
        }
        return {
          message: await this.sendCompression.writeMessage(resolvedMessage.message, compress),
          flags: resolvedMessage.flags
        };
      }
      async receiveMessage(message) {
        return this.receiveCompression.readMessage(await message);
      }
    };
    exports2.CompressionFilter = CompressionFilter;
    var CompressionFilterFactory = class CompressionFilterFactory {
      static {
        __name(this, "CompressionFilterFactory");
      }
      constructor(channel, options) {
        this.options = options;
        this.sharedFilterConfig = {};
      }
      createFilter() {
        return new CompressionFilter(this.options, this.sharedFilterConfig);
      }
    };
    exports2.CompressionFilterFactory = CompressionFilterFactory;
  }
});

// node_modules/@grpc/grpc-js/build/src/deadline.js
var require_deadline = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/deadline.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.minDeadline = minDeadline;
    exports2.getDeadlineTimeoutString = getDeadlineTimeoutString;
    exports2.getRelativeTimeout = getRelativeTimeout;
    exports2.deadlineToString = deadlineToString;
    exports2.formatDateDifference = formatDateDifference;
    function minDeadline(...deadlineList) {
      let minValue = Infinity;
      for (const deadline of deadlineList) {
        const deadlineMsecs = deadline instanceof Date ? deadline.getTime() : deadline;
        if (deadlineMsecs < minValue) {
          minValue = deadlineMsecs;
        }
      }
      return minValue;
    }
    __name(minDeadline, "minDeadline");
    var units = [
      [
        "m",
        1
      ],
      [
        "S",
        1e3
      ],
      [
        "M",
        60 * 1e3
      ],
      [
        "H",
        60 * 60 * 1e3
      ]
    ];
    function getDeadlineTimeoutString(deadline) {
      const now = (/* @__PURE__ */ new Date()).getTime();
      if (deadline instanceof Date) {
        deadline = deadline.getTime();
      }
      const timeoutMs = Math.max(deadline - now, 0);
      for (const [unit, factor] of units) {
        const amount = timeoutMs / factor;
        if (amount < 1e8) {
          return String(Math.ceil(amount)) + unit;
        }
      }
      throw new Error("Deadline is too far in the future");
    }
    __name(getDeadlineTimeoutString, "getDeadlineTimeoutString");
    var MAX_TIMEOUT_TIME = 2147483647;
    function getRelativeTimeout(deadline) {
      const deadlineMs = deadline instanceof Date ? deadline.getTime() : deadline;
      const now = (/* @__PURE__ */ new Date()).getTime();
      const timeout = deadlineMs - now;
      if (timeout < 0) {
        return 0;
      } else if (timeout > MAX_TIMEOUT_TIME) {
        return Infinity;
      } else {
        return timeout;
      }
    }
    __name(getRelativeTimeout, "getRelativeTimeout");
    function deadlineToString(deadline) {
      if (deadline instanceof Date) {
        return deadline.toISOString();
      } else {
        const dateDeadline = new Date(deadline);
        if (Number.isNaN(dateDeadline.getTime())) {
          return "" + deadline;
        } else {
          return dateDeadline.toISOString();
        }
      }
    }
    __name(deadlineToString, "deadlineToString");
    function formatDateDifference(startDate, endDate) {
      return ((endDate.getTime() - startDate.getTime()) / 1e3).toFixed(3) + "s";
    }
    __name(formatDateDifference, "formatDateDifference");
  }
});

// node_modules/@grpc/grpc-js/build/src/control-plane-status.js
var require_control_plane_status = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/control-plane-status.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.restrictControlPlaneStatusCode = restrictControlPlaneStatusCode;
    var constants_1 = require_constants3();
    var INAPPROPRIATE_CONTROL_PLANE_CODES = [
      constants_1.Status.OK,
      constants_1.Status.INVALID_ARGUMENT,
      constants_1.Status.NOT_FOUND,
      constants_1.Status.ALREADY_EXISTS,
      constants_1.Status.FAILED_PRECONDITION,
      constants_1.Status.ABORTED,
      constants_1.Status.OUT_OF_RANGE,
      constants_1.Status.DATA_LOSS
    ];
    function restrictControlPlaneStatusCode(code, details) {
      if (INAPPROPRIATE_CONTROL_PLANE_CODES.includes(code)) {
        return {
          code: constants_1.Status.INTERNAL,
          details: `Invalid status from control plane: ${code} ${constants_1.Status[code]} ${details}`
        };
      } else {
        return {
          code,
          details
        };
      }
    }
    __name(restrictControlPlaneStatusCode, "restrictControlPlaneStatusCode");
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancing-call.js
var require_load_balancing_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancing-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LoadBalancingCall = void 0;
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants3();
    var deadline_1 = require_deadline();
    var metadata_1 = require_metadata2();
    var picker_1 = require_picker();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var control_plane_status_1 = require_control_plane_status();
    var http2 = require("http2");
    var TRACER_NAME = "load_balancing_call";
    var LoadBalancingCall = class LoadBalancingCall {
      static {
        __name(this, "LoadBalancingCall");
      }
      constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber) {
        var _a2, _b2;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.metadata = null;
        this.listener = null;
        this.onCallEnded = null;
        this.childStartTime = null;
        const splitPath = this.methodName.split("/");
        let serviceName = "";
        if (splitPath.length >= 2) {
          serviceName = splitPath[1];
        }
        const hostname = (_b2 = (_a2 = (0, uri_parser_1.splitHostPort)(this.host)) === null || _a2 === void 0 ? void 0 : _a2.host) !== null && _b2 !== void 0 ? _b2 : "localhost";
        this.serviceUrl = `https://${hostname}/${serviceName}`;
        this.startTime = /* @__PURE__ */ new Date();
      }
      getDeadlineInfo() {
        var _a2, _b2;
        const deadlineInfo = [];
        if (this.childStartTime) {
          if (this.childStartTime > this.startTime) {
            if ((_a2 = this.metadata) === null || _a2 === void 0 ? void 0 : _a2.getOptions().waitForReady) {
              deadlineInfo.push("wait_for_ready");
            }
            deadlineInfo.push(`LB pick: ${(0, deadline_1.formatDateDifference)(this.startTime, this.childStartTime)}`);
          }
          deadlineInfo.push(...this.child.getDeadlineInfo());
          return deadlineInfo;
        } else {
          if ((_b2 = this.metadata) === null || _b2 === void 0 ? void 0 : _b2.getOptions().waitForReady) {
            deadlineInfo.push("wait_for_ready");
          }
          deadlineInfo.push("Waiting for LB pick");
        }
        return deadlineInfo;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      outputStatus(status, progress) {
        var _a2, _b2;
        if (!this.ended) {
          this.ended = true;
          this.trace("ended with status: code=" + status.code + ' details="' + status.details + '" start time=' + this.startTime.toISOString());
          const finalStatus = Object.assign(Object.assign({}, status), {
            progress
          });
          (_a2 = this.listener) === null || _a2 === void 0 ? void 0 : _a2.onReceiveStatus(finalStatus);
          (_b2 = this.onCallEnded) === null || _b2 === void 0 ? void 0 : _b2.call(this, finalStatus.code);
        }
      }
      doPick() {
        var _a2, _b2;
        if (this.ended) {
          return;
        }
        if (!this.metadata) {
          throw new Error("doPick called before start");
        }
        this.trace("Pick called");
        const finalMetadata = this.metadata.clone();
        const pickResult = this.channel.doPick(finalMetadata, this.callConfig.pickInformation);
        const subchannelString = pickResult.subchannel ? "(" + pickResult.subchannel.getChannelzRef().id + ") " + pickResult.subchannel.getAddress() : "" + pickResult.subchannel;
        this.trace("Pick result: " + picker_1.PickResultType[pickResult.pickResultType] + " subchannel: " + subchannelString + " status: " + ((_a2 = pickResult.status) === null || _a2 === void 0 ? void 0 : _a2.code) + " " + ((_b2 = pickResult.status) === null || _b2 === void 0 ? void 0 : _b2.details));
        switch (pickResult.pickResultType) {
          case picker_1.PickResultType.COMPLETE:
            this.credentials.generateMetadata({
              method_name: this.methodName,
              service_url: this.serviceUrl
            }).then((credsMetadata) => {
              var _a3, _b3, _c2;
              if (this.ended) {
                this.trace("Credentials metadata generation finished after call ended");
                return;
              }
              finalMetadata.merge(credsMetadata);
              if (finalMetadata.get("authorization").length > 1) {
                this.outputStatus({
                  code: constants_1.Status.INTERNAL,
                  details: '"authorization" metadata cannot have multiple values',
                  metadata: new metadata_1.Metadata()
                }, "PROCESSED");
              }
              if (pickResult.subchannel.getConnectivityState() !== connectivity_state_1.ConnectivityState.READY) {
                this.trace("Picked subchannel " + subchannelString + " has state " + connectivity_state_1.ConnectivityState[pickResult.subchannel.getConnectivityState()] + " after getting credentials metadata. Retrying pick");
                this.doPick();
                return;
              }
              if (this.deadline !== Infinity) {
                finalMetadata.set("grpc-timeout", (0, deadline_1.getDeadlineTimeoutString)(this.deadline));
              }
              try {
                this.child = pickResult.subchannel.getRealSubchannel().createCall(finalMetadata, this.host, this.methodName, {
                  onReceiveMetadata: /* @__PURE__ */ __name((metadata) => {
                    this.trace("Received metadata");
                    this.listener.onReceiveMetadata(metadata);
                  }, "onReceiveMetadata"),
                  onReceiveMessage: /* @__PURE__ */ __name((message) => {
                    this.trace("Received message");
                    this.listener.onReceiveMessage(message);
                  }, "onReceiveMessage"),
                  onReceiveStatus: /* @__PURE__ */ __name((status) => {
                    this.trace("Received status");
                    if (status.rstCode === http2.constants.NGHTTP2_REFUSED_STREAM) {
                      this.outputStatus(status, "REFUSED");
                    } else {
                      this.outputStatus(status, "PROCESSED");
                    }
                  }, "onReceiveStatus")
                });
                this.childStartTime = /* @__PURE__ */ new Date();
              } catch (error) {
                this.trace("Failed to start call on picked subchannel " + subchannelString + " with error " + error.message);
                this.outputStatus({
                  code: constants_1.Status.INTERNAL,
                  details: "Failed to start HTTP/2 stream with error " + error.message,
                  metadata: new metadata_1.Metadata()
                }, "NOT_STARTED");
                return;
              }
              (_b3 = (_a3 = this.callConfig).onCommitted) === null || _b3 === void 0 ? void 0 : _b3.call(_a3);
              (_c2 = pickResult.onCallStarted) === null || _c2 === void 0 ? void 0 : _c2.call(pickResult);
              this.onCallEnded = pickResult.onCallEnded;
              this.trace("Created child call [" + this.child.getCallNumber() + "]");
              if (this.readPending) {
                this.child.startRead();
              }
              if (this.pendingMessage) {
                this.child.sendMessageWithContext(this.pendingMessage.context, this.pendingMessage.message);
              }
              if (this.pendingHalfClose) {
                this.child.halfClose();
              }
            }, (error) => {
              const { code: code2, details: details2 } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(typeof error.code === "number" ? error.code : constants_1.Status.UNKNOWN, `Getting metadata from plugin failed with error: ${error.message}`);
              this.outputStatus({
                code: code2,
                details: details2,
                metadata: new metadata_1.Metadata()
              }, "PROCESSED");
            });
            break;
          case picker_1.PickResultType.DROP:
            const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
            setImmediate(() => {
              this.outputStatus({
                code,
                details,
                metadata: pickResult.status.metadata
              }, "DROP");
            });
            break;
          case picker_1.PickResultType.TRANSIENT_FAILURE:
            if (this.metadata.getOptions().waitForReady) {
              this.channel.queueCallForPick(this);
            } else {
              const { code: code2, details: details2 } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(pickResult.status.code, pickResult.status.details);
              setImmediate(() => {
                this.outputStatus({
                  code: code2,
                  details: details2,
                  metadata: pickResult.status.metadata
                }, "PROCESSED");
              });
            }
            break;
          case picker_1.PickResultType.QUEUE:
            this.channel.queueCallForPick(this);
        }
      }
      cancelWithStatus(status, details) {
        var _a2;
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.cancelWithStatus(status, details);
        this.outputStatus({
          code: status,
          details,
          metadata: new metadata_1.Metadata()
        }, "PROCESSED");
      }
      getPeer() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.getPeer()) !== null && _b2 !== void 0 ? _b2 : this.channel.getTarget();
      }
      start(metadata, listener) {
        this.trace("start called");
        this.listener = listener;
        this.metadata = metadata;
        this.doPick();
      }
      sendMessageWithContext(context, message) {
        this.trace("write() called with message of length " + message.length);
        if (this.child) {
          this.child.sendMessageWithContext(context, message);
        } else {
          this.pendingMessage = {
            context,
            message
          };
        }
      }
      startRead() {
        this.trace("startRead called");
        if (this.child) {
          this.child.startRead();
        } else {
          this.readPending = true;
        }
      }
      halfClose() {
        this.trace("halfClose called");
        if (this.child) {
          this.child.halfClose();
        } else {
          this.pendingHalfClose = true;
        }
      }
      setCredentials(credentials) {
        throw new Error("Method not implemented.");
      }
      getCallNumber() {
        return this.callNumber;
      }
    };
    exports2.LoadBalancingCall = LoadBalancingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/resolving-call.js
var require_resolving_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolving-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ResolvingCall = void 0;
    var constants_1 = require_constants3();
    var deadline_1 = require_deadline();
    var metadata_1 = require_metadata2();
    var logging = require_logging();
    var control_plane_status_1 = require_control_plane_status();
    var TRACER_NAME = "resolving_call";
    var ResolvingCall = class ResolvingCall {
      static {
        __name(this, "ResolvingCall");
      }
      constructor(channel, method, options, filterStackFactory, credentials, callNumber) {
        this.channel = channel;
        this.method = method;
        this.filterStackFactory = filterStackFactory;
        this.credentials = credentials;
        this.callNumber = callNumber;
        this.child = null;
        this.readPending = false;
        this.pendingMessage = null;
        this.pendingHalfClose = false;
        this.ended = false;
        this.readFilterPending = false;
        this.writeFilterPending = false;
        this.pendingChildStatus = null;
        this.metadata = null;
        this.listener = null;
        this.statusWatchers = [];
        this.deadlineTimer = setTimeout(() => {
        }, 0);
        this.filterStack = null;
        this.deadlineStartTime = null;
        this.configReceivedTime = null;
        this.childStartTime = null;
        this.deadline = options.deadline;
        this.host = options.host;
        if (options.parentCall) {
          if (options.flags & constants_1.Propagate.CANCELLATION) {
            options.parentCall.on("cancelled", () => {
              this.cancelWithStatus(constants_1.Status.CANCELLED, "Cancelled by parent call");
            });
          }
          if (options.flags & constants_1.Propagate.DEADLINE) {
            this.trace("Propagating deadline from parent: " + options.parentCall.getDeadline());
            this.deadline = (0, deadline_1.minDeadline)(this.deadline, options.parentCall.getDeadline());
          }
        }
        this.trace("Created");
        this.runDeadlineTimer();
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      runDeadlineTimer() {
        clearTimeout(this.deadlineTimer);
        this.deadlineStartTime = /* @__PURE__ */ new Date();
        this.trace("Deadline: " + (0, deadline_1.deadlineToString)(this.deadline));
        const timeout = (0, deadline_1.getRelativeTimeout)(this.deadline);
        if (timeout !== Infinity) {
          this.trace("Deadline will be reached in " + timeout + "ms");
          const handleDeadline = /* @__PURE__ */ __name(() => {
            if (!this.deadlineStartTime) {
              this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, "Deadline exceeded");
              return;
            }
            const deadlineInfo = [];
            const deadlineEndTime = /* @__PURE__ */ new Date();
            deadlineInfo.push(`Deadline exceeded after ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, deadlineEndTime)}`);
            if (this.configReceivedTime) {
              if (this.configReceivedTime > this.deadlineStartTime) {
                deadlineInfo.push(`name resolution: ${(0, deadline_1.formatDateDifference)(this.deadlineStartTime, this.configReceivedTime)}`);
              }
              if (this.childStartTime) {
                if (this.childStartTime > this.configReceivedTime) {
                  deadlineInfo.push(`metadata filters: ${(0, deadline_1.formatDateDifference)(this.configReceivedTime, this.childStartTime)}`);
                }
              } else {
                deadlineInfo.push("waiting for metadata filters");
              }
            } else {
              deadlineInfo.push("waiting for name resolution");
            }
            if (this.child) {
              deadlineInfo.push(...this.child.getDeadlineInfo());
            }
            this.cancelWithStatus(constants_1.Status.DEADLINE_EXCEEDED, deadlineInfo.join(","));
          }, "handleDeadline");
          if (timeout <= 0) {
            process.nextTick(handleDeadline);
          } else {
            this.deadlineTimer = setTimeout(handleDeadline, timeout);
          }
        }
      }
      outputStatus(status) {
        if (!this.ended) {
          this.ended = true;
          if (!this.filterStack) {
            this.filterStack = this.filterStackFactory.createFilter();
          }
          clearTimeout(this.deadlineTimer);
          const filteredStatus = this.filterStack.receiveTrailers(status);
          this.trace("ended with status: code=" + filteredStatus.code + ' details="' + filteredStatus.details + '"');
          this.statusWatchers.forEach((watcher) => watcher(filteredStatus));
          process.nextTick(() => {
            var _a2;
            (_a2 = this.listener) === null || _a2 === void 0 ? void 0 : _a2.onReceiveStatus(filteredStatus);
          });
        }
      }
      sendMessageOnChild(context, message) {
        if (!this.child) {
          throw new Error("sendMessageonChild called with child not populated");
        }
        const child = this.child;
        this.writeFilterPending = true;
        this.filterStack.sendMessage(Promise.resolve({
          message,
          flags: context.flags
        })).then((filteredMessage) => {
          this.writeFilterPending = false;
          child.sendMessageWithContext(context, filteredMessage.message);
          if (this.pendingHalfClose) {
            child.halfClose();
          }
        }, (status) => {
          this.cancelWithStatus(status.code, status.details);
        });
      }
      getConfig() {
        if (this.ended) {
          return;
        }
        if (!this.metadata || !this.listener) {
          throw new Error("getConfig called before start");
        }
        const configResult = this.channel.getConfig(this.method, this.metadata);
        if (configResult.type === "NONE") {
          this.channel.queueCallForConfig(this);
          return;
        } else if (configResult.type === "ERROR") {
          if (this.metadata.getOptions().waitForReady) {
            this.channel.queueCallForConfig(this);
          } else {
            this.outputStatus(configResult.error);
          }
          return;
        }
        this.configReceivedTime = /* @__PURE__ */ new Date();
        const config = configResult.config;
        if (config.status !== constants_1.Status.OK) {
          const { code, details } = (0, control_plane_status_1.restrictControlPlaneStatusCode)(config.status, "Failed to route call to method " + this.method);
          this.outputStatus({
            code,
            details,
            metadata: new metadata_1.Metadata()
          });
          return;
        }
        if (config.methodConfig.timeout) {
          const configDeadline = /* @__PURE__ */ new Date();
          configDeadline.setSeconds(configDeadline.getSeconds() + config.methodConfig.timeout.seconds);
          configDeadline.setMilliseconds(configDeadline.getMilliseconds() + config.methodConfig.timeout.nanos / 1e6);
          this.deadline = (0, deadline_1.minDeadline)(this.deadline, configDeadline);
          this.runDeadlineTimer();
        }
        this.filterStackFactory.push(config.dynamicFilterFactories);
        this.filterStack = this.filterStackFactory.createFilter();
        this.filterStack.sendMetadata(Promise.resolve(this.metadata)).then((filteredMetadata) => {
          this.child = this.channel.createInnerCall(config, this.method, this.host, this.credentials, this.deadline);
          this.trace("Created child [" + this.child.getCallNumber() + "]");
          this.childStartTime = /* @__PURE__ */ new Date();
          this.child.start(filteredMetadata, {
            onReceiveMetadata: /* @__PURE__ */ __name((metadata) => {
              this.trace("Received metadata");
              this.listener.onReceiveMetadata(this.filterStack.receiveMetadata(metadata));
            }, "onReceiveMetadata"),
            onReceiveMessage: /* @__PURE__ */ __name((message) => {
              this.trace("Received message");
              this.readFilterPending = true;
              this.filterStack.receiveMessage(message).then((filteredMesssage) => {
                this.trace("Finished filtering received message");
                this.readFilterPending = false;
                this.listener.onReceiveMessage(filteredMesssage);
                if (this.pendingChildStatus) {
                  this.outputStatus(this.pendingChildStatus);
                }
              }, (status) => {
                this.cancelWithStatus(status.code, status.details);
              });
            }, "onReceiveMessage"),
            onReceiveStatus: /* @__PURE__ */ __name((status) => {
              this.trace("Received status");
              if (this.readFilterPending) {
                this.pendingChildStatus = status;
              } else {
                this.outputStatus(status);
              }
            }, "onReceiveStatus")
          });
          if (this.readPending) {
            this.child.startRead();
          }
          if (this.pendingMessage) {
            this.sendMessageOnChild(this.pendingMessage.context, this.pendingMessage.message);
          } else if (this.pendingHalfClose) {
            this.child.halfClose();
          }
        }, (status) => {
          this.outputStatus(status);
        });
      }
      reportResolverError(status) {
        var _a2;
        if ((_a2 = this.metadata) === null || _a2 === void 0 ? void 0 : _a2.getOptions().waitForReady) {
          this.channel.queueCallForConfig(this);
        } else {
          this.outputStatus(status);
        }
      }
      cancelWithStatus(status, details) {
        var _a2;
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.cancelWithStatus(status, details);
        this.outputStatus({
          code: status,
          details,
          metadata: new metadata_1.Metadata()
        });
      }
      getPeer() {
        var _a2, _b2;
        return (_b2 = (_a2 = this.child) === null || _a2 === void 0 ? void 0 : _a2.getPeer()) !== null && _b2 !== void 0 ? _b2 : this.channel.getTarget();
      }
      start(metadata, listener) {
        this.trace("start called");
        this.metadata = metadata.clone();
        this.listener = listener;
        this.getConfig();
      }
      sendMessageWithContext(context, message) {
        this.trace("write() called with message of length " + message.length);
        if (this.child) {
          this.sendMessageOnChild(context, message);
        } else {
          this.pendingMessage = {
            context,
            message
          };
        }
      }
      startRead() {
        this.trace("startRead called");
        if (this.child) {
          this.child.startRead();
        } else {
          this.readPending = true;
        }
      }
      halfClose() {
        this.trace("halfClose called");
        if (this.child && !this.writeFilterPending) {
          this.child.halfClose();
        } else {
          this.pendingHalfClose = true;
        }
      }
      setCredentials(credentials) {
        this.credentials = this.credentials.compose(credentials);
      }
      addStatusWatcher(watcher) {
        this.statusWatchers.push(watcher);
      }
      getCallNumber() {
        return this.callNumber;
      }
    };
    exports2.ResolvingCall = ResolvingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/retrying-call.js
var require_retrying_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/retrying-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RetryingCall = exports2.MessageBufferTracker = exports2.RetryThrottler = void 0;
    var constants_1 = require_constants3();
    var deadline_1 = require_deadline();
    var metadata_1 = require_metadata2();
    var logging = require_logging();
    var TRACER_NAME = "retrying_call";
    var RetryThrottler = class RetryThrottler {
      static {
        __name(this, "RetryThrottler");
      }
      constructor(maxTokens, tokenRatio, previousRetryThrottler) {
        this.maxTokens = maxTokens;
        this.tokenRatio = tokenRatio;
        if (previousRetryThrottler) {
          this.tokens = previousRetryThrottler.tokens * (maxTokens / previousRetryThrottler.maxTokens);
        } else {
          this.tokens = maxTokens;
        }
      }
      addCallSucceeded() {
        this.tokens = Math.max(this.tokens + this.tokenRatio, this.maxTokens);
      }
      addCallFailed() {
        this.tokens = Math.min(this.tokens - 1, 0);
      }
      canRetryCall() {
        return this.tokens > this.maxTokens / 2;
      }
    };
    exports2.RetryThrottler = RetryThrottler;
    var MessageBufferTracker = class MessageBufferTracker {
      static {
        __name(this, "MessageBufferTracker");
      }
      constructor(totalLimit, limitPerCall) {
        this.totalLimit = totalLimit;
        this.limitPerCall = limitPerCall;
        this.totalAllocated = 0;
        this.allocatedPerCall = /* @__PURE__ */ new Map();
      }
      allocate(size, callId) {
        var _a2;
        const currentPerCall = (_a2 = this.allocatedPerCall.get(callId)) !== null && _a2 !== void 0 ? _a2 : 0;
        if (this.limitPerCall - currentPerCall < size || this.totalLimit - this.totalAllocated < size) {
          return false;
        }
        this.allocatedPerCall.set(callId, currentPerCall + size);
        this.totalAllocated += size;
        return true;
      }
      free(size, callId) {
        var _a2;
        if (this.totalAllocated < size) {
          throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= size;
        const currentPerCall = (_a2 = this.allocatedPerCall.get(callId)) !== null && _a2 !== void 0 ? _a2 : 0;
        if (currentPerCall < size) {
          throw new Error(`Invalid buffer allocation state: call ${callId} freed ${size} > allocated for call ${currentPerCall}`);
        }
        this.allocatedPerCall.set(callId, currentPerCall - size);
      }
      freeAll(callId) {
        var _a2;
        const currentPerCall = (_a2 = this.allocatedPerCall.get(callId)) !== null && _a2 !== void 0 ? _a2 : 0;
        if (this.totalAllocated < currentPerCall) {
          throw new Error(`Invalid buffer allocation state: call ${callId} allocated ${currentPerCall} > total allocated ${this.totalAllocated}`);
        }
        this.totalAllocated -= currentPerCall;
        this.allocatedPerCall.delete(callId);
      }
    };
    exports2.MessageBufferTracker = MessageBufferTracker;
    var PREVIONS_RPC_ATTEMPTS_METADATA_KEY = "grpc-previous-rpc-attempts";
    var DEFAULT_MAX_ATTEMPTS_LIMIT = 5;
    var RetryingCall = class RetryingCall {
      static {
        __name(this, "RetryingCall");
      }
      constructor(channel, callConfig, methodName, host, credentials, deadline, callNumber, bufferTracker, retryThrottler) {
        var _a2;
        this.channel = channel;
        this.callConfig = callConfig;
        this.methodName = methodName;
        this.host = host;
        this.credentials = credentials;
        this.deadline = deadline;
        this.callNumber = callNumber;
        this.bufferTracker = bufferTracker;
        this.retryThrottler = retryThrottler;
        this.listener = null;
        this.initialMetadata = null;
        this.underlyingCalls = [];
        this.writeBuffer = [];
        this.writeBufferOffset = 0;
        this.readStarted = false;
        this.transparentRetryUsed = false;
        this.attempts = 0;
        this.hedgingTimer = null;
        this.committedCallIndex = null;
        this.initialRetryBackoffSec = 0;
        this.nextRetryBackoffSec = 0;
        const maxAttemptsLimit = (_a2 = channel.getOptions()["grpc-node.retry_max_attempts_limit"]) !== null && _a2 !== void 0 ? _a2 : DEFAULT_MAX_ATTEMPTS_LIMIT;
        if (callConfig.methodConfig.retryPolicy) {
          this.state = "RETRY";
          const retryPolicy = callConfig.methodConfig.retryPolicy;
          this.nextRetryBackoffSec = this.initialRetryBackoffSec = Number(retryPolicy.initialBackoff.substring(0, retryPolicy.initialBackoff.length - 1));
          this.maxAttempts = Math.min(retryPolicy.maxAttempts, maxAttemptsLimit);
        } else if (callConfig.methodConfig.hedgingPolicy) {
          this.state = "HEDGING";
          this.maxAttempts = Math.min(callConfig.methodConfig.hedgingPolicy.maxAttempts, maxAttemptsLimit);
        } else {
          this.state = "TRANSPARENT_ONLY";
          this.maxAttempts = 1;
        }
        this.startTime = /* @__PURE__ */ new Date();
      }
      getDeadlineInfo() {
        if (this.underlyingCalls.length === 0) {
          return [];
        }
        const deadlineInfo = [];
        const latestCall = this.underlyingCalls[this.underlyingCalls.length - 1];
        if (this.underlyingCalls.length > 1) {
          deadlineInfo.push(`previous attempts: ${this.underlyingCalls.length - 1}`);
        }
        if (latestCall.startTime > this.startTime) {
          deadlineInfo.push(`time to current attempt start: ${(0, deadline_1.formatDateDifference)(this.startTime, latestCall.startTime)}`);
        }
        deadlineInfo.push(...latestCall.call.getDeadlineInfo());
        return deadlineInfo;
      }
      getCallNumber() {
        return this.callNumber;
      }
      trace(text) {
        logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "[" + this.callNumber + "] " + text);
      }
      reportStatus(statusObject) {
        this.trace("ended with status: code=" + statusObject.code + ' details="' + statusObject.details + '" start time=' + this.startTime.toISOString());
        this.bufferTracker.freeAll(this.callNumber);
        this.writeBufferOffset = this.writeBufferOffset + this.writeBuffer.length;
        this.writeBuffer = [];
        process.nextTick(() => {
          var _a2;
          (_a2 = this.listener) === null || _a2 === void 0 ? void 0 : _a2.onReceiveStatus({
            code: statusObject.code,
            details: statusObject.details,
            metadata: statusObject.metadata
          });
        });
      }
      cancelWithStatus(status, details) {
        this.trace("cancelWithStatus code: " + status + ' details: "' + details + '"');
        this.reportStatus({
          code: status,
          details,
          metadata: new metadata_1.Metadata()
        });
        for (const { call } of this.underlyingCalls) {
          call.cancelWithStatus(status, details);
        }
      }
      getPeer() {
        if (this.committedCallIndex !== null) {
          return this.underlyingCalls[this.committedCallIndex].call.getPeer();
        } else {
          return "unknown";
        }
      }
      getBufferEntry(messageIndex) {
        var _a2;
        return (_a2 = this.writeBuffer[messageIndex - this.writeBufferOffset]) !== null && _a2 !== void 0 ? _a2 : {
          entryType: "FREED",
          allocated: false
        };
      }
      getNextBufferIndex() {
        return this.writeBufferOffset + this.writeBuffer.length;
      }
      clearSentMessages() {
        if (this.state !== "COMMITTED") {
          return;
        }
        const earliestNeededMessageIndex = this.underlyingCalls[this.committedCallIndex].nextMessageToSend;
        for (let messageIndex = this.writeBufferOffset; messageIndex < earliestNeededMessageIndex; messageIndex++) {
          const bufferEntry = this.getBufferEntry(messageIndex);
          if (bufferEntry.allocated) {
            this.bufferTracker.free(bufferEntry.message.message.length, this.callNumber);
          }
        }
        this.writeBuffer = this.writeBuffer.slice(earliestNeededMessageIndex - this.writeBufferOffset);
        this.writeBufferOffset = earliestNeededMessageIndex;
      }
      commitCall(index) {
        if (this.state === "COMMITTED") {
          return;
        }
        if (this.underlyingCalls[index].state === "COMPLETED") {
          return;
        }
        this.trace("Committing call [" + this.underlyingCalls[index].call.getCallNumber() + "] at index " + index);
        this.state = "COMMITTED";
        this.committedCallIndex = index;
        for (let i = 0; i < this.underlyingCalls.length; i++) {
          if (i === index) {
            continue;
          }
          if (this.underlyingCalls[i].state === "COMPLETED") {
            continue;
          }
          this.underlyingCalls[i].state = "COMPLETED";
          this.underlyingCalls[i].call.cancelWithStatus(constants_1.Status.CANCELLED, "Discarded in favor of other hedged attempt");
        }
        this.clearSentMessages();
      }
      commitCallWithMostMessages() {
        if (this.state === "COMMITTED") {
          return;
        }
        let mostMessages = -1;
        let callWithMostMessages = -1;
        for (const [index, childCall] of this.underlyingCalls.entries()) {
          if (childCall.state === "ACTIVE" && childCall.nextMessageToSend > mostMessages) {
            mostMessages = childCall.nextMessageToSend;
            callWithMostMessages = index;
          }
        }
        if (callWithMostMessages === -1) {
          this.state = "TRANSPARENT_ONLY";
        } else {
          this.commitCall(callWithMostMessages);
        }
      }
      isStatusCodeInList(list, code) {
        return list.some((value2) => {
          var _a2;
          return value2 === code || value2.toString().toLowerCase() === ((_a2 = constants_1.Status[code]) === null || _a2 === void 0 ? void 0 : _a2.toLowerCase());
        });
      }
      getNextRetryBackoffMs() {
        var _a2;
        const retryPolicy = (_a2 = this.callConfig) === null || _a2 === void 0 ? void 0 : _a2.methodConfig.retryPolicy;
        if (!retryPolicy) {
          return 0;
        }
        const nextBackoffMs = Math.random() * this.nextRetryBackoffSec * 1e3;
        const maxBackoffSec = Number(retryPolicy.maxBackoff.substring(0, retryPolicy.maxBackoff.length - 1));
        this.nextRetryBackoffSec = Math.min(this.nextRetryBackoffSec * retryPolicy.backoffMultiplier, maxBackoffSec);
        return nextBackoffMs;
      }
      maybeRetryCall(pushback, callback) {
        if (this.state !== "RETRY") {
          callback(false);
          return;
        }
        if (this.attempts >= this.maxAttempts) {
          callback(false);
          return;
        }
        let retryDelayMs;
        if (pushback === null) {
          retryDelayMs = this.getNextRetryBackoffMs();
        } else if (pushback < 0) {
          this.state = "TRANSPARENT_ONLY";
          callback(false);
          return;
        } else {
          retryDelayMs = pushback;
          this.nextRetryBackoffSec = this.initialRetryBackoffSec;
        }
        setTimeout(() => {
          var _a2, _b2;
          if (this.state !== "RETRY") {
            callback(false);
            return;
          }
          if ((_b2 = (_a2 = this.retryThrottler) === null || _a2 === void 0 ? void 0 : _a2.canRetryCall()) !== null && _b2 !== void 0 ? _b2 : true) {
            callback(true);
            this.attempts += 1;
            this.startNewAttempt();
          }
        }, retryDelayMs);
      }
      countActiveCalls() {
        let count = 0;
        for (const call of this.underlyingCalls) {
          if ((call === null || call === void 0 ? void 0 : call.state) === "ACTIVE") {
            count += 1;
          }
        }
        return count;
      }
      handleProcessedStatus(status, callIndex, pushback) {
        var _a2, _b2, _c2;
        switch (this.state) {
          case "COMMITTED":
          case "TRANSPARENT_ONLY":
            this.commitCall(callIndex);
            this.reportStatus(status);
            break;
          case "HEDGING":
            if (this.isStatusCodeInList((_a2 = this.callConfig.methodConfig.hedgingPolicy.nonFatalStatusCodes) !== null && _a2 !== void 0 ? _a2 : [], status.code)) {
              (_b2 = this.retryThrottler) === null || _b2 === void 0 ? void 0 : _b2.addCallFailed();
              let delayMs;
              if (pushback === null) {
                delayMs = 0;
              } else if (pushback < 0) {
                this.state = "TRANSPARENT_ONLY";
                this.commitCall(callIndex);
                this.reportStatus(status);
                return;
              } else {
                delayMs = pushback;
              }
              setTimeout(() => {
                this.maybeStartHedgingAttempt();
                if (this.countActiveCalls() === 0) {
                  this.commitCall(callIndex);
                  this.reportStatus(status);
                }
              }, delayMs);
            } else {
              this.commitCall(callIndex);
              this.reportStatus(status);
            }
            break;
          case "RETRY":
            if (this.isStatusCodeInList(this.callConfig.methodConfig.retryPolicy.retryableStatusCodes, status.code)) {
              (_c2 = this.retryThrottler) === null || _c2 === void 0 ? void 0 : _c2.addCallFailed();
              this.maybeRetryCall(pushback, (retried) => {
                if (!retried) {
                  this.commitCall(callIndex);
                  this.reportStatus(status);
                }
              });
            } else {
              this.commitCall(callIndex);
              this.reportStatus(status);
            }
            break;
        }
      }
      getPushback(metadata) {
        const mdValue = metadata.get("grpc-retry-pushback-ms");
        if (mdValue.length === 0) {
          return null;
        }
        try {
          return parseInt(mdValue[0]);
        } catch (e) {
          return -1;
        }
      }
      handleChildStatus(status, callIndex) {
        var _a2;
        if (this.underlyingCalls[callIndex].state === "COMPLETED") {
          return;
        }
        this.trace("state=" + this.state + " handling status with progress " + status.progress + " from child [" + this.underlyingCalls[callIndex].call.getCallNumber() + "] in state " + this.underlyingCalls[callIndex].state);
        this.underlyingCalls[callIndex].state = "COMPLETED";
        if (status.code === constants_1.Status.OK) {
          (_a2 = this.retryThrottler) === null || _a2 === void 0 ? void 0 : _a2.addCallSucceeded();
          this.commitCall(callIndex);
          this.reportStatus(status);
          return;
        }
        if (this.state === "COMMITTED") {
          this.reportStatus(status);
          return;
        }
        const pushback = this.getPushback(status.metadata);
        switch (status.progress) {
          case "NOT_STARTED":
            this.startNewAttempt();
            break;
          case "REFUSED":
            if (this.transparentRetryUsed) {
              this.handleProcessedStatus(status, callIndex, pushback);
            } else {
              this.transparentRetryUsed = true;
              this.startNewAttempt();
            }
            break;
          case "DROP":
            this.commitCall(callIndex);
            this.reportStatus(status);
            break;
          case "PROCESSED":
            this.handleProcessedStatus(status, callIndex, pushback);
            break;
        }
      }
      maybeStartHedgingAttempt() {
        if (this.state !== "HEDGING") {
          return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
          return;
        }
        if (this.attempts >= this.maxAttempts) {
          return;
        }
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
      }
      maybeStartHedgingTimer() {
        var _a2, _b2, _c2;
        if (this.hedgingTimer) {
          clearTimeout(this.hedgingTimer);
        }
        if (this.state !== "HEDGING") {
          return;
        }
        if (!this.callConfig.methodConfig.hedgingPolicy) {
          return;
        }
        const hedgingPolicy = this.callConfig.methodConfig.hedgingPolicy;
        if (this.attempts >= this.maxAttempts) {
          return;
        }
        const hedgingDelayString = (_a2 = hedgingPolicy.hedgingDelay) !== null && _a2 !== void 0 ? _a2 : "0s";
        const hedgingDelaySec = Number(hedgingDelayString.substring(0, hedgingDelayString.length - 1));
        this.hedgingTimer = setTimeout(() => {
          this.maybeStartHedgingAttempt();
        }, hedgingDelaySec * 1e3);
        (_c2 = (_b2 = this.hedgingTimer).unref) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
      }
      startNewAttempt() {
        const child = this.channel.createLoadBalancingCall(this.callConfig, this.methodName, this.host, this.credentials, this.deadline);
        this.trace("Created child call [" + child.getCallNumber() + "] for attempt " + this.attempts);
        const index = this.underlyingCalls.length;
        this.underlyingCalls.push({
          state: "ACTIVE",
          call: child,
          nextMessageToSend: 0,
          startTime: /* @__PURE__ */ new Date()
        });
        const previousAttempts = this.attempts - 1;
        const initialMetadata = this.initialMetadata.clone();
        if (previousAttempts > 0) {
          initialMetadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
        }
        let receivedMetadata = false;
        child.start(initialMetadata, {
          onReceiveMetadata: /* @__PURE__ */ __name((metadata) => {
            this.trace("Received metadata from child [" + child.getCallNumber() + "]");
            this.commitCall(index);
            receivedMetadata = true;
            if (previousAttempts > 0) {
              metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
            }
            if (this.underlyingCalls[index].state === "ACTIVE") {
              this.listener.onReceiveMetadata(metadata);
            }
          }, "onReceiveMetadata"),
          onReceiveMessage: /* @__PURE__ */ __name((message) => {
            this.trace("Received message from child [" + child.getCallNumber() + "]");
            this.commitCall(index);
            if (this.underlyingCalls[index].state === "ACTIVE") {
              this.listener.onReceiveMessage(message);
            }
          }, "onReceiveMessage"),
          onReceiveStatus: /* @__PURE__ */ __name((status) => {
            this.trace("Received status from child [" + child.getCallNumber() + "]");
            if (!receivedMetadata && previousAttempts > 0) {
              status.metadata.set(PREVIONS_RPC_ATTEMPTS_METADATA_KEY, `${previousAttempts}`);
            }
            this.handleChildStatus(status, index);
          }, "onReceiveStatus")
        });
        this.sendNextChildMessage(index);
        if (this.readStarted) {
          child.startRead();
        }
      }
      start(metadata, listener) {
        this.trace("start called");
        this.listener = listener;
        this.initialMetadata = metadata;
        this.attempts += 1;
        this.startNewAttempt();
        this.maybeStartHedgingTimer();
      }
      handleChildWriteCompleted(childIndex) {
        var _a2, _b2;
        const childCall = this.underlyingCalls[childIndex];
        const messageIndex = childCall.nextMessageToSend;
        (_b2 = (_a2 = this.getBufferEntry(messageIndex)).callback) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
        this.clearSentMessages();
        childCall.nextMessageToSend += 1;
        this.sendNextChildMessage(childIndex);
      }
      sendNextChildMessage(childIndex) {
        const childCall = this.underlyingCalls[childIndex];
        if (childCall.state === "COMPLETED") {
          return;
        }
        if (this.getBufferEntry(childCall.nextMessageToSend)) {
          const bufferEntry = this.getBufferEntry(childCall.nextMessageToSend);
          switch (bufferEntry.entryType) {
            case "MESSAGE":
              childCall.call.sendMessageWithContext({
                callback: /* @__PURE__ */ __name((error) => {
                  this.handleChildWriteCompleted(childIndex);
                }, "callback")
              }, bufferEntry.message.message);
              break;
            case "HALF_CLOSE":
              childCall.nextMessageToSend += 1;
              childCall.call.halfClose();
              break;
            case "FREED":
              break;
          }
        }
      }
      sendMessageWithContext(context, message) {
        var _a2;
        this.trace("write() called with message of length " + message.length);
        const writeObj = {
          message,
          flags: context.flags
        };
        const messageIndex = this.getNextBufferIndex();
        const bufferEntry = {
          entryType: "MESSAGE",
          message: writeObj,
          allocated: this.bufferTracker.allocate(message.length, this.callNumber)
        };
        this.writeBuffer.push(bufferEntry);
        if (bufferEntry.allocated) {
          (_a2 = context.callback) === null || _a2 === void 0 ? void 0 : _a2.call(context);
          for (const [callIndex, call] of this.underlyingCalls.entries()) {
            if (call.state === "ACTIVE" && call.nextMessageToSend === messageIndex) {
              call.call.sendMessageWithContext({
                callback: /* @__PURE__ */ __name((error) => {
                  this.handleChildWriteCompleted(callIndex);
                }, "callback")
              }, message);
            }
          }
        } else {
          this.commitCallWithMostMessages();
          if (this.committedCallIndex === null) {
            return;
          }
          const call = this.underlyingCalls[this.committedCallIndex];
          bufferEntry.callback = context.callback;
          if (call.state === "ACTIVE" && call.nextMessageToSend === messageIndex) {
            call.call.sendMessageWithContext({
              callback: /* @__PURE__ */ __name((error) => {
                this.handleChildWriteCompleted(this.committedCallIndex);
              }, "callback")
            }, message);
          }
        }
      }
      startRead() {
        this.trace("startRead called");
        this.readStarted = true;
        for (const underlyingCall of this.underlyingCalls) {
          if ((underlyingCall === null || underlyingCall === void 0 ? void 0 : underlyingCall.state) === "ACTIVE") {
            underlyingCall.call.startRead();
          }
        }
      }
      halfClose() {
        this.trace("halfClose called");
        const halfCloseIndex = this.getNextBufferIndex();
        this.writeBuffer.push({
          entryType: "HALF_CLOSE",
          allocated: false
        });
        for (const call of this.underlyingCalls) {
          if ((call === null || call === void 0 ? void 0 : call.state) === "ACTIVE" && call.nextMessageToSend === halfCloseIndex) {
            call.nextMessageToSend += 1;
            call.call.halfClose();
          }
        }
      }
      setCredentials(newCredentials) {
        throw new Error("Method not implemented.");
      }
      getMethod() {
        return this.methodName;
      }
      getHost() {
        return this.host;
      }
    };
    exports2.RetryingCall = RetryingCall;
  }
});

// node_modules/@grpc/grpc-js/build/src/subchannel-interface.js
var require_subchannel_interface = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/subchannel-interface.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BaseSubchannelWrapper = void 0;
    var BaseSubchannelWrapper = class BaseSubchannelWrapper {
      static {
        __name(this, "BaseSubchannelWrapper");
      }
      constructor(child) {
        this.child = child;
        this.healthy = true;
        this.healthListeners = /* @__PURE__ */ new Set();
        child.addHealthStateWatcher((childHealthy) => {
          if (this.healthy) {
            this.updateHealthListeners();
          }
        });
      }
      updateHealthListeners() {
        for (const listener of this.healthListeners) {
          listener(this.isHealthy());
        }
      }
      getConnectivityState() {
        return this.child.getConnectivityState();
      }
      addConnectivityStateListener(listener) {
        this.child.addConnectivityStateListener(listener);
      }
      removeConnectivityStateListener(listener) {
        this.child.removeConnectivityStateListener(listener);
      }
      startConnecting() {
        this.child.startConnecting();
      }
      getAddress() {
        return this.child.getAddress();
      }
      throttleKeepalive(newKeepaliveTime) {
        this.child.throttleKeepalive(newKeepaliveTime);
      }
      ref() {
        this.child.ref();
      }
      unref() {
        this.child.unref();
      }
      getChannelzRef() {
        return this.child.getChannelzRef();
      }
      isHealthy() {
        return this.healthy && this.child.isHealthy();
      }
      addHealthStateWatcher(listener) {
        this.healthListeners.add(listener);
      }
      removeHealthStateWatcher(listener) {
        this.healthListeners.delete(listener);
      }
      setHealthy(healthy) {
        if (healthy !== this.healthy) {
          this.healthy = healthy;
          if (this.child.isHealthy()) {
            this.updateHealthListeners();
          }
        }
      }
      getRealSubchannel() {
        return this.child.getRealSubchannel();
      }
      realSubchannelEquals(other) {
        return this.getRealSubchannel() === other.getRealSubchannel();
      }
    };
    exports2.BaseSubchannelWrapper = BaseSubchannelWrapper;
  }
});

// node_modules/@grpc/grpc-js/build/src/internal-channel.js
var require_internal_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/internal-channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.InternalChannel = void 0;
    var channel_credentials_1 = require_channel_credentials();
    var resolving_load_balancer_1 = require_resolving_load_balancer();
    var subchannel_pool_1 = require_subchannel_pool();
    var picker_1 = require_picker();
    var metadata_1 = require_metadata2();
    var constants_1 = require_constants3();
    var filter_stack_1 = require_filter_stack();
    var compression_filter_1 = require_compression_filter();
    var resolver_1 = require_resolver();
    var logging_1 = require_logging();
    var http_proxy_1 = require_http_proxy();
    var uri_parser_1 = require_uri_parser();
    var connectivity_state_1 = require_connectivity_state();
    var channelz_1 = require_channelz();
    var load_balancing_call_1 = require_load_balancing_call();
    var deadline_1 = require_deadline();
    var resolving_call_1 = require_resolving_call();
    var call_number_1 = require_call_number();
    var control_plane_status_1 = require_control_plane_status();
    var retrying_call_1 = require_retrying_call();
    var subchannel_interface_1 = require_subchannel_interface();
    var MAX_TIMEOUT_TIME = 2147483647;
    var MIN_IDLE_TIMEOUT_MS = 1e3;
    var DEFAULT_IDLE_TIMEOUT_MS = 30 * 60 * 1e3;
    var RETRY_THROTTLER_MAP = /* @__PURE__ */ new Map();
    var DEFAULT_RETRY_BUFFER_SIZE_BYTES = 1 << 24;
    var DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES = 1 << 20;
    var ChannelSubchannelWrapper = class ChannelSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
      static {
        __name(this, "ChannelSubchannelWrapper");
      }
      constructor(childSubchannel, channel) {
        super(childSubchannel);
        this.channel = channel;
        this.refCount = 0;
        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime) => {
          channel.throttleKeepalive(keepaliveTime);
        };
      }
      ref() {
        if (this.refCount === 0) {
          this.child.addConnectivityStateListener(this.subchannelStateListener);
          this.channel.addWrappedSubchannel(this);
        }
        this.child.ref();
        this.refCount += 1;
      }
      unref() {
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) {
          this.child.removeConnectivityStateListener(this.subchannelStateListener);
          this.channel.removeWrappedSubchannel(this);
        }
      }
    };
    var ShutdownPicker = class ShutdownPicker {
      static {
        __name(this, "ShutdownPicker");
      }
      pick(pickArgs) {
        return {
          pickResultType: picker_1.PickResultType.DROP,
          status: {
            code: constants_1.Status.UNAVAILABLE,
            details: "Channel closed before call started",
            metadata: new metadata_1.Metadata()
          },
          subchannel: null,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    var ChannelzInfoTracker = class ChannelzInfoTracker {
      static {
        __name(this, "ChannelzInfoTracker");
      }
      constructor(target) {
        this.target = target;
        this.trace = new channelz_1.ChannelzTrace();
        this.callTracker = new channelz_1.ChannelzCallTracker();
        this.childrenTracker = new channelz_1.ChannelzChildrenTracker();
        this.state = connectivity_state_1.ConnectivityState.IDLE;
      }
      getChannelzInfoCallback() {
        return () => {
          return {
            target: this.target,
            state: this.state,
            trace: this.trace,
            callTracker: this.callTracker,
            children: this.childrenTracker.getChildLists()
          };
        };
      }
    };
    var InternalChannel = class InternalChannel {
      static {
        __name(this, "InternalChannel");
      }
      constructor(target, credentials, options) {
        var _a2, _b2, _c2, _d, _e, _f;
        this.credentials = credentials;
        this.options = options;
        this.connectivityState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentPicker = new picker_1.UnavailablePicker();
        this.configSelectionQueue = [];
        this.pickQueue = [];
        this.connectivityStateWatchers = [];
        this.callRefTimer = null;
        this.configSelector = null;
        this.currentResolutionError = null;
        this.wrappedSubchannels = /* @__PURE__ */ new Set();
        this.callCount = 0;
        this.idleTimer = null;
        this.channelzEnabled = true;
        this.randomChannelId = Math.floor(Math.random() * Number.MAX_SAFE_INTEGER);
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options) {
          if (typeof options !== "object") {
            throw new TypeError("Channel options must be an object");
          }
        }
        this.channelzInfoTracker = new ChannelzInfoTracker(target);
        const originalTargetUri = (0, uri_parser_1.parseUri)(target);
        if (originalTargetUri === null) {
          throw new Error(`Could not parse target name "${target}"`);
        }
        const defaultSchemeMapResult = (0, resolver_1.mapUriDefaultScheme)(originalTargetUri);
        if (defaultSchemeMapResult === null) {
          throw new Error(`Could not find a default scheme for target name "${target}"`);
        }
        if (this.options["grpc.enable_channelz"] === 0) {
          this.channelzEnabled = false;
        }
        this.channelzRef = (0, channelz_1.registerChannelzChannel)(target, this.channelzInfoTracker.getChannelzInfoCallback(), this.channelzEnabled);
        if (this.channelzEnabled) {
          this.channelzInfoTracker.trace.addTrace("CT_INFO", "Channel created");
        }
        if (this.options["grpc.default_authority"]) {
          this.defaultAuthority = this.options["grpc.default_authority"];
        } else {
          this.defaultAuthority = (0, resolver_1.getDefaultAuthority)(defaultSchemeMapResult);
        }
        const proxyMapResult = (0, http_proxy_1.mapProxyName)(defaultSchemeMapResult, options);
        this.target = proxyMapResult.target;
        this.options = Object.assign({}, this.options, proxyMapResult.extraOptions);
        this.subchannelPool = (0, subchannel_pool_1.getSubchannelPool)(((_a2 = options["grpc.use_local_subchannel_pool"]) !== null && _a2 !== void 0 ? _a2 : 0) === 0);
        this.retryBufferTracker = new retrying_call_1.MessageBufferTracker((_b2 = options["grpc.retry_buffer_size"]) !== null && _b2 !== void 0 ? _b2 : DEFAULT_RETRY_BUFFER_SIZE_BYTES, (_c2 = options["grpc.per_rpc_retry_buffer_size"]) !== null && _c2 !== void 0 ? _c2 : DEFAULT_PER_RPC_RETRY_BUFFER_SIZE_BYTES);
        this.keepaliveTime = (_d = options["grpc.keepalive_time_ms"]) !== null && _d !== void 0 ? _d : -1;
        this.idleTimeoutMs = Math.max((_e = options["grpc.client_idle_timeout_ms"]) !== null && _e !== void 0 ? _e : DEFAULT_IDLE_TIMEOUT_MS, MIN_IDLE_TIMEOUT_MS);
        const channelControlHelper = {
          createSubchannel: /* @__PURE__ */ __name((subchannelAddress, subchannelArgs, credentialsOverride) => {
            const subchannel = this.subchannelPool.getOrCreateSubchannel(this.target, subchannelAddress, Object.assign({}, this.options, subchannelArgs), credentialsOverride !== null && credentialsOverride !== void 0 ? credentialsOverride : this.credentials);
            subchannel.throttleKeepalive(this.keepaliveTime);
            if (this.channelzEnabled) {
              this.channelzInfoTracker.trace.addTrace("CT_INFO", "Created subchannel or used existing subchannel", subchannel.getChannelzRef());
            }
            const wrappedSubchannel = new ChannelSubchannelWrapper(subchannel, this);
            return wrappedSubchannel;
          }, "createSubchannel"),
          updateState: /* @__PURE__ */ __name((connectivityState, picker) => {
            this.currentPicker = picker;
            const queueCopy = this.pickQueue.slice();
            this.pickQueue = [];
            if (queueCopy.length > 0) {
              this.callRefTimerUnref();
            }
            for (const call of queueCopy) {
              call.doPick();
            }
            this.updateState(connectivityState);
          }, "updateState"),
          requestReresolution: /* @__PURE__ */ __name(() => {
            throw new Error("Resolving load balancer should never call requestReresolution");
          }, "requestReresolution"),
          addChannelzChild: /* @__PURE__ */ __name((child) => {
            if (this.channelzEnabled) {
              this.channelzInfoTracker.childrenTracker.refChild(child);
            }
          }, "addChannelzChild"),
          removeChannelzChild: /* @__PURE__ */ __name((child) => {
            if (this.channelzEnabled) {
              this.channelzInfoTracker.childrenTracker.unrefChild(child);
            }
          }, "removeChannelzChild")
        };
        this.resolvingLoadBalancer = new resolving_load_balancer_1.ResolvingLoadBalancer(this.target, channelControlHelper, credentials, options, (serviceConfig, configSelector) => {
          if (serviceConfig.retryThrottling) {
            RETRY_THROTTLER_MAP.set(this.getTarget(), new retrying_call_1.RetryThrottler(serviceConfig.retryThrottling.maxTokens, serviceConfig.retryThrottling.tokenRatio, RETRY_THROTTLER_MAP.get(this.getTarget())));
          } else {
            RETRY_THROTTLER_MAP.delete(this.getTarget());
          }
          if (this.channelzEnabled) {
            this.channelzInfoTracker.trace.addTrace("CT_INFO", "Address resolution succeeded");
          }
          this.configSelector = configSelector;
          this.currentResolutionError = null;
          process.nextTick(() => {
            const localQueue = this.configSelectionQueue;
            this.configSelectionQueue = [];
            if (localQueue.length > 0) {
              this.callRefTimerUnref();
            }
            for (const call of localQueue) {
              call.getConfig();
            }
          });
        }, (status) => {
          if (this.channelzEnabled) {
            this.channelzInfoTracker.trace.addTrace("CT_WARNING", "Address resolution failed with code " + status.code + ' and details "' + status.details + '"');
          }
          if (this.configSelectionQueue.length > 0) {
            this.trace("Name resolution failed with calls queued for config selection");
          }
          if (this.configSelector === null) {
            this.currentResolutionError = Object.assign(Object.assign({}, (0, control_plane_status_1.restrictControlPlaneStatusCode)(status.code, status.details)), {
              metadata: status.metadata
            });
          }
          const localQueue = this.configSelectionQueue;
          this.configSelectionQueue = [];
          if (localQueue.length > 0) {
            this.callRefTimerUnref();
          }
          for (const call of localQueue) {
            call.reportResolverError(status);
          }
        });
        this.filterStackFactory = new filter_stack_1.FilterStackFactory([
          new compression_filter_1.CompressionFilterFactory(this, this.options)
        ]);
        this.trace("Channel constructed with options " + JSON.stringify(options, void 0, 2));
        const error = new Error();
        if ((0, logging_1.isTracerEnabled)("channel_stacktrace")) {
          (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, "channel_stacktrace", "(" + this.channelzRef.id + ") Channel constructed \n" + ((_f = error.stack) === null || _f === void 0 ? void 0 : _f.substring(error.stack.indexOf("\n") + 1)));
        }
        this.lastActivityTimestamp = /* @__PURE__ */ new Date();
      }
      trace(text, verbosityOverride) {
        (0, logging_1.trace)(verbosityOverride !== null && verbosityOverride !== void 0 ? verbosityOverride : constants_1.LogVerbosity.DEBUG, "channel", "(" + this.channelzRef.id + ") " + (0, uri_parser_1.uriToString)(this.target) + " " + text);
      }
      callRefTimerRef() {
        var _a2, _b2, _c2, _d;
        if (!this.callRefTimer) {
          this.callRefTimer = setInterval(() => {
          }, MAX_TIMEOUT_TIME);
        }
        if (!((_b2 = (_a2 = this.callRefTimer).hasRef) === null || _b2 === void 0 ? void 0 : _b2.call(_a2))) {
          this.trace("callRefTimer.ref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_d = (_c2 = this.callRefTimer).ref) === null || _d === void 0 ? void 0 : _d.call(_c2);
        }
      }
      callRefTimerUnref() {
        var _a2, _b2, _c2;
        if (!((_a2 = this.callRefTimer) === null || _a2 === void 0 ? void 0 : _a2.hasRef) || this.callRefTimer.hasRef()) {
          this.trace("callRefTimer.unref | configSelectionQueue.length=" + this.configSelectionQueue.length + " pickQueue.length=" + this.pickQueue.length);
          (_c2 = (_b2 = this.callRefTimer) === null || _b2 === void 0 ? void 0 : _b2.unref) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
        }
      }
      removeConnectivityStateWatcher(watcherObject) {
        const watcherIndex = this.connectivityStateWatchers.findIndex((value2) => value2 === watcherObject);
        if (watcherIndex >= 0) {
          this.connectivityStateWatchers.splice(watcherIndex, 1);
        }
      }
      updateState(newState) {
        (0, logging_1.trace)(constants_1.LogVerbosity.DEBUG, "connectivity_state", "(" + this.channelzRef.id + ") " + (0, uri_parser_1.uriToString)(this.target) + " " + connectivity_state_1.ConnectivityState[this.connectivityState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (this.channelzEnabled) {
          this.channelzInfoTracker.trace.addTrace("CT_INFO", "Connectivity state change to " + connectivity_state_1.ConnectivityState[newState]);
        }
        this.connectivityState = newState;
        this.channelzInfoTracker.state = newState;
        const watchersCopy = this.connectivityStateWatchers.slice();
        for (const watcherObject of watchersCopy) {
          if (newState !== watcherObject.currentState) {
            if (watcherObject.timer) {
              clearTimeout(watcherObject.timer);
            }
            this.removeConnectivityStateWatcher(watcherObject);
            watcherObject.callback();
          }
        }
        if (newState !== connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
          this.currentResolutionError = null;
        }
      }
      throttleKeepalive(newKeepaliveTime) {
        if (newKeepaliveTime > this.keepaliveTime) {
          this.keepaliveTime = newKeepaliveTime;
          for (const wrappedSubchannel of this.wrappedSubchannels) {
            wrappedSubchannel.throttleKeepalive(newKeepaliveTime);
          }
        }
      }
      addWrappedSubchannel(wrappedSubchannel) {
        this.wrappedSubchannels.add(wrappedSubchannel);
      }
      removeWrappedSubchannel(wrappedSubchannel) {
        this.wrappedSubchannels.delete(wrappedSubchannel);
      }
      doPick(metadata, extraPickInfo) {
        return this.currentPicker.pick({
          metadata,
          extraPickInfo
        });
      }
      queueCallForPick(call) {
        this.pickQueue.push(call);
        this.callRefTimerRef();
      }
      getConfig(method, metadata) {
        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN) {
          this.resolvingLoadBalancer.exitIdle();
        }
        if (this.configSelector) {
          return {
            type: "SUCCESS",
            config: this.configSelector(method, metadata, this.randomChannelId)
          };
        } else {
          if (this.currentResolutionError) {
            return {
              type: "ERROR",
              error: this.currentResolutionError
            };
          } else {
            return {
              type: "NONE"
            };
          }
        }
      }
      queueCallForConfig(call) {
        this.configSelectionQueue.push(call);
        this.callRefTimerRef();
      }
      enterIdle() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.IDLE);
        this.currentPicker = new picker_1.QueuePicker(this.resolvingLoadBalancer);
        if (this.idleTimer) {
          clearTimeout(this.idleTimer);
          this.idleTimer = null;
        }
        if (this.callRefTimer) {
          clearInterval(this.callRefTimer);
          this.callRefTimer = null;
        }
      }
      startIdleTimeout(timeoutMs) {
        var _a2, _b2;
        this.idleTimer = setTimeout(() => {
          if (this.callCount > 0) {
            this.startIdleTimeout(this.idleTimeoutMs);
            return;
          }
          const now = /* @__PURE__ */ new Date();
          const timeSinceLastActivity = now.valueOf() - this.lastActivityTimestamp.valueOf();
          if (timeSinceLastActivity >= this.idleTimeoutMs) {
            this.trace("Idle timer triggered after " + this.idleTimeoutMs + "ms of inactivity");
            this.enterIdle();
          } else {
            this.startIdleTimeout(this.idleTimeoutMs - timeSinceLastActivity);
          }
        }, timeoutMs);
        (_b2 = (_a2 = this.idleTimer).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
      maybeStartIdleTimer() {
        if (this.connectivityState !== connectivity_state_1.ConnectivityState.SHUTDOWN && !this.idleTimer) {
          this.startIdleTimeout(this.idleTimeoutMs);
        }
      }
      onCallStart() {
        if (this.channelzEnabled) {
          this.channelzInfoTracker.callTracker.addCallStarted();
        }
        this.callCount += 1;
      }
      onCallEnd(status) {
        if (this.channelzEnabled) {
          if (status.code === constants_1.Status.OK) {
            this.channelzInfoTracker.callTracker.addCallSucceeded();
          } else {
            this.channelzInfoTracker.callTracker.addCallFailed();
          }
        }
        this.callCount -= 1;
        this.lastActivityTimestamp = /* @__PURE__ */ new Date();
        this.maybeStartIdleTimer();
      }
      createLoadBalancingCall(callConfig, method, host, credentials, deadline) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createLoadBalancingCall [" + callNumber + '] method="' + method + '"');
        return new load_balancing_call_1.LoadBalancingCall(this, callConfig, method, host, credentials, deadline, callNumber);
      }
      createRetryingCall(callConfig, method, host, credentials, deadline) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createRetryingCall [" + callNumber + '] method="' + method + '"');
        return new retrying_call_1.RetryingCall(this, callConfig, method, host, credentials, deadline, callNumber, this.retryBufferTracker, RETRY_THROTTLER_MAP.get(this.getTarget()));
      }
      createInnerCall(callConfig, method, host, credentials, deadline) {
        if (this.options["grpc.enable_retries"] === 0) {
          return this.createLoadBalancingCall(callConfig, method, host, credentials, deadline);
        } else {
          return this.createRetryingCall(callConfig, method, host, credentials, deadline);
        }
      }
      createResolvingCall(method, deadline, host, parentCall, propagateFlags) {
        const callNumber = (0, call_number_1.getNextCallNumber)();
        this.trace("createResolvingCall [" + callNumber + '] method="' + method + '", deadline=' + (0, deadline_1.deadlineToString)(deadline));
        const finalOptions = {
          deadline,
          flags: propagateFlags !== null && propagateFlags !== void 0 ? propagateFlags : constants_1.Propagate.DEFAULTS,
          host: host !== null && host !== void 0 ? host : this.defaultAuthority,
          parentCall
        };
        const call = new resolving_call_1.ResolvingCall(this, method, finalOptions, this.filterStackFactory.clone(), this.credentials._getCallCredentials(), callNumber);
        this.onCallStart();
        call.addStatusWatcher((status) => {
          this.onCallEnd(status);
        });
        return call;
      }
      close() {
        this.resolvingLoadBalancer.destroy();
        this.updateState(connectivity_state_1.ConnectivityState.SHUTDOWN);
        this.currentPicker = new ShutdownPicker();
        for (const call of this.configSelectionQueue) {
          call.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Channel closed before call started");
        }
        this.configSelectionQueue = [];
        for (const call of this.pickQueue) {
          call.cancelWithStatus(constants_1.Status.UNAVAILABLE, "Channel closed before call started");
        }
        this.pickQueue = [];
        if (this.callRefTimer) {
          clearInterval(this.callRefTimer);
        }
        if (this.idleTimer) {
          clearTimeout(this.idleTimer);
        }
        if (this.channelzEnabled) {
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
        }
        this.subchannelPool.unrefUnusedSubchannels();
      }
      getTarget() {
        return (0, uri_parser_1.uriToString)(this.target);
      }
      getConnectivityState(tryToConnect) {
        const connectivityState = this.connectivityState;
        if (tryToConnect) {
          this.resolvingLoadBalancer.exitIdle();
          this.lastActivityTimestamp = /* @__PURE__ */ new Date();
          this.maybeStartIdleTimer();
        }
        return connectivityState;
      }
      watchConnectivityState(currentState, deadline, callback) {
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        let timer = null;
        if (deadline !== Infinity) {
          const deadlineDate = deadline instanceof Date ? deadline : new Date(deadline);
          const now = /* @__PURE__ */ new Date();
          if (deadline === -Infinity || deadlineDate <= now) {
            process.nextTick(callback, new Error("Deadline passed without connectivity state change"));
            return;
          }
          timer = setTimeout(() => {
            this.removeConnectivityStateWatcher(watcherObject);
            callback(new Error("Deadline passed without connectivity state change"));
          }, deadlineDate.getTime() - now.getTime());
        }
        const watcherObject = {
          currentState,
          callback,
          timer
        };
        this.connectivityStateWatchers.push(watcherObject);
      }
      /**
       * Get the channelz reference object for this channel. The returned value is
       * garbage if channelz is disabled for this channel.
       * @returns
       */
      getChannelzRef() {
        return this.channelzRef;
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        if (this.connectivityState === connectivity_state_1.ConnectivityState.SHUTDOWN) {
          throw new Error("Channel has been shut down");
        }
        return this.createResolvingCall(method, deadline, host, parentCall, propagateFlags);
      }
      getOptions() {
        return this.options;
      }
    };
    exports2.InternalChannel = InternalChannel;
  }
});

// node_modules/@grpc/grpc-js/build/src/channel.js
var require_channel = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/channel.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ChannelImplementation = void 0;
    var channel_credentials_1 = require_channel_credentials();
    var internal_channel_1 = require_internal_channel();
    var ChannelImplementation = class ChannelImplementation {
      static {
        __name(this, "ChannelImplementation");
      }
      constructor(target, credentials, options) {
        if (typeof target !== "string") {
          throw new TypeError("Channel target must be a string");
        }
        if (!(credentials instanceof channel_credentials_1.ChannelCredentials)) {
          throw new TypeError("Channel credentials must be a ChannelCredentials object");
        }
        if (options) {
          if (typeof options !== "object") {
            throw new TypeError("Channel options must be an object");
          }
        }
        this.internalChannel = new internal_channel_1.InternalChannel(target, credentials, options);
      }
      close() {
        this.internalChannel.close();
      }
      getTarget() {
        return this.internalChannel.getTarget();
      }
      getConnectivityState(tryToConnect) {
        return this.internalChannel.getConnectivityState(tryToConnect);
      }
      watchConnectivityState(currentState, deadline, callback) {
        this.internalChannel.watchConnectivityState(currentState, deadline, callback);
      }
      /**
       * Get the channelz reference object for this channel. The returned value is
       * garbage if channelz is disabled for this channel.
       * @returns
       */
      getChannelzRef() {
        return this.internalChannel.getChannelzRef();
      }
      createCall(method, deadline, host, parentCall, propagateFlags) {
        if (typeof method !== "string") {
          throw new TypeError("Channel#createCall: method must be a string");
        }
        if (!(typeof deadline === "number" || deadline instanceof Date)) {
          throw new TypeError("Channel#createCall: deadline must be a number or Date");
        }
        return this.internalChannel.createCall(method, deadline, host, parentCall, propagateFlags);
      }
    };
    exports2.ChannelImplementation = ChannelImplementation;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-call.js
var require_server_call = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-call.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ServerDuplexStreamImpl = exports2.ServerWritableStreamImpl = exports2.ServerReadableStreamImpl = exports2.ServerUnaryCallImpl = void 0;
    exports2.serverErrorToStatus = serverErrorToStatus;
    var events_1 = require("events");
    var stream_1 = require("stream");
    var constants_1 = require_constants3();
    var metadata_1 = require_metadata2();
    function serverErrorToStatus(error, overrideTrailers) {
      var _a2;
      const status = {
        code: constants_1.Status.UNKNOWN,
        details: "message" in error ? error.message : "Unknown Error",
        metadata: (_a2 = overrideTrailers !== null && overrideTrailers !== void 0 ? overrideTrailers : error.metadata) !== null && _a2 !== void 0 ? _a2 : null
      };
      if ("code" in error && typeof error.code === "number" && Number.isInteger(error.code)) {
        status.code = error.code;
        if ("details" in error && typeof error.details === "string") {
          status.details = error.details;
        }
      }
      return status;
    }
    __name(serverErrorToStatus, "serverErrorToStatus");
    var ServerUnaryCallImpl = class ServerUnaryCallImpl extends events_1.EventEmitter {
      static {
        __name(this, "ServerUnaryCallImpl");
      }
      constructor(path, call, metadata, request) {
        super();
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.cancelled = false;
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.path;
      }
      getHost() {
        return this.call.getHost();
      }
    };
    exports2.ServerUnaryCallImpl = ServerUnaryCallImpl;
    var ServerReadableStreamImpl = class ServerReadableStreamImpl extends stream_1.Readable {
      static {
        __name(this, "ServerReadableStreamImpl");
      }
      constructor(path, call, metadata) {
        super({
          objectMode: true
        });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.cancelled = false;
      }
      _read(size) {
        this.call.startRead();
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.path;
      }
      getHost() {
        return this.call.getHost();
      }
    };
    exports2.ServerReadableStreamImpl = ServerReadableStreamImpl;
    var ServerWritableStreamImpl = class ServerWritableStreamImpl extends stream_1.Writable {
      static {
        __name(this, "ServerWritableStreamImpl");
      }
      constructor(path, call, metadata, request) {
        super({
          objectMode: true
        });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.request = request;
        this.pendingStatus = {
          code: constants_1.Status.OK,
          details: "OK"
        };
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.on("error", (err) => {
          this.pendingStatus = serverErrorToStatus(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.path;
      }
      getHost() {
        return this.call.getHost();
      }
      _write(chunk, encoding, callback) {
        this.call.sendMessage(chunk, callback);
      }
      _final(callback) {
        var _a2;
        callback(null);
        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), {
          metadata: (_a2 = this.pendingStatus.metadata) !== null && _a2 !== void 0 ? _a2 : this.trailingMetadata
        }));
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        return super.end();
      }
    };
    exports2.ServerWritableStreamImpl = ServerWritableStreamImpl;
    var ServerDuplexStreamImpl = class ServerDuplexStreamImpl extends stream_1.Duplex {
      static {
        __name(this, "ServerDuplexStreamImpl");
      }
      constructor(path, call, metadata) {
        super({
          objectMode: true
        });
        this.path = path;
        this.call = call;
        this.metadata = metadata;
        this.pendingStatus = {
          code: constants_1.Status.OK,
          details: "OK"
        };
        this.cancelled = false;
        this.trailingMetadata = new metadata_1.Metadata();
        this.on("error", (err) => {
          this.pendingStatus = serverErrorToStatus(err);
          this.end();
        });
      }
      getPeer() {
        return this.call.getPeer();
      }
      sendMetadata(responseMetadata) {
        this.call.sendMetadata(responseMetadata);
      }
      getDeadline() {
        return this.call.getDeadline();
      }
      getPath() {
        return this.path;
      }
      getHost() {
        return this.call.getHost();
      }
      _read(size) {
        this.call.startRead();
      }
      _write(chunk, encoding, callback) {
        this.call.sendMessage(chunk, callback);
      }
      _final(callback) {
        var _a2;
        callback(null);
        this.call.sendStatus(Object.assign(Object.assign({}, this.pendingStatus), {
          metadata: (_a2 = this.pendingStatus.metadata) !== null && _a2 !== void 0 ? _a2 : this.trailingMetadata
        }));
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      end(metadata) {
        if (metadata) {
          this.trailingMetadata = metadata;
        }
        return super.end();
      }
    };
    exports2.ServerDuplexStreamImpl = ServerDuplexStreamImpl;
  }
});

// node_modules/@grpc/grpc-js/build/src/server-credentials.js
var require_server_credentials = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-credentials.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.ServerCredentials = void 0;
    exports2.createCertificateProviderServerCredentials = createCertificateProviderServerCredentials;
    exports2.createServerCredentialsWithInterceptors = createServerCredentialsWithInterceptors;
    var tls_helpers_1 = require_tls_helpers();
    var ServerCredentials = class ServerCredentials {
      static {
        __name(this, "ServerCredentials");
      }
      constructor() {
        this.watchers = /* @__PURE__ */ new Set();
        this.latestContextOptions = null;
      }
      _addWatcher(watcher) {
        this.watchers.add(watcher);
      }
      _removeWatcher(watcher) {
        this.watchers.delete(watcher);
      }
      getWatcherCount() {
        return this.watchers.size;
      }
      updateSecureContextOptions(options) {
        this.latestContextOptions = options;
        for (const watcher of this.watchers) {
          watcher(this.latestContextOptions);
        }
      }
      _getSettings() {
        return this.latestContextOptions;
      }
      _getInterceptors() {
        return [];
      }
      static createInsecure() {
        return new InsecureServerCredentials();
      }
      static createSsl(rootCerts, keyCertPairs, checkClientCertificate = false) {
        var _a2;
        if (rootCerts !== null && !Buffer.isBuffer(rootCerts)) {
          throw new TypeError("rootCerts must be null or a Buffer");
        }
        if (!Array.isArray(keyCertPairs)) {
          throw new TypeError("keyCertPairs must be an array");
        }
        if (typeof checkClientCertificate !== "boolean") {
          throw new TypeError("checkClientCertificate must be a boolean");
        }
        const cert = [];
        const key = [];
        for (let i = 0; i < keyCertPairs.length; i++) {
          const pair = keyCertPairs[i];
          if (pair === null || typeof pair !== "object") {
            throw new TypeError(`keyCertPair[${i}] must be an object`);
          }
          if (!Buffer.isBuffer(pair.private_key)) {
            throw new TypeError(`keyCertPair[${i}].private_key must be a Buffer`);
          }
          if (!Buffer.isBuffer(pair.cert_chain)) {
            throw new TypeError(`keyCertPair[${i}].cert_chain must be a Buffer`);
          }
          cert.push(pair.cert_chain);
          key.push(pair.private_key);
        }
        return new SecureServerCredentials({
          ca: (_a2 = rootCerts !== null && rootCerts !== void 0 ? rootCerts : (0, tls_helpers_1.getDefaultRootsData)()) !== null && _a2 !== void 0 ? _a2 : void 0,
          cert,
          key,
          requestCert: checkClientCertificate,
          ciphers: tls_helpers_1.CIPHER_SUITES
        });
      }
    };
    exports2.ServerCredentials = ServerCredentials;
    var InsecureServerCredentials = class InsecureServerCredentials2 extends ServerCredentials {
      static {
        __name(this, "InsecureServerCredentials");
      }
      _isSecure() {
        return false;
      }
      _getSettings() {
        return null;
      }
      _equals(other) {
        return other instanceof InsecureServerCredentials2;
      }
    };
    var SecureServerCredentials = class SecureServerCredentials2 extends ServerCredentials {
      static {
        __name(this, "SecureServerCredentials");
      }
      constructor(options) {
        super();
        this.options = options;
      }
      _isSecure() {
        return true;
      }
      _getSettings() {
        return this.options;
      }
      /**
       * Checks equality by checking the options that are actually set by
       * createSsl.
       * @param other
       * @returns
       */
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof SecureServerCredentials2)) {
          return false;
        }
        if (Buffer.isBuffer(this.options.ca) && Buffer.isBuffer(other.options.ca)) {
          if (!this.options.ca.equals(other.options.ca)) {
            return false;
          }
        } else {
          if (this.options.ca !== other.options.ca) {
            return false;
          }
        }
        if (Array.isArray(this.options.cert) && Array.isArray(other.options.cert)) {
          if (this.options.cert.length !== other.options.cert.length) {
            return false;
          }
          for (let i = 0; i < this.options.cert.length; i++) {
            const thisCert = this.options.cert[i];
            const otherCert = other.options.cert[i];
            if (Buffer.isBuffer(thisCert) && Buffer.isBuffer(otherCert)) {
              if (!thisCert.equals(otherCert)) {
                return false;
              }
            } else {
              if (thisCert !== otherCert) {
                return false;
              }
            }
          }
        } else {
          if (this.options.cert !== other.options.cert) {
            return false;
          }
        }
        if (Array.isArray(this.options.key) && Array.isArray(other.options.key)) {
          if (this.options.key.length !== other.options.key.length) {
            return false;
          }
          for (let i = 0; i < this.options.key.length; i++) {
            const thisKey = this.options.key[i];
            const otherKey = other.options.key[i];
            if (Buffer.isBuffer(thisKey) && Buffer.isBuffer(otherKey)) {
              if (!thisKey.equals(otherKey)) {
                return false;
              }
            } else {
              if (thisKey !== otherKey) {
                return false;
              }
            }
          }
        } else {
          if (this.options.key !== other.options.key) {
            return false;
          }
        }
        if (this.options.requestCert !== other.options.requestCert) {
          return false;
        }
        return true;
      }
    };
    var CertificateProviderServerCredentials = class CertificateProviderServerCredentials2 extends ServerCredentials {
      static {
        __name(this, "CertificateProviderServerCredentials");
      }
      constructor(identityCertificateProvider, caCertificateProvider, requireClientCertificate) {
        super();
        this.identityCertificateProvider = identityCertificateProvider;
        this.caCertificateProvider = caCertificateProvider;
        this.requireClientCertificate = requireClientCertificate;
        this.latestCaUpdate = null;
        this.latestIdentityUpdate = null;
        this.caCertificateUpdateListener = this.handleCaCertificateUpdate.bind(this);
        this.identityCertificateUpdateListener = this.handleIdentityCertitificateUpdate.bind(this);
      }
      _addWatcher(watcher) {
        var _a2;
        if (this.getWatcherCount() === 0) {
          (_a2 = this.caCertificateProvider) === null || _a2 === void 0 ? void 0 : _a2.addCaCertificateListener(this.caCertificateUpdateListener);
          this.identityCertificateProvider.addIdentityCertificateListener(this.identityCertificateUpdateListener);
        }
        super._addWatcher(watcher);
      }
      _removeWatcher(watcher) {
        var _a2;
        super._removeWatcher(watcher);
        if (this.getWatcherCount() === 0) {
          (_a2 = this.caCertificateProvider) === null || _a2 === void 0 ? void 0 : _a2.removeCaCertificateListener(this.caCertificateUpdateListener);
          this.identityCertificateProvider.removeIdentityCertificateListener(this.identityCertificateUpdateListener);
        }
      }
      _isSecure() {
        return true;
      }
      _equals(other) {
        if (this === other) {
          return true;
        }
        if (!(other instanceof CertificateProviderServerCredentials2)) {
          return false;
        }
        return this.caCertificateProvider === other.caCertificateProvider && this.identityCertificateProvider === other.identityCertificateProvider && this.requireClientCertificate === other.requireClientCertificate;
      }
      calculateSecureContextOptions() {
        var _a2;
        if (this.latestIdentityUpdate === null) {
          return null;
        }
        if (this.caCertificateProvider !== null && this.latestCaUpdate === null) {
          return null;
        }
        return {
          ca: (_a2 = this.latestCaUpdate) === null || _a2 === void 0 ? void 0 : _a2.caCertificate,
          cert: this.latestIdentityUpdate.certificate,
          key: this.latestIdentityUpdate.privateKey,
          requestCert: this.latestIdentityUpdate !== null,
          rejectUnauthorized: this.requireClientCertificate
        };
      }
      finalizeUpdate() {
        this.updateSecureContextOptions(this.calculateSecureContextOptions());
      }
      handleCaCertificateUpdate(update) {
        this.latestCaUpdate = update;
        this.finalizeUpdate();
      }
      handleIdentityCertitificateUpdate(update) {
        this.latestIdentityUpdate = update;
        this.finalizeUpdate();
      }
    };
    function createCertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate) {
      return new CertificateProviderServerCredentials(caCertificateProvider, identityCertificateProvider, requireClientCertificate);
    }
    __name(createCertificateProviderServerCredentials, "createCertificateProviderServerCredentials");
    var InterceptorServerCredentials = class InterceptorServerCredentials2 extends ServerCredentials {
      static {
        __name(this, "InterceptorServerCredentials");
      }
      constructor(childCredentials, interceptors) {
        super();
        this.childCredentials = childCredentials;
        this.interceptors = interceptors;
      }
      _isSecure() {
        return this.childCredentials._isSecure();
      }
      _equals(other) {
        if (!(other instanceof InterceptorServerCredentials2)) {
          return false;
        }
        if (!this.childCredentials._equals(other.childCredentials)) {
          return false;
        }
        if (this.interceptors.length !== other.interceptors.length) {
          return false;
        }
        for (let i = 0; i < this.interceptors.length; i++) {
          if (this.interceptors[i] !== other.interceptors[i]) {
            return false;
          }
        }
        return true;
      }
      _getInterceptors() {
        return this.interceptors;
      }
      _addWatcher(watcher) {
        this.childCredentials._addWatcher(watcher);
      }
      _removeWatcher(watcher) {
        this.childCredentials._removeWatcher(watcher);
      }
    };
    function createServerCredentialsWithInterceptors(credentials, interceptors) {
      return new InterceptorServerCredentials(credentials, interceptors);
    }
    __name(createServerCredentialsWithInterceptors, "createServerCredentialsWithInterceptors");
  }
});

// node_modules/@grpc/grpc-js/build/src/server-interceptors.js
var require_server_interceptors = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server-interceptors.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.BaseServerInterceptingCall = exports2.ServerInterceptingCall = exports2.ResponderBuilder = exports2.ServerListenerBuilder = void 0;
    exports2.isInterceptingServerListener = isInterceptingServerListener;
    exports2.getServerInterceptingCall = getServerInterceptingCall;
    var metadata_1 = require_metadata2();
    var constants_1 = require_constants3();
    var http2 = require("http2");
    var error_1 = require_error();
    var zlib = require("zlib");
    var stream_decoder_1 = require_stream_decoder();
    var logging = require_logging();
    var TRACER_NAME = "server_call";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    var ServerListenerBuilder = class ServerListenerBuilder {
      static {
        __name(this, "ServerListenerBuilder");
      }
      constructor() {
        this.metadata = void 0;
        this.message = void 0;
        this.halfClose = void 0;
        this.cancel = void 0;
      }
      withOnReceiveMetadata(onReceiveMetadata) {
        this.metadata = onReceiveMetadata;
        return this;
      }
      withOnReceiveMessage(onReceiveMessage) {
        this.message = onReceiveMessage;
        return this;
      }
      withOnReceiveHalfClose(onReceiveHalfClose) {
        this.halfClose = onReceiveHalfClose;
        return this;
      }
      withOnCancel(onCancel) {
        this.cancel = onCancel;
        return this;
      }
      build() {
        return {
          onReceiveMetadata: this.metadata,
          onReceiveMessage: this.message,
          onReceiveHalfClose: this.halfClose,
          onCancel: this.cancel
        };
      }
    };
    exports2.ServerListenerBuilder = ServerListenerBuilder;
    function isInterceptingServerListener(listener) {
      return listener.onReceiveMetadata !== void 0 && listener.onReceiveMetadata.length === 1;
    }
    __name(isInterceptingServerListener, "isInterceptingServerListener");
    var InterceptingServerListenerImpl = class InterceptingServerListenerImpl {
      static {
        __name(this, "InterceptingServerListenerImpl");
      }
      constructor(listener, nextListener) {
        this.listener = listener;
        this.nextListener = nextListener;
        this.cancelled = false;
        this.processingMetadata = false;
        this.hasPendingMessage = false;
        this.pendingMessage = null;
        this.processingMessage = false;
        this.hasPendingHalfClose = false;
      }
      processPendingMessage() {
        if (this.hasPendingMessage) {
          this.nextListener.onReceiveMessage(this.pendingMessage);
          this.pendingMessage = null;
          this.hasPendingMessage = false;
        }
      }
      processPendingHalfClose() {
        if (this.hasPendingHalfClose) {
          this.nextListener.onReceiveHalfClose();
          this.hasPendingHalfClose = false;
        }
      }
      onReceiveMetadata(metadata) {
        if (this.cancelled) {
          return;
        }
        this.processingMetadata = true;
        this.listener.onReceiveMetadata(metadata, (interceptedMetadata) => {
          this.processingMetadata = false;
          if (this.cancelled) {
            return;
          }
          this.nextListener.onReceiveMetadata(interceptedMetadata);
          this.processPendingMessage();
          this.processPendingHalfClose();
        });
      }
      onReceiveMessage(message) {
        if (this.cancelled) {
          return;
        }
        this.processingMessage = true;
        this.listener.onReceiveMessage(message, (msg) => {
          this.processingMessage = false;
          if (this.cancelled) {
            return;
          }
          if (this.processingMetadata) {
            this.pendingMessage = msg;
            this.hasPendingMessage = true;
          } else {
            this.nextListener.onReceiveMessage(msg);
            this.processPendingHalfClose();
          }
        });
      }
      onReceiveHalfClose() {
        if (this.cancelled) {
          return;
        }
        this.listener.onReceiveHalfClose(() => {
          if (this.cancelled) {
            return;
          }
          if (this.processingMetadata || this.processingMessage) {
            this.hasPendingHalfClose = true;
          } else {
            this.nextListener.onReceiveHalfClose();
          }
        });
      }
      onCancel() {
        this.cancelled = true;
        this.listener.onCancel();
        this.nextListener.onCancel();
      }
    };
    var ResponderBuilder = class ResponderBuilder {
      static {
        __name(this, "ResponderBuilder");
      }
      constructor() {
        this.start = void 0;
        this.metadata = void 0;
        this.message = void 0;
        this.status = void 0;
      }
      withStart(start) {
        this.start = start;
        return this;
      }
      withSendMetadata(sendMetadata) {
        this.metadata = sendMetadata;
        return this;
      }
      withSendMessage(sendMessage) {
        this.message = sendMessage;
        return this;
      }
      withSendStatus(sendStatus) {
        this.status = sendStatus;
        return this;
      }
      build() {
        return {
          start: this.start,
          sendMetadata: this.metadata,
          sendMessage: this.message,
          sendStatus: this.status
        };
      }
    };
    exports2.ResponderBuilder = ResponderBuilder;
    var defaultServerListener = {
      onReceiveMetadata: /* @__PURE__ */ __name((metadata, next) => {
        next(metadata);
      }, "onReceiveMetadata"),
      onReceiveMessage: /* @__PURE__ */ __name((message, next) => {
        next(message);
      }, "onReceiveMessage"),
      onReceiveHalfClose: /* @__PURE__ */ __name((next) => {
        next();
      }, "onReceiveHalfClose"),
      onCancel: /* @__PURE__ */ __name(() => {
      }, "onCancel")
    };
    var defaultResponder = {
      start: /* @__PURE__ */ __name((next) => {
        next();
      }, "start"),
      sendMetadata: /* @__PURE__ */ __name((metadata, next) => {
        next(metadata);
      }, "sendMetadata"),
      sendMessage: /* @__PURE__ */ __name((message, next) => {
        next(message);
      }, "sendMessage"),
      sendStatus: /* @__PURE__ */ __name((status, next) => {
        next(status);
      }, "sendStatus")
    };
    var ServerInterceptingCall = class ServerInterceptingCall {
      static {
        __name(this, "ServerInterceptingCall");
      }
      constructor(nextCall, responder) {
        var _a2, _b2, _c2, _d;
        this.nextCall = nextCall;
        this.processingMetadata = false;
        this.processingMessage = false;
        this.pendingMessage = null;
        this.pendingMessageCallback = null;
        this.pendingStatus = null;
        this.responder = {
          start: (_a2 = responder === null || responder === void 0 ? void 0 : responder.start) !== null && _a2 !== void 0 ? _a2 : defaultResponder.start,
          sendMetadata: (_b2 = responder === null || responder === void 0 ? void 0 : responder.sendMetadata) !== null && _b2 !== void 0 ? _b2 : defaultResponder.sendMetadata,
          sendMessage: (_c2 = responder === null || responder === void 0 ? void 0 : responder.sendMessage) !== null && _c2 !== void 0 ? _c2 : defaultResponder.sendMessage,
          sendStatus: (_d = responder === null || responder === void 0 ? void 0 : responder.sendStatus) !== null && _d !== void 0 ? _d : defaultResponder.sendStatus
        };
      }
      processPendingMessage() {
        if (this.pendingMessageCallback) {
          this.nextCall.sendMessage(this.pendingMessage, this.pendingMessageCallback);
          this.pendingMessage = null;
          this.pendingMessageCallback = null;
        }
      }
      processPendingStatus() {
        if (this.pendingStatus) {
          this.nextCall.sendStatus(this.pendingStatus);
          this.pendingStatus = null;
        }
      }
      start(listener) {
        this.responder.start((interceptedListener) => {
          var _a2, _b2, _c2, _d;
          const fullInterceptedListener = {
            onReceiveMetadata: (_a2 = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMetadata) !== null && _a2 !== void 0 ? _a2 : defaultServerListener.onReceiveMetadata,
            onReceiveMessage: (_b2 = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveMessage) !== null && _b2 !== void 0 ? _b2 : defaultServerListener.onReceiveMessage,
            onReceiveHalfClose: (_c2 = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onReceiveHalfClose) !== null && _c2 !== void 0 ? _c2 : defaultServerListener.onReceiveHalfClose,
            onCancel: (_d = interceptedListener === null || interceptedListener === void 0 ? void 0 : interceptedListener.onCancel) !== null && _d !== void 0 ? _d : defaultServerListener.onCancel
          };
          const finalInterceptingListener = new InterceptingServerListenerImpl(fullInterceptedListener, listener);
          this.nextCall.start(finalInterceptingListener);
        });
      }
      sendMetadata(metadata) {
        this.processingMetadata = true;
        this.responder.sendMetadata(metadata, (interceptedMetadata) => {
          this.processingMetadata = false;
          this.nextCall.sendMetadata(interceptedMetadata);
          this.processPendingMessage();
          this.processPendingStatus();
        });
      }
      sendMessage(message, callback) {
        this.processingMessage = true;
        this.responder.sendMessage(message, (interceptedMessage) => {
          this.processingMessage = false;
          if (this.processingMetadata) {
            this.pendingMessage = interceptedMessage;
            this.pendingMessageCallback = callback;
          } else {
            this.nextCall.sendMessage(interceptedMessage, callback);
          }
        });
      }
      sendStatus(status) {
        this.responder.sendStatus(status, (interceptedStatus) => {
          if (this.processingMetadata || this.processingMessage) {
            this.pendingStatus = interceptedStatus;
          } else {
            this.nextCall.sendStatus(interceptedStatus);
          }
        });
      }
      startRead() {
        this.nextCall.startRead();
      }
      getPeer() {
        return this.nextCall.getPeer();
      }
      getDeadline() {
        return this.nextCall.getDeadline();
      }
      getHost() {
        return this.nextCall.getHost();
      }
    };
    exports2.ServerInterceptingCall = ServerInterceptingCall;
    var GRPC_ACCEPT_ENCODING_HEADER = "grpc-accept-encoding";
    var GRPC_ENCODING_HEADER = "grpc-encoding";
    var GRPC_MESSAGE_HEADER = "grpc-message";
    var GRPC_STATUS_HEADER = "grpc-status";
    var GRPC_TIMEOUT_HEADER = "grpc-timeout";
    var DEADLINE_REGEX = /(\d{1,8})\s*([HMSmun])/;
    var deadlineUnitsToMs = {
      H: 36e5,
      M: 6e4,
      S: 1e3,
      m: 1,
      u: 1e-3,
      n: 1e-6
    };
    var defaultCompressionHeaders = {
      // TODO(cjihrig): Remove these encoding headers from the default response
      // once compression is integrated.
      [GRPC_ACCEPT_ENCODING_HEADER]: "identity,deflate,gzip",
      [GRPC_ENCODING_HEADER]: "identity"
    };
    var defaultResponseHeaders = {
      [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
      [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
    };
    var defaultResponseOptions = {
      waitForTrailers: true
    };
    var BaseServerInterceptingCall = class BaseServerInterceptingCall {
      static {
        __name(this, "BaseServerInterceptingCall");
      }
      constructor(stream, headers, callEventTracker, handler, options) {
        var _a2;
        this.stream = stream;
        this.callEventTracker = callEventTracker;
        this.handler = handler;
        this.listener = null;
        this.deadlineTimer = null;
        this.deadline = Infinity;
        this.maxSendMessageSize = constants_1.DEFAULT_MAX_SEND_MESSAGE_LENGTH;
        this.maxReceiveMessageSize = constants_1.DEFAULT_MAX_RECEIVE_MESSAGE_LENGTH;
        this.cancelled = false;
        this.metadataSent = false;
        this.wantTrailers = false;
        this.cancelNotified = false;
        this.incomingEncoding = "identity";
        this.readQueue = [];
        this.isReadPending = false;
        this.receivedHalfClose = false;
        this.streamEnded = false;
        this.stream.once("error", (err) => {
        });
        this.stream.once("close", () => {
          var _a3;
          trace("Request to method " + ((_a3 = this.handler) === null || _a3 === void 0 ? void 0 : _a3.path) + " stream closed with rstCode " + this.stream.rstCode);
          if (this.callEventTracker && !this.streamEnded) {
            this.streamEnded = true;
            this.callEventTracker.onStreamEnd(false);
            this.callEventTracker.onCallEnd({
              code: constants_1.Status.CANCELLED,
              details: "Stream closed before sending status",
              metadata: null
            });
          }
          this.notifyOnCancel();
        });
        this.stream.on("data", (data) => {
          this.handleDataFrame(data);
        });
        this.stream.pause();
        this.stream.on("end", () => {
          this.handleEndEvent();
        });
        if ("grpc.max_send_message_length" in options) {
          this.maxSendMessageSize = options["grpc.max_send_message_length"];
        }
        if ("grpc.max_receive_message_length" in options) {
          this.maxReceiveMessageSize = options["grpc.max_receive_message_length"];
        }
        this.host = (_a2 = headers[":authority"]) !== null && _a2 !== void 0 ? _a2 : headers.host;
        this.decoder = new stream_decoder_1.StreamDecoder(this.maxReceiveMessageSize);
        const metadata = metadata_1.Metadata.fromHttp2Headers(headers);
        if (logging.isTracerEnabled(TRACER_NAME)) {
          trace("Request to " + this.handler.path + " received headers " + JSON.stringify(metadata.toJSON()));
        }
        const timeoutHeader = metadata.get(GRPC_TIMEOUT_HEADER);
        if (timeoutHeader.length > 0) {
          this.handleTimeoutHeader(timeoutHeader[0]);
        }
        const encodingHeader = metadata.get(GRPC_ENCODING_HEADER);
        if (encodingHeader.length > 0) {
          this.incomingEncoding = encodingHeader[0];
        }
        metadata.remove(GRPC_TIMEOUT_HEADER);
        metadata.remove(GRPC_ENCODING_HEADER);
        metadata.remove(GRPC_ACCEPT_ENCODING_HEADER);
        metadata.remove(http2.constants.HTTP2_HEADER_ACCEPT_ENCODING);
        metadata.remove(http2.constants.HTTP2_HEADER_TE);
        metadata.remove(http2.constants.HTTP2_HEADER_CONTENT_TYPE);
        this.metadata = metadata;
      }
      handleTimeoutHeader(timeoutHeader) {
        const match = timeoutHeader.toString().match(DEADLINE_REGEX);
        if (match === null) {
          const status = {
            code: constants_1.Status.INTERNAL,
            details: `Invalid ${GRPC_TIMEOUT_HEADER} value "${timeoutHeader}"`,
            metadata: null
          };
          process.nextTick(() => {
            this.sendStatus(status);
          });
          return;
        }
        const timeout = +match[1] * deadlineUnitsToMs[match[2]] | 0;
        const now = /* @__PURE__ */ new Date();
        this.deadline = now.setMilliseconds(now.getMilliseconds() + timeout);
        this.deadlineTimer = setTimeout(() => {
          const status = {
            code: constants_1.Status.DEADLINE_EXCEEDED,
            details: "Deadline exceeded",
            metadata: null
          };
          this.sendStatus(status);
        }, timeout);
      }
      checkCancelled() {
        if (!this.cancelled && (this.stream.destroyed || this.stream.closed)) {
          this.notifyOnCancel();
          this.cancelled = true;
        }
        return this.cancelled;
      }
      notifyOnCancel() {
        if (this.cancelNotified) {
          return;
        }
        this.cancelNotified = true;
        this.cancelled = true;
        process.nextTick(() => {
          var _a2;
          (_a2 = this.listener) === null || _a2 === void 0 ? void 0 : _a2.onCancel();
        });
        if (this.deadlineTimer) {
          clearTimeout(this.deadlineTimer);
        }
        this.stream.resume();
      }
      /**
       * A server handler can start sending messages without explicitly sending
       * metadata. In that case, we need to send headers before sending any
       * messages. This function does that if necessary.
       */
      maybeSendMetadata() {
        if (!this.metadataSent) {
          this.sendMetadata(new metadata_1.Metadata());
        }
      }
      /**
       * Serialize a message to a length-delimited byte string.
       * @param value
       * @returns
       */
      serializeMessage(value2) {
        const messageBuffer = this.handler.serialize(value2);
        const byteLength2 = messageBuffer.byteLength;
        const output = Buffer.allocUnsafe(byteLength2 + 5);
        output.writeUInt8(0, 0);
        output.writeUInt32BE(byteLength2, 1);
        messageBuffer.copy(output, 5);
        return output;
      }
      decompressMessage(message, encoding) {
        const messageContents = message.subarray(5);
        if (encoding === "identity") {
          return messageContents;
        } else if (encoding === "deflate" || encoding === "gzip") {
          let decompresser;
          if (encoding === "deflate") {
            decompresser = zlib.createInflate();
          } else {
            decompresser = zlib.createGunzip();
          }
          return new Promise((resolve5, reject) => {
            let totalLength2 = 0;
            const messageParts = [];
            decompresser.on("data", (chunk) => {
              messageParts.push(chunk);
              totalLength2 += chunk.byteLength;
              if (this.maxReceiveMessageSize !== -1 && totalLength2 > this.maxReceiveMessageSize) {
                decompresser.destroy();
                reject({
                  code: constants_1.Status.RESOURCE_EXHAUSTED,
                  details: `Received message that decompresses to a size larger than ${this.maxReceiveMessageSize}`
                });
              }
            });
            decompresser.on("end", () => {
              resolve5(Buffer.concat(messageParts));
            });
            decompresser.write(messageContents);
            decompresser.end();
          });
        } else {
          return Promise.reject({
            code: constants_1.Status.UNIMPLEMENTED,
            details: `Received message compressed with unsupported encoding "${encoding}"`
          });
        }
      }
      async decompressAndMaybePush(queueEntry) {
        if (queueEntry.type !== "COMPRESSED") {
          throw new Error(`Invalid queue entry type: ${queueEntry.type}`);
        }
        const compressed = queueEntry.compressedMessage.readUInt8(0) === 1;
        const compressedMessageEncoding = compressed ? this.incomingEncoding : "identity";
        let decompressedMessage;
        try {
          decompressedMessage = await this.decompressMessage(queueEntry.compressedMessage, compressedMessageEncoding);
        } catch (err) {
          this.sendStatus(err);
          return;
        }
        try {
          queueEntry.parsedMessage = this.handler.deserialize(decompressedMessage);
        } catch (err) {
          this.sendStatus({
            code: constants_1.Status.INTERNAL,
            details: `Error deserializing request: ${err.message}`
          });
          return;
        }
        queueEntry.type = "READABLE";
        this.maybePushNextMessage();
      }
      maybePushNextMessage() {
        if (this.listener && this.isReadPending && this.readQueue.length > 0 && this.readQueue[0].type !== "COMPRESSED") {
          this.isReadPending = false;
          const nextQueueEntry = this.readQueue.shift();
          if (nextQueueEntry.type === "READABLE") {
            this.listener.onReceiveMessage(nextQueueEntry.parsedMessage);
          } else {
            this.listener.onReceiveHalfClose();
          }
        }
      }
      handleDataFrame(data) {
        var _a2;
        if (this.checkCancelled()) {
          return;
        }
        trace("Request to " + this.handler.path + " received data frame of size " + data.length);
        let rawMessages;
        try {
          rawMessages = this.decoder.write(data);
        } catch (e) {
          this.sendStatus({
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: e.message
          });
          return;
        }
        for (const messageBytes of rawMessages) {
          this.stream.pause();
          const queueEntry = {
            type: "COMPRESSED",
            compressedMessage: messageBytes,
            parsedMessage: null
          };
          this.readQueue.push(queueEntry);
          this.decompressAndMaybePush(queueEntry);
          (_a2 = this.callEventTracker) === null || _a2 === void 0 ? void 0 : _a2.addMessageReceived();
        }
      }
      handleEndEvent() {
        this.readQueue.push({
          type: "HALF_CLOSE",
          compressedMessage: null,
          parsedMessage: null
        });
        this.receivedHalfClose = true;
        this.maybePushNextMessage();
      }
      start(listener) {
        trace("Request to " + this.handler.path + " start called");
        if (this.checkCancelled()) {
          return;
        }
        this.listener = listener;
        listener.onReceiveMetadata(this.metadata);
      }
      sendMetadata(metadata) {
        if (this.checkCancelled()) {
          return;
        }
        if (this.metadataSent) {
          return;
        }
        this.metadataSent = true;
        const custom2 = metadata ? metadata.toHttp2Headers() : null;
        const headers = Object.assign(Object.assign(Object.assign({}, defaultResponseHeaders), defaultCompressionHeaders), custom2);
        this.stream.respond(headers, defaultResponseOptions);
      }
      sendMessage(message, callback) {
        if (this.checkCancelled()) {
          return;
        }
        let response;
        try {
          response = this.serializeMessage(message);
        } catch (e) {
          this.sendStatus({
            code: constants_1.Status.INTERNAL,
            details: `Error serializing response: ${(0, error_1.getErrorMessage)(e)}`,
            metadata: null
          });
          return;
        }
        if (this.maxSendMessageSize !== -1 && response.length - 5 > this.maxSendMessageSize) {
          this.sendStatus({
            code: constants_1.Status.RESOURCE_EXHAUSTED,
            details: `Sent message larger than max (${response.length} vs. ${this.maxSendMessageSize})`,
            metadata: null
          });
          return;
        }
        this.maybeSendMetadata();
        trace("Request to " + this.handler.path + " sent data frame of size " + response.length);
        this.stream.write(response, (error) => {
          var _a2;
          if (error) {
            this.sendStatus({
              code: constants_1.Status.INTERNAL,
              details: `Error writing message: ${(0, error_1.getErrorMessage)(error)}`,
              metadata: null
            });
            return;
          }
          (_a2 = this.callEventTracker) === null || _a2 === void 0 ? void 0 : _a2.addMessageSent();
          callback();
        });
      }
      sendStatus(status) {
        var _a2, _b2;
        if (this.checkCancelled()) {
          return;
        }
        trace("Request to method " + ((_a2 = this.handler) === null || _a2 === void 0 ? void 0 : _a2.path) + " ended with status code: " + constants_1.Status[status.code] + " details: " + status.details);
        if (this.metadataSent) {
          if (!this.wantTrailers) {
            this.wantTrailers = true;
            this.stream.once("wantTrailers", () => {
              var _a3;
              if (this.callEventTracker && !this.streamEnded) {
                this.streamEnded = true;
                this.callEventTracker.onStreamEnd(true);
                this.callEventTracker.onCallEnd(status);
              }
              const trailersToSend = Object.assign({
                [GRPC_STATUS_HEADER]: status.code,
                [GRPC_MESSAGE_HEADER]: encodeURI(status.details)
              }, (_a3 = status.metadata) === null || _a3 === void 0 ? void 0 : _a3.toHttp2Headers());
              this.stream.sendTrailers(trailersToSend);
              this.notifyOnCancel();
            });
            this.stream.end();
          } else {
            this.notifyOnCancel();
          }
        } else {
          if (this.callEventTracker && !this.streamEnded) {
            this.streamEnded = true;
            this.callEventTracker.onStreamEnd(true);
            this.callEventTracker.onCallEnd(status);
          }
          const trailersToSend = Object.assign(Object.assign({
            [GRPC_STATUS_HEADER]: status.code,
            [GRPC_MESSAGE_HEADER]: encodeURI(status.details)
          }, defaultResponseHeaders), (_b2 = status.metadata) === null || _b2 === void 0 ? void 0 : _b2.toHttp2Headers());
          this.stream.respond(trailersToSend, {
            endStream: true
          });
          this.notifyOnCancel();
        }
      }
      startRead() {
        trace("Request to " + this.handler.path + " startRead called");
        if (this.checkCancelled()) {
          return;
        }
        this.isReadPending = true;
        if (this.readQueue.length === 0) {
          if (!this.receivedHalfClose) {
            this.stream.resume();
          }
        } else {
          this.maybePushNextMessage();
        }
      }
      getPeer() {
        var _a2;
        const socket = (_a2 = this.stream.session) === null || _a2 === void 0 ? void 0 : _a2.socket;
        if (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) {
          if (socket.remotePort) {
            return `${socket.remoteAddress}:${socket.remotePort}`;
          } else {
            return socket.remoteAddress;
          }
        } else {
          return "unknown";
        }
      }
      getDeadline() {
        return this.deadline;
      }
      getHost() {
        return this.host;
      }
    };
    exports2.BaseServerInterceptingCall = BaseServerInterceptingCall;
    function getServerInterceptingCall(interceptors, stream, headers, callEventTracker, handler, options) {
      const methodDefinition = {
        path: handler.path,
        requestStream: handler.type === "clientStream" || handler.type === "bidi",
        responseStream: handler.type === "serverStream" || handler.type === "bidi",
        requestDeserialize: handler.deserialize,
        responseSerialize: handler.serialize
      };
      const baseCall = new BaseServerInterceptingCall(stream, headers, callEventTracker, handler, options);
      return interceptors.reduce((call, interceptor) => {
        return interceptor(methodDefinition, call);
      }, baseCall);
    }
    __name(getServerInterceptingCall, "getServerInterceptingCall");
  }
});

// node_modules/@grpc/grpc-js/build/src/server.js
var require_server2 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/server.js"(exports2) {
    "use strict";
    var __runInitializers = exports2 && exports2.__runInitializers || function(thisArg, initializers, value2) {
      var useValue = arguments.length > 2;
      for (var i = 0; i < initializers.length; i++) {
        value2 = useValue ? initializers[i].call(thisArg, value2) : initializers[i].call(thisArg);
      }
      return useValue ? value2 : void 0;
    };
    var __esDecorate = exports2 && exports2.__esDecorate || function(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {
      function accept(f) {
        if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected");
        return f;
      }
      __name(accept, "accept");
      var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";
      var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;
      var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});
      var _, done = false;
      for (var i = decorators.length - 1; i >= 0; i--) {
        var context = {};
        for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];
        for (var p in contextIn.access) context.access[p] = contextIn.access[p];
        context.addInitializer = function(f) {
          if (done) throw new TypeError("Cannot add initializers after decoration has completed");
          extraInitializers.push(accept(f || null));
        };
        var result2 = (0, decorators[i])(kind === "accessor" ? {
          get: descriptor.get,
          set: descriptor.set
        } : descriptor[key], context);
        if (kind === "accessor") {
          if (result2 === void 0) continue;
          if (result2 === null || typeof result2 !== "object") throw new TypeError("Object expected");
          if (_ = accept(result2.get)) descriptor.get = _;
          if (_ = accept(result2.set)) descriptor.set = _;
          if (_ = accept(result2.init)) initializers.unshift(_);
        } else if (_ = accept(result2)) {
          if (kind === "field") initializers.unshift(_);
          else descriptor[key] = _;
        }
      }
      if (target) Object.defineProperty(target, contextIn.name, descriptor);
      done = true;
    };
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.Server = void 0;
    var http2 = require("http2");
    var util2 = require("util");
    var constants_1 = require_constants3();
    var server_call_1 = require_server_call();
    var server_credentials_1 = require_server_credentials();
    var resolver_1 = require_resolver();
    var logging = require_logging();
    var subchannel_address_1 = require_subchannel_address();
    var uri_parser_1 = require_uri_parser();
    var channelz_1 = require_channelz();
    var server_interceptors_1 = require_server_interceptors();
    var UNLIMITED_CONNECTION_AGE_MS = ~(1 << 31);
    var KEEPALIVE_MAX_TIME_MS = ~(1 << 31);
    var KEEPALIVE_TIMEOUT_MS = 2e4;
    var MAX_CONNECTION_IDLE_MS = ~(1 << 31);
    var { HTTP2_HEADER_PATH } = http2.constants;
    var TRACER_NAME = "server";
    var kMaxAge = Buffer.from("max_age");
    function noop() {
    }
    __name(noop, "noop");
    function deprecate(message) {
      return function(target, context) {
        return util2.deprecate(target, message);
      };
    }
    __name(deprecate, "deprecate");
    function getUnimplementedStatusResponse(methodName) {
      return {
        code: constants_1.Status.UNIMPLEMENTED,
        details: `The server does not implement the method ${methodName}`
      };
    }
    __name(getUnimplementedStatusResponse, "getUnimplementedStatusResponse");
    function getDefaultHandler(handlerType, methodName) {
      const unimplementedStatusResponse = getUnimplementedStatusResponse(methodName);
      switch (handlerType) {
        case "unary":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "clientStream":
          return (call, callback) => {
            callback(unimplementedStatusResponse, null);
          };
        case "serverStream":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        case "bidi":
          return (call) => {
            call.emit("error", unimplementedStatusResponse);
          };
        default:
          throw new Error(`Invalid handlerType ${handlerType}`);
      }
    }
    __name(getDefaultHandler, "getDefaultHandler");
    var Server = (() => {
      var _a2;
      let _instanceExtraInitializers = [];
      let _start_decorators;
      return _a2 = class Server {
        static {
          __name(this, "Server");
        }
        constructor(options) {
          var _b2, _c2, _d, _e, _f, _g;
          this.boundPorts = (__runInitializers(this, _instanceExtraInitializers), /* @__PURE__ */ new Map());
          this.http2Servers = /* @__PURE__ */ new Map();
          this.sessionIdleTimeouts = /* @__PURE__ */ new Map();
          this.handlers = /* @__PURE__ */ new Map();
          this.sessions = /* @__PURE__ */ new Map();
          this.started = false;
          this.shutdown = false;
          this.serverAddressString = "null";
          this.channelzEnabled = true;
          this.options = options !== null && options !== void 0 ? options : {};
          if (this.options["grpc.enable_channelz"] === 0) {
            this.channelzEnabled = false;
            this.channelzTrace = new channelz_1.ChannelzTraceStub();
            this.callTracker = new channelz_1.ChannelzCallTrackerStub();
            this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
            this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTrackerStub();
          } else {
            this.channelzTrace = new channelz_1.ChannelzTrace();
            this.callTracker = new channelz_1.ChannelzCallTracker();
            this.listenerChildrenTracker = new channelz_1.ChannelzChildrenTracker();
            this.sessionChildrenTracker = new channelz_1.ChannelzChildrenTracker();
          }
          this.channelzRef = (0, channelz_1.registerChannelzServer)("server", () => this.getChannelzInfo(), this.channelzEnabled);
          this.channelzTrace.addTrace("CT_INFO", "Server created");
          this.maxConnectionAgeMs = (_b2 = this.options["grpc.max_connection_age_ms"]) !== null && _b2 !== void 0 ? _b2 : UNLIMITED_CONNECTION_AGE_MS;
          this.maxConnectionAgeGraceMs = (_c2 = this.options["grpc.max_connection_age_grace_ms"]) !== null && _c2 !== void 0 ? _c2 : UNLIMITED_CONNECTION_AGE_MS;
          this.keepaliveTimeMs = (_d = this.options["grpc.keepalive_time_ms"]) !== null && _d !== void 0 ? _d : KEEPALIVE_MAX_TIME_MS;
          this.keepaliveTimeoutMs = (_e = this.options["grpc.keepalive_timeout_ms"]) !== null && _e !== void 0 ? _e : KEEPALIVE_TIMEOUT_MS;
          this.sessionIdleTimeout = (_f = this.options["grpc.max_connection_idle_ms"]) !== null && _f !== void 0 ? _f : MAX_CONNECTION_IDLE_MS;
          this.commonServerOptions = {
            maxSendHeaderBlockLength: Number.MAX_SAFE_INTEGER
          };
          if ("grpc-node.max_session_memory" in this.options) {
            this.commonServerOptions.maxSessionMemory = this.options["grpc-node.max_session_memory"];
          } else {
            this.commonServerOptions.maxSessionMemory = Number.MAX_SAFE_INTEGER;
          }
          if ("grpc.max_concurrent_streams" in this.options) {
            this.commonServerOptions.settings = {
              maxConcurrentStreams: this.options["grpc.max_concurrent_streams"]
            };
          }
          this.interceptors = (_g = this.options.interceptors) !== null && _g !== void 0 ? _g : [];
          this.trace("Server constructed");
        }
        getChannelzInfo() {
          return {
            trace: this.channelzTrace,
            callTracker: this.callTracker,
            listenerChildren: this.listenerChildrenTracker.getChildLists(),
            sessionChildren: this.sessionChildrenTracker.getChildLists()
          };
        }
        getChannelzSessionInfo(session) {
          var _b2, _c2, _d;
          const sessionInfo = this.sessions.get(session);
          const sessionSocket = session.socket;
          const remoteAddress = sessionSocket.remoteAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.remoteAddress, sessionSocket.remotePort) : null;
          const localAddress = sessionSocket.localAddress ? (0, subchannel_address_1.stringToSubchannelAddress)(sessionSocket.localAddress, sessionSocket.localPort) : null;
          let tlsInfo;
          if (session.encrypted) {
            const tlsSocket = sessionSocket;
            const cipherInfo = tlsSocket.getCipher();
            const certificate = tlsSocket.getCertificate();
            const peerCertificate = tlsSocket.getPeerCertificate();
            tlsInfo = {
              cipherSuiteStandardName: (_b2 = cipherInfo.standardName) !== null && _b2 !== void 0 ? _b2 : null,
              cipherSuiteOtherName: cipherInfo.standardName ? null : cipherInfo.name,
              localCertificate: certificate && "raw" in certificate ? certificate.raw : null,
              remoteCertificate: peerCertificate && "raw" in peerCertificate ? peerCertificate.raw : null
            };
          } else {
            tlsInfo = null;
          }
          const socketInfo = {
            remoteAddress,
            localAddress,
            security: tlsInfo,
            remoteName: null,
            streamsStarted: sessionInfo.streamTracker.callsStarted,
            streamsSucceeded: sessionInfo.streamTracker.callsSucceeded,
            streamsFailed: sessionInfo.streamTracker.callsFailed,
            messagesSent: sessionInfo.messagesSent,
            messagesReceived: sessionInfo.messagesReceived,
            keepAlivesSent: sessionInfo.keepAlivesSent,
            lastLocalStreamCreatedTimestamp: null,
            lastRemoteStreamCreatedTimestamp: sessionInfo.streamTracker.lastCallStartedTimestamp,
            lastMessageSentTimestamp: sessionInfo.lastMessageSentTimestamp,
            lastMessageReceivedTimestamp: sessionInfo.lastMessageReceivedTimestamp,
            localFlowControlWindow: (_c2 = session.state.localWindowSize) !== null && _c2 !== void 0 ? _c2 : null,
            remoteFlowControlWindow: (_d = session.state.remoteWindowSize) !== null && _d !== void 0 ? _d : null
          };
          return socketInfo;
        }
        trace(text) {
          logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, "(" + this.channelzRef.id + ") " + text);
        }
        keepaliveTrace(text) {
          logging.trace(constants_1.LogVerbosity.DEBUG, "keepalive", "(" + this.channelzRef.id + ") " + text);
        }
        addProtoService() {
          throw new Error("Not implemented. Use addService() instead");
        }
        addService(service, implementation) {
          if (service === null || typeof service !== "object" || implementation === null || typeof implementation !== "object") {
            throw new Error("addService() requires two objects as arguments");
          }
          const serviceKeys = Object.keys(service);
          if (serviceKeys.length === 0) {
            throw new Error("Cannot add an empty service to a server");
          }
          serviceKeys.forEach((name) => {
            const attrs = service[name];
            let methodType;
            if (attrs.requestStream) {
              if (attrs.responseStream) {
                methodType = "bidi";
              } else {
                methodType = "clientStream";
              }
            } else {
              if (attrs.responseStream) {
                methodType = "serverStream";
              } else {
                methodType = "unary";
              }
            }
            let implFn = implementation[name];
            let impl;
            if (implFn === void 0 && typeof attrs.originalName === "string") {
              implFn = implementation[attrs.originalName];
            }
            if (implFn !== void 0) {
              impl = implFn.bind(implementation);
            } else {
              impl = getDefaultHandler(methodType, name);
            }
            const success = this.register(attrs.path, impl, attrs.responseSerialize, attrs.requestDeserialize, methodType);
            if (success === false) {
              throw new Error(`Method handler for ${attrs.path} already provided.`);
            }
          });
        }
        removeService(service) {
          if (service === null || typeof service !== "object") {
            throw new Error("removeService() requires object as argument");
          }
          const serviceKeys = Object.keys(service);
          serviceKeys.forEach((name) => {
            const attrs = service[name];
            this.unregister(attrs.path);
          });
        }
        bind(port, creds) {
          throw new Error("Not implemented. Use bindAsync() instead");
        }
        registerListenerToChannelz(boundAddress) {
          return (0, channelz_1.registerChannelzSocket)((0, subchannel_address_1.subchannelAddressToString)(boundAddress), () => {
            return {
              localAddress: boundAddress,
              remoteAddress: null,
              security: null,
              remoteName: null,
              streamsStarted: 0,
              streamsSucceeded: 0,
              streamsFailed: 0,
              messagesSent: 0,
              messagesReceived: 0,
              keepAlivesSent: 0,
              lastLocalStreamCreatedTimestamp: null,
              lastRemoteStreamCreatedTimestamp: null,
              lastMessageSentTimestamp: null,
              lastMessageReceivedTimestamp: null,
              localFlowControlWindow: null,
              remoteFlowControlWindow: null
            };
          }, this.channelzEnabled);
        }
        createHttp2Server(credentials) {
          let http2Server;
          if (credentials._isSecure()) {
            const credentialsSettings = credentials._getSettings();
            const secureServerOptions = Object.assign(Object.assign(Object.assign({}, this.commonServerOptions), credentialsSettings), {
              enableTrace: this.options["grpc-node.tls_enable_trace"] === 1
            });
            let areCredentialsValid = credentialsSettings !== null;
            http2Server = http2.createSecureServer(secureServerOptions);
            http2Server.on("connection", (socket) => {
              if (!areCredentialsValid) {
                socket.destroy();
              }
            });
            http2Server.on("secureConnection", (socket) => {
              socket.on("error", (e) => {
                this.trace("An incoming TLS connection closed with error: " + e.message);
              });
            });
            const credsWatcher = /* @__PURE__ */ __name((options) => {
              if (options) {
                http2Server.setSecureContext(options);
              }
              areCredentialsValid = options !== null;
            }, "credsWatcher");
            credentials._addWatcher(credsWatcher);
            http2Server.on("close", () => {
              credentials._removeWatcher(credsWatcher);
            });
          } else {
            http2Server = http2.createServer(this.commonServerOptions);
          }
          http2Server.setTimeout(0, noop);
          this._setupHandlers(http2Server, credentials._getInterceptors());
          return http2Server;
        }
        bindOneAddress(address, boundPortObject) {
          this.trace("Attempting to bind " + (0, subchannel_address_1.subchannelAddressToString)(address));
          const http2Server = this.createHttp2Server(boundPortObject.credentials);
          return new Promise((resolve5, reject) => {
            const onError = /* @__PURE__ */ __name((err) => {
              this.trace("Failed to bind " + (0, subchannel_address_1.subchannelAddressToString)(address) + " with error " + err.message);
              resolve5({
                port: "port" in address ? address.port : 1,
                error: err.message
              });
            }, "onError");
            http2Server.once("error", onError);
            http2Server.listen(address, () => {
              const boundAddress = http2Server.address();
              let boundSubchannelAddress;
              if (typeof boundAddress === "string") {
                boundSubchannelAddress = {
                  path: boundAddress
                };
              } else {
                boundSubchannelAddress = {
                  host: boundAddress.address,
                  port: boundAddress.port
                };
              }
              const channelzRef = this.registerListenerToChannelz(boundSubchannelAddress);
              this.listenerChildrenTracker.refChild(channelzRef);
              this.http2Servers.set(http2Server, {
                channelzRef,
                sessions: /* @__PURE__ */ new Set()
              });
              boundPortObject.listeningServers.add(http2Server);
              this.trace("Successfully bound " + (0, subchannel_address_1.subchannelAddressToString)(boundSubchannelAddress));
              resolve5({
                port: "port" in boundSubchannelAddress ? boundSubchannelAddress.port : 1
              });
              http2Server.removeListener("error", onError);
            });
          });
        }
        async bindManyPorts(addressList, boundPortObject) {
          if (addressList.length === 0) {
            return {
              count: 0,
              port: 0,
              errors: []
            };
          }
          if ((0, subchannel_address_1.isTcpSubchannelAddress)(addressList[0]) && addressList[0].port === 0) {
            const firstAddressResult = await this.bindOneAddress(addressList[0], boundPortObject);
            if (firstAddressResult.error) {
              const restAddressResult = await this.bindManyPorts(addressList.slice(1), boundPortObject);
              return Object.assign(Object.assign({}, restAddressResult), {
                errors: [
                  firstAddressResult.error,
                  ...restAddressResult.errors
                ]
              });
            } else {
              const restAddresses = addressList.slice(1).map((address) => (0, subchannel_address_1.isTcpSubchannelAddress)(address) ? {
                host: address.host,
                port: firstAddressResult.port
              } : address);
              const restAddressResult = await Promise.all(restAddresses.map((address) => this.bindOneAddress(address, boundPortObject)));
              const allResults = [
                firstAddressResult,
                ...restAddressResult
              ];
              return {
                count: allResults.filter((result2) => result2.error === void 0).length,
                port: firstAddressResult.port,
                errors: allResults.filter((result2) => result2.error).map((result2) => result2.error)
              };
            }
          } else {
            const allResults = await Promise.all(addressList.map((address) => this.bindOneAddress(address, boundPortObject)));
            return {
              count: allResults.filter((result2) => result2.error === void 0).length,
              port: allResults[0].port,
              errors: allResults.filter((result2) => result2.error).map((result2) => result2.error)
            };
          }
        }
        async bindAddressList(addressList, boundPortObject) {
          const bindResult = await this.bindManyPorts(addressList, boundPortObject);
          if (bindResult.count > 0) {
            if (bindResult.count < addressList.length) {
              logging.log(constants_1.LogVerbosity.INFO, `WARNING Only ${bindResult.count} addresses added out of total ${addressList.length} resolved`);
            }
            return bindResult.port;
          } else {
            const errorString = `No address added out of total ${addressList.length} resolved`;
            logging.log(constants_1.LogVerbosity.ERROR, errorString);
            throw new Error(`${errorString} errors: [${bindResult.errors.join(",")}]`);
          }
        }
        resolvePort(port) {
          return new Promise((resolve5, reject) => {
            const resolverListener = {
              onSuccessfulResolution: /* @__PURE__ */ __name((endpointList, serviceConfig, serviceConfigError) => {
                resolverListener.onSuccessfulResolution = () => {
                };
                const addressList = [].concat(...endpointList.map((endpoint) => endpoint.addresses));
                if (addressList.length === 0) {
                  reject(new Error(`No addresses resolved for port ${port}`));
                  return;
                }
                resolve5(addressList);
              }, "onSuccessfulResolution"),
              onError: /* @__PURE__ */ __name((error) => {
                reject(new Error(error.details));
              }, "onError")
            };
            const resolver = (0, resolver_1.createResolver)(port, resolverListener, this.options);
            resolver.updateResolution();
          });
        }
        async bindPort(port, boundPortObject) {
          const addressList = await this.resolvePort(port);
          if (boundPortObject.cancelled) {
            this.completeUnbind(boundPortObject);
            throw new Error("bindAsync operation cancelled by unbind call");
          }
          const portNumber = await this.bindAddressList(addressList, boundPortObject);
          if (boundPortObject.cancelled) {
            this.completeUnbind(boundPortObject);
            throw new Error("bindAsync operation cancelled by unbind call");
          }
          return portNumber;
        }
        normalizePort(port) {
          const initialPortUri = (0, uri_parser_1.parseUri)(port);
          if (initialPortUri === null) {
            throw new Error(`Could not parse port "${port}"`);
          }
          const portUri = (0, resolver_1.mapUriDefaultScheme)(initialPortUri);
          if (portUri === null) {
            throw new Error(`Could not get a default scheme for port "${port}"`);
          }
          return portUri;
        }
        bindAsync(port, creds, callback) {
          if (this.shutdown) {
            throw new Error("bindAsync called after shutdown");
          }
          if (typeof port !== "string") {
            throw new TypeError("port must be a string");
          }
          if (creds === null || !(creds instanceof server_credentials_1.ServerCredentials)) {
            throw new TypeError("creds must be a ServerCredentials object");
          }
          if (typeof callback !== "function") {
            throw new TypeError("callback must be a function");
          }
          this.trace("bindAsync port=" + port);
          const portUri = this.normalizePort(port);
          const deferredCallback = /* @__PURE__ */ __name((error, port2) => {
            process.nextTick(() => callback(error, port2));
          }, "deferredCallback");
          let boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
          if (boundPortObject) {
            if (!creds._equals(boundPortObject.credentials)) {
              deferredCallback(new Error(`${port} already bound with incompatible credentials`), 0);
              return;
            }
            boundPortObject.cancelled = false;
            if (boundPortObject.completionPromise) {
              boundPortObject.completionPromise.then((portNum) => callback(null, portNum), (error) => callback(error, 0));
            } else {
              deferredCallback(null, boundPortObject.portNumber);
            }
            return;
          }
          boundPortObject = {
            mapKey: (0, uri_parser_1.uriToString)(portUri),
            originalUri: portUri,
            completionPromise: null,
            cancelled: false,
            portNumber: 0,
            credentials: creds,
            listeningServers: /* @__PURE__ */ new Set()
          };
          const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
          const completionPromise = this.bindPort(portUri, boundPortObject);
          boundPortObject.completionPromise = completionPromise;
          if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
            completionPromise.then((portNum) => {
              const finalUri = {
                scheme: portUri.scheme,
                authority: portUri.authority,
                path: (0, uri_parser_1.combineHostPort)({
                  host: splitPort.host,
                  port: portNum
                })
              };
              boundPortObject.mapKey = (0, uri_parser_1.uriToString)(finalUri);
              boundPortObject.completionPromise = null;
              boundPortObject.portNumber = portNum;
              this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
              callback(null, portNum);
            }, (error) => {
              callback(error, 0);
            });
          } else {
            this.boundPorts.set(boundPortObject.mapKey, boundPortObject);
            completionPromise.then((portNum) => {
              boundPortObject.completionPromise = null;
              boundPortObject.portNumber = portNum;
              callback(null, portNum);
            }, (error) => {
              callback(error, 0);
            });
          }
        }
        registerInjectorToChannelz() {
          return (0, channelz_1.registerChannelzSocket)("injector", () => {
            return {
              localAddress: null,
              remoteAddress: null,
              security: null,
              remoteName: null,
              streamsStarted: 0,
              streamsSucceeded: 0,
              streamsFailed: 0,
              messagesSent: 0,
              messagesReceived: 0,
              keepAlivesSent: 0,
              lastLocalStreamCreatedTimestamp: null,
              lastRemoteStreamCreatedTimestamp: null,
              lastMessageSentTimestamp: null,
              lastMessageReceivedTimestamp: null,
              localFlowControlWindow: null,
              remoteFlowControlWindow: null
            };
          }, this.channelzEnabled);
        }
        createConnectionInjector(credentials) {
          if (credentials === null || !(credentials instanceof server_credentials_1.ServerCredentials)) {
            throw new TypeError("creds must be a ServerCredentials object");
          }
          const server = this.createHttp2Server(credentials);
          const channelzRef = this.registerInjectorToChannelz();
          if (this.channelzEnabled) {
            this.listenerChildrenTracker.refChild(channelzRef);
          }
          const sessionsSet = /* @__PURE__ */ new Set();
          this.http2Servers.set(server, {
            channelzRef,
            sessions: sessionsSet
          });
          return {
            injectConnection: /* @__PURE__ */ __name((connection) => {
              server.emit("connection", connection);
            }, "injectConnection"),
            drain: /* @__PURE__ */ __name((graceTimeMs) => {
              var _b2, _c2;
              for (const session of sessionsSet) {
                this.closeSession(session);
              }
              (_c2 = (_b2 = setTimeout(() => {
                for (const session of sessionsSet) {
                  session.destroy(http2.constants.NGHTTP2_CANCEL);
                }
              }, graceTimeMs)).unref) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
            }, "drain"),
            destroy: /* @__PURE__ */ __name(() => {
              this.closeServer(server);
              for (const session of sessionsSet) {
                this.closeSession(session);
              }
            }, "destroy")
          };
        }
        closeServer(server, callback) {
          this.trace("Closing server with address " + JSON.stringify(server.address()));
          const serverInfo = this.http2Servers.get(server);
          server.close(() => {
            if (serverInfo) {
              this.listenerChildrenTracker.unrefChild(serverInfo.channelzRef);
              (0, channelz_1.unregisterChannelzRef)(serverInfo.channelzRef);
            }
            this.http2Servers.delete(server);
            callback === null || callback === void 0 ? void 0 : callback();
          });
        }
        closeSession(session, callback) {
          var _b2;
          this.trace("Closing session initiated by " + ((_b2 = session.socket) === null || _b2 === void 0 ? void 0 : _b2.remoteAddress));
          const sessionInfo = this.sessions.get(session);
          const closeCallback = /* @__PURE__ */ __name(() => {
            if (sessionInfo) {
              this.sessionChildrenTracker.unrefChild(sessionInfo.ref);
              (0, channelz_1.unregisterChannelzRef)(sessionInfo.ref);
            }
            callback === null || callback === void 0 ? void 0 : callback();
          }, "closeCallback");
          if (session.closed) {
            queueMicrotask(closeCallback);
          } else {
            session.close(closeCallback);
          }
        }
        completeUnbind(boundPortObject) {
          for (const server of boundPortObject.listeningServers) {
            const serverInfo = this.http2Servers.get(server);
            this.closeServer(server, () => {
              boundPortObject.listeningServers.delete(server);
            });
            if (serverInfo) {
              for (const session of serverInfo.sessions) {
                this.closeSession(session);
              }
            }
          }
          this.boundPorts.delete(boundPortObject.mapKey);
        }
        /**
             * Unbind a previously bound port, or cancel an in-progress bindAsync
             * operation. If port 0 was bound, only the actual bound port can be
             * unbound. For example, if bindAsync was called with "localhost:0" and the
             * bound port result was 54321, it can be unbound as "localhost:54321".
             * @param port
             */
        unbind(port) {
          this.trace("unbind port=" + port);
          const portUri = this.normalizePort(port);
          const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
          if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
            throw new Error("Cannot unbind port 0");
          }
          const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
          if (boundPortObject) {
            this.trace("unbinding " + boundPortObject.mapKey + " originally bound as " + (0, uri_parser_1.uriToString)(boundPortObject.originalUri));
            if (boundPortObject.completionPromise) {
              boundPortObject.cancelled = true;
            } else {
              this.completeUnbind(boundPortObject);
            }
          }
        }
        /**
             * Gracefully close all connections associated with a previously bound port.
             * After the grace time, forcefully close all remaining open connections.
             *
             * If port 0 was bound, only the actual bound port can be
             * drained. For example, if bindAsync was called with "localhost:0" and the
             * bound port result was 54321, it can be drained as "localhost:54321".
             * @param port
             * @param graceTimeMs
             * @returns
             */
        drain(port, graceTimeMs) {
          var _b2, _c2;
          this.trace("drain port=" + port + " graceTimeMs=" + graceTimeMs);
          const portUri = this.normalizePort(port);
          const splitPort = (0, uri_parser_1.splitHostPort)(portUri.path);
          if ((splitPort === null || splitPort === void 0 ? void 0 : splitPort.port) === 0) {
            throw new Error("Cannot drain port 0");
          }
          const boundPortObject = this.boundPorts.get((0, uri_parser_1.uriToString)(portUri));
          if (!boundPortObject) {
            return;
          }
          const allSessions = /* @__PURE__ */ new Set();
          for (const http2Server of boundPortObject.listeningServers) {
            const serverEntry = this.http2Servers.get(http2Server);
            if (serverEntry) {
              for (const session of serverEntry.sessions) {
                allSessions.add(session);
                this.closeSession(session, () => {
                  allSessions.delete(session);
                });
              }
            }
          }
          (_c2 = (_b2 = setTimeout(() => {
            for (const session of allSessions) {
              session.destroy(http2.constants.NGHTTP2_CANCEL);
            }
          }, graceTimeMs)).unref) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
        }
        forceShutdown() {
          for (const boundPortObject of this.boundPorts.values()) {
            boundPortObject.cancelled = true;
          }
          this.boundPorts.clear();
          for (const server of this.http2Servers.keys()) {
            this.closeServer(server);
          }
          this.sessions.forEach((channelzInfo, session) => {
            this.closeSession(session);
            session.destroy(http2.constants.NGHTTP2_CANCEL);
          });
          this.sessions.clear();
          (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
          this.shutdown = true;
        }
        register(name, handler, serialize, deserialize, type) {
          if (this.handlers.has(name)) {
            return false;
          }
          this.handlers.set(name, {
            func: handler,
            serialize,
            deserialize,
            type,
            path: name
          });
          return true;
        }
        unregister(name) {
          return this.handlers.delete(name);
        }
        /**
             * @deprecated No longer needed as of version 1.10.x
             */
        start() {
          if (this.http2Servers.size === 0 || [
            ...this.http2Servers.keys()
          ].every((server) => !server.listening)) {
            throw new Error("server must be bound in order to start");
          }
          if (this.started === true) {
            throw new Error("server is already started");
          }
          this.started = true;
        }
        tryShutdown(callback) {
          var _b2;
          const wrappedCallback = /* @__PURE__ */ __name((error) => {
            (0, channelz_1.unregisterChannelzRef)(this.channelzRef);
            callback(error);
          }, "wrappedCallback");
          let pendingChecks = 0;
          function maybeCallback() {
            pendingChecks--;
            if (pendingChecks === 0) {
              wrappedCallback();
            }
          }
          __name(maybeCallback, "maybeCallback");
          this.shutdown = true;
          for (const [serverKey, server] of this.http2Servers.entries()) {
            pendingChecks++;
            const serverString = server.channelzRef.name;
            this.trace("Waiting for server " + serverString + " to close");
            this.closeServer(serverKey, () => {
              this.trace("Server " + serverString + " finished closing");
              maybeCallback();
            });
            for (const session of server.sessions.keys()) {
              pendingChecks++;
              const sessionString = (_b2 = session.socket) === null || _b2 === void 0 ? void 0 : _b2.remoteAddress;
              this.trace("Waiting for session " + sessionString + " to close");
              this.closeSession(session, () => {
                this.trace("Session " + sessionString + " finished closing");
                maybeCallback();
              });
            }
          }
          if (pendingChecks === 0) {
            wrappedCallback();
          }
        }
        addHttp2Port() {
          throw new Error("Not yet implemented");
        }
        /**
             * Get the channelz reference object for this server. The returned value is
             * garbage if channelz is disabled for this server.
             * @returns
             */
        getChannelzRef() {
          return this.channelzRef;
        }
        _verifyContentType(stream, headers) {
          const contentType = headers[http2.constants.HTTP2_HEADER_CONTENT_TYPE];
          if (typeof contentType !== "string" || !contentType.startsWith("application/grpc")) {
            stream.respond({
              [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE
            }, {
              endStream: true
            });
            return false;
          }
          return true;
        }
        _retrieveHandler(path) {
          this.trace("Received call to method " + path + " at address " + this.serverAddressString);
          const handler = this.handlers.get(path);
          if (handler === void 0) {
            this.trace("No handler registered for method " + path + ". Sending UNIMPLEMENTED status.");
            return null;
          }
          return handler;
        }
        _respondWithError(err, stream, channelzSessionInfo = null) {
          var _b2, _c2;
          const trailersToSend = Object.assign({
            "grpc-status": (_b2 = err.code) !== null && _b2 !== void 0 ? _b2 : constants_1.Status.INTERNAL,
            "grpc-message": err.details,
            [http2.constants.HTTP2_HEADER_STATUS]: http2.constants.HTTP_STATUS_OK,
            [http2.constants.HTTP2_HEADER_CONTENT_TYPE]: "application/grpc+proto"
          }, (_c2 = err.metadata) === null || _c2 === void 0 ? void 0 : _c2.toHttp2Headers());
          stream.respond(trailersToSend, {
            endStream: true
          });
          this.callTracker.addCallFailed();
          channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
        }
        _channelzHandler(extraInterceptors, stream, headers) {
          this.onStreamOpened(stream);
          const channelzSessionInfo = this.sessions.get(stream.session);
          this.callTracker.addCallStarted();
          channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallStarted();
          if (!this._verifyContentType(stream, headers)) {
            this.callTracker.addCallFailed();
            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            return;
          }
          const path = headers[HTTP2_HEADER_PATH];
          const handler = this._retrieveHandler(path);
          if (!handler) {
            this._respondWithError(getUnimplementedStatusResponse(path), stream, channelzSessionInfo);
            return;
          }
          const callEventTracker = {
            addMessageSent: /* @__PURE__ */ __name(() => {
              if (channelzSessionInfo) {
                channelzSessionInfo.messagesSent += 1;
                channelzSessionInfo.lastMessageSentTimestamp = /* @__PURE__ */ new Date();
              }
            }, "addMessageSent"),
            addMessageReceived: /* @__PURE__ */ __name(() => {
              if (channelzSessionInfo) {
                channelzSessionInfo.messagesReceived += 1;
                channelzSessionInfo.lastMessageReceivedTimestamp = /* @__PURE__ */ new Date();
              }
            }, "addMessageReceived"),
            onCallEnd: /* @__PURE__ */ __name((status) => {
              if (status.code === constants_1.Status.OK) {
                this.callTracker.addCallSucceeded();
              } else {
                this.callTracker.addCallFailed();
              }
            }, "onCallEnd"),
            onStreamEnd: /* @__PURE__ */ __name((success) => {
              if (channelzSessionInfo) {
                if (success) {
                  channelzSessionInfo.streamTracker.addCallSucceeded();
                } else {
                  channelzSessionInfo.streamTracker.addCallFailed();
                }
              }
            }, "onStreamEnd")
          };
          const call = (0, server_interceptors_1.getServerInterceptingCall)([
            ...extraInterceptors,
            ...this.interceptors
          ], stream, headers, callEventTracker, handler, this.options);
          if (!this._runHandlerForCall(call, handler)) {
            this.callTracker.addCallFailed();
            channelzSessionInfo === null || channelzSessionInfo === void 0 ? void 0 : channelzSessionInfo.streamTracker.addCallFailed();
            call.sendStatus({
              code: constants_1.Status.INTERNAL,
              details: `Unknown handler type: ${handler.type}`
            });
          }
        }
        _streamHandler(extraInterceptors, stream, headers) {
          this.onStreamOpened(stream);
          if (this._verifyContentType(stream, headers) !== true) {
            return;
          }
          const path = headers[HTTP2_HEADER_PATH];
          const handler = this._retrieveHandler(path);
          if (!handler) {
            this._respondWithError(getUnimplementedStatusResponse(path), stream, null);
            return;
          }
          const call = (0, server_interceptors_1.getServerInterceptingCall)([
            ...extraInterceptors,
            ...this.interceptors
          ], stream, headers, null, handler, this.options);
          if (!this._runHandlerForCall(call, handler)) {
            call.sendStatus({
              code: constants_1.Status.INTERNAL,
              details: `Unknown handler type: ${handler.type}`
            });
          }
        }
        _runHandlerForCall(call, handler) {
          const { type } = handler;
          if (type === "unary") {
            handleUnary(call, handler);
          } else if (type === "clientStream") {
            handleClientStreaming(call, handler);
          } else if (type === "serverStream") {
            handleServerStreaming(call, handler);
          } else if (type === "bidi") {
            handleBidiStreaming(call, handler);
          } else {
            return false;
          }
          return true;
        }
        _setupHandlers(http2Server, extraInterceptors) {
          if (http2Server === null) {
            return;
          }
          const serverAddress = http2Server.address();
          let serverAddressString = "null";
          if (serverAddress) {
            if (typeof serverAddress === "string") {
              serverAddressString = serverAddress;
            } else {
              serverAddressString = serverAddress.address + ":" + serverAddress.port;
            }
          }
          this.serverAddressString = serverAddressString;
          const handler = this.channelzEnabled ? this._channelzHandler : this._streamHandler;
          const sessionHandler = this.channelzEnabled ? this._channelzSessionHandler(http2Server) : this._sessionHandler(http2Server);
          http2Server.on("stream", handler.bind(this, extraInterceptors));
          http2Server.on("session", sessionHandler);
        }
        _sessionHandler(http2Server) {
          return (session) => {
            var _b2, _c2;
            (_b2 = this.http2Servers.get(http2Server)) === null || _b2 === void 0 ? void 0 : _b2.sessions.add(session);
            let connectionAgeTimer = null;
            let connectionAgeGraceTimer = null;
            let keepaliveTimer = null;
            let sessionClosedByServer = false;
            const idleTimeoutObj = this.enableIdleTimeout(session);
            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
              const jitterMagnitude = this.maxConnectionAgeMs / 10;
              const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
              connectionAgeTimer = setTimeout(() => {
                var _b3, _c3;
                sessionClosedByServer = true;
                this.trace("Connection dropped by max connection age: " + ((_b3 = session.socket) === null || _b3 === void 0 ? void 0 : _b3.remoteAddress));
                try {
                  session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
                } catch (e) {
                  session.destroy();
                  return;
                }
                session.close();
                if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                  connectionAgeGraceTimer = setTimeout(() => {
                    session.destroy();
                  }, this.maxConnectionAgeGraceMs);
                  (_c3 = connectionAgeGraceTimer.unref) === null || _c3 === void 0 ? void 0 : _c3.call(connectionAgeGraceTimer);
                }
              }, this.maxConnectionAgeMs + jitter);
              (_c2 = connectionAgeTimer.unref) === null || _c2 === void 0 ? void 0 : _c2.call(connectionAgeTimer);
            }
            const clearKeepaliveTimeout = /* @__PURE__ */ __name(() => {
              if (keepaliveTimer) {
                clearTimeout(keepaliveTimer);
                keepaliveTimer = null;
              }
            }, "clearKeepaliveTimeout");
            const canSendPing = /* @__PURE__ */ __name(() => {
              return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;
            }, "canSendPing");
            let sendPing;
            const maybeStartKeepalivePingTimer = /* @__PURE__ */ __name(() => {
              var _b3;
              if (!canSendPing()) {
                return;
              }
              this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
              keepaliveTimer = setTimeout(() => {
                clearKeepaliveTimeout();
                sendPing();
              }, this.keepaliveTimeMs);
              (_b3 = keepaliveTimer.unref) === null || _b3 === void 0 ? void 0 : _b3.call(keepaliveTimer);
            }, "maybeStartKeepalivePingTimer");
            sendPing = /* @__PURE__ */ __name(() => {
              var _b3;
              if (!canSendPing()) {
                return;
              }
              this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
              let pingSendError = "";
              try {
                const pingSentSuccessfully = session.ping((err, duration, payload) => {
                  clearKeepaliveTimeout();
                  if (err) {
                    this.keepaliveTrace("Ping failed with error: " + err.message);
                    sessionClosedByServer = true;
                    session.close();
                  } else {
                    this.keepaliveTrace("Received ping response");
                    maybeStartKeepalivePingTimer();
                  }
                });
                if (!pingSentSuccessfully) {
                  pingSendError = "Ping returned false";
                }
              } catch (e) {
                pingSendError = (e instanceof Error ? e.message : "") || "Unknown error";
              }
              if (pingSendError) {
                this.keepaliveTrace("Ping send failed: " + pingSendError);
                this.trace("Connection dropped due to ping send error: " + pingSendError);
                sessionClosedByServer = true;
                session.close();
                return;
              }
              keepaliveTimer = setTimeout(() => {
                clearKeepaliveTimeout();
                this.keepaliveTrace("Ping timeout passed without response");
                this.trace("Connection dropped by keepalive timeout");
                sessionClosedByServer = true;
                session.close();
              }, this.keepaliveTimeoutMs);
              (_b3 = keepaliveTimer.unref) === null || _b3 === void 0 ? void 0 : _b3.call(keepaliveTimer);
            }, "sendPing");
            maybeStartKeepalivePingTimer();
            session.on("close", () => {
              var _b3, _c3;
              if (!sessionClosedByServer) {
                this.trace(`Connection dropped by client ${(_b3 = session.socket) === null || _b3 === void 0 ? void 0 : _b3.remoteAddress}`);
              }
              if (connectionAgeTimer) {
                clearTimeout(connectionAgeTimer);
              }
              if (connectionAgeGraceTimer) {
                clearTimeout(connectionAgeGraceTimer);
              }
              clearKeepaliveTimeout();
              if (idleTimeoutObj !== null) {
                clearTimeout(idleTimeoutObj.timeout);
                this.sessionIdleTimeouts.delete(session);
              }
              (_c3 = this.http2Servers.get(http2Server)) === null || _c3 === void 0 ? void 0 : _c3.sessions.delete(session);
            });
          };
        }
        _channelzSessionHandler(http2Server) {
          return (session) => {
            var _b2, _c2, _d, _e;
            const channelzRef = (0, channelz_1.registerChannelzSocket)((_c2 = (_b2 = session.socket) === null || _b2 === void 0 ? void 0 : _b2.remoteAddress) !== null && _c2 !== void 0 ? _c2 : "unknown", this.getChannelzSessionInfo.bind(this, session), this.channelzEnabled);
            const channelzSessionInfo = {
              ref: channelzRef,
              streamTracker: new channelz_1.ChannelzCallTracker(),
              messagesSent: 0,
              messagesReceived: 0,
              keepAlivesSent: 0,
              lastMessageSentTimestamp: null,
              lastMessageReceivedTimestamp: null
            };
            (_d = this.http2Servers.get(http2Server)) === null || _d === void 0 ? void 0 : _d.sessions.add(session);
            this.sessions.set(session, channelzSessionInfo);
            const clientAddress = `${session.socket.remoteAddress}:${session.socket.remotePort}`;
            this.channelzTrace.addTrace("CT_INFO", "Connection established by client " + clientAddress);
            this.trace("Connection established by client " + clientAddress);
            this.sessionChildrenTracker.refChild(channelzRef);
            let connectionAgeTimer = null;
            let connectionAgeGraceTimer = null;
            let keepaliveTimeout = null;
            let sessionClosedByServer = false;
            const idleTimeoutObj = this.enableIdleTimeout(session);
            if (this.maxConnectionAgeMs !== UNLIMITED_CONNECTION_AGE_MS) {
              const jitterMagnitude = this.maxConnectionAgeMs / 10;
              const jitter = Math.random() * jitterMagnitude * 2 - jitterMagnitude;
              connectionAgeTimer = setTimeout(() => {
                var _b3;
                sessionClosedByServer = true;
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by max connection age from " + clientAddress);
                try {
                  session.goaway(http2.constants.NGHTTP2_NO_ERROR, ~(1 << 31), kMaxAge);
                } catch (e) {
                  session.destroy();
                  return;
                }
                session.close();
                if (this.maxConnectionAgeGraceMs !== UNLIMITED_CONNECTION_AGE_MS) {
                  connectionAgeGraceTimer = setTimeout(() => {
                    session.destroy();
                  }, this.maxConnectionAgeGraceMs);
                  (_b3 = connectionAgeGraceTimer.unref) === null || _b3 === void 0 ? void 0 : _b3.call(connectionAgeGraceTimer);
                }
              }, this.maxConnectionAgeMs + jitter);
              (_e = connectionAgeTimer.unref) === null || _e === void 0 ? void 0 : _e.call(connectionAgeTimer);
            }
            const clearKeepaliveTimeout = /* @__PURE__ */ __name(() => {
              if (keepaliveTimeout) {
                clearTimeout(keepaliveTimeout);
                keepaliveTimeout = null;
              }
            }, "clearKeepaliveTimeout");
            const canSendPing = /* @__PURE__ */ __name(() => {
              return !session.destroyed && this.keepaliveTimeMs < KEEPALIVE_MAX_TIME_MS && this.keepaliveTimeMs > 0;
            }, "canSendPing");
            let sendPing;
            const maybeStartKeepalivePingTimer = /* @__PURE__ */ __name(() => {
              var _b3;
              if (!canSendPing()) {
                return;
              }
              this.keepaliveTrace("Starting keepalive timer for " + this.keepaliveTimeMs + "ms");
              keepaliveTimeout = setTimeout(() => {
                clearKeepaliveTimeout();
                sendPing();
              }, this.keepaliveTimeMs);
              (_b3 = keepaliveTimeout.unref) === null || _b3 === void 0 ? void 0 : _b3.call(keepaliveTimeout);
            }, "maybeStartKeepalivePingTimer");
            sendPing = /* @__PURE__ */ __name(() => {
              var _b3;
              if (!canSendPing()) {
                return;
              }
              this.keepaliveTrace("Sending ping with timeout " + this.keepaliveTimeoutMs + "ms");
              let pingSendError = "";
              try {
                const pingSentSuccessfully = session.ping((err, duration, payload) => {
                  clearKeepaliveTimeout();
                  if (err) {
                    this.keepaliveTrace("Ping failed with error: " + err.message);
                    this.channelzTrace.addTrace("CT_INFO", "Connection dropped due to error of a ping frame " + err.message + " return in " + duration);
                    sessionClosedByServer = true;
                    session.close();
                  } else {
                    this.keepaliveTrace("Received ping response");
                    maybeStartKeepalivePingTimer();
                  }
                });
                if (!pingSentSuccessfully) {
                  pingSendError = "Ping returned false";
                }
              } catch (e) {
                pingSendError = (e instanceof Error ? e.message : "") || "Unknown error";
              }
              if (pingSendError) {
                this.keepaliveTrace("Ping send failed: " + pingSendError);
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped due to ping send error: " + pingSendError);
                sessionClosedByServer = true;
                session.close();
                return;
              }
              channelzSessionInfo.keepAlivesSent += 1;
              keepaliveTimeout = setTimeout(() => {
                clearKeepaliveTimeout();
                this.keepaliveTrace("Ping timeout passed without response");
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by keepalive timeout from " + clientAddress);
                sessionClosedByServer = true;
                session.close();
              }, this.keepaliveTimeoutMs);
              (_b3 = keepaliveTimeout.unref) === null || _b3 === void 0 ? void 0 : _b3.call(keepaliveTimeout);
            }, "sendPing");
            maybeStartKeepalivePingTimer();
            session.on("close", () => {
              var _b3;
              if (!sessionClosedByServer) {
                this.channelzTrace.addTrace("CT_INFO", "Connection dropped by client " + clientAddress);
              }
              this.sessionChildrenTracker.unrefChild(channelzRef);
              (0, channelz_1.unregisterChannelzRef)(channelzRef);
              if (connectionAgeTimer) {
                clearTimeout(connectionAgeTimer);
              }
              if (connectionAgeGraceTimer) {
                clearTimeout(connectionAgeGraceTimer);
              }
              clearKeepaliveTimeout();
              if (idleTimeoutObj !== null) {
                clearTimeout(idleTimeoutObj.timeout);
                this.sessionIdleTimeouts.delete(session);
              }
              (_b3 = this.http2Servers.get(http2Server)) === null || _b3 === void 0 ? void 0 : _b3.sessions.delete(session);
              this.sessions.delete(session);
            });
          };
        }
        enableIdleTimeout(session) {
          var _b2, _c2;
          if (this.sessionIdleTimeout >= MAX_CONNECTION_IDLE_MS) {
            return null;
          }
          const idleTimeoutObj = {
            activeStreams: 0,
            lastIdle: Date.now(),
            onClose: this.onStreamClose.bind(this, session),
            timeout: setTimeout(this.onIdleTimeout, this.sessionIdleTimeout, this, session)
          };
          (_c2 = (_b2 = idleTimeoutObj.timeout).unref) === null || _c2 === void 0 ? void 0 : _c2.call(_b2);
          this.sessionIdleTimeouts.set(session, idleTimeoutObj);
          const { socket } = session;
          this.trace("Enable idle timeout for " + socket.remoteAddress + ":" + socket.remotePort);
          return idleTimeoutObj;
        }
        onIdleTimeout(ctx, session) {
          const { socket } = session;
          const sessionInfo = ctx.sessionIdleTimeouts.get(session);
          if (sessionInfo !== void 0 && sessionInfo.activeStreams === 0) {
            if (Date.now() - sessionInfo.lastIdle >= ctx.sessionIdleTimeout) {
              ctx.trace("Session idle timeout triggered for " + (socket === null || socket === void 0 ? void 0 : socket.remoteAddress) + ":" + (socket === null || socket === void 0 ? void 0 : socket.remotePort) + " last idle at " + sessionInfo.lastIdle);
              ctx.closeSession(session);
            } else {
              sessionInfo.timeout.refresh();
            }
          }
        }
        onStreamOpened(stream) {
          const session = stream.session;
          const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
          if (idleTimeoutObj) {
            idleTimeoutObj.activeStreams += 1;
            stream.once("close", idleTimeoutObj.onClose);
          }
        }
        onStreamClose(session) {
          var _b2, _c2;
          const idleTimeoutObj = this.sessionIdleTimeouts.get(session);
          if (idleTimeoutObj) {
            idleTimeoutObj.activeStreams -= 1;
            if (idleTimeoutObj.activeStreams === 0) {
              idleTimeoutObj.lastIdle = Date.now();
              idleTimeoutObj.timeout.refresh();
              this.trace("Session onStreamClose" + ((_b2 = session.socket) === null || _b2 === void 0 ? void 0 : _b2.remoteAddress) + ":" + ((_c2 = session.socket) === null || _c2 === void 0 ? void 0 : _c2.remotePort) + " at " + idleTimeoutObj.lastIdle);
            }
          }
        }
      }, (() => {
        const _metadata = typeof Symbol === "function" && Symbol.metadata ? /* @__PURE__ */ Object.create(null) : void 0;
        _start_decorators = [
          deprecate("Calling start() is no longer necessary. It can be safely omitted.")
        ];
        __esDecorate(_a2, null, _start_decorators, {
          kind: "method",
          name: "start",
          static: false,
          private: false,
          access: {
            has: /* @__PURE__ */ __name((obj) => "start" in obj, "has"),
            get: /* @__PURE__ */ __name((obj) => obj.start, "get")
          },
          metadata: _metadata
        }, null, _instanceExtraInitializers);
        if (_metadata) Object.defineProperty(_a2, Symbol.metadata, {
          enumerable: true,
          configurable: true,
          writable: true,
          value: _metadata
        });
      })(), _a2;
    })();
    exports2.Server = Server;
    async function handleUnary(call, handler) {
      let stream;
      function respond(err, value2, trailer, flags) {
        if (err) {
          call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
          return;
        }
        call.sendMessage(value2, () => {
          call.sendStatus({
            code: constants_1.Status.OK,
            details: "OK",
            metadata: trailer !== null && trailer !== void 0 ? trailer : null
          });
        });
      }
      __name(respond, "respond");
      let requestMetadata;
      let requestMessage = null;
      call.start({
        onReceiveMetadata(metadata) {
          requestMetadata = metadata;
          call.startRead();
        },
        onReceiveMessage(message) {
          if (requestMessage) {
            call.sendStatus({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received a second request message for server streaming method ${handler.path}`,
              metadata: null
            });
            return;
          }
          requestMessage = message;
          call.startRead();
        },
        onReceiveHalfClose() {
          if (!requestMessage) {
            call.sendStatus({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received no request message for server streaming method ${handler.path}`,
              metadata: null
            });
            return;
          }
          stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
          try {
            handler.func(stream, respond);
          } catch (err) {
            call.sendStatus({
              code: constants_1.Status.UNKNOWN,
              details: `Server method handler threw error ${err.message}`,
              metadata: null
            });
          }
        },
        onCancel() {
          if (stream) {
            stream.cancelled = true;
            stream.emit("cancelled", "cancelled");
          }
        }
      });
    }
    __name(handleUnary, "handleUnary");
    function handleClientStreaming(call, handler) {
      let stream;
      function respond(err, value2, trailer, flags) {
        if (err) {
          call.sendStatus((0, server_call_1.serverErrorToStatus)(err, trailer));
          return;
        }
        call.sendMessage(value2, () => {
          call.sendStatus({
            code: constants_1.Status.OK,
            details: "OK",
            metadata: trailer !== null && trailer !== void 0 ? trailer : null
          });
        });
      }
      __name(respond, "respond");
      call.start({
        onReceiveMetadata(metadata) {
          stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
          try {
            handler.func(stream, respond);
          } catch (err) {
            call.sendStatus({
              code: constants_1.Status.UNKNOWN,
              details: `Server method handler threw error ${err.message}`,
              metadata: null
            });
          }
        },
        onReceiveMessage(message) {
          stream.push(message);
        },
        onReceiveHalfClose() {
          stream.push(null);
        },
        onCancel() {
          if (stream) {
            stream.cancelled = true;
            stream.emit("cancelled", "cancelled");
            stream.destroy();
          }
        }
      });
    }
    __name(handleClientStreaming, "handleClientStreaming");
    function handleServerStreaming(call, handler) {
      let stream;
      let requestMetadata;
      let requestMessage = null;
      call.start({
        onReceiveMetadata(metadata) {
          requestMetadata = metadata;
          call.startRead();
        },
        onReceiveMessage(message) {
          if (requestMessage) {
            call.sendStatus({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received a second request message for server streaming method ${handler.path}`,
              metadata: null
            });
            return;
          }
          requestMessage = message;
          call.startRead();
        },
        onReceiveHalfClose() {
          if (!requestMessage) {
            call.sendStatus({
              code: constants_1.Status.UNIMPLEMENTED,
              details: `Received no request message for server streaming method ${handler.path}`,
              metadata: null
            });
            return;
          }
          stream = new server_call_1.ServerWritableStreamImpl(handler.path, call, requestMetadata, requestMessage);
          try {
            handler.func(stream);
          } catch (err) {
            call.sendStatus({
              code: constants_1.Status.UNKNOWN,
              details: `Server method handler threw error ${err.message}`,
              metadata: null
            });
          }
        },
        onCancel() {
          if (stream) {
            stream.cancelled = true;
            stream.emit("cancelled", "cancelled");
            stream.destroy();
          }
        }
      });
    }
    __name(handleServerStreaming, "handleServerStreaming");
    function handleBidiStreaming(call, handler) {
      let stream;
      call.start({
        onReceiveMetadata(metadata) {
          stream = new server_call_1.ServerDuplexStreamImpl(handler.path, call, metadata);
          try {
            handler.func(stream);
          } catch (err) {
            call.sendStatus({
              code: constants_1.Status.UNKNOWN,
              details: `Server method handler threw error ${err.message}`,
              metadata: null
            });
          }
        },
        onReceiveMessage(message) {
          stream.push(message);
        },
        onReceiveHalfClose() {
          stream.push(null);
        },
        onCancel() {
          if (stream) {
            stream.cancelled = true;
            stream.emit("cancelled", "cancelled");
            stream.destroy();
          }
        }
      });
    }
    __name(handleBidiStreaming, "handleBidiStreaming");
  }
});

// node_modules/@grpc/grpc-js/build/src/status-builder.js
var require_status_builder = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/status-builder.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.StatusBuilder = void 0;
    var StatusBuilder = class StatusBuilder {
      static {
        __name(this, "StatusBuilder");
      }
      constructor() {
        this.code = null;
        this.details = null;
        this.metadata = null;
      }
      /**
       * Adds a status code to the builder.
       */
      withCode(code) {
        this.code = code;
        return this;
      }
      /**
       * Adds details to the builder.
       */
      withDetails(details) {
        this.details = details;
        return this;
      }
      /**
       * Adds metadata to the builder.
       */
      withMetadata(metadata) {
        this.metadata = metadata;
        return this;
      }
      /**
       * Builds the status object.
       */
      build() {
        const status = {};
        if (this.code !== null) {
          status.code = this.code;
        }
        if (this.details !== null) {
          status.details = this.details;
        }
        if (this.metadata !== null) {
          status.metadata = this.metadata;
        }
        return status;
      }
    };
    exports2.StatusBuilder = StatusBuilder;
  }
});

// node_modules/@grpc/grpc-js/build/src/duration.js
var require_duration = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/duration.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.msToDuration = msToDuration;
    exports2.durationToMs = durationToMs;
    exports2.isDuration = isDuration;
    exports2.parseDuration = parseDuration;
    function msToDuration(millis) {
      return {
        seconds: millis / 1e3 | 0,
        nanos: millis % 1e3 * 1e6 | 0
      };
    }
    __name(msToDuration, "msToDuration");
    function durationToMs(duration) {
      return duration.seconds * 1e3 + duration.nanos / 1e6 | 0;
    }
    __name(durationToMs, "durationToMs");
    function isDuration(value2) {
      return typeof value2.seconds === "number" && typeof value2.nanos === "number";
    }
    __name(isDuration, "isDuration");
    var durationRegex2 = /^(\d+)(?:\.(\d+))?s$/;
    function parseDuration(value2) {
      const match = value2.match(durationRegex2);
      if (!match) {
        return null;
      }
      return {
        seconds: Number.parseInt(match[1], 10),
        nanos: match[2] ? Number.parseInt(match[2].padEnd(9, "0"), 10) : 0
      };
    }
    __name(parseDuration, "parseDuration");
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js
var require_load_balancer_pick_first = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-pick-first.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.LeafLoadBalancer = exports2.PickFirstLoadBalancer = exports2.PickFirstLoadBalancingConfig = void 0;
    exports2.shuffled = shuffled;
    exports2.setup = setup;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var logging = require_logging();
    var constants_1 = require_constants3();
    var subchannel_address_2 = require_subchannel_address();
    var net_1 = require("net");
    var TRACER_NAME = "pick_first";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    var TYPE_NAME = "pick_first";
    var CONNECTION_DELAY_INTERVAL_MS = 250;
    var PickFirstLoadBalancingConfig = class PickFirstLoadBalancingConfig2 {
      static {
        __name(this, "PickFirstLoadBalancingConfig");
      }
      constructor(shuffleAddressList) {
        this.shuffleAddressList = shuffleAddressList;
      }
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {
            shuffleAddressList: this.shuffleAddressList
          }
        };
      }
      getShuffleAddressList() {
        return this.shuffleAddressList;
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static createFromJson(obj) {
        if ("shuffleAddressList" in obj && !(typeof obj.shuffleAddressList === "boolean")) {
          throw new Error("pick_first config field shuffleAddressList must be a boolean if provided");
        }
        return new PickFirstLoadBalancingConfig2(obj.shuffleAddressList === true);
      }
    };
    exports2.PickFirstLoadBalancingConfig = PickFirstLoadBalancingConfig;
    var PickFirstPicker = class PickFirstPicker {
      static {
        __name(this, "PickFirstPicker");
      }
      constructor(subchannel) {
        this.subchannel = subchannel;
      }
      pick(pickArgs) {
        return {
          pickResultType: picker_1.PickResultType.COMPLETE,
          subchannel: this.subchannel,
          status: null,
          onCallStarted: null,
          onCallEnded: null
        };
      }
    };
    function shuffled(list) {
      const result2 = list.slice();
      for (let i = result2.length - 1; i > 1; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        const temp = result2[i];
        result2[i] = result2[j];
        result2[j] = temp;
      }
      return result2;
    }
    __name(shuffled, "shuffled");
    function interleaveAddressFamilies(addressList) {
      const result2 = [];
      const ipv6Addresses = [];
      const ipv4Addresses = [];
      const ipv6First = (0, subchannel_address_2.isTcpSubchannelAddress)(addressList[0]) && (0, net_1.isIPv6)(addressList[0].host);
      for (const address of addressList) {
        if ((0, subchannel_address_2.isTcpSubchannelAddress)(address) && (0, net_1.isIPv6)(address.host)) {
          ipv6Addresses.push(address);
        } else {
          ipv4Addresses.push(address);
        }
      }
      const firstList = ipv6First ? ipv6Addresses : ipv4Addresses;
      const secondList = ipv6First ? ipv4Addresses : ipv6Addresses;
      for (let i = 0; i < Math.max(firstList.length, secondList.length); i++) {
        if (i < firstList.length) {
          result2.push(firstList[i]);
        }
        if (i < secondList.length) {
          result2.push(secondList[i]);
        }
      }
      return result2;
    }
    __name(interleaveAddressFamilies, "interleaveAddressFamilies");
    var REPORT_HEALTH_STATUS_OPTION_NAME = "grpc-node.internal.pick-first.report_health_status";
    var PickFirstLoadBalancer = class PickFirstLoadBalancer {
      static {
        __name(this, "PickFirstLoadBalancer");
      }
      /**
       * Load balancer that attempts to connect to each backend in the address list
       * in order, and picks the first one that connects, using it for every
       * request.
       * @param channelControlHelper `ChannelControlHelper` instance provided by
       *     this load balancer's owner.
       */
      constructor(channelControlHelper, credentials, options) {
        this.channelControlHelper = channelControlHelper;
        this.children = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentSubchannelIndex = 0;
        this.currentPick = null;
        this.subchannelStateListener = (subchannel, previousState, newState, keepaliveTime, errorMessage) => {
          this.onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage);
        };
        this.pickedSubchannelHealthListener = () => this.calculateAndReportNewState();
        this.stickyTransientFailureMode = false;
        this.lastError = null;
        this.latestAddressList = null;
        this.connectionDelayTimeout = setTimeout(() => {
        }, 0);
        clearTimeout(this.connectionDelayTimeout);
        this.reportHealthStatus = options[REPORT_HEALTH_STATUS_OPTION_NAME];
      }
      allChildrenHaveReportedTF() {
        return this.children.every((child) => child.hasReportedTransientFailure);
      }
      resetChildrenReportedTF() {
        this.children.every((child) => child.hasReportedTransientFailure = false);
      }
      calculateAndReportNewState() {
        if (this.currentPick) {
          if (this.reportHealthStatus && !this.currentPick.isHealthy()) {
            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
              details: `Picked subchannel ${this.currentPick.getAddress()} is unhealthy`
            }));
          } else {
            this.updateState(connectivity_state_1.ConnectivityState.READY, new PickFirstPicker(this.currentPick));
          }
        } else if (this.children.length === 0) {
          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        } else {
          if (this.stickyTransientFailureMode) {
            this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
              details: `No connection established. Last error: ${this.lastError}`
            }));
          } else {
            this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
          }
        }
      }
      requestReresolution() {
        this.channelControlHelper.requestReresolution();
      }
      maybeEnterStickyTransientFailureMode() {
        if (!this.allChildrenHaveReportedTF()) {
          return;
        }
        this.requestReresolution();
        this.resetChildrenReportedTF();
        if (this.stickyTransientFailureMode) {
          this.calculateAndReportNewState();
          return;
        }
        this.stickyTransientFailureMode = true;
        for (const { subchannel } of this.children) {
          subchannel.startConnecting();
        }
        this.calculateAndReportNewState();
      }
      removeCurrentPick() {
        if (this.currentPick !== null) {
          this.currentPick.removeConnectivityStateListener(this.subchannelStateListener);
          this.channelControlHelper.removeChannelzChild(this.currentPick.getChannelzRef());
          this.currentPick.removeHealthStateWatcher(this.pickedSubchannelHealthListener);
          this.currentPick.unref();
          this.currentPick = null;
        }
      }
      onSubchannelStateUpdate(subchannel, previousState, newState, errorMessage) {
        var _a2;
        if ((_a2 = this.currentPick) === null || _a2 === void 0 ? void 0 : _a2.realSubchannelEquals(subchannel)) {
          if (newState !== connectivity_state_1.ConnectivityState.READY) {
            this.removeCurrentPick();
            this.calculateAndReportNewState();
          }
          return;
        }
        for (const [index, child] of this.children.entries()) {
          if (subchannel.realSubchannelEquals(child.subchannel)) {
            if (newState === connectivity_state_1.ConnectivityState.READY) {
              this.pickSubchannel(child.subchannel);
            }
            if (newState === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
              child.hasReportedTransientFailure = true;
              if (errorMessage) {
                this.lastError = errorMessage;
              }
              this.maybeEnterStickyTransientFailureMode();
              if (index === this.currentSubchannelIndex) {
                this.startNextSubchannelConnecting(index + 1);
              }
            }
            child.subchannel.startConnecting();
            return;
          }
        }
      }
      startNextSubchannelConnecting(startIndex) {
        clearTimeout(this.connectionDelayTimeout);
        for (const [index, child] of this.children.entries()) {
          if (index >= startIndex) {
            const subchannelState = child.subchannel.getConnectivityState();
            if (subchannelState === connectivity_state_1.ConnectivityState.IDLE || subchannelState === connectivity_state_1.ConnectivityState.CONNECTING) {
              this.startConnecting(index);
              return;
            }
          }
        }
        this.maybeEnterStickyTransientFailureMode();
      }
      /**
       * Have a single subchannel in the `subchannels` list start connecting.
       * @param subchannelIndex The index into the `subchannels` list.
       */
      startConnecting(subchannelIndex) {
        var _a2, _b2;
        clearTimeout(this.connectionDelayTimeout);
        this.currentSubchannelIndex = subchannelIndex;
        if (this.children[subchannelIndex].subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
          trace("Start connecting to subchannel with address " + this.children[subchannelIndex].subchannel.getAddress());
          process.nextTick(() => {
            var _a3;
            (_a3 = this.children[subchannelIndex]) === null || _a3 === void 0 ? void 0 : _a3.subchannel.startConnecting();
          });
        }
        this.connectionDelayTimeout = setTimeout(() => {
          this.startNextSubchannelConnecting(subchannelIndex + 1);
        }, CONNECTION_DELAY_INTERVAL_MS);
        (_b2 = (_a2 = this.connectionDelayTimeout).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a2);
      }
      /**
       * Declare that the specified subchannel should be used to make requests.
       * This functions the same independent of whether subchannel is a member of
       * this.children and whether it is equal to this.currentPick.
       * Prerequisite: subchannel.getConnectivityState() === READY.
       * @param subchannel
       */
      pickSubchannel(subchannel) {
        trace("Pick subchannel with address " + subchannel.getAddress());
        this.stickyTransientFailureMode = false;
        subchannel.ref();
        this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        this.removeCurrentPick();
        this.resetSubchannelList();
        subchannel.addConnectivityStateListener(this.subchannelStateListener);
        subchannel.addHealthStateWatcher(this.pickedSubchannelHealthListener);
        this.currentPick = subchannel;
        clearTimeout(this.connectionDelayTimeout);
        this.calculateAndReportNewState();
      }
      updateState(newState, picker) {
        trace(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const child of this.children) {
          child.subchannel.removeConnectivityStateListener(this.subchannelStateListener);
          child.subchannel.unref();
          this.channelControlHelper.removeChannelzChild(child.subchannel.getChannelzRef());
        }
        this.currentSubchannelIndex = 0;
        this.children = [];
      }
      connectToAddressList(addressList) {
        trace("connectToAddressList([" + addressList.map((address) => (0, subchannel_address_1.subchannelAddressToString)(address)) + "])");
        const newChildrenList = addressList.map((address) => ({
          subchannel: this.channelControlHelper.createSubchannel(address, {}, null),
          hasReportedTransientFailure: false
        }));
        for (const { subchannel } of newChildrenList) {
          if (subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.READY) {
            this.pickSubchannel(subchannel);
            return;
          }
        }
        for (const { subchannel } of newChildrenList) {
          subchannel.ref();
          this.channelControlHelper.addChannelzChild(subchannel.getChannelzRef());
        }
        this.resetSubchannelList();
        this.children = newChildrenList;
        for (const { subchannel } of this.children) {
          subchannel.addConnectivityStateListener(this.subchannelStateListener);
        }
        for (const child of this.children) {
          if (child.subchannel.getConnectivityState() === connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) {
            child.hasReportedTransientFailure = true;
          }
        }
        this.startNextSubchannelConnecting(0);
        this.calculateAndReportNewState();
      }
      updateAddressList(endpointList, lbConfig) {
        if (!(lbConfig instanceof PickFirstLoadBalancingConfig)) {
          return;
        }
        if (lbConfig.getShuffleAddressList()) {
          endpointList = shuffled(endpointList);
        }
        const rawAddressList = [].concat(...endpointList.map((endpoint) => endpoint.addresses));
        trace("updateAddressList([" + rawAddressList.map((address) => (0, subchannel_address_1.subchannelAddressToString)(address)) + "])");
        if (rawAddressList.length === 0) {
          throw new Error("No addresses in endpoint list passed to pick_first");
        }
        const addressList = interleaveAddressFamilies(rawAddressList);
        this.latestAddressList = addressList;
        this.connectToAddressList(addressList);
      }
      exitIdle() {
        if (this.currentState === connectivity_state_1.ConnectivityState.IDLE && this.latestAddressList) {
          this.connectToAddressList(this.latestAddressList);
        }
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
        this.removeCurrentPick();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.PickFirstLoadBalancer = PickFirstLoadBalancer;
    var LEAF_CONFIG = new PickFirstLoadBalancingConfig(false);
    var LeafLoadBalancer = class LeafLoadBalancer {
      static {
        __name(this, "LeafLoadBalancer");
      }
      constructor(endpoint, channelControlHelper, credentials, options) {
        this.endpoint = endpoint;
        this.latestState = connectivity_state_1.ConnectivityState.IDLE;
        const childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
          updateState: /* @__PURE__ */ __name((connectivityState, picker) => {
            this.latestState = connectivityState;
            this.latestPicker = picker;
            channelControlHelper.updateState(connectivityState, picker);
          }, "updateState")
        });
        this.pickFirstBalancer = new PickFirstLoadBalancer(childChannelControlHelper, credentials, Object.assign(Object.assign({}, options), {
          [REPORT_HEALTH_STATUS_OPTION_NAME]: true
        }));
        this.latestPicker = new picker_1.QueuePicker(this.pickFirstBalancer);
      }
      startConnecting() {
        this.pickFirstBalancer.updateAddressList([
          this.endpoint
        ], LEAF_CONFIG);
      }
      /**
       * Update the endpoint associated with this LeafLoadBalancer to a new
       * endpoint. Does not trigger connection establishment if a connection
       * attempt is not already in progress.
       * @param newEndpoint
       */
      updateEndpoint(newEndpoint) {
        this.endpoint = newEndpoint;
        if (this.latestState !== connectivity_state_1.ConnectivityState.IDLE) {
          this.startConnecting();
        }
      }
      getConnectivityState() {
        return this.latestState;
      }
      getPicker() {
        return this.latestPicker;
      }
      getEndpoint() {
        return this.endpoint;
      }
      exitIdle() {
        this.pickFirstBalancer.exitIdle();
      }
      destroy() {
        this.pickFirstBalancer.destroy();
      }
    };
    exports2.LeafLoadBalancer = LeafLoadBalancer;
    function setup() {
      (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, PickFirstLoadBalancer, PickFirstLoadBalancingConfig);
      (0, load_balancer_1.registerDefaultLoadBalancerType)(TYPE_NAME);
    }
    __name(setup, "setup");
  }
});

// node_modules/@grpc/grpc-js/build/src/certificate-provider.js
var require_certificate_provider = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/certificate-provider.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.FileWatcherCertificateProvider = void 0;
    var fs = require("fs");
    var logging = require_logging();
    var constants_1 = require_constants3();
    var util_1 = require("util");
    var TRACER_NAME = "certificate_provider";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    var readFilePromise = (0, util_1.promisify)(fs.readFile);
    var FileWatcherCertificateProvider = class FileWatcherCertificateProvider {
      static {
        __name(this, "FileWatcherCertificateProvider");
      }
      constructor(config) {
        this.config = config;
        this.refreshTimer = null;
        this.fileResultPromise = null;
        this.latestCaUpdate = null;
        this.caListeners = /* @__PURE__ */ new Set();
        this.latestIdentityUpdate = null;
        this.identityListeners = /* @__PURE__ */ new Set();
        this.lastUpdateTime = null;
        if (config.certificateFile === void 0 !== (config.privateKeyFile === void 0)) {
          throw new Error("certificateFile and privateKeyFile must be set or unset together");
        }
        if (config.certificateFile === void 0 && config.caCertificateFile === void 0) {
          throw new Error("At least one of certificateFile and caCertificateFile must be set");
        }
        trace("File watcher constructed with config " + JSON.stringify(config));
      }
      updateCertificates() {
        if (this.fileResultPromise) {
          return;
        }
        this.fileResultPromise = Promise.allSettled([
          this.config.certificateFile ? readFilePromise(this.config.certificateFile) : Promise.reject(),
          this.config.privateKeyFile ? readFilePromise(this.config.privateKeyFile) : Promise.reject(),
          this.config.caCertificateFile ? readFilePromise(this.config.caCertificateFile) : Promise.reject()
        ]);
        this.fileResultPromise.then(([certificateResult, privateKeyResult, caCertificateResult]) => {
          if (!this.refreshTimer) {
            return;
          }
          trace("File watcher read certificates certificate" + (certificateResult ? "!=" : "==") + "null, privateKey" + (privateKeyResult ? "!=" : "==") + "null, CA certificate" + (caCertificateResult ? "!=" : "==") + "null");
          this.lastUpdateTime = /* @__PURE__ */ new Date();
          this.fileResultPromise = null;
          if (certificateResult.status === "fulfilled" && privateKeyResult.status === "fulfilled") {
            this.latestIdentityUpdate = {
              certificate: certificateResult.value,
              privateKey: privateKeyResult.value
            };
          } else {
            this.latestIdentityUpdate = null;
          }
          if (caCertificateResult.status === "fulfilled") {
            this.latestCaUpdate = {
              caCertificate: caCertificateResult.value
            };
          }
          for (const listener of this.identityListeners) {
            listener(this.latestIdentityUpdate);
          }
          for (const listener of this.caListeners) {
            listener(this.latestCaUpdate);
          }
        });
        trace("File watcher initiated certificate update");
      }
      maybeStartWatchingFiles() {
        if (!this.refreshTimer) {
          const timeSinceLastUpdate = this.lastUpdateTime ? (/* @__PURE__ */ new Date()).getTime() - this.lastUpdateTime.getTime() : Infinity;
          if (timeSinceLastUpdate > this.config.refreshIntervalMs) {
            this.updateCertificates();
          }
          if (timeSinceLastUpdate > this.config.refreshIntervalMs * 2) {
            this.latestCaUpdate = null;
            this.latestIdentityUpdate = null;
          }
          this.refreshTimer = setInterval(() => this.updateCertificates(), this.config.refreshIntervalMs);
          trace("File watcher started watching");
        }
      }
      maybeStopWatchingFiles() {
        if (this.caListeners.size === 0 && this.identityListeners.size === 0) {
          this.fileResultPromise = null;
          if (this.refreshTimer) {
            clearInterval(this.refreshTimer);
            this.refreshTimer = null;
          }
        }
      }
      addCaCertificateListener(listener) {
        this.caListeners.add(listener);
        this.maybeStartWatchingFiles();
        process.nextTick(listener, this.latestCaUpdate);
      }
      removeCaCertificateListener(listener) {
        this.caListeners.delete(listener);
        this.maybeStopWatchingFiles();
      }
      addIdentityCertificateListener(listener) {
        this.identityListeners.add(listener);
        this.maybeStartWatchingFiles();
        process.nextTick(listener, this.latestIdentityUpdate);
      }
      removeIdentityCertificateListener(listener) {
        this.identityListeners.delete(listener);
        this.maybeStopWatchingFiles();
      }
    };
    exports2.FileWatcherCertificateProvider = FileWatcherCertificateProvider;
  }
});

// node_modules/@grpc/grpc-js/build/src/experimental.js
var require_experimental = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/experimental.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.createCertificateProviderChannelCredentials = exports2.FileWatcherCertificateProvider = exports2.createCertificateProviderServerCredentials = exports2.createServerCredentialsWithInterceptors = exports2.BaseSubchannelWrapper = exports2.registerAdminService = exports2.FilterStackFactory = exports2.BaseFilter = exports2.PickResultType = exports2.QueuePicker = exports2.UnavailablePicker = exports2.ChildLoadBalancerHandler = exports2.EndpointMap = exports2.endpointHasAddress = exports2.endpointToString = exports2.subchannelAddressToString = exports2.LeafLoadBalancer = exports2.isLoadBalancerNameRegistered = exports2.parseLoadBalancingConfig = exports2.selectLbConfigFromList = exports2.registerLoadBalancerType = exports2.createChildChannelControlHelper = exports2.BackoffTimeout = exports2.parseDuration = exports2.durationToMs = exports2.splitHostPort = exports2.uriToString = exports2.createResolver = exports2.registerResolver = exports2.log = exports2.trace = void 0;
    var logging_1 = require_logging();
    Object.defineProperty(exports2, "trace", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return logging_1.trace;
      }, "get")
    });
    Object.defineProperty(exports2, "log", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return logging_1.log;
      }, "get")
    });
    var resolver_1 = require_resolver();
    Object.defineProperty(exports2, "registerResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return resolver_1.registerResolver;
      }, "get")
    });
    Object.defineProperty(exports2, "createResolver", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return resolver_1.createResolver;
      }, "get")
    });
    var uri_parser_1 = require_uri_parser();
    Object.defineProperty(exports2, "uriToString", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return uri_parser_1.uriToString;
      }, "get")
    });
    Object.defineProperty(exports2, "splitHostPort", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return uri_parser_1.splitHostPort;
      }, "get")
    });
    var duration_1 = require_duration();
    Object.defineProperty(exports2, "durationToMs", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return duration_1.durationToMs;
      }, "get")
    });
    Object.defineProperty(exports2, "parseDuration", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return duration_1.parseDuration;
      }, "get")
    });
    var backoff_timeout_1 = require_backoff_timeout();
    Object.defineProperty(exports2, "BackoffTimeout", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return backoff_timeout_1.BackoffTimeout;
      }, "get")
    });
    var load_balancer_1 = require_load_balancer();
    Object.defineProperty(exports2, "createChildChannelControlHelper", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return load_balancer_1.createChildChannelControlHelper;
      }, "get")
    });
    Object.defineProperty(exports2, "registerLoadBalancerType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return load_balancer_1.registerLoadBalancerType;
      }, "get")
    });
    Object.defineProperty(exports2, "selectLbConfigFromList", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return load_balancer_1.selectLbConfigFromList;
      }, "get")
    });
    Object.defineProperty(exports2, "parseLoadBalancingConfig", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return load_balancer_1.parseLoadBalancingConfig;
      }, "get")
    });
    Object.defineProperty(exports2, "isLoadBalancerNameRegistered", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return load_balancer_1.isLoadBalancerNameRegistered;
      }, "get")
    });
    var load_balancer_pick_first_1 = require_load_balancer_pick_first();
    Object.defineProperty(exports2, "LeafLoadBalancer", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return load_balancer_pick_first_1.LeafLoadBalancer;
      }, "get")
    });
    var subchannel_address_1 = require_subchannel_address();
    Object.defineProperty(exports2, "subchannelAddressToString", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return subchannel_address_1.subchannelAddressToString;
      }, "get")
    });
    Object.defineProperty(exports2, "endpointToString", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return subchannel_address_1.endpointToString;
      }, "get")
    });
    Object.defineProperty(exports2, "endpointHasAddress", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return subchannel_address_1.endpointHasAddress;
      }, "get")
    });
    Object.defineProperty(exports2, "EndpointMap", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return subchannel_address_1.EndpointMap;
      }, "get")
    });
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    Object.defineProperty(exports2, "ChildLoadBalancerHandler", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return load_balancer_child_handler_1.ChildLoadBalancerHandler;
      }, "get")
    });
    var picker_1 = require_picker();
    Object.defineProperty(exports2, "UnavailablePicker", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return picker_1.UnavailablePicker;
      }, "get")
    });
    Object.defineProperty(exports2, "QueuePicker", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return picker_1.QueuePicker;
      }, "get")
    });
    Object.defineProperty(exports2, "PickResultType", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return picker_1.PickResultType;
      }, "get")
    });
    var filter_1 = require_filter();
    Object.defineProperty(exports2, "BaseFilter", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return filter_1.BaseFilter;
      }, "get")
    });
    var filter_stack_1 = require_filter_stack();
    Object.defineProperty(exports2, "FilterStackFactory", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return filter_stack_1.FilterStackFactory;
      }, "get")
    });
    var admin_1 = require_admin();
    Object.defineProperty(exports2, "registerAdminService", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return admin_1.registerAdminService;
      }, "get")
    });
    var subchannel_interface_1 = require_subchannel_interface();
    Object.defineProperty(exports2, "BaseSubchannelWrapper", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return subchannel_interface_1.BaseSubchannelWrapper;
      }, "get")
    });
    var server_credentials_1 = require_server_credentials();
    Object.defineProperty(exports2, "createServerCredentialsWithInterceptors", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return server_credentials_1.createServerCredentialsWithInterceptors;
      }, "get")
    });
    Object.defineProperty(exports2, "createCertificateProviderServerCredentials", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return server_credentials_1.createCertificateProviderServerCredentials;
      }, "get")
    });
    var certificate_provider_1 = require_certificate_provider();
    Object.defineProperty(exports2, "FileWatcherCertificateProvider", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return certificate_provider_1.FileWatcherCertificateProvider;
      }, "get")
    });
    var channel_credentials_1 = require_channel_credentials();
    Object.defineProperty(exports2, "createCertificateProviderChannelCredentials", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return channel_credentials_1.createCertificateProviderChannelCredentials;
      }, "get")
    });
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-uds.js
var require_resolver_uds = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-uds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.setup = setup;
    var resolver_1 = require_resolver();
    var UdsResolver = class UdsResolver {
      static {
        __name(this, "UdsResolver");
      }
      constructor(target, listener, channelOptions) {
        this.listener = listener;
        this.hasReturnedResult = false;
        this.endpoints = [];
        let path;
        if (target.authority === "") {
          path = "/" + target.path;
        } else {
          path = target.path;
        }
        this.endpoints = [
          {
            addresses: [
              {
                path
              }
            ]
          }
        ];
      }
      updateResolution() {
        if (!this.hasReturnedResult) {
          this.hasReturnedResult = true;
          process.nextTick(this.listener.onSuccessfulResolution, this.endpoints, null, null, null, {});
        }
      }
      destroy() {
        this.hasReturnedResult = false;
      }
      static getDefaultAuthority(target) {
        return "localhost";
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)("unix", UdsResolver);
    }
    __name(setup, "setup");
  }
});

// node_modules/@grpc/grpc-js/build/src/resolver-ip.js
var require_resolver_ip = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/resolver-ip.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.setup = setup;
    var net_1 = require("net");
    var constants_1 = require_constants3();
    var metadata_1 = require_metadata2();
    var resolver_1 = require_resolver();
    var uri_parser_1 = require_uri_parser();
    var logging = require_logging();
    var TRACER_NAME = "ip_resolver";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    var IPV4_SCHEME = "ipv4";
    var IPV6_SCHEME = "ipv6";
    var DEFAULT_PORT = 443;
    var IpResolver = class IpResolver {
      static {
        __name(this, "IpResolver");
      }
      constructor(target, listener, channelOptions) {
        var _a2;
        this.listener = listener;
        this.endpoints = [];
        this.error = null;
        this.hasReturnedResult = false;
        trace("Resolver constructed for target " + (0, uri_parser_1.uriToString)(target));
        const addresses = [];
        if (!(target.scheme === IPV4_SCHEME || target.scheme === IPV6_SCHEME)) {
          this.error = {
            code: constants_1.Status.UNAVAILABLE,
            details: `Unrecognized scheme ${target.scheme} in IP resolver`,
            metadata: new metadata_1.Metadata()
          };
          return;
        }
        const pathList = target.path.split(",");
        for (const path of pathList) {
          const hostPort = (0, uri_parser_1.splitHostPort)(path);
          if (hostPort === null) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          if (target.scheme === IPV4_SCHEME && !(0, net_1.isIPv4)(hostPort.host) || target.scheme === IPV6_SCHEME && !(0, net_1.isIPv6)(hostPort.host)) {
            this.error = {
              code: constants_1.Status.UNAVAILABLE,
              details: `Failed to parse ${target.scheme} address ${path}`,
              metadata: new metadata_1.Metadata()
            };
            return;
          }
          addresses.push({
            host: hostPort.host,
            port: (_a2 = hostPort.port) !== null && _a2 !== void 0 ? _a2 : DEFAULT_PORT
          });
        }
        this.endpoints = addresses.map((address) => ({
          addresses: [
            address
          ]
        }));
        trace("Parsed " + target.scheme + " address list " + addresses);
      }
      updateResolution() {
        if (!this.hasReturnedResult) {
          this.hasReturnedResult = true;
          process.nextTick(() => {
            if (this.error) {
              this.listener.onError(this.error);
            } else {
              this.listener.onSuccessfulResolution(this.endpoints, null, null, null, {});
            }
          });
        }
      }
      destroy() {
        this.hasReturnedResult = false;
      }
      static getDefaultAuthority(target) {
        return target.path.split(",")[0];
      }
    };
    function setup() {
      (0, resolver_1.registerResolver)(IPV4_SCHEME, IpResolver);
      (0, resolver_1.registerResolver)(IPV6_SCHEME, IpResolver);
    }
    __name(setup, "setup");
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js
var require_load_balancer_round_robin = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-round-robin.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.RoundRobinLoadBalancer = void 0;
    exports2.setup = setup;
    var load_balancer_1 = require_load_balancer();
    var connectivity_state_1 = require_connectivity_state();
    var picker_1 = require_picker();
    var logging = require_logging();
    var constants_1 = require_constants3();
    var subchannel_address_1 = require_subchannel_address();
    var load_balancer_pick_first_1 = require_load_balancer_pick_first();
    var TRACER_NAME = "round_robin";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    var TYPE_NAME = "round_robin";
    var RoundRobinLoadBalancingConfig = class RoundRobinLoadBalancingConfig2 {
      static {
        __name(this, "RoundRobinLoadBalancingConfig");
      }
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      constructor() {
      }
      toJsonObject() {
        return {
          [TYPE_NAME]: {}
        };
      }
      // eslint-disable-next-line @typescript-eslint/no-explicit-any
      static createFromJson(obj) {
        return new RoundRobinLoadBalancingConfig2();
      }
    };
    var RoundRobinPicker = class RoundRobinPicker {
      static {
        __name(this, "RoundRobinPicker");
      }
      constructor(children, nextIndex = 0) {
        this.children = children;
        this.nextIndex = nextIndex;
      }
      pick(pickArgs) {
        const childPicker = this.children[this.nextIndex].picker;
        this.nextIndex = (this.nextIndex + 1) % this.children.length;
        return childPicker.pick(pickArgs);
      }
      /**
       * Check what the next subchannel returned would be. Used by the load
       * balancer implementation to preserve this part of the picker state if
       * possible when a subchannel connects or disconnects.
       */
      peekNextEndpoint() {
        return this.children[this.nextIndex].endpoint;
      }
    };
    var RoundRobinLoadBalancer = class RoundRobinLoadBalancer {
      static {
        __name(this, "RoundRobinLoadBalancer");
      }
      constructor(channelControlHelper, credentials, options) {
        this.channelControlHelper = channelControlHelper;
        this.credentials = credentials;
        this.options = options;
        this.children = [];
        this.currentState = connectivity_state_1.ConnectivityState.IDLE;
        this.currentReadyPicker = null;
        this.updatesPaused = false;
        this.lastError = null;
        this.childChannelControlHelper = (0, load_balancer_1.createChildChannelControlHelper)(channelControlHelper, {
          updateState: /* @__PURE__ */ __name((connectivityState, picker) => {
            if (this.currentState === connectivity_state_1.ConnectivityState.READY && connectivityState !== connectivity_state_1.ConnectivityState.READY) {
              this.channelControlHelper.requestReresolution();
            }
            this.calculateAndUpdateState();
          }, "updateState")
        });
      }
      countChildrenWithState(state) {
        return this.children.filter((child) => child.getConnectivityState() === state).length;
      }
      calculateAndUpdateState() {
        if (this.updatesPaused) {
          return;
        }
        if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.READY) > 0) {
          const readyChildren = this.children.filter((child) => child.getConnectivityState() === connectivity_state_1.ConnectivityState.READY);
          let index = 0;
          if (this.currentReadyPicker !== null) {
            const nextPickedEndpoint = this.currentReadyPicker.peekNextEndpoint();
            index = readyChildren.findIndex((child) => (0, subchannel_address_1.endpointEqual)(child.getEndpoint(), nextPickedEndpoint));
            if (index < 0) {
              index = 0;
            }
          }
          this.updateState(connectivity_state_1.ConnectivityState.READY, new RoundRobinPicker(readyChildren.map((child) => ({
            endpoint: child.getEndpoint(),
            picker: child.getPicker()
          })), index));
        } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.CONNECTING) > 0) {
          this.updateState(connectivity_state_1.ConnectivityState.CONNECTING, new picker_1.QueuePicker(this));
        } else if (this.countChildrenWithState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE) > 0) {
          this.updateState(connectivity_state_1.ConnectivityState.TRANSIENT_FAILURE, new picker_1.UnavailablePicker({
            details: `No connection established. Last error: ${this.lastError}`
          }));
        } else {
          this.updateState(connectivity_state_1.ConnectivityState.IDLE, new picker_1.QueuePicker(this));
        }
        for (const child of this.children) {
          if (child.getConnectivityState() === connectivity_state_1.ConnectivityState.IDLE) {
            child.exitIdle();
          }
        }
      }
      updateState(newState, picker) {
        trace(connectivity_state_1.ConnectivityState[this.currentState] + " -> " + connectivity_state_1.ConnectivityState[newState]);
        if (newState === connectivity_state_1.ConnectivityState.READY) {
          this.currentReadyPicker = picker;
        } else {
          this.currentReadyPicker = null;
        }
        this.currentState = newState;
        this.channelControlHelper.updateState(newState, picker);
      }
      resetSubchannelList() {
        for (const child of this.children) {
          child.destroy();
        }
      }
      updateAddressList(endpointList, lbConfig) {
        this.resetSubchannelList();
        trace("Connect to endpoint list " + endpointList.map(subchannel_address_1.endpointToString));
        this.updatesPaused = true;
        this.children = endpointList.map((endpoint) => new load_balancer_pick_first_1.LeafLoadBalancer(endpoint, this.childChannelControlHelper, this.credentials, this.options));
        for (const child of this.children) {
          child.startConnecting();
        }
        this.updatesPaused = false;
        this.calculateAndUpdateState();
      }
      exitIdle() {
      }
      resetBackoff() {
      }
      destroy() {
        this.resetSubchannelList();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.RoundRobinLoadBalancer = RoundRobinLoadBalancer;
    function setup() {
      (0, load_balancer_1.registerLoadBalancerType)(TYPE_NAME, RoundRobinLoadBalancer, RoundRobinLoadBalancingConfig);
    }
    __name(setup, "setup");
  }
});

// node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js
var require_load_balancer_outlier_detection = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/load-balancer-outlier-detection.js"(exports2) {
    "use strict";
    var _a2;
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.OutlierDetectionLoadBalancer = exports2.OutlierDetectionLoadBalancingConfig = void 0;
    exports2.setup = setup;
    var connectivity_state_1 = require_connectivity_state();
    var constants_1 = require_constants3();
    var duration_1 = require_duration();
    var experimental_1 = require_experimental();
    var load_balancer_1 = require_load_balancer();
    var load_balancer_child_handler_1 = require_load_balancer_child_handler();
    var picker_1 = require_picker();
    var subchannel_address_1 = require_subchannel_address();
    var subchannel_interface_1 = require_subchannel_interface();
    var logging = require_logging();
    var TRACER_NAME = "outlier_detection";
    function trace(text) {
      logging.trace(constants_1.LogVerbosity.DEBUG, TRACER_NAME, text);
    }
    __name(trace, "trace");
    var TYPE_NAME = "outlier_detection";
    var OUTLIER_DETECTION_ENABLED = ((_a2 = process.env.GRPC_EXPERIMENTAL_ENABLE_OUTLIER_DETECTION) !== null && _a2 !== void 0 ? _a2 : "true") === "true";
    var defaultSuccessRateEjectionConfig = {
      stdev_factor: 1900,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 100
    };
    var defaultFailurePercentageEjectionConfig = {
      threshold: 85,
      enforcement_percentage: 100,
      minimum_hosts: 5,
      request_volume: 50
    };
    function validateFieldType(obj, fieldName, expectedType, objectName) {
      if (fieldName in obj && obj[fieldName] !== void 0 && typeof obj[fieldName] !== expectedType) {
        const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
        throw new Error(`outlier detection config ${fullFieldName} parse error: expected ${expectedType}, got ${typeof obj[fieldName]}`);
      }
    }
    __name(validateFieldType, "validateFieldType");
    function validatePositiveDuration(obj, fieldName, objectName) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      if (fieldName in obj && obj[fieldName] !== void 0) {
        if (!(0, duration_1.isDuration)(obj[fieldName])) {
          throw new Error(`outlier detection config ${fullFieldName} parse error: expected Duration, got ${typeof obj[fieldName]}`);
        }
        if (!(obj[fieldName].seconds >= 0 && obj[fieldName].seconds <= 315576e6 && obj[fieldName].nanos >= 0 && obj[fieldName].nanos <= 999999999)) {
          throw new Error(`outlier detection config ${fullFieldName} parse error: values out of range for non-negative Duaration`);
        }
      }
    }
    __name(validatePositiveDuration, "validatePositiveDuration");
    function validatePercentage(obj, fieldName, objectName) {
      const fullFieldName = objectName ? `${objectName}.${fieldName}` : fieldName;
      validateFieldType(obj, fieldName, "number", objectName);
      if (fieldName in obj && obj[fieldName] !== void 0 && !(obj[fieldName] >= 0 && obj[fieldName] <= 100)) {
        throw new Error(`outlier detection config ${fullFieldName} parse error: value out of range for percentage (0-100)`);
      }
    }
    __name(validatePercentage, "validatePercentage");
    var OutlierDetectionLoadBalancingConfig = class OutlierDetectionLoadBalancingConfig2 {
      static {
        __name(this, "OutlierDetectionLoadBalancingConfig");
      }
      constructor(intervalMs, baseEjectionTimeMs, maxEjectionTimeMs, maxEjectionPercent, successRateEjection, failurePercentageEjection, childPolicy) {
        this.childPolicy = childPolicy;
        if (childPolicy.getLoadBalancerName() === "pick_first") {
          throw new Error("outlier_detection LB policy cannot have a pick_first child policy");
        }
        this.intervalMs = intervalMs !== null && intervalMs !== void 0 ? intervalMs : 1e4;
        this.baseEjectionTimeMs = baseEjectionTimeMs !== null && baseEjectionTimeMs !== void 0 ? baseEjectionTimeMs : 3e4;
        this.maxEjectionTimeMs = maxEjectionTimeMs !== null && maxEjectionTimeMs !== void 0 ? maxEjectionTimeMs : 3e5;
        this.maxEjectionPercent = maxEjectionPercent !== null && maxEjectionPercent !== void 0 ? maxEjectionPercent : 10;
        this.successRateEjection = successRateEjection ? Object.assign(Object.assign({}, defaultSuccessRateEjectionConfig), successRateEjection) : null;
        this.failurePercentageEjection = failurePercentageEjection ? Object.assign(Object.assign({}, defaultFailurePercentageEjectionConfig), failurePercentageEjection) : null;
      }
      getLoadBalancerName() {
        return TYPE_NAME;
      }
      toJsonObject() {
        var _a3, _b2;
        return {
          outlier_detection: {
            interval: (0, duration_1.msToDuration)(this.intervalMs),
            base_ejection_time: (0, duration_1.msToDuration)(this.baseEjectionTimeMs),
            max_ejection_time: (0, duration_1.msToDuration)(this.maxEjectionTimeMs),
            max_ejection_percent: this.maxEjectionPercent,
            success_rate_ejection: (_a3 = this.successRateEjection) !== null && _a3 !== void 0 ? _a3 : void 0,
            failure_percentage_ejection: (_b2 = this.failurePercentageEjection) !== null && _b2 !== void 0 ? _b2 : void 0,
            child_policy: [
              this.childPolicy.toJsonObject()
            ]
          }
        };
      }
      getIntervalMs() {
        return this.intervalMs;
      }
      getBaseEjectionTimeMs() {
        return this.baseEjectionTimeMs;
      }
      getMaxEjectionTimeMs() {
        return this.maxEjectionTimeMs;
      }
      getMaxEjectionPercent() {
        return this.maxEjectionPercent;
      }
      getSuccessRateEjectionConfig() {
        return this.successRateEjection;
      }
      getFailurePercentageEjectionConfig() {
        return this.failurePercentageEjection;
      }
      getChildPolicy() {
        return this.childPolicy;
      }
      static createFromJson(obj) {
        var _a3;
        validatePositiveDuration(obj, "interval");
        validatePositiveDuration(obj, "base_ejection_time");
        validatePositiveDuration(obj, "max_ejection_time");
        validatePercentage(obj, "max_ejection_percent");
        if ("success_rate_ejection" in obj && obj.success_rate_ejection !== void 0) {
          if (typeof obj.success_rate_ejection !== "object") {
            throw new Error("outlier detection config success_rate_ejection must be an object");
          }
          validateFieldType(obj.success_rate_ejection, "stdev_factor", "number", "success_rate_ejection");
          validatePercentage(obj.success_rate_ejection, "enforcement_percentage", "success_rate_ejection");
          validateFieldType(obj.success_rate_ejection, "minimum_hosts", "number", "success_rate_ejection");
          validateFieldType(obj.success_rate_ejection, "request_volume", "number", "success_rate_ejection");
        }
        if ("failure_percentage_ejection" in obj && obj.failure_percentage_ejection !== void 0) {
          if (typeof obj.failure_percentage_ejection !== "object") {
            throw new Error("outlier detection config failure_percentage_ejection must be an object");
          }
          validatePercentage(obj.failure_percentage_ejection, "threshold", "failure_percentage_ejection");
          validatePercentage(obj.failure_percentage_ejection, "enforcement_percentage", "failure_percentage_ejection");
          validateFieldType(obj.failure_percentage_ejection, "minimum_hosts", "number", "failure_percentage_ejection");
          validateFieldType(obj.failure_percentage_ejection, "request_volume", "number", "failure_percentage_ejection");
        }
        if (!("child_policy" in obj) || !Array.isArray(obj.child_policy)) {
          throw new Error("outlier detection config child_policy must be an array");
        }
        const childPolicy = (0, load_balancer_1.selectLbConfigFromList)(obj.child_policy);
        if (!childPolicy) {
          throw new Error("outlier detection config child_policy: no valid recognized policy found");
        }
        return new OutlierDetectionLoadBalancingConfig2(obj.interval ? (0, duration_1.durationToMs)(obj.interval) : null, obj.base_ejection_time ? (0, duration_1.durationToMs)(obj.base_ejection_time) : null, obj.max_ejection_time ? (0, duration_1.durationToMs)(obj.max_ejection_time) : null, (_a3 = obj.max_ejection_percent) !== null && _a3 !== void 0 ? _a3 : null, obj.success_rate_ejection, obj.failure_percentage_ejection, childPolicy);
      }
    };
    exports2.OutlierDetectionLoadBalancingConfig = OutlierDetectionLoadBalancingConfig;
    var OutlierDetectionSubchannelWrapper = class OutlierDetectionSubchannelWrapper extends subchannel_interface_1.BaseSubchannelWrapper {
      static {
        __name(this, "OutlierDetectionSubchannelWrapper");
      }
      constructor(childSubchannel, mapEntry) {
        super(childSubchannel);
        this.mapEntry = mapEntry;
        this.refCount = 0;
      }
      ref() {
        this.child.ref();
        this.refCount += 1;
      }
      unref() {
        this.child.unref();
        this.refCount -= 1;
        if (this.refCount <= 0) {
          if (this.mapEntry) {
            const index = this.mapEntry.subchannelWrappers.indexOf(this);
            if (index >= 0) {
              this.mapEntry.subchannelWrappers.splice(index, 1);
            }
          }
        }
      }
      eject() {
        this.setHealthy(false);
      }
      uneject() {
        this.setHealthy(true);
      }
      getMapEntry() {
        return this.mapEntry;
      }
      getWrappedSubchannel() {
        return this.child;
      }
    };
    function createEmptyBucket() {
      return {
        success: 0,
        failure: 0
      };
    }
    __name(createEmptyBucket, "createEmptyBucket");
    var CallCounter = class CallCounter {
      static {
        __name(this, "CallCounter");
      }
      constructor() {
        this.activeBucket = createEmptyBucket();
        this.inactiveBucket = createEmptyBucket();
      }
      addSuccess() {
        this.activeBucket.success += 1;
      }
      addFailure() {
        this.activeBucket.failure += 1;
      }
      switchBuckets() {
        this.inactiveBucket = this.activeBucket;
        this.activeBucket = createEmptyBucket();
      }
      getLastSuccesses() {
        return this.inactiveBucket.success;
      }
      getLastFailures() {
        return this.inactiveBucket.failure;
      }
    };
    var OutlierDetectionPicker = class OutlierDetectionPicker {
      static {
        __name(this, "OutlierDetectionPicker");
      }
      constructor(wrappedPicker, countCalls) {
        this.wrappedPicker = wrappedPicker;
        this.countCalls = countCalls;
      }
      pick(pickArgs) {
        const wrappedPick = this.wrappedPicker.pick(pickArgs);
        if (wrappedPick.pickResultType === picker_1.PickResultType.COMPLETE) {
          const subchannelWrapper = wrappedPick.subchannel;
          const mapEntry = subchannelWrapper.getMapEntry();
          if (mapEntry) {
            let onCallEnded = wrappedPick.onCallEnded;
            if (this.countCalls) {
              onCallEnded = /* @__PURE__ */ __name((statusCode) => {
                var _a3;
                if (statusCode === constants_1.Status.OK) {
                  mapEntry.counter.addSuccess();
                } else {
                  mapEntry.counter.addFailure();
                }
                (_a3 = wrappedPick.onCallEnded) === null || _a3 === void 0 ? void 0 : _a3.call(wrappedPick, statusCode);
              }, "onCallEnded");
            }
            return Object.assign(Object.assign({}, wrappedPick), {
              subchannel: subchannelWrapper.getWrappedSubchannel(),
              onCallEnded
            });
          } else {
            return Object.assign(Object.assign({}, wrappedPick), {
              subchannel: subchannelWrapper.getWrappedSubchannel()
            });
          }
        } else {
          return wrappedPick;
        }
      }
    };
    var OutlierDetectionLoadBalancer = class OutlierDetectionLoadBalancer {
      static {
        __name(this, "OutlierDetectionLoadBalancer");
      }
      constructor(channelControlHelper, credentials, options) {
        this.entryMap = new subchannel_address_1.EndpointMap();
        this.latestConfig = null;
        this.timerStartTime = null;
        this.childBalancer = new load_balancer_child_handler_1.ChildLoadBalancerHandler((0, experimental_1.createChildChannelControlHelper)(channelControlHelper, {
          createSubchannel: /* @__PURE__ */ __name((subchannelAddress, subchannelArgs, credentialsOverride) => {
            const originalSubchannel = channelControlHelper.createSubchannel(subchannelAddress, subchannelArgs, credentialsOverride);
            const mapEntry = this.entryMap.getForSubchannelAddress(subchannelAddress);
            const subchannelWrapper = new OutlierDetectionSubchannelWrapper(originalSubchannel, mapEntry);
            if ((mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.currentEjectionTimestamp) !== null) {
              subchannelWrapper.eject();
            }
            mapEntry === null || mapEntry === void 0 ? void 0 : mapEntry.subchannelWrappers.push(subchannelWrapper);
            return subchannelWrapper;
          }, "createSubchannel"),
          updateState: /* @__PURE__ */ __name((connectivityState, picker) => {
            if (connectivityState === connectivity_state_1.ConnectivityState.READY) {
              channelControlHelper.updateState(connectivityState, new OutlierDetectionPicker(picker, this.isCountingEnabled()));
            } else {
              channelControlHelper.updateState(connectivityState, picker);
            }
          }, "updateState")
        }), credentials, options);
        this.ejectionTimer = setInterval(() => {
        }, 0);
        clearInterval(this.ejectionTimer);
      }
      isCountingEnabled() {
        return this.latestConfig !== null && (this.latestConfig.getSuccessRateEjectionConfig() !== null || this.latestConfig.getFailurePercentageEjectionConfig() !== null);
      }
      getCurrentEjectionPercent() {
        let ejectionCount = 0;
        for (const mapEntry of this.entryMap.values()) {
          if (mapEntry.currentEjectionTimestamp !== null) {
            ejectionCount += 1;
          }
        }
        return ejectionCount * 100 / this.entryMap.size;
      }
      runSuccessRateCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
          return;
        }
        const successRateConfig = this.latestConfig.getSuccessRateEjectionConfig();
        if (!successRateConfig) {
          return;
        }
        trace("Running success rate check");
        const targetRequestVolume = successRateConfig.request_volume;
        let addresesWithTargetVolume = 0;
        const successRates = [];
        for (const [endpoint, mapEntry] of this.entryMap.entries()) {
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          trace("Stats for " + (0, subchannel_address_1.endpointToString)(endpoint) + ": successes=" + successes + " failures=" + failures + " targetRequestVolume=" + targetRequestVolume);
          if (successes + failures >= targetRequestVolume) {
            addresesWithTargetVolume += 1;
            successRates.push(successes / (successes + failures));
          }
        }
        trace("Found " + addresesWithTargetVolume + " success rate candidates; currentEjectionPercent=" + this.getCurrentEjectionPercent() + " successRates=[" + successRates + "]");
        if (addresesWithTargetVolume < successRateConfig.minimum_hosts) {
          return;
        }
        const successRateMean = successRates.reduce((a, b) => a + b) / successRates.length;
        let successRateDeviationSum = 0;
        for (const rate of successRates) {
          const deviation = rate - successRateMean;
          successRateDeviationSum += deviation * deviation;
        }
        const successRateVariance = successRateDeviationSum / successRates.length;
        const successRateStdev = Math.sqrt(successRateVariance);
        const ejectionThreshold = successRateMean - successRateStdev * (successRateConfig.stdev_factor / 1e3);
        trace("stdev=" + successRateStdev + " ejectionThreshold=" + ejectionThreshold);
        for (const [address, mapEntry] of this.entryMap.entries()) {
          if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {
            break;
          }
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          if (successes + failures < targetRequestVolume) {
            continue;
          }
          const successRate = successes / (successes + failures);
          trace("Checking candidate " + address + " successRate=" + successRate);
          if (successRate < ejectionThreshold) {
            const randomNumber = Math.random() * 100;
            trace("Candidate " + address + " randomNumber=" + randomNumber + " enforcement_percentage=" + successRateConfig.enforcement_percentage);
            if (randomNumber < successRateConfig.enforcement_percentage) {
              trace("Ejecting candidate " + address);
              this.eject(mapEntry, ejectionTimestamp);
            }
          }
        }
      }
      runFailurePercentageCheck(ejectionTimestamp) {
        if (!this.latestConfig) {
          return;
        }
        const failurePercentageConfig = this.latestConfig.getFailurePercentageEjectionConfig();
        if (!failurePercentageConfig) {
          return;
        }
        trace("Running failure percentage check. threshold=" + failurePercentageConfig.threshold + " request volume threshold=" + failurePercentageConfig.request_volume);
        let addressesWithTargetVolume = 0;
        for (const mapEntry of this.entryMap.values()) {
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          if (successes + failures >= failurePercentageConfig.request_volume) {
            addressesWithTargetVolume += 1;
          }
        }
        if (addressesWithTargetVolume < failurePercentageConfig.minimum_hosts) {
          return;
        }
        for (const [address, mapEntry] of this.entryMap.entries()) {
          if (this.getCurrentEjectionPercent() >= this.latestConfig.getMaxEjectionPercent()) {
            break;
          }
          const successes = mapEntry.counter.getLastSuccesses();
          const failures = mapEntry.counter.getLastFailures();
          trace("Candidate successes=" + successes + " failures=" + failures);
          if (successes + failures < failurePercentageConfig.request_volume) {
            continue;
          }
          const failurePercentage = failures * 100 / (failures + successes);
          if (failurePercentage > failurePercentageConfig.threshold) {
            const randomNumber = Math.random() * 100;
            trace("Candidate " + address + " randomNumber=" + randomNumber + " enforcement_percentage=" + failurePercentageConfig.enforcement_percentage);
            if (randomNumber < failurePercentageConfig.enforcement_percentage) {
              trace("Ejecting candidate " + address);
              this.eject(mapEntry, ejectionTimestamp);
            }
          }
        }
      }
      eject(mapEntry, ejectionTimestamp) {
        mapEntry.currentEjectionTimestamp = /* @__PURE__ */ new Date();
        mapEntry.ejectionTimeMultiplier += 1;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
          subchannelWrapper.eject();
        }
      }
      uneject(mapEntry) {
        mapEntry.currentEjectionTimestamp = null;
        for (const subchannelWrapper of mapEntry.subchannelWrappers) {
          subchannelWrapper.uneject();
        }
      }
      switchAllBuckets() {
        for (const mapEntry of this.entryMap.values()) {
          mapEntry.counter.switchBuckets();
        }
      }
      startTimer(delayMs) {
        var _a3, _b2;
        this.ejectionTimer = setTimeout(() => this.runChecks(), delayMs);
        (_b2 = (_a3 = this.ejectionTimer).unref) === null || _b2 === void 0 ? void 0 : _b2.call(_a3);
      }
      runChecks() {
        const ejectionTimestamp = /* @__PURE__ */ new Date();
        trace("Ejection timer running");
        this.switchAllBuckets();
        if (!this.latestConfig) {
          return;
        }
        this.timerStartTime = ejectionTimestamp;
        this.startTimer(this.latestConfig.getIntervalMs());
        this.runSuccessRateCheck(ejectionTimestamp);
        this.runFailurePercentageCheck(ejectionTimestamp);
        for (const [address, mapEntry] of this.entryMap.entries()) {
          if (mapEntry.currentEjectionTimestamp === null) {
            if (mapEntry.ejectionTimeMultiplier > 0) {
              mapEntry.ejectionTimeMultiplier -= 1;
            }
          } else {
            const baseEjectionTimeMs = this.latestConfig.getBaseEjectionTimeMs();
            const maxEjectionTimeMs = this.latestConfig.getMaxEjectionTimeMs();
            const returnTime = new Date(mapEntry.currentEjectionTimestamp.getTime());
            returnTime.setMilliseconds(returnTime.getMilliseconds() + Math.min(baseEjectionTimeMs * mapEntry.ejectionTimeMultiplier, Math.max(baseEjectionTimeMs, maxEjectionTimeMs)));
            if (returnTime < /* @__PURE__ */ new Date()) {
              trace("Unejecting " + address);
              this.uneject(mapEntry);
            }
          }
        }
      }
      updateAddressList(endpointList, lbConfig, attributes) {
        if (!(lbConfig instanceof OutlierDetectionLoadBalancingConfig)) {
          return;
        }
        for (const endpoint of endpointList) {
          if (!this.entryMap.has(endpoint)) {
            trace("Adding map entry for " + (0, subchannel_address_1.endpointToString)(endpoint));
            this.entryMap.set(endpoint, {
              counter: new CallCounter(),
              currentEjectionTimestamp: null,
              ejectionTimeMultiplier: 0,
              subchannelWrappers: []
            });
          }
        }
        this.entryMap.deleteMissing(endpointList);
        const childPolicy = lbConfig.getChildPolicy();
        this.childBalancer.updateAddressList(endpointList, childPolicy, attributes);
        if (lbConfig.getSuccessRateEjectionConfig() || lbConfig.getFailurePercentageEjectionConfig()) {
          if (this.timerStartTime) {
            trace("Previous timer existed. Replacing timer");
            clearTimeout(this.ejectionTimer);
            const remainingDelay = lbConfig.getIntervalMs() - ((/* @__PURE__ */ new Date()).getTime() - this.timerStartTime.getTime());
            this.startTimer(remainingDelay);
          } else {
            trace("Starting new timer");
            this.timerStartTime = /* @__PURE__ */ new Date();
            this.startTimer(lbConfig.getIntervalMs());
            this.switchAllBuckets();
          }
        } else {
          trace("Counting disabled. Cancelling timer.");
          this.timerStartTime = null;
          clearTimeout(this.ejectionTimer);
          for (const mapEntry of this.entryMap.values()) {
            this.uneject(mapEntry);
            mapEntry.ejectionTimeMultiplier = 0;
          }
        }
        this.latestConfig = lbConfig;
      }
      exitIdle() {
        this.childBalancer.exitIdle();
      }
      resetBackoff() {
        this.childBalancer.resetBackoff();
      }
      destroy() {
        clearTimeout(this.ejectionTimer);
        this.childBalancer.destroy();
      }
      getTypeName() {
        return TYPE_NAME;
      }
    };
    exports2.OutlierDetectionLoadBalancer = OutlierDetectionLoadBalancer;
    function setup() {
      if (OUTLIER_DETECTION_ENABLED) {
        (0, experimental_1.registerLoadBalancerType)(TYPE_NAME, OutlierDetectionLoadBalancer, OutlierDetectionLoadBalancingConfig);
      }
    }
    __name(setup, "setup");
  }
});

// node_modules/@grpc/grpc-js/build/src/index.js
var require_src7 = __commonJS({
  "node_modules/@grpc/grpc-js/build/src/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", {
      value: true
    });
    exports2.experimental = exports2.ServerInterceptingCall = exports2.ResponderBuilder = exports2.ServerListenerBuilder = exports2.addAdminServicesToServer = exports2.getChannelzHandlers = exports2.getChannelzServiceDefinition = exports2.InterceptorConfigurationError = exports2.InterceptingCall = exports2.RequesterBuilder = exports2.ListenerBuilder = exports2.StatusBuilder = exports2.getClientChannel = exports2.ServerCredentials = exports2.Server = exports2.setLogVerbosity = exports2.setLogger = exports2.load = exports2.loadObject = exports2.CallCredentials = exports2.ChannelCredentials = exports2.waitForClientReady = exports2.closeClient = exports2.Channel = exports2.makeGenericClientConstructor = exports2.makeClientConstructor = exports2.loadPackageDefinition = exports2.Client = exports2.compressionAlgorithms = exports2.propagate = exports2.connectivityState = exports2.status = exports2.logVerbosity = exports2.Metadata = exports2.credentials = void 0;
    var call_credentials_1 = require_call_credentials();
    Object.defineProperty(exports2, "CallCredentials", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return call_credentials_1.CallCredentials;
      }, "get")
    });
    var channel_1 = require_channel();
    Object.defineProperty(exports2, "Channel", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return channel_1.ChannelImplementation;
      }, "get")
    });
    var compression_algorithms_1 = require_compression_algorithms();
    Object.defineProperty(exports2, "compressionAlgorithms", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return compression_algorithms_1.CompressionAlgorithms;
      }, "get")
    });
    var connectivity_state_1 = require_connectivity_state();
    Object.defineProperty(exports2, "connectivityState", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return connectivity_state_1.ConnectivityState;
      }, "get")
    });
    var channel_credentials_1 = require_channel_credentials();
    Object.defineProperty(exports2, "ChannelCredentials", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return channel_credentials_1.ChannelCredentials;
      }, "get")
    });
    var client_1 = require_client2();
    Object.defineProperty(exports2, "Client", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return client_1.Client;
      }, "get")
    });
    var constants_1 = require_constants3();
    Object.defineProperty(exports2, "logVerbosity", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return constants_1.LogVerbosity;
      }, "get")
    });
    Object.defineProperty(exports2, "status", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return constants_1.Status;
      }, "get")
    });
    Object.defineProperty(exports2, "propagate", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return constants_1.Propagate;
      }, "get")
    });
    var logging = require_logging();
    var make_client_1 = require_make_client();
    Object.defineProperty(exports2, "loadPackageDefinition", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return make_client_1.loadPackageDefinition;
      }, "get")
    });
    Object.defineProperty(exports2, "makeClientConstructor", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return make_client_1.makeClientConstructor;
      }, "get")
    });
    Object.defineProperty(exports2, "makeGenericClientConstructor", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return make_client_1.makeClientConstructor;
      }, "get")
    });
    var metadata_1 = require_metadata2();
    Object.defineProperty(exports2, "Metadata", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return metadata_1.Metadata;
      }, "get")
    });
    var server_1 = require_server2();
    Object.defineProperty(exports2, "Server", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return server_1.Server;
      }, "get")
    });
    var server_credentials_1 = require_server_credentials();
    Object.defineProperty(exports2, "ServerCredentials", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return server_credentials_1.ServerCredentials;
      }, "get")
    });
    var status_builder_1 = require_status_builder();
    Object.defineProperty(exports2, "StatusBuilder", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return status_builder_1.StatusBuilder;
      }, "get")
    });
    exports2.credentials = {
      /**
       * Combine a ChannelCredentials with any number of CallCredentials into a
       * single ChannelCredentials object.
       * @param channelCredentials The ChannelCredentials object.
       * @param callCredentials Any number of CallCredentials objects.
       * @return The resulting ChannelCredentials object.
       */
      combineChannelCredentials: /* @__PURE__ */ __name((channelCredentials, ...callCredentials) => {
        return callCredentials.reduce((acc, other) => acc.compose(other), channelCredentials);
      }, "combineChannelCredentials"),
      /**
       * Combine any number of CallCredentials into a single CallCredentials
       * object.
       * @param first The first CallCredentials object.
       * @param additional Any number of additional CallCredentials objects.
       * @return The resulting CallCredentials object.
       */
      combineCallCredentials: /* @__PURE__ */ __name((first, ...additional) => {
        return additional.reduce((acc, other) => acc.compose(other), first);
      }, "combineCallCredentials"),
      // from channel-credentials.ts
      createInsecure: channel_credentials_1.ChannelCredentials.createInsecure,
      createSsl: channel_credentials_1.ChannelCredentials.createSsl,
      createFromSecureContext: channel_credentials_1.ChannelCredentials.createFromSecureContext,
      // from call-credentials.ts
      createFromMetadataGenerator: call_credentials_1.CallCredentials.createFromMetadataGenerator,
      createFromGoogleCredential: call_credentials_1.CallCredentials.createFromGoogleCredential,
      createEmpty: call_credentials_1.CallCredentials.createEmpty
    };
    var closeClient = /* @__PURE__ */ __name((client2) => client2.close(), "closeClient");
    exports2.closeClient = closeClient;
    var waitForClientReady = /* @__PURE__ */ __name((client2, deadline, callback) => client2.waitForReady(deadline, callback), "waitForClientReady");
    exports2.waitForClientReady = waitForClientReady;
    var loadObject = /* @__PURE__ */ __name((value2, options) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    }, "loadObject");
    exports2.loadObject = loadObject;
    var load = /* @__PURE__ */ __name((filename, format5, options) => {
      throw new Error("Not available in this library. Use @grpc/proto-loader and loadPackageDefinition instead");
    }, "load");
    exports2.load = load;
    var setLogger = /* @__PURE__ */ __name((logger2) => {
      logging.setLogger(logger2);
    }, "setLogger");
    exports2.setLogger = setLogger;
    var setLogVerbosity = /* @__PURE__ */ __name((verbosity) => {
      logging.setLoggerVerbosity(verbosity);
    }, "setLogVerbosity");
    exports2.setLogVerbosity = setLogVerbosity;
    var getClientChannel = /* @__PURE__ */ __name((client2) => {
      return client_1.Client.prototype.getChannel.call(client2);
    }, "getClientChannel");
    exports2.getClientChannel = getClientChannel;
    var client_interceptors_1 = require_client_interceptors();
    Object.defineProperty(exports2, "ListenerBuilder", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return client_interceptors_1.ListenerBuilder;
      }, "get")
    });
    Object.defineProperty(exports2, "RequesterBuilder", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return client_interceptors_1.RequesterBuilder;
      }, "get")
    });
    Object.defineProperty(exports2, "InterceptingCall", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return client_interceptors_1.InterceptingCall;
      }, "get")
    });
    Object.defineProperty(exports2, "InterceptorConfigurationError", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return client_interceptors_1.InterceptorConfigurationError;
      }, "get")
    });
    var channelz_1 = require_channelz();
    Object.defineProperty(exports2, "getChannelzServiceDefinition", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return channelz_1.getChannelzServiceDefinition;
      }, "get")
    });
    Object.defineProperty(exports2, "getChannelzHandlers", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return channelz_1.getChannelzHandlers;
      }, "get")
    });
    var admin_1 = require_admin();
    Object.defineProperty(exports2, "addAdminServicesToServer", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return admin_1.addAdminServicesToServer;
      }, "get")
    });
    var server_interceptors_1 = require_server_interceptors();
    Object.defineProperty(exports2, "ServerListenerBuilder", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return server_interceptors_1.ServerListenerBuilder;
      }, "get")
    });
    Object.defineProperty(exports2, "ResponderBuilder", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return server_interceptors_1.ResponderBuilder;
      }, "get")
    });
    Object.defineProperty(exports2, "ServerInterceptingCall", {
      enumerable: true,
      get: /* @__PURE__ */ __name(function() {
        return server_interceptors_1.ServerInterceptingCall;
      }, "get")
    });
    var experimental = require_experimental();
    exports2.experimental = experimental;
    var resolver_dns = require_resolver_dns();
    var resolver_uds = require_resolver_uds();
    var resolver_ip = require_resolver_ip();
    var load_balancer_pick_first = require_load_balancer_pick_first();
    var load_balancer_round_robin = require_load_balancer_round_robin();
    var load_balancer_outlier_detection = require_load_balancer_outlier_detection();
    var channelz = require_channelz();
    (() => {
      resolver_dns.setup();
      resolver_uds.setup();
      resolver_ip.setup();
      load_balancer_pick_first.setup();
      load_balancer_round_robin.setup();
      load_balancer_outlier_detection.setup();
      channelz.setup();
    })();
  }
});

// node_modules/uuid/dist/esm-node/max.js
var max_default;
var init_max = __esm({
  "node_modules/uuid/dist/esm-node/max.js"() {
    "use strict";
    max_default = "ffffffff-ffff-ffff-ffff-ffffffffffff";
  }
});

// node_modules/uuid/dist/esm-node/nil.js
var nil_default;
var init_nil = __esm({
  "node_modules/uuid/dist/esm-node/nil.js"() {
    "use strict";
    nil_default = "00000000-0000-0000-0000-000000000000";
  }
});

// node_modules/uuid/dist/esm-node/regex.js
var regex_default;
var init_regex = __esm({
  "node_modules/uuid/dist/esm-node/regex.js"() {
    "use strict";
    regex_default = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-8][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000|ffffffff-ffff-ffff-ffff-ffffffffffff)$/i;
  }
});

// node_modules/uuid/dist/esm-node/validate.js
function validate(uuid) {
  return typeof uuid === "string" && regex_default.test(uuid);
}
var validate_default;
var init_validate = __esm({
  "node_modules/uuid/dist/esm-node/validate.js"() {
    "use strict";
    init_regex();
    __name(validate, "validate");
    validate_default = validate;
  }
});

// node_modules/uuid/dist/esm-node/parse.js
function parse4(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  let v;
  const arr = new Uint8Array(16);
  arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
  arr[1] = v >>> 16 & 255;
  arr[2] = v >>> 8 & 255;
  arr[3] = v & 255;
  arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
  arr[5] = v & 255;
  arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
  arr[7] = v & 255;
  arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
  arr[9] = v & 255;
  arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 1099511627776 & 255;
  arr[11] = v / 4294967296 & 255;
  arr[12] = v >>> 24 & 255;
  arr[13] = v >>> 16 & 255;
  arr[14] = v >>> 8 & 255;
  arr[15] = v & 255;
  return arr;
}
var parse_default;
var init_parse = __esm({
  "node_modules/uuid/dist/esm-node/parse.js"() {
    "use strict";
    init_validate();
    __name(parse4, "parse");
    parse_default = parse4;
  }
});

// node_modules/uuid/dist/esm-node/stringify.js
function unsafeStringify(arr, offset = 0) {
  return (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase();
}
function stringify(arr, offset = 0) {
  const uuid = unsafeStringify(arr, offset);
  if (!validate_default(uuid)) {
    throw TypeError("Stringified UUID is invalid");
  }
  return uuid;
}
var byteToHex, stringify_default;
var init_stringify = __esm({
  "node_modules/uuid/dist/esm-node/stringify.js"() {
    "use strict";
    init_validate();
    byteToHex = [];
    for (let i = 0; i < 256; ++i) {
      byteToHex.push((i + 256).toString(16).slice(1));
    }
    __name(unsafeStringify, "unsafeStringify");
    __name(stringify, "stringify");
    stringify_default = stringify;
  }
});

// node_modules/uuid/dist/esm-node/rng.js
function rng() {
  if (poolPtr > rnds8Pool.length - 16) {
    import_node_crypto.default.randomFillSync(rnds8Pool);
    poolPtr = 0;
  }
  return rnds8Pool.slice(poolPtr, poolPtr += 16);
}
var import_node_crypto, rnds8Pool, poolPtr;
var init_rng = __esm({
  "node_modules/uuid/dist/esm-node/rng.js"() {
    "use strict";
    import_node_crypto = __toESM(require("crypto"));
    rnds8Pool = new Uint8Array(256);
    poolPtr = rnds8Pool.length;
    __name(rng, "rng");
  }
});

// node_modules/uuid/dist/esm-node/v1.js
function v1(options, buf, offset) {
  let i = buf && offset || 0;
  const b = buf || new Array(16);
  options = options || {};
  let node = options.node;
  let clockseq = options.clockseq;
  if (!options._v6) {
    if (!node) {
      node = _nodeId;
    }
    if (clockseq == null) {
      clockseq = _clockseq;
    }
  }
  if (node == null || clockseq == null) {
    const seedBytes = options.random || (options.rng || rng)();
    if (node == null) {
      node = [
        seedBytes[0],
        seedBytes[1],
        seedBytes[2],
        seedBytes[3],
        seedBytes[4],
        seedBytes[5]
      ];
      if (!_nodeId && !options._v6) {
        node[0] |= 1;
        _nodeId = node;
      }
    }
    if (clockseq == null) {
      clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 16383;
      if (_clockseq === void 0 && !options._v6) {
        _clockseq = clockseq;
      }
    }
  }
  let msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let nsecs = options.nsecs !== void 0 ? options.nsecs : _lastNSecs + 1;
  const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 1e4;
  if (dt < 0 && options.clockseq === void 0) {
    clockseq = clockseq + 1 & 16383;
  }
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === void 0) {
    nsecs = 0;
  }
  if (nsecs >= 1e4) {
    throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
  }
  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;
  msecs += 122192928e5;
  const tl = ((msecs & 268435455) * 1e4 + nsecs) % 4294967296;
  b[i++] = tl >>> 24 & 255;
  b[i++] = tl >>> 16 & 255;
  b[i++] = tl >>> 8 & 255;
  b[i++] = tl & 255;
  const tmh = msecs / 4294967296 * 1e4 & 268435455;
  b[i++] = tmh >>> 8 & 255;
  b[i++] = tmh & 255;
  b[i++] = tmh >>> 24 & 15 | 16;
  b[i++] = tmh >>> 16 & 255;
  b[i++] = clockseq >>> 8 | 128;
  b[i++] = clockseq & 255;
  for (let n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }
  return buf || unsafeStringify(b);
}
var _nodeId, _clockseq, _lastMSecs, _lastNSecs, v1_default;
var init_v1 = __esm({
  "node_modules/uuid/dist/esm-node/v1.js"() {
    "use strict";
    init_rng();
    init_stringify();
    _lastMSecs = 0;
    _lastNSecs = 0;
    __name(v1, "v1");
    v1_default = v1;
  }
});

// node_modules/uuid/dist/esm-node/v1ToV6.js
function v1ToV6(uuid) {
  const v1Bytes = typeof uuid === "string" ? parse_default(uuid) : uuid;
  const v6Bytes = _v1ToV6(v1Bytes);
  return typeof uuid === "string" ? unsafeStringify(v6Bytes) : v6Bytes;
}
function _v1ToV6(v1Bytes, randomize = false) {
  return Uint8Array.of((v1Bytes[6] & 15) << 4 | v1Bytes[7] >> 4 & 15, (v1Bytes[7] & 15) << 4 | (v1Bytes[4] & 240) >> 4, (v1Bytes[4] & 15) << 4 | (v1Bytes[5] & 240) >> 4, (v1Bytes[5] & 15) << 4 | (v1Bytes[0] & 240) >> 4, (v1Bytes[0] & 15) << 4 | (v1Bytes[1] & 240) >> 4, (v1Bytes[1] & 15) << 4 | (v1Bytes[2] & 240) >> 4, 96 | v1Bytes[2] & 15, v1Bytes[3], v1Bytes[8], v1Bytes[9], v1Bytes[10], v1Bytes[11], v1Bytes[12], v1Bytes[13], v1Bytes[14], v1Bytes[15]);
}
var init_v1ToV6 = __esm({
  "node_modules/uuid/dist/esm-node/v1ToV6.js"() {
    "use strict";
    init_parse();
    init_stringify();
    __name(v1ToV6, "v1ToV6");
    __name(_v1ToV6, "_v1ToV6");
  }
});

// node_modules/uuid/dist/esm-node/v35.js
function stringToBytes(str) {
  str = unescape(encodeURIComponent(str));
  const bytes = [];
  for (let i = 0; i < str.length; ++i) {
    bytes.push(str.charCodeAt(i));
  }
  return bytes;
}
function v35(name, version2, hashfunc) {
  function generateUUID(value2, namespace, buf, offset) {
    var _namespace;
    if (typeof value2 === "string") {
      value2 = stringToBytes(value2);
    }
    if (typeof namespace === "string") {
      namespace = parse_default(namespace);
    }
    if (((_namespace = namespace) === null || _namespace === void 0 ? void 0 : _namespace.length) !== 16) {
      throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
    }
    let bytes = new Uint8Array(16 + value2.length);
    bytes.set(namespace);
    bytes.set(value2, namespace.length);
    bytes = hashfunc(bytes);
    bytes[6] = bytes[6] & 15 | version2;
    bytes[8] = bytes[8] & 63 | 128;
    if (buf) {
      offset = offset || 0;
      for (let i = 0; i < 16; ++i) {
        buf[offset + i] = bytes[i];
      }
      return buf;
    }
    return unsafeStringify(bytes);
  }
  __name(generateUUID, "generateUUID");
  try {
    generateUUID.name = name;
  } catch (err) {
  }
  generateUUID.DNS = DNS;
  generateUUID.URL = URL2;
  return generateUUID;
}
var DNS, URL2;
var init_v35 = __esm({
  "node_modules/uuid/dist/esm-node/v35.js"() {
    "use strict";
    init_stringify();
    init_parse();
    __name(stringToBytes, "stringToBytes");
    DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
    URL2 = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
    __name(v35, "v35");
  }
});

// node_modules/uuid/dist/esm-node/md5.js
function md5(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_node_crypto2.default.createHash("md5").update(bytes).digest();
}
var import_node_crypto2, md5_default;
var init_md5 = __esm({
  "node_modules/uuid/dist/esm-node/md5.js"() {
    "use strict";
    import_node_crypto2 = __toESM(require("crypto"));
    __name(md5, "md5");
    md5_default = md5;
  }
});

// node_modules/uuid/dist/esm-node/v3.js
var v3, v3_default;
var init_v3 = __esm({
  "node_modules/uuid/dist/esm-node/v3.js"() {
    "use strict";
    init_v35();
    init_md5();
    v3 = v35("v3", 48, md5_default);
    v3_default = v3;
  }
});

// node_modules/uuid/dist/esm-node/native.js
var import_node_crypto3, native_default;
var init_native = __esm({
  "node_modules/uuid/dist/esm-node/native.js"() {
    "use strict";
    import_node_crypto3 = __toESM(require("crypto"));
    native_default = {
      randomUUID: import_node_crypto3.default.randomUUID
    };
  }
});

// node_modules/uuid/dist/esm-node/v4.js
function v4(options, buf, offset) {
  if (native_default.randomUUID && !buf && !options) {
    return native_default.randomUUID();
  }
  options = options || {};
  const rnds = options.random || (options.rng || rng)();
  rnds[6] = rnds[6] & 15 | 64;
  rnds[8] = rnds[8] & 63 | 128;
  if (buf) {
    offset = offset || 0;
    for (let i = 0; i < 16; ++i) {
      buf[offset + i] = rnds[i];
    }
    return buf;
  }
  return unsafeStringify(rnds);
}
var v4_default;
var init_v4 = __esm({
  "node_modules/uuid/dist/esm-node/v4.js"() {
    "use strict";
    init_native();
    init_rng();
    init_stringify();
    __name(v4, "v4");
    v4_default = v4;
  }
});

// node_modules/uuid/dist/esm-node/sha1.js
function sha1(bytes) {
  if (Array.isArray(bytes)) {
    bytes = Buffer.from(bytes);
  } else if (typeof bytes === "string") {
    bytes = Buffer.from(bytes, "utf8");
  }
  return import_node_crypto4.default.createHash("sha1").update(bytes).digest();
}
var import_node_crypto4, sha1_default;
var init_sha1 = __esm({
  "node_modules/uuid/dist/esm-node/sha1.js"() {
    "use strict";
    import_node_crypto4 = __toESM(require("crypto"));
    __name(sha1, "sha1");
    sha1_default = sha1;
  }
});

// node_modules/uuid/dist/esm-node/v5.js
var v5, v5_default;
var init_v5 = __esm({
  "node_modules/uuid/dist/esm-node/v5.js"() {
    "use strict";
    init_v35();
    init_sha1();
    v5 = v35("v5", 80, sha1_default);
    v5_default = v5;
  }
});

// node_modules/uuid/dist/esm-node/v6.js
function v6(options = {}, buf, offset = 0) {
  let bytes = v1_default({
    ...options,
    _v6: true
  }, new Uint8Array(16));
  bytes = v1ToV6(bytes);
  if (buf) {
    for (let i = 0; i < 16; i++) {
      buf[offset + i] = bytes[i];
    }
    return buf;
  }
  return unsafeStringify(bytes);
}
var init_v6 = __esm({
  "node_modules/uuid/dist/esm-node/v6.js"() {
    "use strict";
    init_stringify();
    init_v1();
    init_v1ToV6();
    __name(v6, "v6");
  }
});

// node_modules/uuid/dist/esm-node/v6ToV1.js
function v6ToV1(uuid) {
  const v6Bytes = typeof uuid === "string" ? parse_default(uuid) : uuid;
  const v1Bytes = _v6ToV1(v6Bytes);
  return typeof uuid === "string" ? unsafeStringify(v1Bytes) : v1Bytes;
}
function _v6ToV1(v6Bytes) {
  return Uint8Array.of((v6Bytes[3] & 15) << 4 | v6Bytes[4] >> 4 & 15, (v6Bytes[4] & 15) << 4 | (v6Bytes[5] & 240) >> 4, (v6Bytes[5] & 15) << 4 | v6Bytes[6] & 15, v6Bytes[7], (v6Bytes[1] & 15) << 4 | (v6Bytes[2] & 240) >> 4, (v6Bytes[2] & 15) << 4 | (v6Bytes[3] & 240) >> 4, 16 | (v6Bytes[0] & 240) >> 4, (v6Bytes[0] & 15) << 4 | (v6Bytes[1] & 240) >> 4, v6Bytes[8], v6Bytes[9], v6Bytes[10], v6Bytes[11], v6Bytes[12], v6Bytes[13], v6Bytes[14], v6Bytes[15]);
}
var init_v6ToV1 = __esm({
  "node_modules/uuid/dist/esm-node/v6ToV1.js"() {
    "use strict";
    init_parse();
    init_stringify();
    __name(v6ToV1, "v6ToV1");
    __name(_v6ToV1, "_v6ToV1");
  }
});

// node_modules/uuid/dist/esm-node/v7.js
function v7(options, buf, offset) {
  options = options || {};
  let i = buf && offset || 0;
  const b = buf || new Uint8Array(16);
  const rnds = options.random || (options.rng || rng)();
  const msecs = options.msecs !== void 0 ? options.msecs : Date.now();
  let seq = options.seq !== void 0 ? options.seq : null;
  let seqHigh = _seqHigh;
  let seqLow = _seqLow;
  if (msecs > _msecs && options.msecs === void 0) {
    _msecs = msecs;
    if (seq !== null) {
      seqHigh = null;
      seqLow = null;
    }
  }
  if (seq !== null) {
    if (seq > 2147483647) {
      seq = 2147483647;
    }
    seqHigh = seq >>> 19 & 4095;
    seqLow = seq & 524287;
  }
  if (seqHigh === null || seqLow === null) {
    seqHigh = rnds[6] & 127;
    seqHigh = seqHigh << 8 | rnds[7];
    seqLow = rnds[8] & 63;
    seqLow = seqLow << 8 | rnds[9];
    seqLow = seqLow << 5 | rnds[10] >>> 3;
  }
  if (msecs + 1e4 > _msecs && seq === null) {
    if (++seqLow > 524287) {
      seqLow = 0;
      if (++seqHigh > 4095) {
        seqHigh = 0;
        _msecs++;
      }
    }
  } else {
    _msecs = msecs;
  }
  _seqHigh = seqHigh;
  _seqLow = seqLow;
  b[i++] = _msecs / 1099511627776 & 255;
  b[i++] = _msecs / 4294967296 & 255;
  b[i++] = _msecs / 16777216 & 255;
  b[i++] = _msecs / 65536 & 255;
  b[i++] = _msecs / 256 & 255;
  b[i++] = _msecs & 255;
  b[i++] = seqHigh >>> 4 & 15 | 112;
  b[i++] = seqHigh & 255;
  b[i++] = seqLow >>> 13 & 63 | 128;
  b[i++] = seqLow >>> 5 & 255;
  b[i++] = seqLow << 3 & 255 | rnds[10] & 7;
  b[i++] = rnds[11];
  b[i++] = rnds[12];
  b[i++] = rnds[13];
  b[i++] = rnds[14];
  b[i++] = rnds[15];
  return buf || unsafeStringify(b);
}
var _seqLow, _seqHigh, _msecs, v7_default;
var init_v7 = __esm({
  "node_modules/uuid/dist/esm-node/v7.js"() {
    "use strict";
    init_rng();
    init_stringify();
    _seqLow = null;
    _seqHigh = null;
    _msecs = 0;
    __name(v7, "v7");
    v7_default = v7;
  }
});

// node_modules/uuid/dist/esm-node/version.js
function version(uuid) {
  if (!validate_default(uuid)) {
    throw TypeError("Invalid UUID");
  }
  return parseInt(uuid.slice(14, 15), 16);
}
var version_default;
var init_version = __esm({
  "node_modules/uuid/dist/esm-node/version.js"() {
    "use strict";
    init_validate();
    __name(version, "version");
    version_default = version;
  }
});

// node_modules/uuid/dist/esm-node/index.js
var esm_node_exports = {};
__export(esm_node_exports, {
  MAX: () => max_default,
  NIL: () => nil_default,
  parse: () => parse_default,
  stringify: () => stringify_default,
  v1: () => v1_default,
  v1ToV6: () => v1ToV6,
  v3: () => v3_default,
  v4: () => v4_default,
  v5: () => v5_default,
  v6: () => v6,
  v6ToV1: () => v6ToV1,
  v7: () => v7_default,
  validate: () => validate_default,
  version: () => version_default
});
var init_esm_node = __esm({
  "node_modules/uuid/dist/esm-node/index.js"() {
    "use strict";
    init_max();
    init_nil();
    init_parse();
    init_stringify();
    init_v1();
    init_v1ToV6();
    init_v3();
    init_v4();
    init_v5();
    init_v6();
    init_v6ToV1();
    init_v7();
    init_validate();
    init_version();
  }
});

// node_modules/dockerode/lib/session.js
var require_session = __commonJS({
  "node_modules/dockerode/lib/session.js"(exports2, module2) {
    "use strict";
    var grpc = require_src7();
    var protoLoader = require_src6();
    var path = require("path");
    var uuid = (init_esm_node(), __toCommonJS(esm_node_exports)).v4;
    function withSession(docker, auth, handler) {
      const sessionId = uuid();
      const opts = {
        method: "POST",
        path: "/session",
        hijack: true,
        headers: {
          Upgrade: "h2c",
          "X-Docker-Expose-Session-Uuid": sessionId,
          "X-Docker-Expose-Session-Name": "testcontainers"
        },
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      docker.modem.dial(opts, function(err, socket) {
        if (err) {
          return handler(err, null, () => void 0);
        }
        const server = new grpc.Server();
        const creds = grpc.ServerCredentials.createInsecure();
        const injector = server.createConnectionInjector(creds);
        injector.injectConnection(socket);
        const pkg = protoLoader.loadSync(path.resolve(__dirname, "proto", "auth.proto"));
        const service = grpc.loadPackageDefinition(pkg);
        server.addService(service.moby.filesync.v1.Auth.service, {
          Credentials({ request }, callback) {
            if (auth) {
              callback(null, {
                Username: auth.username,
                Secret: auth.password
              });
            } else {
              callback(null, {});
            }
          }
        });
        function done() {
          server.forceShutdown();
          socket.end();
        }
        __name(done, "done");
        handler(null, sessionId, done);
      });
    }
    __name(withSession, "withSession");
    module2.exports = withSession;
  }
});

// node_modules/dockerode/lib/docker.js
var require_docker2 = __commonJS({
  "node_modules/dockerode/lib/docker.js"(exports2, module2) {
    "use strict";
    var EventEmitter = require("events").EventEmitter;
    var Modem = require_modem();
    var Container2 = require_container2();
    var Image = require_image();
    var Volume = require_volume();
    var Network = require_network2();
    var Service = require_service();
    var Plugin = require_plugin();
    var Secret = require_secret();
    var Config = require_config3();
    var Task = require_task();
    var Node = require_node7();
    var Exec = require_exec();
    var util2 = require_util2();
    var withSession = require_session();
    var extend = util2.extend;
    var Docker2 = /* @__PURE__ */ __name(function(opts) {
      if (!(this instanceof Docker2)) return new Docker2(opts);
      var plibrary = global.Promise;
      if (opts && opts.Promise) {
        plibrary = opts.Promise;
        if (Object.keys(opts).length === 1) {
          opts = void 0;
        }
      }
      if (opts && opts.modem) {
        this.modem = opts.modem;
      } else {
        this.modem = new Modem(opts);
      }
      this.modem.Promise = plibrary;
    }, "Docker");
    Docker2.prototype.createContainer = function(opts, callback) {
      var self2 = this;
      var optsf = {
        path: "/containers/create?",
        method: "POST",
        options: opts,
        authconfig: opts.authconfig,
        abortSignal: opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          400: "bad parameter",
          404: "no such container",
          406: "impossible to attach",
          500: "server error"
        }
      };
      delete opts.authconfig;
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(self2.getContainer(data.Id));
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return callback(err, data);
          callback(err, self2.getContainer(data.Id));
        });
      }
    };
    Docker2.prototype.createImage = function(auth, opts, callback) {
      var self2 = this;
      if (!callback && typeof opts === "function") {
        callback = opts;
        opts = auth;
        auth = opts.authconfig || void 0;
      } else if (!callback && !opts) {
        opts = auth;
        auth = opts.authconfig;
      }
      var optsf = {
        path: "/images/create?",
        method: "POST",
        options: opts,
        authconfig: auth,
        abortSignal: opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Docker2.prototype.loadImage = function(file, opts, callback) {
      var self2 = this;
      if (!callback && typeof opts === "function") {
        callback = opts;
        opts = null;
      }
      var optsf = {
        path: "/images/load?",
        method: "POST",
        options: opts,
        file,
        abortSignal: opts && opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Docker2.prototype.importImage = function(file, opts, callback) {
      var self2 = this;
      if (!callback && typeof opts === "function") {
        callback = opts;
        opts = void 0;
      }
      if (!opts) opts = {};
      opts.fromSrc = "-";
      var optsf = {
        path: "/images/create?",
        method: "POST",
        options: opts,
        file,
        abortSignal: opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Docker2.prototype.checkAuth = function(opts, callback) {
      var self2 = this;
      var optsf = {
        path: "/auth",
        method: "POST",
        options: opts,
        abortSignal: opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Docker2.prototype.buildImage = function(file, opts, callback) {
      var self2 = this;
      if (!callback && typeof opts === "function") {
        callback = opts;
        opts = null;
      }
      var optsf = {
        path: "/build?",
        method: "POST",
        file: void 0,
        options: opts,
        abortSignal: opts && opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (opts) {
        if (opts.registryconfig) {
          optsf.registryconfig = optsf.options.registryconfig;
          delete optsf.options.registryconfig;
        }
        if (opts.authconfig) {
          optsf.authconfig = optsf.options.authconfig;
          delete optsf.options.authconfig;
        }
      }
      function dial(callback2) {
        util2.prepareBuildContext(file, (ctx) => {
          optsf.file = ctx;
          self2.modem.dial(optsf, callback2);
        });
      }
      __name(dial, "dial");
      function dialWithSession(callback2) {
        if (opts?.version === "2") {
          withSession(self2, optsf.authconfig, (err, sessionId, done) => {
            if (err) {
              return callback2(err);
            }
            optsf.options.session = sessionId;
            dial((err2, data) => {
              callback2(err2, data);
              if (data) {
                data.on("end", done);
              }
            });
          });
        } else {
          dial(callback2);
        }
      }
      __name(dialWithSession, "dialWithSession");
      if (callback === void 0) {
        return new self2.modem.Promise(function(resolve5, reject) {
          dialWithSession(function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        dialWithSession(callback);
      }
    };
    Docker2.prototype.getContainer = function(id) {
      return new Container2(this.modem, id);
    };
    Docker2.prototype.getImage = function(name) {
      return new Image(this.modem, name);
    };
    Docker2.prototype.getVolume = function(name) {
      return new Volume(this.modem, name);
    };
    Docker2.prototype.getPlugin = function(name, remote) {
      return new Plugin(this.modem, name, remote);
    };
    Docker2.prototype.getService = function(id) {
      return new Service(this.modem, id);
    };
    Docker2.prototype.getTask = function(id) {
      return new Task(this.modem, id);
    };
    Docker2.prototype.getNode = function(id) {
      return new Node(this.modem, id);
    };
    Docker2.prototype.getNetwork = function(id) {
      return new Network(this.modem, id);
    };
    Docker2.prototype.getSecret = function(id) {
      return new Secret(this.modem, id);
    };
    Docker2.prototype.getConfig = function(id) {
      return new Config(this.modem, id);
    };
    Docker2.prototype.getExec = function(id) {
      return new Exec(this.modem, id);
    };
    Docker2.prototype.listContainers = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/containers/json?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.listImages = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/images/json?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.getImages = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/images/get?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          400: "bad parameter",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.listServices = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/services?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.listNodes = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/nodes?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          404: "no such node",
          500: "server error",
          503: "node is not part of a swarm"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.listTasks = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/tasks?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.createSecret = function(opts, callback) {
      var args = util2.processArgs(opts, callback);
      var self2 = this;
      var optsf = {
        path: "/secrets/create?",
        method: "POST",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          406: "server error or node is not part of a swarm",
          409: "name conflicts with an existing object",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(self2.getSecret(data.ID));
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, self2.getSecret(data.ID));
        });
      }
    };
    Docker2.prototype.createConfig = function(opts, callback) {
      var args = util2.processArgs(opts, callback);
      var self2 = this;
      var optsf = {
        path: "/configs/create?",
        method: "POST",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          406: "server error or node is not part of a swarm",
          409: "name conflicts with an existing object",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(self2.getConfig(data.ID));
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, self2.getConfig(data.ID));
        });
      }
    };
    Docker2.prototype.listSecrets = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/secrets?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.listConfigs = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/configs?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.createPlugin = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins/create?",
        method: "POST",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          204: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(self2.getPlugin(args.opts.name));
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, self2.getPlugin(args.opts.name));
        });
      }
    };
    Docker2.prototype.listPlugins = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/plugins?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.pruneImages = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/images/prune?",
        method: "POST",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.pruneBuilder = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/build/prune",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.pruneContainers = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/containers/prune?",
        method: "POST",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.pruneVolumes = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/volumes/prune?",
        method: "POST",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.pruneNetworks = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/networks/prune?",
        method: "POST",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.createVolume = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/volumes/create?",
        method: "POST",
        allowEmpty: true,
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(self2.getVolume(data.Name));
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, self2.getVolume(data.Name));
        });
      }
    };
    Docker2.prototype.createService = function(auth, opts, callback) {
      if (!callback && typeof opts === "function") {
        callback = opts;
        opts = auth;
        auth = opts.authconfig || void 0;
      } else if (!opts && !callback) {
        opts = auth;
      }
      var self2 = this;
      var optsf = {
        path: "/services/create",
        method: "POST",
        options: opts,
        authconfig: auth,
        abortSignal: opts && opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(self2.getService(data.ID || data.Id));
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return callback(err, data);
          callback(err, self2.getService(data.ID || data.Id));
        });
      }
    };
    Docker2.prototype.listVolumes = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/volumes?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.createNetwork = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/networks/create?",
        method: "POST",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          201: true,
          404: "driver not found",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(self2.getNetwork(data.Id));
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          if (err) return args.callback(err, data);
          args.callback(err, self2.getNetwork(data.Id));
        });
      }
    };
    Docker2.prototype.listNetworks = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/networks?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.searchImages = function(opts, callback) {
      var self2 = this;
      var optsf = {
        path: "/images/search?",
        method: "GET",
        options: opts,
        authconfig: opts.authconfig,
        abortSignal: opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          callback(err, data);
        });
      }
    };
    Docker2.prototype.info = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var opts = {
        path: "/info",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(opts, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(opts, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.version = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var opts = {
        path: "/version",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(opts, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(opts, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.ping = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/_ping",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.df = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/system/df",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.getEvents = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/events?",
        method: "GET",
        options: args.opts,
        abortSignal: args.opts.abortSignal,
        isStream: true,
        statusCodes: {
          200: true,
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.pull = function(repoTag, opts, callback, auth) {
      var args = util2.processArgs(opts, callback);
      var imageSrc = util2.parseRepositoryTag(repoTag);
      args.opts.fromImage = imageSrc.repository;
      args.opts.tag = imageSrc.tag || "latest";
      var argsf = [
        args.opts,
        args.callback
      ];
      if (auth) {
        argsf = [
          auth,
          args.opts,
          args.callback
        ];
      }
      return this.createImage.apply(this, argsf);
    };
    Docker2.prototype.pullAll = function(repoTag, opts, callback, auth) {
      var args = util2.processArgs(opts, callback);
      var imageSrc = util2.parseRepositoryTag(repoTag);
      args.opts.fromImage = imageSrc.repository;
      var argsf = [
        args.opts,
        args.callback
      ];
      if (auth) {
        argsf = [
          auth,
          args.opts,
          args.callback
        ];
      }
      return this.createImage.apply(this, argsf);
    };
    Docker2.prototype.run = function(image, cmd, streamo, createOptions, startOptions, callback) {
      if (typeof arguments[arguments.length - 1] === "function") {
        return this.runCallback(image, cmd, streamo, createOptions, startOptions, callback);
      } else {
        return this.runPromise(image, cmd, streamo, createOptions, startOptions);
      }
    };
    Docker2.prototype.runCallback = function(image, cmd, streamo, createOptions, startOptions, callback) {
      if (!callback && typeof createOptions === "function") {
        callback = createOptions;
        createOptions = {};
        startOptions = {};
      } else if (!callback && typeof startOptions === "function") {
        callback = startOptions;
        startOptions = {};
      }
      var hub = new EventEmitter();
      function handler(err, container) {
        if (err) return callback(err, null, container);
        hub.emit("container", container);
        container.attach({
          stream: true,
          stdout: true,
          stderr: true
        }, /* @__PURE__ */ __name(function handler2(err2, stream) {
          if (err2) return callback(err2, null, container);
          hub.emit("stream", stream);
          if (streamo) {
            if (streamo instanceof Array) {
              stream.on("end", function() {
                try {
                  streamo[0].end();
                } catch (e) {
                }
                try {
                  streamo[1].end();
                } catch (e) {
                }
              });
              container.modem.demuxStream(stream, streamo[0], streamo[1]);
            } else {
              stream.setEncoding("utf8");
              stream.pipe(streamo, {
                end: true
              });
            }
          }
          container.start(startOptions, function(err3, data) {
            if (err3) return callback(err3, data, container);
            hub.emit("start", container);
            container.wait(function(err4, data2) {
              hub.emit("data", data2);
              callback(err4, data2, container);
            });
          });
        }, "handler"));
      }
      __name(handler, "handler");
      var optsc = {
        "Hostname": "",
        "User": "",
        "AttachStdin": false,
        "AttachStdout": true,
        "AttachStderr": true,
        "Tty": true,
        "OpenStdin": false,
        "StdinOnce": false,
        "Env": null,
        "Cmd": cmd,
        "Image": image,
        "Volumes": {},
        "VolumesFrom": []
      };
      extend(optsc, createOptions);
      this.createContainer(optsc, handler);
      return hub;
    };
    Docker2.prototype.runPromise = function(image, cmd, streamo, createOptions, startOptions) {
      var self2 = this;
      createOptions = createOptions || {};
      startOptions = startOptions || {};
      var optsc = {
        "Hostname": "",
        "User": "",
        "AttachStdin": false,
        "AttachStdout": true,
        "AttachStderr": true,
        "Tty": true,
        "OpenStdin": false,
        "StdinOnce": false,
        "Env": null,
        "Cmd": cmd,
        "Image": image,
        "Volumes": {},
        "VolumesFrom": []
      };
      extend(optsc, createOptions);
      var containero;
      return new this.modem.Promise(function(resolve5, reject) {
        self2.createContainer(optsc).then(function(container) {
          containero = container;
          return container.attach({
            stream: true,
            stdout: true,
            stderr: true
          });
        }).then(function(stream) {
          if (streamo) {
            if (streamo instanceof Array) {
              stream.on("end", function() {
                try {
                  streamo[0].end();
                } catch (e) {
                }
                try {
                  streamo[1].end();
                } catch (e) {
                }
              });
              containero.modem.demuxStream(stream, streamo[0], streamo[1]);
            } else {
              stream.setEncoding("utf8");
              stream.pipe(streamo, {
                end: true
              });
            }
          }
          return containero.start(startOptions);
        }).then(function(data) {
          return containero.wait();
        }).then(function(data) {
          resolve5([
            data,
            containero
          ]);
        }).catch(function(err) {
          reject(err);
        });
      });
    };
    Docker2.prototype.swarmInit = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/swarm/init",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          406: "node is already part of a Swarm"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.swarmJoin = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/swarm/join",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          406: "node is already part of a Swarm"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.swarmLeave = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/swarm/leave?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          406: "node is not part of a Swarm"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.swarmUpdate = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/swarm/update?",
        method: "POST",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          400: "bad parameter",
          406: "node is already part of a Swarm"
        },
        options: args.opts
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.prototype.swarmInspect = function(opts, callback) {
      var self2 = this;
      var args = util2.processArgs(opts, callback);
      var optsf = {
        path: "/swarm",
        method: "GET",
        abortSignal: args.opts.abortSignal,
        statusCodes: {
          200: true,
          406: "This node is not a swarm manager",
          500: "server error"
        }
      };
      if (args.callback === void 0) {
        return new this.modem.Promise(function(resolve5, reject) {
          self2.modem.dial(optsf, function(err, data) {
            if (err) {
              return reject(err);
            }
            resolve5(data);
          });
        });
      } else {
        this.modem.dial(optsf, function(err, data) {
          args.callback(err, data);
        });
      }
    };
    Docker2.Container = Container2;
    Docker2.Image = Image;
    Docker2.Volume = Volume;
    Docker2.Network = Network;
    Docker2.Service = Service;
    Docker2.Plugin = Plugin;
    Docker2.Secret = Secret;
    Docker2.Task = Task;
    Docker2.Node = Node;
    Docker2.Exec = Exec;
    module2.exports = Docker2;
  }
});

// src/modules/client/collector.ts
var si, import_dockerode, ClientCollectorService;
var init_collector = __esm({
  "src/modules/client/collector.ts"() {
    "use strict";
    si = __toESM(require_lib());
    import_dockerode = __toESM(require_docker2());
    ClientCollectorService = class ClientCollectorService2 {
      static {
        __name(this, "ClientCollectorService");
      }
      docker;
      constructor() {
        this.docker = new import_dockerode.default({
          socketPath: "/var/run/docker.sock"
        });
        this.docker.ping();
      }
      async collectMetrics() {
        try {
          const [hostMetrics, workerMetrics, processingMetrics] = await Promise.all([
            this.collectHostMetrics(),
            this.collectWorkerMetrics(),
            this.collectProcessingMetrics()
          ]);
          return {
            hostMetrics,
            workerMetrics,
            processingMetrics,
            error: null
          };
        } catch (error) {
          return {
            hostMetrics: null,
            workerMetrics: null,
            processingMetrics: {},
            error: error.message
          };
        }
      }
      async collectProcessingMetrics() {
        try {
          const containers = await this.docker.listContainers();
          const workerContainers = containers.filter((container) => container.Names.some((name) => name.substring(1).startsWith("autodroid_worker_")));
          const workerMetricsPromises = workerContainers.map((containerInfo) => {
            const container = this.docker.getContainer(containerInfo.Id);
            const name = containerInfo.Names[0].substring(1);
            return this.collectContainerMetrics(container, name);
          });
          const workerMetrics = await Promise.all(workerMetricsPromises);
          return workerMetrics.reduce((acc, metrics) => {
            const processingId = metrics.name.split("_")[3];
            acc[processingId] = {
              processingId,
              ...metrics
            };
            return acc;
          }, {});
        } catch (error) {
          throw new Error(`Error getting main worker metrics: ${error}`);
        }
      }
      async collectWorkerMetrics() {
        try {
          const containers = await this.docker.listContainers();
          const mainWorker = containers.find((container2) => container2.Names.some((name) => name.substring(1) === "autodroid_worker"));
          if (!mainWorker) throw new Error("No autodroid_worker container found");
          const container = this.docker.getContainer(mainWorker.Id);
          const metrics = await this.collectContainerMetrics(container, "autodroid_worker");
          return metrics;
        } catch (error) {
          throw new Error(`Error getting main worker metrics: ${error}`);
        }
      }
      async collectHostMetrics() {
        try {
          const cpuData = await si.currentLoad();
          const memData = await si.mem();
          return {
            name: "host",
            type: "host",
            cpu: {
              usedPercentage: parseFloat(cpuData.currentLoad.toFixed(2)),
              cores: cpuData.cpus.length
            },
            memory: {
              total: memData.total,
              used: memData.active,
              free: memData.available,
              usedPercentage: parseFloat((memData.active / memData.total * 100).toFixed(2))
            }
          };
        } catch (error) {
          throw new Error(`Error getting system metrics: ${error}`);
        }
      }
      async collectContainerMetrics(container, name) {
        const stats = await container.stats({
          stream: false
        });
        const cpuDelta = stats.cpu_stats.cpu_usage.total_usage - stats.precpu_stats.cpu_usage.total_usage;
        const systemCpuDelta = stats.cpu_stats.system_cpu_usage - stats.precpu_stats.system_cpu_usage;
        const cpuCores = stats.cpu_stats.online_cpus || (stats.cpu_stats.cpu_usage.percpu_usage ? stats.cpu_stats.cpu_usage.percpu_usage.length : 1);
        const cpuUsage = cpuDelta / systemCpuDelta * cpuCores * 100;
        const memoryTotal = stats.memory_stats.limit;
        const memoryUsed = stats.memory_stats.usage;
        const memoryFree = memoryTotal - memoryUsed;
        const memoryUsedPercent = memoryUsed / memoryTotal * 100;
        return {
          name,
          type: "container",
          cpu: {
            usedPercentage: parseFloat(Number.isNaN(cpuUsage) ? "0.00" : cpuUsage.toFixed(2)),
            cores: cpuCores
          },
          memory: {
            total: memoryTotal,
            used: memoryUsed,
            free: memoryFree,
            usedPercentage: parseFloat(memoryUsedPercent.toFixed(2))
          }
        };
      }
    };
  }
});

// src/modules/client/index.ts
var client_exports = {};
__export(client_exports, {
  client: () => client
});
var import_systeminformation, ClientService, client, signals, isShuttingDown, shutdown;
var init_client = __esm({
  "src/modules/client/index.ts"() {
    "use strict";
    init_logger();
    init_websocketClient();
    init_index();
    import_systeminformation = __toESM(require_lib());
    init_collector();
    ClientService = class ClientService2 extends ClientCollectorService {
      static {
        __name(this, "ClientService");
      }
      initialization;
      websocketClient;
      workerName;
      procedureId;
      count = 0;
      intervalId = null;
      disconnectionTimeout = null;
      constructor() {
        super();
        this.websocketClient = new WebSocketClient();
        this.initialization = this.websocketClient.init();
        this.workerName = params.name;
        this.websocketClient.socket.on("connect", () => {
          logger.info("\u{1F7E2} Connected to server...");
          if (this.disconnectionTimeout) {
            clearTimeout(this.disconnectionTimeout);
            this.disconnectionTimeout = null;
          }
        });
        this.websocketClient.socket.on("start", (data) => {
          logger.info(`\u{1F7E2} Received START command for procedureId: ${data.procedureId}`);
          this.start({
            procedureId: data.procedureId
          }).catch((error) => {
            logger.error(`\u274C Error starting client: ${error}`);
          });
        });
        this.websocketClient.socket.on("stop", (data) => {
          logger.info(`\u{1F534} Received STOP command for procedureId: ${data.procedureId}`);
          this.stop().catch((error) => {
            logger.error(`\u274C Error stopping client: ${error}`);
          });
        });
        this.websocketClient.socket.on("disconnect", () => {
          if (this.intervalId) {
            logger.info("\u{1F534} Disconnected from server... Stop sending data.");
            this.disconnectionTimeout = setTimeout(() => this.stop().catch((error) => {
              logger.error(`\u274C Error stopping client: ${error}`);
            }), 6e4);
          }
        });
      }
      async start({ procedureId }) {
        await this.initialization;
        this.procedureId = procedureId;
        this.count = 0;
        const systemInfo = await (0, import_systeminformation.getAllData)();
        this.websocketClient.socket.emit("systemInformation", {
          ...systemInfo,
          procedureId: this.procedureId,
          workerName: this.workerName
        });
        if (this.intervalId) clearInterval(this.intervalId);
        this.intervalId = setInterval(async () => {
          try {
            const metrics = await this.collectMetrics();
            await this.send(metrics);
            this.count += 1;
          } catch (error) {
            logger.error(`\u274C Error collecting or sending metrics: ${error}`);
          }
        }, 1e3);
      }
      async stop() {
        if (this.intervalId) {
          clearInterval(this.intervalId);
          this.intervalId = null;
        }
      }
      async send(data) {
        try {
          this.websocketClient.socket.emit("report", {
            workerName: this.workerName,
            procedureId: this.procedureId,
            count: this.count,
            ...data,
            time: (/* @__PURE__ */ new Date()).toISOString()
          });
        } catch (error) {
          logger.error(`\u274C Failed to send metrics to server: ${error}`);
        }
      }
    };
    client = new ClientService();
    signals = [
      "SIGINT",
      "SIGTERM"
    ];
    isShuttingDown = false;
    shutdown = /* @__PURE__ */ __name(() => {
      if (isShuttingDown) return;
      isShuttingDown = true;
      logger.info("Shutting down client...");
      client.stop();
      client.websocketClient.disconnect();
      process.exit(0);
    }, "shutdown");
    signals.forEach((signal) => {
      process.on(signal, shutdown);
    });
  }
});

// src/index.ts
var index_exports = {};
__export(index_exports, {
  params: () => params
});
module.exports = __toCommonJS(index_exports);
var argv, paramsSchema, params, parsedConfig;
var init_index = __esm({
  "src/index.ts"() {
    init_yargs();
    init_helpers();
    init_lib4();
    init_package();
    init_logger();
    argv = yargs_default(hideBin(process.argv)).scriptName(package_default.name).option("token", {
      type: "string",
      alias: "t",
      demandOption: true,
      description: "Authentication token for worker"
    }).option("url", {
      type: "string",
      alias: "u",
      demandOption: true,
      description: "The server URL (required for client mode)"
    }).option("name", {
      type: "string",
      alias: "n",
      demandOption: true,
      description: "Name of the worker"
    }).help().parseSync();
    paramsSchema = z.object({
      token: z.string(),
      url: z.string().url(),
      name: z.string()
    });
    params = {
      token: argv.token,
      url: argv.url,
      name: argv.name
    };
    parsedConfig = paramsSchema.safeParse(params);
    if (!parsedConfig.success) {
      const formattedErrors = parsedConfig.error.errors.map((err) => `${err.path.join(".")}`).join(", ");
      logger.error(`\u274C Invalid configuration: ${formattedErrors}`);
      process.exit(1);
    }
    Promise.resolve().then(() => init_client());
  }
});
init_index();
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  params
});
/*! Bundled license information:

yargs-parser/build/lib/string-utils.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/tokenize-arg-string.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/yargs-parser-types.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/yargs-parser.js:
  (**
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

yargs-parser/build/lib/index.js:
  (**
   * @fileoverview Main entrypoint for libraries using yargs-parser in Node.js
   * CJS and ESM environments.
   *
   * @license
   * Copyright (c) 2016, Contributors
   * SPDX-License-Identifier: ISC
   *)

safe-buffer/index.js:
  (*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> *)

xmlhttprequest-ssl/lib/XMLHttpRequest.js:
  (**
   * Wrapper for built-in http.js to emulate the browser XMLHttpRequest object.
   *
   * This can be used with JS designed for browsers to improve reuse of code and
   * allow the use of existing libraries.
   *
   * Usage: include("XMLHttpRequest.js") and use XMLHttpRequest per W3C specs.
   *
   * @author Dan DeFelippi <dan@driverdan.com>
   * @contributor David Ellis <d.f.ellis@ieee.org>
   * @license MIT
   *)

@balena/dockerignore/ignore.js:
  (**
   * @license
   * Copyright 2020 Balena Ltd.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *    http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * ------------------------------------------------------------------------
   *
   * Copyright 2018 Zeit, Inc.
   * Licensed under the MIT License. See file LICENSE.md for a full copy.
   *
   * ------------------------------------------------------------------------
   *)

@grpc/proto-loader/build/src/util.js:
  (**
   * @license
   * Copyright 2018 gRPC authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)

long/umd/index.js:
  (**
   * @license
   * Copyright 2009 The Closure Library Authors
   * Copyright 2020 Daniel Wirtz / The long.js Authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   * SPDX-License-Identifier: Apache-2.0
   *)

@grpc/proto-loader/build/src/index.js:
  (**
   * @license
   * Copyright 2018 gRPC authors.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *     http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   *
   *)
*/
//# sourceMappingURL=index.js.map